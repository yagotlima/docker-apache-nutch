<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>The Apache HBase&#153; Reference Guide</title><link rel="stylesheet" type="text/css" href="css/freebsd_docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><meta name="description" content="This is the official reference guide of Apache HBase&#153;, a distributed, versioned, big data store built on top of Apache Hadoop&#153; and Apache ZooKeeper&#153;."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><script type="text/javascript">
    var disqus_shortname = 'hbase'; // required: replace example with your forum shortname
    var disqus_url = 'http://hbase.apache.org/book/book.html';
    </script><div class="book" title="The Apache HBase&#153; Reference Guide"><div class="titlepage"><div><div><h1 class="title"><a name="book"></a><a class="link" href="http://www.hbase.org" target="_top"> The Apache HBase&#153; Reference Guide </a></h1></div><div><h2 class="subtitle"><a class="link" href="http://www.hbase.org" target="_top">
        <span class="inlinemediaobject"><img src="images/hbase_logo.png" align="middle"></span>
        <span class="inlinemediaobject"><img src="images/jumping-orca_rotated_25percent.png" align="middle"></span>
      </a>
    </h2></div><div><p class="copyright">Copyright &copy; 2014 Apache Software Foundation. All Rights Reserved. Apache Hadoop, Hadoop, MapReduce,
        HDFS, Zookeeper, HBase, and the HBase project logo are trademarks of the Apache Software
        Foundation. </p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 
          0.98.8-hadoop2
        </td><td align="left">
          2014-11-14T18:17
        </td></tr></table></div></div><div><div class="abstract" title="Abstract"><p class="title"><b>Abstract</b></p><p>This is the official reference guide of <a class="link" href="http://www.hbase.org" target="_top">Apache HBase&#153;</a>, a distributed, versioned, big
        data store built on top of <a class="link" href="http://hadoop.apache.org/" target="_top">Apache Hadoop&#153;</a> and <a class="link" href="http://zookeeper.apache.org/" target="_top">Apache ZooKeeper&#153;</a>. </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#getting_started">1. Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e102">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#quickstart">1.2. Quick Start - Standalone HBase</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">2. Apache HBase Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#basic.prerequisites">2.1. Basic Prerequisites</a></span></dt><dt><span class="section"><a href="#standalone_dist">2.2. HBase run modes: Standalone and Distributed</a></span></dt><dt><span class="section"><a href="#confirm">2.3. Running and Confirming Your Installation</a></span></dt><dt><span class="section"><a href="#config.files">2.4. Configuration Files</a></span></dt><dt><span class="section"><a href="#example_config">2.5. Example Configurations</a></span></dt><dt><span class="section"><a href="#important_configurations">2.6. The Important Configurations</a></span></dt><dt><span class="section"><a href="#dyn_config">2.7. Dynamic Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#upgrading">3. Upgrading</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.versioning">3.1. HBase version numbers</a></span></dt><dt><span class="section"><a href="#upgrade1.0">3.2. Upgrading from 0.98.x to 1.0.x</a></span></dt><dt><span class="section"><a href="#upgrade0.98">3.3. Upgrading from 0.96.x to 0.98.x</a></span></dt><dt><span class="section"><a href="#d2875e4700">3.4. Upgrading from 0.94.x to 0.98.x</a></span></dt><dt><span class="section"><a href="#upgrade0.96">3.5. Upgrading from 0.94.x to 0.96.x</a></span></dt><dt><span class="section"><a href="#upgrade0.94">3.6. Upgrading from 0.92.x to 0.94.x</a></span></dt><dt><span class="section"><a href="#upgrade0.92">3.7. Upgrading from 0.90.x to 0.92.x</a></span></dt><dt><span class="section"><a href="#upgrade0.90">3.8. Upgrading to HBase 0.90.x from 0.20.x or 0.89.x</a></span></dt></dl></dd><dt><span class="chapter"><a href="#shell">4. The Apache HBase Shell</a></span></dt><dd><dl><dt><span class="section"><a href="#scripting">4.1. Scripting with Ruby</a></span></dt><dt><span class="section"><a href="#d2875e5109">4.2. Running the Shell in Non-Interactive Mode</a></span></dt><dt><span class="section"><a href="#hbase.shell.noninteractive">4.3. HBase Shell in OS Scripts</a></span></dt><dt><span class="section"><a href="#d2875e5185">4.4. Read HBase Shell Commands from a Command File</a></span></dt><dt><span class="section"><a href="#d2875e5214">4.5. Passing VM Options to the Shell</a></span></dt><dt><span class="section"><a href="#shell_tricks">4.6. Shell Tricks</a></span></dt></dl></dd><dt><span class="chapter"><a href="#datamodel">5. Data Model</a></span></dt><dd><dl><dt><span class="section"><a href="#conceptual.view">5.1. Conceptual View</a></span></dt><dt><span class="section"><a href="#physical.view">5.2. Physical View</a></span></dt><dt><span class="section"><a href="#namespace">5.3. Namespace</a></span></dt><dt><span class="section"><a href="#table">5.4. Table</a></span></dt><dt><span class="section"><a href="#row">5.5. Row</a></span></dt><dt><span class="section"><a href="#columnfamily">5.6. Column Family</a></span></dt><dt><span class="section"><a href="#cells">5.7. Cells</a></span></dt><dt><span class="section"><a href="#data_model_operations">5.8. Data Model Operations</a></span></dt><dt><span class="section"><a href="#versions">5.9. Versions</a></span></dt><dt><span class="section"><a href="#dm.sort">5.10. Sort Order</a></span></dt><dt><span class="section"><a href="#dm.column.metadata">5.11. Column Metadata</a></span></dt><dt><span class="section"><a href="#joins">5.12. Joins</a></span></dt><dt><span class="section"><a href="#acid">5.13. ACID</a></span></dt></dl></dd><dt><span class="chapter"><a href="#schema">6. HBase and Schema Design</a></span></dt><dd><dl><dt><span class="section"><a href="#schema.creation">6.1.  Schema Creation </a></span></dt><dt><span class="section"><a href="#number.of.cfs">6.2.  On the number of column families </a></span></dt><dt><span class="section"><a href="#rowkey.design">6.3. Rowkey Design</a></span></dt><dt><span class="section"><a href="#schema.versions">6.4.  Number of Versions </a></span></dt><dt><span class="section"><a href="#supported.datatypes">6.5.  Supported Datatypes </a></span></dt><dt><span class="section"><a href="#schema.joins">6.6. Joins</a></span></dt><dt><span class="section"><a href="#ttl">6.7. Time To Live (TTL)</a></span></dt><dt><span class="section"><a href="#cf.keep.deleted">6.8.  Keeping Deleted Cells </a></span></dt><dt><span class="section"><a href="#secondary.indexes">6.9.  Secondary Indexes and Alternate Query Paths </a></span></dt><dt><span class="section"><a href="#constraints">6.10. Constraints</a></span></dt><dt><span class="section"><a href="#schema.casestudies">6.11. Schema Design Case Studies</a></span></dt><dt><span class="section"><a href="#schema.ops">6.12. Operational and Performance Configuration Options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mapreduce">7. HBase and MapReduce</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.mapreduce.classpath">7.1. HBase, MapReduce, and the CLASSPATH</a></span></dt><dt><span class="section"><a href="#d2875e7384">7.2. MapReduce Scan Caching</a></span></dt><dt><span class="section"><a href="#d2875e7426">7.3. Bundled HBase MapReduce Jobs</a></span></dt><dt><span class="section"><a href="#d2875e7445">7.4. HBase as a MapReduce Job Data Source and Data Sink</a></span></dt><dt><span class="section"><a href="#d2875e7498">7.5. Writing HFiles Directly During Bulk Import</a></span></dt><dt><span class="section"><a href="#d2875e7505">7.6. RowCounter Example</a></span></dt><dt><span class="section"><a href="#splitter">7.7. Map-Task Splitting</a></span></dt><dt><span class="section"><a href="#mapreduce.example">7.8. HBase MapReduce Examples</a></span></dt><dt><span class="section"><a href="#mapreduce.htable.access">7.9. Accessing Other HBase Tables in a MapReduce Job</a></span></dt><dt><span class="section"><a href="#mapreduce.specex">7.10. Speculative Execution</a></span></dt></dl></dd><dt><span class="chapter"><a href="#security">8. Secure Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.secure.configuration">8.1. Secure Client Access to Apache HBase</a></span></dt><dt><span class="section"><a href="#hbase.secure.simpleconfiguration">8.2. Simple User Access to Apache HBase</a></span></dt><dt><span class="section"><a href="#d2875e8115">8.3. Securing Access To Your Data</a></span></dt><dt><span class="section"><a href="#security.example.config">8.4. Security Configuration Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">9. Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#arch.overview">9.1. Overview</a></span></dt><dt><span class="section"><a href="#arch.catalog">9.2. Catalog Tables</a></span></dt><dt><span class="section"><a href="#client">9.3. Client</a></span></dt><dt><span class="section"><a href="#client.filter">9.4. Client Request Filters</a></span></dt><dt><span class="section"><a href="#master">9.5. Master</a></span></dt><dt><span class="section"><a href="#regionserver.arch">9.6. RegionServer</a></span></dt><dt><span class="section"><a href="#regions.arch">9.7. Regions</a></span></dt><dt><span class="section"><a href="#arch.bulk.load">9.8. Bulk Loading</a></span></dt><dt><span class="section"><a href="#arch.hdfs">9.9. HDFS</a></span></dt><dt><span class="section"><a href="#arch.timelineconsistent.reads">9.10. Timeline-consistent High Available Reads</a></span></dt></dl></dd><dt><span class="chapter"><a href="#hbase_apis">10. Apache HBase APIs</a></span></dt><dt><span class="chapter"><a href="#external_apis">11. Apache HBase External APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#nonjava.jvm">11.1. Non-Java Languages Talking to the JVM</a></span></dt><dt><span class="section"><a href="#rest">11.2. REST</a></span></dt><dt><span class="section"><a href="#d2875e12924">11.3. Thrift</a></span></dt><dt><span class="section"><a href="#c">11.4. C/C++ Apache HBase Client</a></span></dt></dl></dd><dt><span class="chapter"><a href="#thrift">12. Thrift API and Filter Language</a></span></dt><dd><dl><dt><span class="section"><a href="#thrift.filter-language">12.1. Filter Language</a></span></dt></dl></dd><dt><span class="chapter"><a href="#cp">13. Apache HBase Coprocessors</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e13646">13.1. Coprocessor Framework</a></span></dt><dt><span class="section"><a href="#d2875e13822">13.2. Examples</a></span></dt><dt><span class="section"><a href="#d2875e13830">13.3. Building A Coprocessor</a></span></dt><dt><span class="section"><a href="#d2875e13944">13.4. Check the Status of a Coprocessor</a></span></dt><dt><span class="section"><a href="#d2875e13960">13.5. Monitor Time Spent in Coprocessors</a></span></dt><dt><span class="section"><a href="#d2875e13981">13.6. Status of Coprocessors in HBase</a></span></dt></dl></dd><dt><span class="chapter"><a href="#performance">14. Apache HBase Performance Tuning</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.os">14.1. Operating System</a></span></dt><dt><span class="section"><a href="#perf.network">14.2. Network</a></span></dt><dt><span class="section"><a href="#jvm">14.3. Java</a></span></dt><dt><span class="section"><a href="#perf.configurations">14.4. HBase Configurations</a></span></dt><dt><span class="section"><a href="#perf.zookeeper">14.5. ZooKeeper</a></span></dt><dt><span class="section"><a href="#perf.schema">14.6. Schema Design</a></span></dt><dt><span class="section"><a href="#perf.general">14.7. HBase General Patterns</a></span></dt><dt><span class="section"><a href="#perf.writing">14.8. Writing to HBase</a></span></dt><dt><span class="section"><a href="#perf.reading">14.9. Reading from HBase</a></span></dt><dt><span class="section"><a href="#perf.deleting">14.10. Deleting from HBase</a></span></dt><dt><span class="section"><a href="#perf.hdfs">14.11. HDFS</a></span></dt><dt><span class="section"><a href="#perf.ec2">14.12. Amazon EC2</a></span></dt><dt><span class="section"><a href="#perf.hbase.mr.cluster">14.13. Collocating HBase and MapReduce</a></span></dt><dt><span class="section"><a href="#perf.casestudy">14.14. Case Studies</a></span></dt></dl></dd><dt><span class="chapter"><a href="#trouble">15. Troubleshooting and Debugging Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.general">15.1. General Guidelines</a></span></dt><dt><span class="section"><a href="#trouble.log">15.2. Logs</a></span></dt><dt><span class="section"><a href="#trouble.resources">15.3. Resources</a></span></dt><dt><span class="section"><a href="#trouble.tools">15.4. Tools</a></span></dt><dt><span class="section"><a href="#trouble.client">15.5. Client</a></span></dt><dt><span class="section"><a href="#trouble.mapreduce">15.6. MapReduce</a></span></dt><dt><span class="section"><a href="#trouble.namenode">15.7. NameNode</a></span></dt><dt><span class="section"><a href="#trouble.network">15.8. Network</a></span></dt><dt><span class="section"><a href="#trouble.rs">15.9. RegionServer</a></span></dt><dt><span class="section"><a href="#trouble.master">15.10. Master</a></span></dt><dt><span class="section"><a href="#trouble.zookeeper">15.11. ZooKeeper</a></span></dt><dt><span class="section"><a href="#trouble.ec2">15.12. Amazon EC2</a></span></dt><dt><span class="section"><a href="#trouble.versions">15.13. HBase and Hadoop version issues</a></span></dt><dt><span class="section"><a href="#d2875e16399">15.14. IPC Configuration Conflicts with Hadoop</a></span></dt><dt><span class="section"><a href="#d2875e16556">15.15. HBase and HDFS</a></span></dt><dt><span class="section"><a href="#trouble.tests">15.16. Running unit or integration tests</a></span></dt><dt><span class="section"><a href="#trouble.casestudy">15.17. Case Studies</a></span></dt><dt><span class="section"><a href="#trouble.crypto">15.18. Cryptographic Features</a></span></dt><dt><span class="section"><a href="#d2875e16806">15.19. Operating System Specific Issues</a></span></dt><dt><span class="section"><a href="#d2875e16848">15.20. JDK Issues</a></span></dt></dl></dd><dt><span class="chapter"><a href="#casestudies">16. Apache HBase Case Studies</a></span></dt><dd><dl><dt><span class="section"><a href="#casestudies.overview">16.1. Overview</a></span></dt><dt><span class="section"><a href="#casestudies.schema">16.2. Schema Design</a></span></dt><dt><span class="section"><a href="#casestudies.perftroub">16.3. Performance/Troubleshooting</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ops_mgt">17. Apache HBase Operational Management</a></span></dt><dd><dl><dt><span class="section"><a href="#tools">17.1. HBase Tools and Utilities</a></span></dt><dt><span class="section"><a href="#ops.regionmgt">17.2. Region Management</a></span></dt><dt><span class="section"><a href="#node.management">17.3. Node Management</a></span></dt><dt><span class="section"><a href="#hbase_metrics">17.4. HBase Metrics</a></span></dt><dt><span class="section"><a href="#ops.monitoring">17.5. HBase Monitoring</a></span></dt><dt><span class="section"><a href="#cluster_replication">17.6. Cluster Replication</a></span></dt><dt><span class="section"><a href="#ops.backup">17.7. HBase Backup</a></span></dt><dt><span class="section"><a href="#ops.snapshots">17.8. HBase Snapshots</a></span></dt><dt><span class="section"><a href="#ops.capacity">17.9. Capacity Planning and Region Sizing</a></span></dt><dt><span class="section"><a href="#table.rename">17.10. Table Rename</a></span></dt></dl></dd><dt><span class="chapter"><a href="#developer">18. Building and Developing Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#getting.involved">18.1. Getting Involved</a></span></dt><dt><span class="section"><a href="#repos">18.2. Apache HBase Repositories</a></span></dt><dt><span class="section"><a href="#ides">18.3. IDEs</a></span></dt><dt><span class="section"><a href="#build">18.4. Building Apache HBase</a></span></dt><dt><span class="section"><a href="#releasing">18.5. Releasing Apache HBase</a></span></dt><dt><span class="section"><a href="#hbase.rc.voting">18.6. Voting on Release Candidates</a></span></dt><dt><span class="section"><a href="#documentation">18.7. Generating the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#hbase.org">18.8. Updating hbase.apache.org</a></span></dt><dt><span class="section"><a href="#hbase.tests">18.9. Tests</a></span></dt><dt><span class="section"><a href="#developing">18.10. Developer Guidelines</a></span></dt></dl></dd><dt><span class="chapter"><a href="#unit.tests">19. Unit Testing HBase Applications</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e22105">19.1. JUnit</a></span></dt><dt><span class="section"><a href="#mockito">19.2. Mockito</a></span></dt><dt><span class="section"><a href="#d2875e22189">19.3. MRUnit</a></span></dt><dt><span class="section"><a href="#d2875e22218">19.4. Integration Testing with a HBase Mini-Cluster</a></span></dt></dl></dd><dt><span class="chapter"><a href="#zookeeper">20. ZooKeeper</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e22377">20.1. Using existing ZooKeeper ensemble</a></span></dt><dt><span class="section"><a href="#zk.sasl.auth">20.2. SASL Authentication with ZooKeeper</a></span></dt></dl></dd><dt><span class="chapter"><a href="#community">21. Community</a></span></dt><dd><dl><dt><span class="section"><a href="#decisions">21.1. Decisions</a></span></dt><dt><span class="section"><a href="#community.roles">21.2. Community Roles</a></span></dt><dt><span class="section"><a href="#hbase.commit.msg.format">21.3. Commit Message format</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix_contributing_to_documentation">A. Contributing to Documentation</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e22874">A.1. Getting Access to the Wiki</a></span></dt><dt><span class="section"><a href="#d2875e22882">A.2. Contributing to Documentation or Other Strings</a></span></dt><dt><span class="section"><a href="#d2875e22953">A.3. Editing the HBase Website</a></span></dt><dt><span class="section"><a href="#d2875e22982">A.4. Editing the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#d2875e23001">A.5. Auto-Generated Content</a></span></dt><dt><span class="section"><a href="#d2875e23016">A.6. Multi-Page and Single-Page Output</a></span></dt><dt><span class="section"><a href="#d2875e23039">A.7. Images in the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#d2875e23055">A.8. Adding a New Chapter to the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#d2875e23066">A.9. Docbook Common Issues</a></span></dt></dl></dd><dt><span class="appendix"><a href="#faq">B. FAQ</a></span></dt><dt><span class="appendix"><a href="#hbck.in.depth">C. hbck In Depth</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e23441">C.1. Running hbck to identify inconsistencies</a></span></dt><dt><span class="section"><a href="#d2875e23459">C.2. Inconsistencies</a></span></dt><dt><span class="section"><a href="#d2875e23480">C.3. Localized repairs</a></span></dt><dt><span class="section"><a href="#d2875e23525">C.4. Region Overlap Repairs</a></span></dt></dl></dd><dt><span class="appendix"><a href="#appendix_acl_matrix">D. Access Control Matrix</a></span></dt><dt><span class="appendix"><a href="#compression">E. Compression and Data Block Encoding In
          HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e24649">E.1. Which Compressor or Data Block Encoder To Use</a></span></dt><dt><span class="section"><a href="#hadoop.native.lib">E.2. Making use of Hadoop Native Libraries in HBase</a></span></dt><dt><span class="section"><a href="#d2875e24742">E.3. Compressor Configuration, Installation, and Use</a></span></dt><dt><span class="section"><a href="#data.block.encoding.enable">E.4. Enable Data Block Encoding</a></span></dt></dl></dd><dt><span class="appendix"><a href="#sql">F. SQL over HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#phoenix">F.1. Apache Phoenix</a></span></dt><dt><span class="section"><a href="#trafodion">F.2. Trafodion</a></span></dt></dl></dd><dt><span class="appendix"><a href="#d2875e24943">G. YCSB: The Yahoo! Cloud Serving Benchmark and HBase</a></span></dt><dt><span class="appendix"><a href="#hfile_format">H. HFile format</a></span></dt><dd><dl><dt><span class="section"><a href="#hfilev1">H.1. HBase File Format (version 1)</a></span></dt><dt><span class="section"><a href="#hfilev2">H.2. 
      HBase file format with inline blocks (version 2)
      </a></span></dt><dt><span class="section"><a href="#hfilev3">H.3. HBase File Format with Security Enhancements (version 3)</a></span></dt></dl></dd><dt><span class="appendix"><a href="#other.info">I. Other Information About HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#other.info.videos">I.1. HBase Videos</a></span></dt><dt><span class="section"><a href="#other.info.pres">I.2. HBase Presentations (Slides)</a></span></dt><dt><span class="section"><a href="#other.info.papers">I.3. HBase Papers</a></span></dt><dt><span class="section"><a href="#other.info.sites">I.4. HBase Sites</a></span></dt><dt><span class="section"><a href="#other.info.books">I.5. HBase Books</a></span></dt><dt><span class="section"><a href="#other.info.books.hadoop">I.6. Hadoop Books</a></span></dt></dl></dd><dt><span class="appendix"><a href="#hbase.history">J. HBase History</a></span></dt><dt><span class="appendix"><a href="#asf">K. HBase and the Apache Software Foundation</a></span></dt><dd><dl><dt><span class="section"><a href="#asf.devprocess">K.1. ASF Development Process</a></span></dt><dt><span class="section"><a href="#asf.reporting">K.2. ASF Board Reporting</a></span></dt></dl></dd><dt><span class="appendix"><a href="#orca">L. Apache HBase Orca</a></span></dt><dt><span class="appendix"><a href="#tracing">M. Enabling Dapper-like Tracing in HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#tracing.spanreceivers">M.1. SpanReceivers</a></span></dt><dt><span class="section"><a href="#tracing.client.modifications">M.2. Client Modifications</a></span></dt><dt><span class="section"><a href="#tracing.client.shell">M.3. Tracing from HBase Shell</a></span></dt></dl></dd><dt><span class="appendix"><a href="#hbase.rpc">N. 0.95 RPC Specification</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e25940">N.1. Goals</a></span></dt><dt><span class="section"><a href="#d2875e25953">N.2. TODO</a></span></dt><dt><span class="section"><a href="#d2875e25969">N.3. RPC</a></span></dt><dt><span class="section"><a href="#d2875e26087">N.4. Notes</a></span></dt></dl></dd><dt><span class="index"><a href="#book_index">Index</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>9.1. <a href="#d2875e10868">Region State Transitions</a></dt><dt>9.2. <a href="#d2875e12690">HFile Version 1</a></dt><dt>13.1. <a href="#d2875e13972">Coprocessor Metrics UI</a></dt><dt>17.1. <a href="#d2875e18564">Basic Info</a></dt><dt>17.2. <a href="#d2875e18573">Config</a></dt><dt>17.3. <a href="#d2875e18582">Stats</a></dt><dt>17.4. <a href="#d2875e18591">L1 and L2</a></dt><dt>17.5. <a href="#d2875e18634">Replication Architecture Overview</a></dt><dt>E.1. <a href="#d2875e24601">ColumnFamily with No Encoding</a></dt><dt>E.2. <a href="#d2875e24612">ColumnFamily with Prefix Encoding</a></dt><dt>E.3. <a href="#d2875e24628">ColumnFamily with Diff Encoding</a></dt><dt>H.1. <a href="#d2875e24976">HFile V1 Format</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>1.1. <a href="#d2875e614">Distributed Cluster Demo Architecture</a></dt><dt>2.1. <a href="#java">Java</a></dt><dt>2.2. <a href="#d2875e1440">Hadoop version support matrix</a></dt><dt>5.1. <a href="#d2875e5484">Table <code class="varname">webtable</code></a></dt><dt>5.2. <a href="#d2875e5590">ColumnFamily <code class="varname">anchor</code></a></dt><dt>5.3. <a href="#d2875e5628">ColumnFamily <code class="varname">contents</code></a></dt><dt>8.1. <a href="#d2875e8216">Operation To Permission Mapping</a></dt><dt>8.2. <a href="#d2875e8742">Examples of Visibility Expressions</a></dt><dt>9.1. <a href="#d2875e12392">Stripe Sizing Settings</a></dt><dt>18.1. <a href="#d2875e21124">Release Managers</a></dt><dt>D.1. <a href="#d2875e23713">ACL Matrix</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>1.1. <a href="#d2875e143">Example /etc/hosts File for Ubuntu</a></dt><dt>1.2. <a href="#d2875e245">Example <code class="filename">hbase-site.xml</code> for Standalone HBase</a></dt><dt>1.3. <a href="#d2875e950"><code class="code">node-a</code> <span class="command">jps</span> Output</a></dt><dt>1.4. <a href="#d2875e963"><code class="code">node-b</code> <span class="command">jps</span> Output</a></dt><dt>1.5. <a href="#d2875e976"><code class="code">node-c</code> <span class="command">jps</span> Output</a></dt><dt>2.1. <a href="#d2875e1333">Calculate the Potential Number of Open Files</a></dt><dt>2.2. <a href="#d2875e1872">Example Distributed HBase Cluster</a></dt><dt>4.1. <a href="#d2875e5136">Passing Commands to the HBase Shell</a></dt><dt>4.2. <a href="#d2875e5165">Checking the Result of a Scripted Command</a></dt><dt>4.3. <a href="#d2875e5190">Example Command File</a></dt><dt>4.4. <a href="#d2875e5195">Directing HBase Shell to Execute the Commands</a></dt><dt>5.1. <a href="#d2875e5735">Examples</a></dt><dt>5.2. <a href="#d2875e5758">Examples</a></dt><dt>5.3. <a href="#d2875e5959">Modify the Maximum Number of Versions for a Column</a></dt><dt>5.4. <a href="#d2875e5972">Modify the Minimum Number of Versions for a Column</a></dt><dt>6.1. <a href="#d2875e6273">Salting Example</a></dt><dt>6.2. <a href="#d2875e6314">Hashing Example</a></dt><dt>6.3. <a href="#d2875e6598">Change the Value of <code class="code">KEEP_DELETED_CELLS</code> Using HBase Shell</a></dt><dt>6.4. <a href="#d2875e6606">Change the Value of <code class="code">KEEP_DELETED_CELLS</code> Using the API</a></dt><dt>8.1. <a href="#d2875e8537">HBase Shell</a></dt><dt>8.2. <a href="#d2875e8622">API</a></dt><dt>8.3. <a href="#d2875e8657">Revoking Access To a Table</a></dt><dt>8.4. <a href="#d2875e8665">HBase Shell</a></dt><dt>8.5. <a href="#d2875e8676">API</a></dt><dt>8.6. <a href="#d2875e8842">HBase Shell</a></dt><dt>8.7. <a href="#d2875e8849">Java API</a></dt><dt>8.8. <a href="#d2875e8857">HBase Shell</a></dt><dt>8.9. <a href="#d2875e8872">Java API</a></dt><dt>8.10. <a href="#d2875e8880">HBase Shell</a></dt><dt>8.11. <a href="#d2875e8895">Java API</a></dt><dt>8.12. <a href="#d2875e8905">HBase Shell</a></dt><dt>8.13. <a href="#d2875e8923">Java API</a></dt><dt>8.14. <a href="#d2875e9124">HBase Shell</a></dt><dt>8.15. <a href="#d2875e9129">Java API</a></dt><dt>8.16. <a href="#d2875e9254">Example Security Settings in <code class="filename">hbase-site.xml</code></a></dt><dt>8.17. <a href="#d2875e9261">Example Group Mapper in Hadoop <code class="filename">core-site.xml</code></a></dt><dt>9.1. <a href="#d2875e9541">Pre-Creating a <code class="code">HConnection</code></a></dt><dt>10.1. <a href="#d2875e12861">Create a Table Using Java</a></dt><dt>10.2. <a href="#d2875e12868">Add, Modify, and Delete a Table</a></dt><dt>12.1. <a href="#d2875e13040">Compound Operators</a></dt><dt>12.2. <a href="#d2875e13072">Precedence Example</a></dt><dt>12.3. <a href="#d2875e13173">Example 1</a></dt><dt>12.4. <a href="#d2875e13180">Example 2</a></dt><dt>12.5. <a href="#d2875e13187">Example 3</a></dt><dt>12.6. <a href="#d2875e13194">Example 4</a></dt><dt>13.1. <a href="#d2875e13859">Example RegionObserver Configuration</a></dt><dt>13.2. <a href="#d2875e13886">Load a Coprocessor On a Table Using HBase Shell</a></dt><dt>13.3. <a href="#d2875e13921">Unload a Coprocessor From a Table Using HBase Shell</a></dt><dt>14.1. <a href="#d2875e14163">Enable Prefetch Using HBase Shell</a></dt><dt>14.2. <a href="#d2875e14168">Enable Prefetch Using the API</a></dt><dt>14.3. <a href="#d2875e15143">Hedged Reads Configuration Example</a></dt><dt>17.1. <a href="#d2875e17869"><code class="filename">rolling-restart.sh</code> General Usage</a></dt><dt>18.1. <a href="#submitting.patches.jira.code">Code Blocks in Jira Comments</a></dt><dt>18.2. <a href="#mvn.settings.file">Example <code class="filename">~/.m2/settings.xml</code> File</a></dt><dt>18.3. <a href="#d2875e21956">Example of Committing a Patch</a></dt><dt>B.1. <a href="#d2875e23254">Maven Dependency for HBase 0.98</a></dt><dt>B.2. <a href="#d2875e23259">Maven Dependency for HBase 0.96</a></dt><dt>B.3. <a href="#d2875e23264">Maven Dependency for HBase 0.94</a></dt><dt>E.1. <a href="#d2875e24872">Enabling Compression on a ColumnFamily of an Existing Table using HBase
            Shell</a></dt><dt>E.2. <a href="#d2875e24877">Creating a New Table with Compression On a ColumnFamily</a></dt><dt>E.3. <a href="#d2875e24882">Verifying a ColumnFamily's Compression Settings</a></dt><dt>E.4. <a href="#d2875e24898"><span class="command">LoadTestTool</span> Usage</a></dt><dt>E.5. <a href="#d2875e24905">Example Usage of LoadTestTool</a></dt><dt>E.6. <a href="#d2875e24918">Enable Data Block Encoding On a Table</a></dt><dt>E.7. <a href="#d2875e24923">Verifying a ColumnFamily's Data Block Encoding</a></dt></dl></div><div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><p>This is the official reference guide for the <a class="link" href="http://hbase.apache.org/" target="_top">HBase</a> version it ships with. Herein you
        will find either the definitive documentation on an HBase topic as of its standing when the
        referenced HBase version shipped, or it will point to the location in <a class="link" href="http://hbase.apache.org/apidocs/index.html" target="_top">javadoc</a>, <a class="link" href="https://issues.apache.org/jira/browse/HBASE" target="_top">JIRA</a> or <a class="link" href="http://wiki.apache.org/hadoop/Hbase" target="_top">wiki</a> where the pertinent
        information can be found.</p><p title="About This Guide"><b>About This Guide.&nbsp;</b>This reference guide is a work in progress. The source for this guide can be found in
            the <code class="filename">src/main/docbkx</code> directory of the HBase source. This reference
            guide is marked up using <a class="link" href="http://www.docbook.org/" target="_top">DocBook</a> from
            which the the finished guide is generated as part of the 'site' build target. Run
            </p><pre class="programlisting">mvn site</pre><p title="About This Guide"> to generate this documentation. Amendments and
            improvements to the documentation are welcomed. Click <a class="link" href="https://issues.apache.org/jira/secure/CreateIssueDetails!init.jspa?pid=12310753&amp;issuetype=1&amp;components=12312132&amp;summary=SHORT+DESCRIPTION" target="_top">this link</a> to file a new documentation bug against Apache HBase with some
            values pre-selected.</p><p title="Contributing to the Documentation"><b>Contributing to the Documentation.&nbsp;</b>For an overview of Docbook and suggestions to get started contributing to the documentation, see <a class="xref" href="#appendix_contributing_to_documentation" title="Appendix&nbsp;A.&nbsp;Contributing to Documentation">Appendix&nbsp;A, <i>Contributing to Documentation</i></a>.</p><p title="Providing Feedback"><b>Providing Feedback.&nbsp;</b>This guide allows you to leave comments or questions on any page, using Disqus. Look
            for the Comments area at the bottom of the page. Answering these questions is a
            volunteer effort, and may be delayed.</p><div class="note" title="Heads-up if this is your first foray into the world of distributed computing..." style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="headsup"></a>Heads-up if this is your first foray into the world of distributed
            computing...</h3><p> If this is your first foray into the wonderful world of Distributed Computing, then
            you are in for some interesting times. First off, distributed systems are hard; making a
            distributed system hum requires a disparate skillset that spans systems (hardware and
            software) and networking. Your cluster' operation can hiccup because of any of a myriad
            set of reasons from bugs in HBase itself through misconfigurations -- misconfiguration
            of HBase but also operating system misconfigurations -- through to hardware problems
            whether it be a bug in your network card drivers or an underprovisioned RAM bus (to
            mention two recent examples of hardware issues that manifested as "HBase is slow"). You
            will also need to do a recalibration if up to this your computing has been bound to a
            single box. Here is one good starting point: <a class="link" href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing" target="_top">Fallacies
                of Distributed Computing</a>. That said, you are welcome. Its a fun place to be.
            Yours, the HBase Community. </p></div></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Getting Started"><div class="titlepage"><div><div><h2 class="title"><a name="getting_started"></a>Chapter&nbsp;1.&nbsp;Getting Started</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e102">1.1. Introduction</a></span></dt><dt><span class="section"><a href="#quickstart">1.2. Quick Start - Standalone HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e153">1.2.1. JDK Version Requirements</a></span></dt><dt><span class="section"><a href="#d2875e160">1.2.2. Get Started with HBase</a></span></dt><dt><span class="section"><a href="#quickstart-pseudo">1.2.3. Intermediate - Pseudo-Distributed Local Install</a></span></dt><dt><span class="section"><a href="#quickstart-fully-distributed">1.2.4. Advanced - Fully Distributed</a></span></dt><dt><span class="section"><a href="#d2875e1026">1.2.5. Where to go next</a></span></dt></dl></dd></dl></div><div class="section" title="1.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e102"></a>1.1.&nbsp;Introduction</h2></div></div></div><p><a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a> will get you up and running on a single-node, standalone
      instance of HBase, followed by a pseudo-distributed single-machine instance, and finally a
      fully-distributed cluster. </p></div><div class="section" title="1.2.&nbsp;Quick Start - Standalone HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quickstart"></a>1.2.&nbsp;Quick Start - Standalone HBase</h2></div></div></div><p>This guide describes setup of a standalone HBase instance running against the local
      filesystem. This is not an appropriate configuration for a production instance of HBase, but
      will allow you to experiment with HBase. This section shows you how to create a table in
      HBase using the <span class="command"><strong>hbase shell</strong></span> CLI, insert rows into the table, perform put
      and scan operations against the table, enable or disable the table, and start and stop HBase.
      Apart from downloading HBase, this procedure should take less than 10 minutes.</p><div class="warning" title="Local Filesystem and Durability" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="local.fs.durability"></a>Local Filesystem and Durability</h3><p><span class="emphasis"><em>The below advice is for HBase 0.98.2 and earlier releases only. This is fixed
        in HBase 0.98.3 and beyond. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11272" target="_top">HBASE-11272</a> and
        <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11218" target="_top">HBASE-11218</a>.</em></span></p><p>Using HBase with a local filesystem does not guarantee durability. The HDFS
        local filesystem implementation will lose edits if files are not properly closed. This is
        very likely to happen when you are experimenting with new software, starting and stopping
        the daemons often and not always cleanly. You need to run HBase on HDFS
        to ensure all writes are preserved. Running against the local filesystem is intended as a
        shortcut to get you familiar with how the general system works, as the very first phase of
        evaluation. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3696" target="_top">https://issues.apache.org/jira/browse/HBASE-3696</a> and its associated issues
        for more details about the issues of running on the local filesystem.</p></div><div class="note" title="Loopback IP - HBase 0.94.x and earlier" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="loopback.ip.getting.started"></a>Loopback IP - HBase 0.94.x and earlier</h3><p><span class="emphasis"><em>The below advice is for hbase-0.94.x and older versions only. This is fixed in
          hbase-0.96.0 and beyond.</em></span></p><p>Prior to HBase 0.94.x, HBase expected the loopback IP address to be 127.0.0.1. Ubuntu
        and some other distributions default to 127.0.1.1 and this will cause problems for you . See <a class="link" href="http://blog.devving.com/why-does-hbase-care-about-etchosts/" target="_top">Why does HBase
          care about /etc/hosts?</a> for detail.</p><div class="example"><a name="d2875e143"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;Example /etc/hosts File for Ubuntu</b></p><div class="example-contents"><p>The following <code class="filename">/etc/hosts</code> file works correctly for HBase 0.94.x
          and earlier, on Ubuntu. Use this as a template if you run into trouble.</p><pre class="screen">
127.0.0.1 localhost
127.0.0.1 ubuntu.ubuntu-domain ubuntu
        </pre></div></div><br class="example-break"></div><div class="section" title="1.2.1.&nbsp;JDK Version Requirements"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e153"></a>1.2.1.&nbsp;JDK Version Requirements</h3></div></div></div><p>HBase requires that a JDK be installed. See <a class="xref" href="#java" title="Table&nbsp;2.1.&nbsp;Java">Table&nbsp;2.1, &#8220;Java&#8221;</a> for information
        about supported JDK versions.</p></div><div class="section" title="1.2.2.&nbsp;Get Started with HBase"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e160"></a>1.2.2.&nbsp;Get Started with HBase</h3></div></div></div><div class="procedure" title="Procedure&nbsp;1.1.&nbsp;Download, Configure, and Start HBase"><a name="d2875e163"></a><p class="title"><b>Procedure&nbsp;1.1.&nbsp;Download, Configure, and Start HBase</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Choose a download site from this list of <a class="link" href="http://www.apache.org/dyn/closer.cgi/hbase/" target="_top">Apache Download Mirrors</a>.
        Click on the suggested top link. This will take you to a mirror of <span class="emphasis"><em>HBase
          Releases</em></span>. Click on the folder named <code class="filename">stable</code> and then
        download the binary file that ends in <code class="filename">.tar.gz</code> to your local filesystem. Be
        sure to choose the version that corresponds with the version of Hadoop you are likely to use
      later. In most cases, you should choose the file for Hadoop 2, which will be called something
      like <code class="filename">hbase-0.98.3-hadoop2-bin.tar.gz</code>. Do not download the file ending in
        <code class="filename">src.tar.gz</code> for now.</p></li><li class="step" title="Step 2"><p>Extract the downloaded file, and change to the newly-created directory.</p><pre class="screen">
$ tar xzvf hbase-&lt;?eval ${project.version}?&gt;-hadoop2-bin.tar.gz  
$ cd hbase-&lt;?eval ${project.version}?&gt;-hadoop2/
          </pre></li><li class="step" title="Step 3"><p>For HBase 0.98.5 and later, you are required to set the <code class="envar">JAVA_HOME</code>
            environment variable before starting HBase. Prior to 0.98.5, HBase attempted to detect
            the location of Java if the variables was not set. You can set the variable via your
            operating system's usual mechanism, but HBase provides a central mechanism,
              <code class="filename">conf/hbase-env.sh</code>. Edit this file, uncomment the line starting
            with <code class="literal">JAVA_HOME</code>, and set it to the appropriate location for your
            operating system. The <code class="envar">JAVA_HOME</code> variable should be set to a directory
            which contains the executable file <code class="filename">bin/java</code>. Most modern Linux
            operating systems provide a mechanism, such as /usr/bin/alternatives on RHEL or CentOS,
            for transparently switching between versions of executables such as Java. In this case,
            you can set <code class="envar">JAVA_HOME</code> to the directory containing the symbolic link to
              <code class="filename">bin/java</code>, which is usually <code class="filename">/usr</code>.</p><pre class="screen">JAVA_HOME=/usr</pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These instructions assume that each node of your cluster uses the same
              configuration. If this is not the case, you may need to set <code class="envar">JAVA_HOME</code>
              separately for each node.</p></div></li><li class="step" title="Step 4"><p>Edit <code class="filename">conf/hbase-site.xml</code>, which is the main HBase configuration
            file. At this time, you only need to specify the directory on the local filesystem where
            HBase and Zookeeper write data. By default, a new directory is created under /tmp. Many
            servers are configured to delete the contents of /tmp upon reboot, so you should store
            the data elsewhere. The following configuration will store HBase's data in the
              <code class="filename">hbase</code> directory, in the home directory of the user called
              <code class="systemitem">testuser</code>. Paste the <span class="markup">&lt;property&gt;</span> tags beneath the
            <span class="markup">&lt;configuration&gt;</span> tags, which should be empty in a new HBase install.</p><div class="example"><a name="d2875e245"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;Example <code class="filename">hbase-site.xml</code> for Standalone HBase</b></p><div class="example-contents"><pre class="programlisting">
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;file:///home/testuser/hbase&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
    &lt;value&gt;/home/testuser/zookeeper&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;              
              
            </pre></div></div><br class="example-break"><p>You do not need to create the HBase data directory. HBase will do this for you. If
            you create the directory, HBase will attempt to do a migration, which is not what you
            want.</p></li><li class="step" title="Step 5"><a name="start_hbase"></a><p>The <code class="filename">bin/start-hbase.sh</code> script is provided as a convenient way
            to start HBase. Issue the command, and if all goes well, a message is logged to standard
            output showing that HBase started successfully. You can use the <span class="command"><strong>jps</strong></span>
            command to verify that you have one running process called <code class="literal">HMaster</code>.
            In standalone mode HBase runs all daemons within this single JVM, i.e. the HMaster, a
            single HRegionServer, and the ZooKeeper daemon.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Java needs to be installed and available. If you get an error indicating that
            Java is not installed, but it is on your system, perhaps in a non-standard location,
            edit the <code class="filename">conf/hbase-env.sh</code> file and modify the
            <code class="envar">JAVA_HOME</code> setting to point to the directory that contains
            <code class="filename">bin/java</code> your system.</p></div></li></ol></div><div class="procedure" title="Procedure&nbsp;1.2.&nbsp;Use HBase For the First Time"><a name="shell_exercises"></a><p class="title"><b>Procedure&nbsp;1.2.&nbsp;Use HBase For the First Time</b></p><ol class="procedure" type="1"><li class="step" title="Connect to HBase."><p class="title"><b>Connect to HBase.</b></p><p>Connect to your running instance of HBase using the <span class="command"><strong>hbase shell</strong></span>
            command, located in the <code class="filename">bin/</code> directory of your HBase
            install. In this example, some usage and version information that is printed when you
            start HBase Shell has been omitted. The HBase Shell prompt ends with a
            <code class="literal">&gt;</code> character.</p><pre class="screen">
$ <strong class="userinput"><code>./bin/hbase shell</code></strong>
hbase(main):001:0&gt; 
          </pre></li><li class="step" title="Display HBase Shell Help Text."><p class="title"><b>Display HBase Shell Help Text.</b></p><p>Type <code class="literal">help</code> and press Enter, to display some basic usage
            information for HBase Shell, as well as several example commands. Notice that table
            names, rows, columns all must be enclosed in quote characters.</p></li><li class="step" title="Create a table."><p class="title"><b>Create a table.</b></p><p>Use the <code class="code">create</code> command to create a new table. You must specify the
            table name and the ColumnFamily name.</p><pre class="screen">
hbase&gt; <strong class="userinput"><code>create 'test', 'cf'</code></strong>    
0 row(s) in 1.2200 seconds
          </pre></li><li class="step" title="List Information About your Table"><p class="title"><b>List Information About your Table</b></p><p>Use the <code class="code">list</code> command to </p><pre class="screen">
hbase&gt; <strong class="userinput"><code>list 'test'</code></strong>
TABLE
test
1 row(s) in 0.0350 seconds

=&gt; ["test"]
          </pre></li><li class="step" title="Put data into your table."><p class="title"><b>Put data into your table.</b></p><p>To put data into your table, use the <code class="code">put</code> command.</p><pre class="screen">
hbase&gt; <strong class="userinput"><code>put 'test', 'row1', 'cf:a', 'value1'</code></strong>
0 row(s) in 0.1770 seconds

hbase&gt; <strong class="userinput"><code>put 'test', 'row2', 'cf:b', 'value2'</code></strong>
0 row(s) in 0.0160 seconds

hbase&gt; <strong class="userinput"><code>put 'test', 'row3', 'cf:c', 'value3'</code></strong>
0 row(s) in 0.0260 seconds          
          </pre><p>Here, we insert three values, one at a time. The first insert is at
              <code class="literal">row1</code>, column <code class="literal">cf:a</code>, with a value of
              <code class="literal">value1</code>. Columns in HBase are comprised of a column family prefix,
              <code class="literal">cf</code> in this example, followed by a colon and then a column qualifier
            suffix, <code class="literal">a</code> in this case.</p></li><li class="step" title="Scan the table for all data at once."><p class="title"><b>Scan the table for all data at once.</b></p><p>One of the ways to get data from HBase is to scan. Use the <span class="command"><strong>scan</strong></span>
            command to scan the table for data. You can limit your scan, but for now, all data is
            fetched.</p><pre class="screen">
hbase&gt; <strong class="userinput"><code>scan 'test'</code></strong>
ROW                   COLUMN+CELL
 row1                 column=cf:a, timestamp=1403759475114, value=value1
 row2                 column=cf:b, timestamp=1403759492807, value=value2
 row3                 column=cf:c, timestamp=1403759503155, value=value3
3 row(s) in 0.0440 seconds
          </pre></li><li class="step" title="Get a single row of data."><p class="title"><b>Get a single row of data.</b></p><p>To get a single row of data at a time, use the <span class="command"><strong>get</strong></span> command.</p><pre class="screen">
hbase&gt; <strong class="userinput"><code>get 'test', 'row1'</code></strong>
COLUMN                CELL
 cf:a                 timestamp=1403759475114, value=value1
1 row(s) in 0.0230 seconds            
          </pre></li><li class="step" title="Disable a table."><p class="title"><b>Disable a table.</b></p><p>If you want to delete a table or change its settings, as well as in some other
            situations, you need to disable the table first, using the <code class="code">disable</code>
            command. You can re-enable it using the <code class="code">enable</code> command.</p><pre class="screen">
hbase&gt; disable 'test'
0 row(s) in 1.6270 seconds

hbase&gt; enable 'test'
0 row(s) in 0.4500 seconds
          </pre><p>Disable the table again if you tested the <span class="command"><strong>enable</strong></span> command above:</p><pre class="screen">
hbase&gt; disable 'test'
0 row(s) in 1.6270 seconds            
          </pre></li><li class="step" title="Drop the table."><p class="title"><b>Drop the table.</b></p><p>To drop (delete) a table, use the <code class="code">drop</code> command.</p><pre class="screen">
hbase&gt; drop 'test'
0 row(s) in 0.2900 seconds            
          </pre></li><li class="step" title="Exit the HBase Shell."><p class="title"><b>Exit the HBase Shell.</b></p><p>To exit the HBase Shell and disconnect from your cluster, use the
              <span class="command"><strong>quit</strong></span> command. HBase is still running in the background.</p></li></ol></div><div class="procedure" title="Procedure&nbsp;1.3.&nbsp;Stop HBase"><a name="stopping"></a><p class="title"><b>Procedure&nbsp;1.3.&nbsp;Stop HBase</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>In the same way that the <code class="filename">bin/start-hbase.sh</code> script is provided
            to conveniently start all HBase daemons, the <code class="filename">bin/stop-hbase.sh</code>
            script stops them.</p><pre class="screen">
$ ./bin/stop-hbase.sh
stopping hbase....................
$
        </pre></li><li class="step" title="Step 2"><p>After issuing the command, it can take several minutes for the processes to shut
            down. Use the <span class="command"><strong>jps</strong></span> to be sure that the HMaster and HRegionServer
            processes are shut down.</p></li></ol></div></div><div class="section" title="1.2.3.&nbsp;Intermediate - Pseudo-Distributed Local Install"><div class="titlepage"><div><div><h3 class="title"><a name="quickstart-pseudo"></a>1.2.3.&nbsp;Intermediate - Pseudo-Distributed Local Install</h3></div></div></div><p>After working your way through <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a>, you can re-configure HBase
      to run in pseudo-distributed mode. Pseudo-distributed mode means
      that HBase still runs completely on a single host, but each HBase daemon (HMaster,
      HRegionServer, and Zookeeper) runs as a separate process. By default, unless you configure the
      <code class="code">hbase.rootdir</code> property as described in <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a>, your data
        is still stored in <code class="filename">/tmp/</code>. In this walk-through, we store your data in
        HDFS instead, assuming you have HDFS available. You can skip the HDFS configuration to
        continue storing your data in the local filesystem.</p><div class="note" title="Hadoop Configuration" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Hadoop Configuration</h3><p>This procedure assumes that you have configured Hadoop and HDFS on your local system
          and or a remote system, and that they are running and available. It also assumes you are
          using Hadoop 2. Currently, the documentation on the Hadoop website does not include a
          quick start for Hadoop 2, but the guide at <a class="link" href="http://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide" target="_top">http://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide</a>
          is a good starting point.</p></div><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Stop HBase if it is running."><p class="title"><b>Stop HBase if it is running.</b></p><p>If you have just finished <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a> and HBase is still running,
            stop it. This procedure will create a totally new directory where HBase will store its
            data, so any databases you created before will be lost.</p></li><li class="step" title="Configure HBase."><p class="title"><b>Configure HBase.</b></p><p>
            Edit the <code class="filename">hbase-site.xml</code> configuration. First, add the following
            property. which directs HBase to run in distributed mode, with one JVM instance per
            daemon.
          </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
            </pre><p>Next, change the <code class="code">hbase.rootdir</code> from the local filesystem to the address
            of your HDFS instance, using the <code class="code">hdfs:////</code> URI syntax. In this example,
            HDFS is running on the localhost at port 8020.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.rootdir&lt;/name&gt;
  &lt;value&gt;hdfs://localhost:8020/hbase&lt;/value&gt;
&lt;/property&gt;            
            
          </pre><p>You do not need to create the directory in HDFS. HBase will do this for you. If you
            create the directory, HBase will attempt to do a migration, which is not what you
            want.</p></li><li class="step" title="Start HBase."><p class="title"><b>Start HBase.</b></p><p>Use the <code class="filename">bin/start-hbase.sh</code> command to start HBase. If your
            system is configured correctly, the <span class="command"><strong>jps</strong></span> command should show the
            HMaster and HRegionServer processes running.</p></li><li class="step" title="Check the HBase directory in HDFS."><p class="title"><b>Check the HBase directory in HDFS.</b></p><p>If everything worked correctly, HBase created its directory in HDFS. In the
            configuration above, it is stored in <code class="filename">/hbase/</code> on HDFS. You can use
            the <span class="command"><strong>hadoop fs</strong></span> command in Hadoop's <code class="filename">bin/</code> directory
            to list this directory.</p><pre class="screen">
$ <strong class="userinput"><code>./bin/hadoop fs -ls /hbase</code></strong>
Found 7 items
drwxr-xr-x   - hbase users          0 2014-06-25 18:58 /hbase/.tmp
drwxr-xr-x   - hbase users          0 2014-06-25 21:49 /hbase/WALs
drwxr-xr-x   - hbase users          0 2014-06-25 18:48 /hbase/corrupt
drwxr-xr-x   - hbase users          0 2014-06-25 18:58 /hbase/data
-rw-r--r--   3 hbase users         42 2014-06-25 18:41 /hbase/hbase.id
-rw-r--r--   3 hbase users          7 2014-06-25 18:41 /hbase/hbase.version
drwxr-xr-x   - hbase users          0 2014-06-25 21:49 /hbase/oldWALs
          </pre></li><li class="step" title="Create a table and populate it with data."><p class="title"><b>Create a table and populate it with data.</b></p><p>You can use the HBase Shell to create a table, populate it with data, scan and get
            values from it, using the same procedure as in <a class="xref" href="#shell_exercises" title="Procedure&nbsp;1.2.&nbsp;Use HBase For the First Time">Procedure&nbsp;1.2, &#8220;Use HBase For the First Time&#8221;</a>.</p></li><li class="step" title="Start and stop a backup HBase Master (HMaster) server."><p class="title"><b>Start and stop a backup HBase Master (HMaster) server.</b></p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Running multiple HMaster instances on the same hardware does not make sense in a
              production environment, in the same way that running a pseudo-distributed cluster does
              not make sense for production. This step is offered for testing and learning purposes
              only.</p></div><p>The HMaster server controls the HBase cluster. You can start up to 9 backup HMaster
            servers, which makes 10 total HMasters, counting the primary. To start a backup HMaster,
            use the <span class="command"><strong>local-master-backup.sh</strong></span>. For each backup master you want to
            start, add a parameter representing the port offset for that master. Each HMaster uses
            three ports (16010, 16020, and 16030 by default). The port offset is added to these ports, so
            using an offset of 2, the backup HMaster would use ports 16012, 16022, and 16032. The
            following command starts 3 backup servers using ports 16012/16022/16032, 16013/16023/16033,
            and 16015/16025/16035.</p><pre class="screen">
$ ./bin/local-master-backup.sh 2 3 5             
            </pre><p>To kill a backup master without killing the entire cluster, you need to find its
            process ID (PID). The PID is stored in a file with a name like
            <code class="filename">/tmp/hbase-<em class="replaceable"><code>USER</code></em>-<em class="replaceable"><code>X</code></em>-master.pid</code>.
          The only contents of the file are the PID. You can use the <span class="command"><strong>kill -9</strong></span>
            command to kill that PID. The following command will kill the master with port offset 1,
          but leave the cluster running:</p><pre class="screen">
$ cat /tmp/hbase-testuser-1-master.pid |xargs kill -9            
          </pre></li><li class="step" title="Start and stop additional RegionServers"><p class="title"><b>Start and stop additional RegionServers</b></p><p>The HRegionServer manages the data in its StoreFiles as directed by the HMaster.
            Generally, one HRegionServer runs per node in the cluster. Running multiple
            HRegionServers on the same system can be useful for testing in pseudo-distributed mode.
            The <span class="command"><strong>local-regionservers.sh</strong></span> command allows you to run multiple
            RegionServers. It works in a similar way to the
            <span class="command"><strong>local-master-backup.sh</strong></span> command, in that each parameter you provide
            represents the port offset for an instance. Each RegionServer requires two ports, and
            the default ports are 16020 and 16030. However, the base ports for additional RegionServers
            are not the default ports since the default ports are used by the HMaster, which is also
            a RegionServer since HBase version 1.0.0. The base ports are 16200 and 16300 instead.
            You can run 99 additional RegionServers that are not a HMaster or backup HMaster,
            on a server. The following command starts four additional RegionServers, running on
            sequential ports starting at 16202/16302 (base ports 16200/16300 plus 2).</p><pre class="screen">
$ .bin/local-regionservers.sh start 2 3 4 5            
          </pre><p>To stop a RegionServer manually, use the <span class="command"><strong>local-regionservers.sh</strong></span>
            command with the <code class="literal">stop</code> parameter and the offset of the server to
            stop.</p><pre class="screen">$ .bin/local-regionservers.sh stop 3</pre></li><li class="step" title="Stop HBase."><p class="title"><b>Stop HBase.</b></p><p>You can stop HBase the same way as in the <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a> procedure, using the
            <code class="filename">bin/stop-hbase.sh</code> command.</p></li></ol></div></div><div class="section" title="1.2.4.&nbsp;Advanced - Fully Distributed"><div class="titlepage"><div><div><h3 class="title"><a name="quickstart-fully-distributed"></a>1.2.4.&nbsp;Advanced - Fully Distributed</h3></div></div></div><p>In reality, you need a fully-distributed configuration to fully test HBase and to use it
        in real-world scenarios. In a distributed configuration, the cluster contains multiple
        nodes, each of which runs one or more HBase daemon. These include primary and backup Master
        instances, multiple Zookeeper nodes, and multiple RegionServer nodes.</p><p>This advanced quickstart adds two more nodes to your cluster. The architecture will be
        as follows:</p><div class="table"><a name="d2875e614"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Distributed Cluster Demo Architecture</b></p><div class="table-contents"><table summary="Distributed Cluster Demo Architecture" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Node Name</th><th>Master</th><th>ZooKeeper</th><th>RegionServer</th></tr></thead><tbody><tr><td>node-a.example.com</td><td>yes</td><td>yes</td><td>no</td></tr><tr><td>node-b.example.com</td><td>backup</td><td>yes</td><td>yes</td></tr><tr><td>node-c.example.com</td><td>no</td><td>yes</td><td>yes</td></tr></tbody></table></div></div><br class="table-break"><p>This quickstart assumes that each node is a virtual machine and that they are all on the
      same network. It builds upon the previous quickstart, <a class="xref" href="#quickstart-pseudo" title="1.2.3.&nbsp;Intermediate - Pseudo-Distributed Local Install">Section&nbsp;1.2.3, &#8220;Intermediate - Pseudo-Distributed Local Install&#8221;</a>,
        assuming that the system you configured in that procedure is now <code class="code">node-a</code>. Stop HBase on <code class="code">node-a</code>
        before continuing.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Be sure that all the nodes have full access to communicate, and that no firewall rules
        are in place which could prevent them from talking to each other. If you see any errors like
        <code class="literal">no route to host</code>, check your firewall.</p></div><div class="procedure" title="Procedure&nbsp;1.4.&nbsp;Configure Password-Less SSH Access"><a name="passwordless.ssh.quickstart"></a><p class="title"><b>Procedure&nbsp;1.4.&nbsp;Configure Password-Less SSH Access</b></p><p><code class="code">node-a</code> needs to be able to log into <code class="code">node-b</code> and
          <code class="code">node-c</code> (and to itself) in order to start the daemons. The easiest way to accomplish this is
          to use the same username on all hosts, and configure password-less SSH login from
          <code class="code">node-a</code> to each of the others. </p><ol class="procedure" type="1"><li class="step" title="On node-a, generate a key pair."><p class="title"><b>On <code class="code">node-a</code>, generate a key pair.</b></p><p>While logged in as the user who will run HBase, generate a SSH key pair, using the
            following command:
          </p><pre class="screen">$ ssh-keygen -t rsa</pre><p>If the command succeeds, the location of the key pair is printed to standard output.
          The default name of the public key is <code class="filename">id_rsa.pub</code>.</p></li><li class="step" title="Create the directory that will hold the shared keys on the other nodes."><p class="title"><b>Create the directory that will hold the shared keys on the other nodes.</b></p><p>On <code class="code">node-b</code> and <code class="code">node-c</code>, log in as the HBase user and create
            a <code class="filename">.ssh/</code> directory in the user's home directory, if it does not
            already exist. If it already exists, be aware that it may already contain other keys.</p></li><li class="step" title="Copy the public key to the other nodes."><p class="title"><b>Copy the public key to the other nodes.</b></p><p>Securely copy the public key from <code class="code">node-a</code> to each of the nodes, by
            using the <span class="command"><strong>scp</strong></span> or some other secure means. On each of the other nodes,
            create a new file called <code class="filename">.ssh/authorized_keys</code> <span class="emphasis"><em>if it does
              not already exist</em></span>, and append the contents of the
            <code class="filename">id_rsa.pub</code> file to the end of it. Note that you also need to do
            this for <code class="code">node-a</code> itself.</p><pre class="screen">$ cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</pre></li><li class="step" title="Test password-less login."><p class="title"><b>Test password-less login.</b></p><p>If you performed the procedure correctly, if you SSH from <code class="code">node-a</code> to
            either of the other nodes, using the same username, you should not be prompted for a password.
          </p></li><li class="step" title="Step 5"><p>Since <code class="code">node-b</code> will run a backup Master, repeat the procedure above,
            substituting <code class="code">node-b</code> everywhere you see <code class="code">node-a</code>. Be sure not to
            overwrite your existing <code class="filename">.ssh/authorized_keys</code> files, but concatenate
          the new key onto the existing file using the <code class="code">&gt;&gt;</code> operator rather than
            the <code class="code">&gt;</code> operator.</p></li></ol></div><div class="procedure" title="Procedure&nbsp;1.5.&nbsp;Prepare node-a"><a name="d2875e771"></a><p class="title"><b>Procedure&nbsp;1.5.&nbsp;Prepare <code class="code">node-a</code></b></p><p><code class="code">node-a</code> will run your primary master and ZooKeeper processes, but no
          RegionServers.</p><ol class="procedure" type="1"><li class="step" title="Stop the RegionServer from starting on node-a."><p class="title"><b>Stop the RegionServer from starting on <code class="code">node-a</code>.</b></p><p>Edit <code class="filename">conf/regionservers</code> and remove the line which contains
              <code class="literal">localhost</code>. Add lines with the hostnames or IP addresses for
              <code class="code">node-b</code> and <code class="code">node-c</code>. Even if you did want to run a
            RegionServer on <code class="code">node-a</code>, you should refer to it by the hostname the other
            servers would use to communicate with it. In this case, that would be
              <code class="literal">node-a.example.com</code>. This enables you to distribute the
            configuration to each node of your cluster any hostname conflicts. Save the file.</p></li><li class="step" title="Configure HBase to use node-b as a backup master."><p class="title"><b>Configure HBase to use <code class="code">node-b</code> as a backup master.</b></p><p>Create a new file in <code class="filename">conf/</code> called
            <code class="filename">backup-masters</code>, and add a new line to it with the hostname for
            <code class="code">node-b</code>. In this demonstration, the hostname is
            <code class="literal">node-b.example.com</code>.</p></li><li class="step" title="Configure ZooKeeper"><p class="title"><b>Configure ZooKeeper</b></p><p>In reality, you should carefully consider your ZooKeeper configuration. You can find
            out more about configuring ZooKeeper in <a class="xref" href="#zookeeper" title="Chapter&nbsp;20.&nbsp;ZooKeeper">Chapter&nbsp;20, <i>ZooKeeper</i></a>. This configuration will direct HBase to start and manage a
            ZooKeeper instance on each node of the cluster.</p><p>On <code class="code">node-a</code>, edit <code class="filename">conf/hbase-site.xml</code> and add the
            following properties.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
  &lt;value&gt;node-a.example.com,node-b.example.com,node-c.example.com&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
  &lt;value&gt;/usr/local/zookeeper&lt;/value&gt;
&lt;/property&gt;            
            </pre></li><li class="step" title="Step 4"><p>Everywhere in your configuration that you have referred to <code class="code">node-a</code> as
            <code class="literal">localhost</code>, change the reference to point to the hostname that
            the other nodes will use to refer to <code class="code">node-a</code>. In these examples, the
            hostname is <code class="literal">node-a.example.com</code>.</p></li></ol></div><div class="procedure" title="Procedure&nbsp;1.6.&nbsp;Prepare node-b and node-c"><a name="d2875e858"></a><p class="title"><b>Procedure&nbsp;1.6.&nbsp;Prepare <code class="code">node-b</code> and <code class="code">node-c</code></b></p><p><code class="code">node-b</code> will run a backup master server and a ZooKeeper instance.</p><ol class="procedure" type="1"><li class="step" title="Download and unpack HBase."><p class="title"><b>Download and unpack HBase.</b></p><p>Download and unpack HBase to <code class="code">node-b</code>, just as you did for the standalone
          and pseudo-distributed quickstarts.</p></li><li class="step" title="Copy the configuration files from node-a to node-b.and node-c."><p class="title"><b>Copy the configuration files from <code class="code">node-a</code> to <code class="code">node-b</code>.and
            <code class="code">node-c</code>.</b></p><p>Each node of your cluster needs to have the same configuration information. Copy the
            contents of the <code class="filename">conf/</code> directory to the <code class="filename">conf/</code>
            directory on <code class="code">node-b</code> and <code class="code">node-c</code>.</p></li></ol></div><div class="procedure" title="Procedure&nbsp;1.7.&nbsp;Start and Test Your Cluster"><a name="d2875e904"></a><p class="title"><b>Procedure&nbsp;1.7.&nbsp;Start and Test Your Cluster</b></p><ol class="procedure" type="1"><li class="step" title="Be sure HBase is not running on any node."><p class="title"><b>Be sure HBase is not running on any node.</b></p><p>If you forgot to stop HBase from previous testing, you will have errors. Check to
            see whether HBase is running on any of your nodes by using the <span class="command"><strong>jps</strong></span>
            command. Look for the processes <code class="literal">HMaster</code>,
            <code class="literal">HRegionServer</code>, and <code class="literal">HQuorumPeer</code>. If they exist,
            kill them.</p></li><li class="step" title="Start the cluster."><p class="title"><b>Start the cluster.</b></p><p>On <code class="code">node-a</code>, issue the <span class="command"><strong>start-hbase.sh</strong></span> command. Your
            output will be similar to that below.</p><pre class="screen">
$ <strong class="userinput"><code>bin/start-hbase.sh</code></strong>
node-c.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-c.example.com.out
node-a.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-a.example.com.out
node-b.example.com: starting zookeeper, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-zookeeper-node-b.example.com.out
starting master, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-master-node-a.example.com.out
node-c.example.com: starting regionserver, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-regionserver-node-c.example.com.out
node-b.example.com: starting regionserver, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-regionserver-node-b.example.com.out            
node-b.example.com: starting master, logging to /home/hbuser/hbase-0.98.3-hadoop2/bin/../logs/hbase-hbuser-master-nodeb.example.com.out          
          </pre><p>ZooKeeper starts first, followed by the master, then the RegionServers, and finally
            the backup masters. </p></li><li class="step" title="Verify that the processes are running."><p class="title"><b>Verify that the processes are running.</b></p><p>On each node of the cluster, run the <span class="command"><strong>jps</strong></span> command and verify that
            the correct processes are running on each server. You may see additional Java processes
            running on your servers as well, if they are used for other purposes.</p><div class="example"><a name="d2875e950"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;<code class="code">node-a</code> <span class="command">jps</span> Output</b></p><div class="example-contents"><pre class="screen">
$ <strong class="userinput"><code>jps</code></strong>
20355 Jps
20071 HQuorumPeer
20137 HMaster    
            </pre></div></div><br class="example-break"><div class="example"><a name="d2875e963"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;<code class="code">node-b</code> <span class="command">jps</span> Output</b></p><div class="example-contents"><pre class="screen">
$ <strong class="userinput"><code>jps</code></strong>
15930 HRegionServer
16194 Jps
15838 HQuorumPeer
16010 HMaster            
            </pre></div></div><br class="example-break"><div class="example"><a name="d2875e976"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;<code class="code">node-c</code> <span class="command">jps</span> Output</b></p><div class="example-contents"><pre class="screen">
$ <strong class="userinput"><code>jps</code></strong>    
13901 Jps
13639 HQuorumPeer
13737 HRegionServer
            </pre></div></div><br class="example-break"><div class="note" title="ZooKeeper Process Name" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">ZooKeeper Process Name</h3><p>The <code class="code">HQuorumPeer</code> process is a ZooKeeper instance which is controlled
              and started by HBase. If you use ZooKeeper this way, it is limited to one instance per
              cluster node, , and is appropriate for testing only. If ZooKeeper is run outside of
              HBase, the process is called <code class="code">QuorumPeer</code>. For more about ZooKeeper
              configuration, including using an external ZooKeeper instance with HBase, see <a class="xref" href="#zookeeper" title="Chapter&nbsp;20.&nbsp;ZooKeeper">Chapter&nbsp;20, <i>ZooKeeper</i></a>.</p></div></li><li class="step" title="Browse to the Web UI."><p class="title"><b>Browse to the Web UI.</b></p><div class="note" title="Web UI Port Changes" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Web UI Port Changes</h3><p>In HBase newer than 0.98.x, the HTTP ports used by the HBase Web UI changed from
              60010 for the Master and 60030 for each RegionServer to 16610 for the Master and 16030
              for the RegionServer.</p></div><p>If everything is set up correctly, you should be able to connect to the UI for the
            Master <code class="literal">http://node-a.example.com:60110/</code> or the secondary master at
              <code class="literal">http://node-b.example.com:60110/</code> for the secondary master, using a
            web browser. If you can connect via <code class="code">localhost</code> but not from another host,
            check your firewall rules. You can see the web UI for each of the RegionServers at port
            60130 of their IP addresses, or by clicking their links in the web UI for the
            Master.</p></li><li class="step" title="Test what happens when nodes or services disappear."><p class="title"><b>Test what happens when nodes or services disappear.</b></p><p>With a three-node cluster like you have configured, things will not be very
            resilient. Still, you can test what happens when the primary Master or a RegionServer
            disappears, by killing the processes and watching the logs.</p></li></ol></div></div><div class="section" title="1.2.5.&nbsp;Where to go next"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e1026"></a>1.2.5.&nbsp;Where to go next</h3></div></div></div><p>The next chapter, <a class="xref" href="#configuration" title="Chapter&nbsp;2.&nbsp;Apache HBase Configuration">Chapter&nbsp;2, <i>Apache HBase Configuration</i></a>, gives more information about the different HBase run modes,
        system requirements for running HBase, and critical configuration areas for setting up a
        distributed HBase cluster.</p></div></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Apache HBase Configuration"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;2.&nbsp;Apache HBase Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#basic.prerequisites">2.1. Basic Prerequisites</a></span></dt><dd><dl><dt><span class="section"><a href="#hadoop">2.1.1. Hadoop</a></span></dt><dt><span class="section"><a href="#zookeeper.requirements">2.1.2. ZooKeeper Requirements</a></span></dt></dl></dd><dt><span class="section"><a href="#standalone_dist">2.2. HBase run modes: Standalone and Distributed</a></span></dt><dd><dl><dt><span class="section"><a href="#standalone">2.2.1. Standalone HBase</a></span></dt><dt><span class="section"><a href="#distributed">2.2.2. Distributed</a></span></dt><dt><span class="section"><a href="#fully_dist">2.2.3. Fully-distributed</a></span></dt></dl></dd><dt><span class="section"><a href="#confirm">2.3. Running and Confirming Your Installation</a></span></dt><dt><span class="section"><a href="#config.files">2.4. Configuration Files</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.site">2.4.1. <code class="filename">hbase-site.xml</code> and <code class="filename">hbase-default.xml</code></a></span></dt><dt><span class="section"><a href="#hbase.env.sh">2.4.2. <code class="filename">hbase-env.sh</code></a></span></dt><dt><span class="section"><a href="#log4j">2.4.3. <code class="filename">log4j.properties</code></a></span></dt><dt><span class="section"><a href="#client_dependencies">2.4.4. Client configuration and dependencies connecting to an HBase cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#example_config">2.5. Example Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e4110">2.5.1. Basic Distributed HBase Install</a></span></dt></dl></dd><dt><span class="section"><a href="#important_configurations">2.6. The Important Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#required_configuration">2.6.1. Required Configurations</a></span></dt><dt><span class="section"><a href="#recommended_configurations">2.6.2. Recommended Configurations</a></span></dt><dt><span class="section"><a href="#other_configuration">2.6.3. Other Configurations</a></span></dt></dl></dd><dt><span class="section"><a href="#dyn_config">2.7. Dynamic Configuration</a></span></dt></dl></div><p>This chapter expands upon the <a class="xref" href="#getting_started" title="Chapter&nbsp;1.&nbsp;Getting Started">Chapter&nbsp;1, <i>Getting Started</i></a> chapter to further explain
    configuration of Apache HBase. Please read this chapter carefully, especially <a class="xref" href="#basic.prerequisites" title="2.1.&nbsp;Basic Prerequisites">Section&nbsp;2.1, &#8220;Basic Prerequisites&#8221;</a> to ensure that your HBase testing and deployment goes
    smoothly, and prevent data loss.</p><p> Apache HBase uses the same configuration system as Apache Hadoop. All configuration files
    are located in the <code class="filename">conf/</code> directory, which needs to be kept in sync for each
    node on your cluster.</p><div class="variablelist" title="HBase Configuration Files"><p class="title"><b>HBase Configuration Files</b></p><dl><dt><span class="term"><code class="filename">backup-masters</code></span></dt><dd><p>Not present by default. A plain-text file which lists hosts on which the Master should
          start a backup Master process, one host per line.</p></dd><dt><span class="term"><code class="filename">hadoop-metrics2-hbase.properties</code></span></dt><dd><p>Used to connect HBase Hadoop's Metrics2 framework. See the <a class="link" href="http://wiki.apache.org/hadoop/HADOOP-6728-MetricsV2" target="_top">Hadoop Wiki
            entry</a> for more information on Metrics2. Contains only commented-out examples by
          default.</p></dd><dt><span class="term"><code class="filename">hbase-env.cmd</code> and <code class="filename">hbase-env.sh</code></span></dt><dd><p>Script for Windows and Linux / Unix environments to set up the working environment for
        HBase, including the location of Java, Java options, and other environment variables. The
        file contains many commented-out examples to provide guidance.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In HBase 0.98.5 and newer, you must set <code class="envar">JAVA_HOME</code> on each node of
            your cluster. <code class="filename">hbase-env.sh</code> provides a handy mechanism to do
            this.</p></div></dd><dt><span class="term"><code class="filename">hbase-policy.xml</code></span></dt><dd><p>The default policy configuration file used by RPC servers to make authorization
          decisions on client requests. Only used if HBase security (<a class="xref" href="#security" title="Chapter&nbsp;8.&nbsp;Secure Apache HBase">Chapter&nbsp;8, <i>Secure Apache HBase</i></a>) is enabled.</p></dd><dt><span class="term"><code class="filename">hbase-site.xml</code></span></dt><dd><p>The main HBase configuration file. This file specifies configuration options which
          override HBase's default configuration. You can view (but do not edit) the default
          configuration file at <code class="filename">docs/hbase-default.xml</code>. You can also view the
          entire effective configuration for your cluster (defaults and overrides) in the
            <span class="guilabel">HBase Configuration</span> tab of the HBase Web UI.</p></dd><dt><span class="term"><code class="filename">log4j.properties</code></span></dt><dd><p>Configuration file for HBase logging via <code class="code">log4j</code>.</p></dd><dt><span class="term"><code class="filename">regionservers</code></span></dt><dd><p>A plain-text file containing a list of hosts which should run a RegionServer in your
          HBase cluster. By default this file contains the single entry
          <code class="literal">localhost</code>. It should contain a list of hostnames or IP addresses, one
          per line, and should only contain <code class="literal">localhost</code> if each node in your
          cluster will run a RegionServer on its <code class="literal">localhost</code> interface.</p></dd></dl></div><div class="tip" title="Checking XML Validity" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Checking XML Validity</h3><p>When you edit XML, it is a good idea to use an XML-aware editor to be sure that your
      syntax is correct and your XML is well-formed. You can also use the <span class="command"><strong>xmllint</strong></span>
      utility to check that your XML is well-formed. By default, <span class="command"><strong>xmllint</strong></span> re-flows
      and prints the XML to standard output. To check for well-formedness and only print output if
      errors exist, use the command <span class="command"><strong>xmllint -noout
        <em class="replaceable"><code>filename.xml</code></em></strong></span>.</p></div><div class="warning" title="Keep Configuration In Sync Across the Cluster" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Keep Configuration In Sync Across the Cluster</h3><p>When running in distributed mode, after you make an edit to an HBase configuration, make
      sure you copy the content of the <code class="filename">conf/</code> directory to all nodes of the
      cluster. HBase will not do this for you. Use <span class="command"><strong>rsync</strong></span>, <span class="command"><strong>scp</strong></span>,
      or another secure mechanism for copying the configuration files to your nodes. For most
      configuration, a restart is needed for servers to pick up changes An exception is dynamic
      configuration. to be described later below.</p></div><div class="section" title="2.1.&nbsp;Basic Prerequisites"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basic.prerequisites"></a>2.1.&nbsp;Basic Prerequisites</h2></div></div></div><p>This section lists required services and some required system configuration. </p><div class="table"><a name="java"></a><p class="title"><b>Table&nbsp;2.1.&nbsp;Java</b></p><div class="table-contents"><table summary="Java" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>HBase Version</th><th>JDK 6</th><th>JDK 7</th><th>JDK 8</th></tr></thead><tbody><tr><td>1.0</td><td><a class="link" href="http://search-hadoop.com/m/DHED4Zlz0R1" target="_top">Not Supported</a></td><td>yes</td><td><p>Running with JDK 8 will work but is not well tested.</p></td></tr><tr><td>0.98</td><td>yes</td><td>yes</td><td><p>Running with JDK 8 works but is not well tested. Building with JDK 8 would
                require removal of the deprecated remove() method of the PoolMap class and is under
                consideration. See ee <a class="link" href="https://issues.apache.org/jira/browse/HBASE-7608" target="_top">HBASE-7608</a>
                for more information about JDK 8 support.</p></td></tr><tr><td>0.96</td><td>yes</td><td>yes</td><td>&nbsp;</td></tr><tr><td>0.94</td><td>yes</td><td>yes</td><td>&nbsp;</td></tr></tbody></table></div><div class="longdesc-link" align="right"><br clear="all"><span class="longdesc-link">[<a href="java.html" target="longdesc">D</a>]</span></div></div><br class="table-break"><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In HBase 0.98.5 and newer, you must set <code class="envar">JAVA_HOME</code> on each node of
        your cluster. <code class="filename">hbase-env.sh</code> provides a handy mechanism to do
        this.</p></div><div class="variablelist" title="Operating System Utilities"><a name="os"></a><p class="title"><b>Operating System Utilities</b></p><dl><dt><a name="ssh"></a><span class="term">ssh</span></dt><dd><p>HBase uses the Secure Shell (ssh) command and utilities extensively to communicate
            between cluster nodes. Each server in the cluster must be running <span class="command"><strong>ssh</strong></span>
            so that the Hadoop and HBase daemons can be managed. You must be able to connect to all
            nodes via SSH, including the local node, from the Master as well as any backup Master,
            using a shared key rather than a password. You can see the basic methodology for such a
            set-up in Linux or Unix systems at <a class="xref" href="#passwordless.ssh.quickstart" title="Procedure&nbsp;1.4.&nbsp;Configure Password-Less SSH Access">Procedure&nbsp;1.4, &#8220;Configure Password-Less SSH Access&#8221;</a>. If your cluster nodes use OS X, see the
            section, <a class="link" href="http://wiki.apache.org/hadoop/Running_Hadoop_On_OS_X_10.5_64-bit_%28Single-Node_Cluster%29" target="_top">SSH:
              Setting up Remote Desktop and Enabling Self-Login</a> on the Hadoop wiki.</p></dd><dt><a name="dns"></a><span class="term">DNS</span></dt><dd><p>HBase uses the local hostname to self-report its IP address. Both forward and
            reverse DNS resolving must work in versions of HBase previous to 0.92.0. The <a class="link" href="https://github.com/sujee/hadoop-dns-checker" target="_top">hadoop-dns-checker</a>
                tool can be used to verify DNS is working correctly on the cluster. The project
                README file provides detailed instructions on usage. </p><p>If your server has multiple network interfaces, HBase defaults to using the
            interface that the primary hostname resolves to. To override this behavior, set the
              <code class="code">hbase.regionserver.dns.interface</code> property to a different interface. This
            will only work if each server in your cluster uses the same network interface
            configuration.</p><p>To choose a different DNS nameserver than the system default, set the
              <code class="varname">hbase.regionserver.dns.nameserver</code> property to the IP address of
            that nameserver.</p></dd><dt><a name="loopback.ip"></a><span class="term">Loopback IP</span></dt><dd><p>Prior to hbase-0.96.0, HBase only used the IP address
              <code class="systemitem">127.0.0.1</code> to refer to <code class="code">localhost</code>, and this could
            not be configured. See <a class="xref" href="#loopback.ip">Loopback IP</a>.</p></dd><dt><a name="ntp"></a><span class="term">NTP</span></dt><dd><p>The clocks on cluster nodes should be synchronized. A small amount of variation is
            acceptable, but larger amounts of skew can cause erratic and unexpected behavior. Time
            synchronization is one of the first things to check if you see unexplained problems in
            your cluster. It is recommended that you run a Network Time Protocol (NTP) service, or
            another time-synchronization mechanism, on your cluster, and that all nodes look to the
            same service for time synchronization. See the <a class="link" href="http://www.tldp.org/LDP/sag/html/basic-ntp-config.html" target="_top">Basic NTP
              Configuration</a> at <em class="citetitle">The Linux Documentation Project (TLDP)</em>
            to set up NTP.</p></dd><dt><a name="ulimit"></a><span class="term">Limits on Number of Files and Processes (<span class="command"><strong>ulimit</strong></span>)
          <a class="indexterm" name="d2875e1308"></a><a class="indexterm" name="d2875e1311"></a>
        </span></dt><dd><p>Apache HBase is a database. It requires the ability to open a large number of files
            at once. Many Linux distributions limit the number of files a single user is allowed to
            open to <code class="literal">1024</code> (or <code class="literal">256</code> on older versions of OS X).
            You can check this limit on your servers by running the command <span class="command"><strong>ulimit
              -n</strong></span> when logged in as the user which runs HBase. See <a class="xref" href="#trouble.rs.runtime.filehandles" title="15.9.2.2.&nbsp;java.io.IOException...(Too many open files)">Section&nbsp;15.9.2.2, &#8220;java.io.IOException...(Too many open files)&#8221;</a> for some of the problems you may
            experience if the limit is too low. You may also notice errors such as the
            following:</p><pre class="screen">
2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException
2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901
          </pre><p>It is recommended to raise the ulimit to at least 10,000, but more likely 10,240,
            because the value is usually expressed in multiples of 1024. Each ColumnFamily has at
            least one StoreFile, and possibly more than 6 StoreFiles if the region is under load.
            The number of open files required depends upon the number of ColumnFamilies and the
            number of regions. The following is a rough formula for calculating the potential number
            of open files on a RegionServer. </p><div class="example"><a name="d2875e1333"></a><p class="title"><b>Example&nbsp;2.1.&nbsp;Calculate the Potential Number of Open Files</b></p><div class="example-contents"><pre class="screen">(StoreFiles per ColumnFamily) x (regions per RegionServer)</pre></div></div><br class="example-break"><p>For example, assuming that a schema had 3 ColumnFamilies per region with an average
            of 3 StoreFiles per ColumnFamily, and there are 100 regions per RegionServer, the JVM
            will open 3 * 3 * 100 = 900 file descriptors, not counting open JAR files, configuration
            files, and others. Opening a file does not take many resources, and the risk of allowing
            a user to open too many files is minimal.</p><p>Another related setting is the number of processes a user is allowed to run at once.
            In Linux and Unix, the number of processes is set using the <span class="command"><strong>ulimit -u</strong></span>
            command. This should not be confused with the <span class="command"><strong>nproc</strong></span> command, which
            controls the number of CPUs available to a given user. Under load, a
              <code class="varname">nproc</code> that is too low can cause OutOfMemoryError exceptions. See
            Jack Levin's <a class="link" href="http://thread.gmane.org/gmane.comp.java.hadoop.hbase.user/16374" target="_top">major
              hdfs issues</a> thread on the hbase-users mailing list, from 2011.</p><p>Configuring the fmaximum number of ile descriptors and processes for the user who is
            running the HBase process is an operating system configuration, rather than an HBase
            configuration. It is also important to be sure that the settings are changed for the
            user that actually runs HBase. To see which user started HBase, and that user's ulimit
            configuration, look at the first line of the HBase log for that instance. A useful read
            setting config on you hadoop cluster is Aaron Kimballs' <a class="link" href="http://www.cloudera.com/blog/2009/03/configuration-parameters-what-can-you-just-ignore/" target="_top">Configuration Parameters: What can you just ignore?</a></p><p title="ulimit Settings on Ubuntu"><a name="ulimit_ubuntu"></a><b><span class="command"><strong>ulimit</strong></span> Settings on Ubuntu.&nbsp;</b>To configure <span class="command"><strong>ulimit</strong></span> settings on Ubuntu, edit
                <code class="filename">/etc/security/limits.conf</code>, which is a space-delimited file with
              four columns. Refer to the <a class="link" href="http://manpages.ubuntu.com/manpages/lucid/man5/limits.conf.5.html" target="_top">man
                page for limits.conf</a> for details about the format of this file. In the
              following example, the first line sets both soft and hard limits for the number of
              open files (<code class="literal">nofile</code>) to <code class="literal">32768</code> for the operating
              system user with the username <code class="literal">hadoop</code>. The second line sets the
              number of processes to 32000 for the same user.</p><pre class="screen">
hadoop  -       nofile  32768
hadoop  -       nproc   32000
          </pre><p>The settings are only applied if the Pluggable Authentication Module (PAM)
            environment is directed to use them. To configure PAM to use these limits, be sure that
            the <code class="filename">/etc/pam.d/common-session</code> file contains the following line:</p><pre class="screen">session required  pam_limits.so</pre></dd><dt><a name="windows"></a><span class="term">Windows</span></dt><dd><p>Prior to HBase 0.96, testing for running HBase on Microsoft Windows was limited.
            Running a on Windows nodes is not recommended for production systems.</p><p>To run versions of HBase prior to 0.96 on Microsoft Windows, you must install <a class="link" href="http://cygwin.com/" target="_top">Cygwin</a> and run HBase within the Cygwin
          environment. This provides support for Linux/Unix commands and scripts. The full details are explained in the <a class="link" href="http://hbase.apache.org/cygwin.html" target="_top">Windows Installation</a> guide. Also <a class="link" href="http://search-hadoop.com/?q=hbase+windows&amp;fc_project=HBase&amp;fc_type=mail+_hash_+dev" target="_top">search
            our user mailing list</a> to pick up latest fixes figured by Windows users.</p><p>Post-hbase-0.96.0, hbase runs natively on windows with supporting
            <span class="command"><strong>*.cmd</strong></span> scripts bundled. </p></dd></dl></div><div class="section" title="2.1.1.&nbsp;Hadoop"><div class="titlepage"><div><div><h3 class="title"><a name="hadoop"></a>2.1.1.&nbsp;<a class="link" href="http://hadoop.apache.org" target="_top">Hadoop</a><a class="indexterm" name="d2875e1419"></a></h3></div></div></div><p>The following table summarizes the versions of Hadoop supported with each version of
        HBase. Based on the version of HBase, you should select the most
        appropriate version of Hadoop. You can use Apache Hadoop, or a vendor's distribution of
        Hadoop. No distinction is made here. See <a class="link" href="http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support" target="_top">http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support</a>
        for information about vendors of Hadoop.</p><div class="tip" title="Hadoop 2.x is recommended." style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Hadoop 2.x is recommended.</h3><p>Hadoop 2.x is faster and includes features, such as short-circuit reads, which will
          help improve your HBase random read profile. Hadoop 2.x also includes important bug fixes
          that will improve your overall HBase experience. HBase 0.98 drops support for Hadoop 1.0, deprecates use of Hadoop 1.1+,
          and HBase 1.0 will not support Hadoop 1.x.</p></div><p>Use the following legend to interpret this table:</p><table border="0" summary="Simple list" class="simplelist"><tr><td>S = supported and tested,</td></tr><tr><td>X = not supported,</td></tr><tr><td>NT = it should run, but not tested enough.</td></tr></table><div class="table"><a name="d2875e1440"></a><p class="title"><b>Table&nbsp;2.2.&nbsp;Hadoop version support matrix</b></p><div class="table-contents"><table summary="Hadoop version support matrix" border="1"><colgroup><col align="left" class="c1"><col align="center" class="c2"><col align="center" class="c3"><col align="center" class="c4"><col align="center" class="c5"><col align="center" class="c6"></colgroup><thead><tr><th align="left"> </th><th align="center">HBase-0.92.x</th><th align="center">HBase-0.94.x</th><th align="center">HBase-0.96.x</th><th align="center"><p>HBase-0.98.x (Support for Hadoop 1.1+ is deprecated.)</p></th><th align="center"><p>HBase-1.0.x (Hadoop 1.x is NOT supported)</p></th></tr></thead><tbody><tr><td align="left">Hadoop-0.20.205</td><td align="center">S</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-0.22.x </td><td align="center">S</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-1.0.x</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-1.1.x </td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">NT</td><td align="center">X</td></tr><tr><td align="left">Hadoop-0.23.x </td><td align="center">X</td><td align="center">S</td><td align="center">NT</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-2.0.x-alpha </td><td align="center">X</td><td align="center">NT</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-2.1.0-beta </td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-2.2.0 </td><td align="center">X</td><td align="center"><a class="link" href="#hadoop2.hbase-0.94" title="2.1.1.1.&nbsp;Apache HBase 0.94 with Hadoop 2">NT</a></td><td align="center">S</td><td align="center">S</td><td align="center">NT</td></tr><tr><td align="left">Hadoop-2.3.x</td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">NT</td></tr><tr><td align="left">Hadoop-2.4.x</td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">S</td></tr><tr><td align="left">Hadoop-2.5.x</td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">S</td></tr></tbody></table></div></div><br class="table-break"><div class="note" title="Replace the Hadoop Bundled With HBase!" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="replace.hadoop"></a>Replace the Hadoop Bundled With HBase!</h3><p> Because HBase depends on Hadoop, it bundles an instance of the Hadoop jar under its
            <code class="filename">lib</code> directory. The bundled jar is ONLY for use in standalone mode.
          In distributed mode, it is <span class="emphasis"><em>critical</em></span> that the version of Hadoop that
          is out on your cluster match what is under HBase. Replace the hadoop jar found in the
          HBase lib directory with the hadoop jar you are running on your cluster to avoid version
          mismatch issues. Make sure you replace the jar in HBase everywhere on your cluster. Hadoop
          version mismatch issues have various manifestations but often all looks like its hung up.
        </p></div><div class="section" title="2.1.1.1.&nbsp;Apache HBase 0.94 with Hadoop 2"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop2.hbase-0.94"></a>2.1.1.1.&nbsp;Apache HBase 0.94 with Hadoop 2</h4></div></div></div><p>To get 0.94.x to run on hadoop 2.2.0, you need to change the hadoop
        2 and protobuf versions in the <code class="filename">pom.xml</code>: Here is a diff with
        pom.xml changes: </p><pre class="programlisting">$ svn diff pom.xml
Index: pom.xml
===================================================================
--- pom.xml     (revision 1545157)
+++ pom.xml     (working copy)
@@ -1034,7 +1034,7 @@
     &lt;slf4j.version&gt;1.4.3&lt;/slf4j.version&gt;
     &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt;
     &lt;mockito-all.version&gt;1.8.5&lt;/mockito-all.version&gt;
-    &lt;protobuf.version&gt;2.4.0a&lt;/protobuf.version&gt;
+    &lt;protobuf.version&gt;2.5.0&lt;/protobuf.version&gt;
     &lt;stax-api.version&gt;1.0.1&lt;/stax-api.version&gt;
     &lt;thrift.version&gt;0.8.0&lt;/thrift.version&gt;
     &lt;zookeeper.version&gt;3.4.5&lt;/zookeeper.version&gt;
@@ -2241,7 +2241,7 @@
         &lt;/property&gt;
       &lt;/activation&gt;
       &lt;properties&gt;
-        &lt;hadoop.version&gt;2.0.0-alpha&lt;/hadoop.version&gt;
+        &lt;hadoop.version&gt;2.2.0&lt;/hadoop.version&gt;
         &lt;slf4j.version&gt;1.6.1&lt;/slf4j.version&gt;
       &lt;/properties&gt;
       &lt;dependencies&gt;
                   </pre><p>The next step is to regenerate Protobuf files and assuming that the Protobuf
                    has been installed:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Go to the hbase root folder, using the command line;</p></li><li class="listitem"><p>Type the following commands:</p><p>
                        </p><pre class="programlisting">$ protoc -Isrc/main/protobuf --java_out=src/main/java src/main/protobuf/hbase.proto</pre><p>
                      </p><p>
                        </p><pre class="programlisting">$ protoc -Isrc/main/protobuf --java_out=src/main/java src/main/protobuf/ErrorHandling.proto</pre><p>
                      </p></li></ul></div><p> Building against the hadoop 2 profile by running something like the
                    following command: </p><pre class="screen">$  mvn clean install assembly:single -Dhadoop.profile=2.0 -DskipTests</pre></div><div class="section" title="2.1.1.2.&nbsp;Apache HBase 0.92 and 0.94"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.hbase-0.94"></a>2.1.1.2.&nbsp;Apache HBase 0.92 and 0.94</h4></div></div></div><p>HBase 0.92 and 0.94 versions can work with Hadoop versions, 0.20.205, 0.22.x, 1.0.x,
          and 1.1.x. HBase-0.94 can additionally work with Hadoop-0.23.x and 2.x, but you may have
          to recompile the code using the specific maven profile (see top level pom.xml)</p></div><div class="section" title="2.1.1.3.&nbsp;Apache HBase 0.96"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.hbase-0.96"></a>2.1.1.3.&nbsp;Apache HBase 0.96</h4></div></div></div><p> As of Apache HBase 0.96.x, Apache Hadoop 1.0.x at least is required. Hadoop 2 is
          strongly encouraged (faster but also has fixes that help MTTR). We will no longer run
          properly on older Hadoops such as 0.20.205 or branch-0.20-append. Do not move to Apache
          HBase 0.96.x if you cannot upgrade your Hadoop.. See <a class="link" href="http://search-hadoop.com/m/7vFVx4EsUb2" target="_top">HBase, mail # dev - DISCUSS:
                Have hbase require at least hadoop 1.0.0 in hbase 0.96.0?</a></p></div><div class="section" title="2.1.1.4.&nbsp;Hadoop versions 0.20.x - 1.x"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.older.versions"></a>2.1.1.4.&nbsp;Hadoop versions 0.20.x - 1.x</h4></div></div></div><p> HBase will lose data unless it is running on an HDFS that has a durable
            <code class="code">sync</code> implementation. DO NOT use Hadoop 0.20.2, Hadoop 0.20.203.0, and
          Hadoop 0.20.204.0 which DO NOT have this attribute. Currently only Hadoop versions
          0.20.205.x or any release in excess of this version -- this includes hadoop-1.0.0 -- have
          a working, durable sync. The Cloudera blog post <a class="link" href="http://www.cloudera.com/blog/2012/01/an-update-on-apache-hadoop-1-0/" target="_top">An
            update on Apache Hadoop 1.0</a> by Charles Zedlweski has a nice exposition on how all
          the Hadoop versions relate. Its worth checking out if you are having trouble making sense
          of the Hadoop version morass. </p><p>Sync has to be explicitly enabled by setting
            <code class="varname">dfs.support.append</code> equal to true on both the client side -- in
            <code class="filename">hbase-site.xml</code> -- and on the serverside in
            <code class="filename">hdfs-site.xml</code> (The sync facility HBase needs is a subset of the
          append code path).</p><pre class="programlisting">  
&lt;property&gt;
  &lt;name&gt;dfs.support.append&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;</pre><p> You will have to restart your cluster after making this edit. Ignore the
          chicken-little comment you'll find in the <code class="filename">hdfs-default.xml</code> in the
          description for the <code class="varname">dfs.support.append</code> configuration. </p></div><div class="section" title="2.1.1.5.&nbsp;Apache HBase on Secure Hadoop"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.security"></a>2.1.1.5.&nbsp;Apache HBase on Secure Hadoop</h4></div></div></div><p>Apache HBase will run on any Hadoop 0.20.x that incorporates Hadoop security features
          as long as you do as suggested above and replace the Hadoop jar that ships with HBase with
          the secure version. If you want to read more about how to setup Secure HBase, see <a class="xref" href="#hbase.secure.configuration" title="8.1.&nbsp;Secure Client Access to Apache HBase">Section&nbsp;8.1, &#8220;Secure Client Access to Apache HBase&#8221;</a>.</p></div><div class="section" title="2.1.1.6.&nbsp;dfs.datanode.max.transfer.threads"><div class="titlepage"><div><div><h4 class="title"><a name="dfs.datanode.max.transfer.threads"></a>2.1.1.6.&nbsp;<code class="varname">dfs.datanode.max.transfer.threads</code><a class="indexterm" name="d2875e1710"></a></h4></div></div></div><p>An HDFS datanode has an upper bound on the number of files that it will serve
          at any one time. Before doing any loading, make sure you have configured
          Hadoop's <code class="filename">conf/hdfs-site.xml</code>, setting the
          <code class="varname">dfs.datanode.max.transfer.threads</code> value to at least the following:
        </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;dfs.datanode.max.transfer.threads&lt;/name&gt;
  &lt;value&gt;4096&lt;/value&gt;
&lt;/property&gt;
      </pre><p>Be sure to restart your HDFS after making the above configuration.</p><p>Not having this configuration in place makes for strange-looking failures. One
        manifestation is a complaint about missing blocks. For example:</p><pre class="screen">10/12/08 20:10:31 INFO hdfs.DFSClient: Could not obtain block
          blk_XXXXXXXXXXXXXXXXXXXXXX_YYYYYYYY from any node: java.io.IOException: No live nodes
          contain current block. Will get new block locations from namenode and retry...</pre><p>See also <a class="xref" href="#casestudies.max.transfer.threads" title="16.3.4.&nbsp;Case Study #4 (max.transfer.threads Config)">Section&nbsp;16.3.4, &#8220;Case Study #4 (max.transfer.threads Config)&#8221;</a> and note that this
          property was previously known as <code class="varname">dfs.datanode.max.xcievers</code> (e.g.
          <a class="link" href="http://ccgtech.blogspot.com/2010/02/hadoop-hdfs-deceived-by-xciever.html" target="_top">
            Hadoop HDFS: Deceived by Xciever</a>).
        </p></div></div><div class="section" title="2.1.2.&nbsp;ZooKeeper Requirements"><div class="titlepage"><div><div><h3 class="title"><a name="zookeeper.requirements"></a>2.1.2.&nbsp;ZooKeeper Requirements</h3></div></div></div><p>ZooKeeper 3.4.x is required as of HBase 1.0.0. HBase makes use of the
        <code class="methodname">multi</code> functionality that is only available since 3.4.0
        (The <span class="property">useMulti</span> is defaulted true in HBase 1.0.0).
        See HBASE-12241 The crash of regionServer when taking deadserver's replication queue breaks replication
        and Use ZK.multi when available for HBASE-6710 0.92/0.94 compatibility fix for background.</p></div></div><div class="section" title="2.2.&nbsp;HBase run modes: Standalone and Distributed"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="standalone_dist"></a>2.2.&nbsp;HBase run modes: Standalone and Distributed</h2></div></div></div><p>HBase has two run modes: <a class="xref" href="#standalone" title="2.2.1.&nbsp;Standalone HBase">Section&nbsp;2.2.1, &#8220;Standalone HBase&#8221;</a> and <a class="xref" href="#distributed" title="2.2.2.&nbsp;Distributed">Section&nbsp;2.2.2, &#8220;Distributed&#8221;</a>. Out of the box, HBase runs in standalone mode. Whatever your mode,
      you will need to configure HBase by editing files in the HBase <code class="filename">conf</code>
      directory. At a minimum, you must edit <code class="code">conf/hbase-env.sh</code> to tell HBase which
        <span class="command"><strong>java</strong></span> to use. In this file you set HBase environment variables such as the
      heapsize and other options for the <span class="application">JVM</span>, the preferred location for
      log files, etc. Set <code class="varname">JAVA_HOME</code> to point at the root of your
        <span class="command"><strong>java</strong></span> install.</p><div class="section" title="2.2.1.&nbsp;Standalone HBase"><div class="titlepage"><div><div><h3 class="title"><a name="standalone"></a>2.2.1.&nbsp;Standalone HBase</h3></div></div></div><p>This is the default mode. Standalone mode is what is described in the <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a> section. In standalone mode, HBase does not use HDFS -- it uses
        the local filesystem instead -- and it runs all HBase daemons and a local ZooKeeper all up
        in the same JVM. Zookeeper binds to a well known port so clients may talk to HBase.</p></div><div class="section" title="2.2.2.&nbsp;Distributed"><div class="titlepage"><div><div><h3 class="title"><a name="distributed"></a>2.2.2.&nbsp;Distributed</h3></div></div></div><p>Distributed mode can be subdivided into distributed but all daemons run on a single node
        -- a.k.a <span class="emphasis"><em>pseudo-distributed</em></span>-- and
          <span class="emphasis"><em>fully-distributed</em></span> where the daemons are spread across all nodes in
        the cluster. The pseudo-distributed vs fully-distributed nomenclature comes from Hadoop.</p><p>Pseudo-distributed mode can run against the local filesystem or it can run against an
        instance of the <span class="emphasis"><em>Hadoop Distributed File System</em></span> (HDFS).
        Fully-distributed mode can ONLY run on HDFS. See the Hadoop <a class="link" href="http://hadoop.apache.org/common/docs/r1.1.1/api/overview-summary.html#overview_description" target="_top">
          requirements and instructions</a> for how to set up HDFS for Hadoop 1.x. A good
        walk-through for setting up HDFS on Hadoop 2 is at <a class="link" href="http://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide" target="_top">http://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide</a>.</p><p>Below we describe the different distributed setups. Starting, verification and
        exploration of your install, whether a <span class="emphasis"><em>pseudo-distributed</em></span> or
          <span class="emphasis"><em>fully-distributed</em></span> configuration is described in a section that
        follows, <a class="xref" href="#confirm" title="2.3.&nbsp;Running and Confirming Your Installation">Section&nbsp;2.3, &#8220;Running and Confirming Your Installation&#8221;</a>. The same verification script applies to both deploy types.</p><div class="section" title="2.2.2.1.&nbsp;Pseudo-distributed"><div class="titlepage"><div><div><h4 class="title"><a name="pseudo"></a>2.2.2.1.&nbsp;Pseudo-distributed</h4></div></div></div><div class="note" title="Pseudo-Distributed Quickstart" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Pseudo-Distributed Quickstart</h3><p>A quickstart has been added to the <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a> chapter. See <a class="xref" href="#quickstart-pseudo" title="1.2.3.&nbsp;Intermediate - Pseudo-Distributed Local Install">Section&nbsp;1.2.3, &#8220;Intermediate - Pseudo-Distributed Local Install&#8221;</a>. Some of the information that was originally in this
            section has been moved there.</p></div><p>A pseudo-distributed mode is simply a fully-distributed mode run on a single host. Use
          this configuration testing and prototyping on HBase. Do not use this configuration for
          production nor for evaluating HBase performance.</p></div></div><div class="section" title="2.2.3.&nbsp;Fully-distributed"><div class="titlepage"><div><div><h3 class="title"><a name="fully_dist"></a>2.2.3.&nbsp;Fully-distributed</h3></div></div></div><p>By default, HBase runs in standalone mode. Both standalone mode and pseudo-distributed
        mode are provided for the purposes of small-scale testing. For a production environment,
        distributed mode is appropriate. In distributed mode, multiple instances of HBase daemons
        run on multiple servers in the cluster.</p><p>Just as in pseudo-distributed mode, a fully distributed configuration requires that you
        set the <code class="code">hbase-cluster.distributed</code> property to <code class="literal">true</code>.
        Typically, the <code class="code">hbase.rootdir</code> is configured to point to a highly-available HDFS
        filesystem. </p><p>In addition, the cluster is configured so that multiple cluster nodes enlist as
        RegionServers, ZooKeeper QuorumPeers, and backup HMaster servers. These configuration basics
        are all demonstrated in <a class="xref" href="#quickstart-fully-distributed" title="1.2.4.&nbsp;Advanced - Fully Distributed">Section&nbsp;1.2.4, &#8220;Advanced - Fully Distributed&#8221;</a>.</p><p title="Distributed RegionServers"><a name="regionserver"></a><b>Distributed RegionServers.&nbsp;</b>Typically, your cluster will contain multiple RegionServers all running on different
          servers, as well as primary and backup Master and Zookeeper daemons. The
            <code class="filename">conf/regionservers</code> file on the master server contains a list of
          hosts whose RegionServers are associated with this cluster. Each host is on a separate
          line. All hosts listed in this file will have their RegionServer processes started and
          stopped when the master server starts or stops.</p><p title="ZooKeeper and HBase"><a name="hbase.zookeeper"></a><b>ZooKeeper and HBase.&nbsp;</b>See section <a class="xref" href="#zookeeper" title="Chapter&nbsp;20.&nbsp;ZooKeeper">Chapter&nbsp;20, <i>ZooKeeper</i></a> for ZooKeeper setup for HBase.</p><div class="example"><a name="d2875e1872"></a><p class="title"><b>Example&nbsp;2.2.&nbsp;Example Distributed HBase Cluster</b></p><div class="example-contents"><p>This is a bare-bones <code class="filename">conf/hbase-site.xml</code> for a distributed HBase
          cluster. A cluster that is used for real-world work would contain more custom
          configuration parameters. Most HBase configuration directives have default values, which
          are used unless the value is overridden in the <code class="filename">hbase-site.xml</code>. See <a class="xref" href="#config.files" title="2.4.&nbsp;Configuration Files">Section&nbsp;2.4, &#8220;Configuration Files&#8221;</a> for more information.</p><pre class="programlisting">
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://namenode.example.org:8020/hbase&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
      &lt;value&gt;node-a.example.com,node-b.example.com,node-c.example.com&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;

        </pre><p>This is an example <code class="filename">conf/regionservers</code> file, which contains a list
          of each node that should run a RegionServer in the cluster. These nodes need HBase
          installed and they need to use the same contents of the <code class="filename">conf/</code>
          directory as the Master server..</p><pre class="programlisting">
node-a.example.com
node-b.example.com
node-c.example.com
        </pre><p>This is an example <code class="filename">conf/backup-masters</code> file, which contains a
          list of each node that should run a backup Master instance. The backup Master instances
          will sit idle unless the main Master becomes unavailable.</p><pre class="programlisting">
node-b.example.com
node-c.example.com
        </pre></div></div><br class="example-break"><p title="Distributed HBase Quickstart"><b>Distributed HBase Quickstart.&nbsp;</b>See <a class="xref" href="#quickstart-fully-distributed" title="1.2.4.&nbsp;Advanced - Fully Distributed">Section&nbsp;1.2.4, &#8220;Advanced - Fully Distributed&#8221;</a> for a walk-through of a simple three-node
          cluster configuration with multiple ZooKeeper, backup HMaster, and RegionServer
          instances.</p><div class="procedure" title="Procedure&nbsp;2.1.&nbsp;HDFS Client Configuration"><a name="hdfs_client_conf"></a><p class="title"><b>Procedure&nbsp;2.1.&nbsp;HDFS Client Configuration</b></p><ul class="procedure"><li class="step" title="Step 1"><p>Of note, if you have made HDFS client configuration on your Hadoop cluster, such as
            configuration directives for HDFS clients, as opposed to server-side configurations, you
            must use one of the following methods to enable HBase to see and use these configuration
            changes:</p><ul class="stepalternatives">
            <li class="step" title="Step 1.1"><p>Add a pointer to your <code class="varname">HADOOP_CONF_DIR</code> to the
                  <code class="varname">HBASE_CLASSPATH</code> environment variable in
                  <code class="filename">hbase-env.sh</code>.</p></li>

            <li class="step" title="Step 1.2"><p>Add a copy of <code class="filename">hdfs-site.xml</code> (or
                  <code class="filename">hadoop-site.xml</code>) or, better, symlinks, under
                  <code class="filename">${HBASE_HOME}/conf</code>, or</p></li>

            <li class="step" title="Step 1.3"><p>if only a small set of HDFS client configurations, add them to
                  <code class="filename">hbase-site.xml</code>.</p></li>
          </ul></li></ul></div><p>An example of such an HDFS client configuration is <code class="varname">dfs.replication</code>.
        If for example, you want to run with a replication factor of 5, hbase will create files with
        the default of 3 unless you do the above to make the configuration available to
        HBase.</p></div></div><div class="section" title="2.3.&nbsp;Running and Confirming Your Installation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="confirm"></a>2.3.&nbsp;Running and Confirming Your Installation</h2></div></div></div><p>Make sure HDFS is running first. Start and stop the Hadoop HDFS daemons by running
          <code class="filename">bin/start-hdfs.sh</code> over in the <code class="varname">HADOOP_HOME</code>
        directory. You can ensure it started properly by testing the <span class="command"><strong>put</strong></span> and
          <span class="command"><strong>get</strong></span> of files into the Hadoop filesystem. HBase does not normally use
        the mapreduce daemons. These do not need to be started.</p><p><span class="emphasis"><em>If</em></span> you are managing your own ZooKeeper, start it and confirm its
        running else, HBase will start up ZooKeeper for you as part of its start process.</p><p>Start HBase with the following command:</p><pre class="screen">bin/start-hbase.sh</pre><p>Run the above from the <code class="varname">HBASE_HOME</code> directory.</p><p>You should now have a running HBase instance. HBase logs can be found in the
          <code class="filename">logs</code> subdirectory. Check them out especially if HBase had trouble
        starting.</p><p>HBase also puts up a UI listing vital attributes. By default its deployed on the Master
        host at port 16010 (HBase RegionServers listen on port 16020 by default and put up an
        informational http server at 16030). If the Master were running on a host named
          <code class="varname">master.example.org</code> on the default port, to see the Master's homepage
        you'd point your browser at <code class="filename">http://master.example.org:16010</code>.</p><p>Prior to HBase 0.98, the default ports the master ui was deployed on port 16010, and the
        HBase RegionServers would listen on port 16020 by default and put up an informational http
        server at 16030. </p><p>Once HBase has started, see the <a class="xref" href="#shell_exercises" title="Procedure&nbsp;1.2.&nbsp;Use HBase For the First Time">Procedure&nbsp;1.2, &#8220;Use HBase For the First Time&#8221;</a> for how to create tables, add data, scan your insertions, and
        finally disable and drop your tables.</p><p>To stop HBase after exiting the HBase shell enter</p><pre class="screen">$ ./bin/stop-hbase.sh
stopping hbase...............</pre><p>Shutdown can take a moment to complete. It can take longer if your cluster is comprised
        of many machines. If you are running a distributed operation, be sure to wait until HBase
        has shut down completely before stopping the Hadoop daemons.</p></div><div class="section" title="2.4.&nbsp;Configuration Files"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="config.files"></a>2.4.&nbsp;Configuration Files</h2></div></div></div><div class="section" title="2.4.1.&nbsp;hbase-site.xml and hbase-default.xml"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.site"></a>2.4.1.&nbsp;<code class="filename">hbase-site.xml</code> and <code class="filename">hbase-default.xml</code></h3></div></div></div><p>Just as in Hadoop where you add site-specific HDFS configuration to the
          <code class="filename">hdfs-site.xml</code> file, for HBase, site specific customizations go into
        the file <code class="filename">conf/hbase-site.xml</code>. For the list of configurable properties,
        see <a class="xref" href="#hbase_default_configurations" title="HBase Default Configuration">HBase Default Configuration</a> below or view the raw
          <code class="filename">hbase-default.xml</code> source file in the HBase source code at
          <code class="filename">src/main/resources</code>. </p><p> Not all configuration options make it out to <code class="filename">hbase-default.xml</code>.
        Configuration that it is thought rare anyone would change can exist only in code; the only
        way to turn up such configurations is via a reading of the source code itself. </p><p> Currently, changes here will require a cluster restart for HBase to notice the change. </p><div class="glossary" title="HBase Default Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_default_configurations"></a>HBase Default Configuration</h4></div></div></div><p>
The documentation below is generated using the default hbase configuration file,
<code class="filename">hbase-default.xml</code>, as source.
</p><dl><dt><a name="hbase.tmp.dir"></a><code class="varname">hbase.tmp.dir</code></dt><dd><p>Temporary directory on the local filesystem.
    Change this setting to point to a location more permanent
    than '/tmp', the usual resolve for java.io.tmpdir, as the
    '/tmp' directory is cleared on machine restart.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${java.io.tmpdir}/hbase-${user.name}</code></p></dd><dt><a name="hbase.rootdir"></a><code class="varname">hbase.rootdir</code></dt><dd><p>The directory shared by region servers and into
    which HBase persists.  The URL should be 'fully-qualified'
    to include the filesystem scheme.  For example, to specify the
    HDFS directory '/hbase' where the HDFS instance's namenode is
    running at namenode.example.org on port 9000, set this value to:
    hdfs://namenode.example.org:9000/hbase.  By default, we write
    to whatever ${hbase.tmp.dir} is set too -- usually /tmp --
    so change this configuration or else all data will be lost on
    machine restart.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.tmp.dir}/hbase</code></p></dd><dt><a name="hbase.cluster.distributed"></a><code class="varname">hbase.cluster.distributed</code></dt><dd><p>The mode the cluster will be in. Possible values are
      false for standalone mode and true for distributed mode.  If
      false, startup will run all HBase and ZooKeeper daemons together
      in the one JVM.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.zookeeper.quorum"></a><code class="varname">hbase.zookeeper.quorum</code></dt><dd><p>Comma separated list of servers in the ZooKeeper ensemble
    (This config. should have been named hbase.zookeeper.ensemble).
    For example, "host1.mydomain.com,host2.mydomain.com,host3.mydomain.com".
    By default this is set to localhost for local and pseudo-distributed modes
    of operation. For a fully-distributed setup, this should be set to a full
    list of ZooKeeper ensemble servers. If HBASE_MANAGES_ZK is set in hbase-env.sh
    this is the list of servers which hbase will start/stop ZooKeeper on as
    part of cluster start/stop.  Client-side, we will take this list of
    ensemble members and put it together with the hbase.zookeeper.clientPort
    config. and pass it into zookeeper constructor as the connectString
    parameter.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">localhost</code></p></dd><dt><a name="hbase.local.dir"></a><code class="varname">hbase.local.dir</code></dt><dd><p>Directory on the local filesystem to be used
    as a local storage.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.tmp.dir}/local/</code></p></dd><dt><a name="hbase.master.port"></a><code class="varname">hbase.master.port</code></dt><dd><p>The port the HBase Master should bind to.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60000</code></p></dd><dt><a name="hbase.master.info.port"></a><code class="varname">hbase.master.info.port</code></dt><dd><p>The port for the HBase Master web UI.
    Set to -1 if you do not want a UI instance run.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60010</code></p></dd><dt><a name="hbase.master.info.bindAddress"></a><code class="varname">hbase.master.info.bindAddress</code></dt><dd><p>The bind address for the HBase Master web UI
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.0.0.0</code></p></dd><dt><a name="hbase.master.logcleaner.plugins"></a><code class="varname">hbase.master.logcleaner.plugins</code></dt><dd><p>A comma-separated list of LogCleanerDelegate invoked by
    the LogsCleaner service. These WAL/HLog cleaners are called in order,
    so put the HLog cleaner that prunes the most HLog files in front. To
    implement your own LogCleanerDelegate, just put it in HBase's classpath
    and add the fully qualified class name here. Always add the above
    default log cleaners in the list.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.cleaner.TimeToLiveLogCleaner</code></p></dd><dt><a name="hbase.master.logcleaner.ttl"></a><code class="varname">hbase.master.logcleaner.ttl</code></dt><dd><p>Maximum time a HLog can stay in the .oldlogdir directory,
    after which it will be cleaned by a Master thread.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">600000</code></p></dd><dt><a name="hbase.master.hfilecleaner.plugins"></a><code class="varname">hbase.master.hfilecleaner.plugins</code></dt><dd><p>A comma-separated list of HFileCleanerDelegate invoked by
    the HFileCleaner service. These HFiles cleaners are called in order,
    so put the cleaner that prunes the most files in front. To
    implement your own HFileCleanerDelegate, just put it in HBase's classpath
    and add the fully qualified class name here. Always add the above
    default log cleaners in the list as they will be overwritten in
    hbase-site.xml.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.cleaner.TimeToLiveHFileCleaner</code></p></dd><dt><a name="hbase.master.catalog.timeout"></a><code class="varname">hbase.master.catalog.timeout</code></dt><dd><p>Timeout value for the Catalog Janitor from the master to
    META.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">600000</code></p></dd><dt><a name="fail.fast.expired.active.master"></a><code class="varname">fail.fast.expired.active.master</code></dt><dd><p>If abort immediately for the expired master without trying
      to recover its zk session.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.master.dns.interface"></a><code class="varname">hbase.master.dns.interface</code></dt><dd><p>The name of the Network Interface from which a master
      should report its IP address.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.master.dns.nameserver"></a><code class="varname">hbase.master.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a master should use to determine the host name used
      for communication and display purposes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.port"></a><code class="varname">hbase.regionserver.port</code></dt><dd><p>The port the HBase RegionServer binds to.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60020</code></p></dd><dt><a name="hbase.regionserver.info.port"></a><code class="varname">hbase.regionserver.info.port</code></dt><dd><p>The port for the HBase RegionServer web UI
    Set to -1 if you do not want the RegionServer UI to run.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60030</code></p></dd><dt><a name="hbase.regionserver.info.bindAddress"></a><code class="varname">hbase.regionserver.info.bindAddress</code></dt><dd><p>The address for the HBase RegionServer web UI</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.0.0.0</code></p></dd><dt><a name="hbase.regionserver.info.port.auto"></a><code class="varname">hbase.regionserver.info.port.auto</code></dt><dd><p>Whether or not the Master or RegionServer
    UI should search for a port to bind to. Enables automatic port
    search if hbase.regionserver.info.port is already in use.
    Useful for testing, turned off by default.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.regionserver.handler.count"></a><code class="varname">hbase.regionserver.handler.count</code></dt><dd><p>Count of RPC Listener instances spun up on RegionServers.
    Same property is used by the Master for count of master handlers.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">30</code></p></dd><dt><a name="hbase.ipc.server.callqueue.handler.factor"></a><code class="varname">hbase.ipc.server.callqueue.handler.factor</code></dt><dd><p>Factor to determine the number of call queues.
      A value of 0 means a single queue shared between all the handlers.
      A value of 1 means that each handler has its own queue.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.1</code></p></dd><dt><a name="hbase.ipc.server.callqueue.read.share"></a><code class="varname">hbase.ipc.server.callqueue.read.share</code></dt><dd><p>Split the call queues into read and write queues.
      A value of 0 indicate to not split the call queues.
      A value of 0.5 means there will be the same number of read and write queues
      A value of 1.0 means that all the queues except one are used to dispatch read requests.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0</code></p></dd><dt><a name="hbase.regionserver.msginterval"></a><code class="varname">hbase.regionserver.msginterval</code></dt><dd><p>Interval between messages from the RegionServer to Master
    in milliseconds.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3000</code></p></dd><dt><a name="hbase.regionserver.regionSplitLimit"></a><code class="varname">hbase.regionserver.regionSplitLimit</code></dt><dd><p>Limit for the number of regions after which no more region
    splitting should take place. This is not a hard limit for the number of
    regions but acts as a guideline for the regionserver to stop splitting after
    a certain limit. Default is MAX_INT; i.e. do not block splitting.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2147483647</code></p></dd><dt><a name="hbase.regionserver.logroll.period"></a><code class="varname">hbase.regionserver.logroll.period</code></dt><dd><p>Period at which we will roll the commit log regardless
    of how many edits it has.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3600000</code></p></dd><dt><a name="hbase.regionserver.logroll.errors.tolerated"></a><code class="varname">hbase.regionserver.logroll.errors.tolerated</code></dt><dd><p>The number of consecutive WAL close errors we will allow
    before triggering a server abort.  A setting of 0 will cause the
    region server to abort if closing the current WAL writer fails during
    log rolling.  Even a small value (2 or 3) will allow a region server
    to ride over transient HDFS errors.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.regionserver.hlog.reader.impl"></a><code class="varname">hbase.regionserver.hlog.reader.impl</code></dt><dd><p>The HLog file reader implementation.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.regionserver.wal.ProtobufLogReader</code></p></dd><dt><a name="hbase.regionserver.hlog.writer.impl"></a><code class="varname">hbase.regionserver.hlog.writer.impl</code></dt><dd><p>The HLog file writer implementation.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.regionserver.wal.ProtobufLogWriter</code></p></dd><dt><a name="hbase.regionserver.global.memstore.upperLimit"></a><code class="varname">hbase.regionserver.global.memstore.upperLimit</code></dt><dd><p>Maximum size of all memstores in a region server before new
      updates are blocked and flushes are forced. Defaults to 40% of heap.
      Updates are blocked and flushes are forced until size of all memstores
      in a region server hits hbase.regionserver.global.memstore.lowerLimit.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.4</code></p></dd><dt><a name="hbase.regionserver.global.memstore.lowerLimit"></a><code class="varname">hbase.regionserver.global.memstore.lowerLimit</code></dt><dd><p>Maximum size of all memstores in a region server before
      flushes are forced. Defaults to 38% of heap.
      This value equal to hbase.regionserver.global.memstore.upperLimit causes
      the minimum possible flushing to occur when updates are blocked due to
      memstore limiting.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.38</code></p></dd><dt><a name="hbase.regionserver.optionalcacheflushinterval"></a><code class="varname">hbase.regionserver.optionalcacheflushinterval</code></dt><dd><p>
    Maximum amount of time an edit lives in memory before being automatically flushed.
    Default 1 hour. Set it to 0 to disable automatic flushing.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3600000</code></p></dd><dt><a name="hbase.regionserver.catalog.timeout"></a><code class="varname">hbase.regionserver.catalog.timeout</code></dt><dd><p>Timeout value for the Catalog Janitor from the regionserver to META.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">600000</code></p></dd><dt><a name="hbase.regionserver.dns.interface"></a><code class="varname">hbase.regionserver.dns.interface</code></dt><dd><p>The name of the Network Interface from which a region server
      should report its IP address.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.dns.nameserver"></a><code class="varname">hbase.regionserver.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a region server should use to determine the host name used by the
      master for communication and display purposes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.region.split.policy"></a><code class="varname">hbase.regionserver.region.split.policy</code></dt><dd><p>
      A split policy determines when a region should be split. The various other split policies that
      are available currently are ConstantSizeRegionSplitPolicy, DisabledRegionSplitPolicy, 
      DelimitedKeyPrefixRegionSplitPolicy, KeyPrefixRegionSplitPolicy etc.  
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.regionserver.IncreasingToUpperBoundRegionSplitPolicy</code></p></dd><dt><a name="zookeeper.session.timeout"></a><code class="varname">zookeeper.session.timeout</code></dt><dd><p>ZooKeeper session timeout in milliseconds. It is used in two different ways.
      First, this value is used in the ZK client that HBase uses to connect to the ensemble.
      It is also used by HBase when it starts a ZK server and it is passed as the 'maxSessionTimeout'. See
      http://hadoop.apache.org/zookeeper/docs/current/zookeeperProgrammers.html#ch_zkSessions.
      For example, if a HBase region server connects to a ZK ensemble that's also managed by HBase, then the
      session timeout will be the one specified by this configuration. But, a region server that connects
      to an ensemble managed with a different configuration will be subjected that ensemble's maxSessionTimeout. So,
      even though HBase might propose using 90 seconds, the ensemble can have a max timeout lower than this and
      it will take precedence. The current default that ZK ships with is 40 seconds, which is lower than HBase's.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">90000</code></p></dd><dt><a name="zookeeper.znode.parent"></a><code class="varname">zookeeper.znode.parent</code></dt><dd><p>Root ZNode for HBase in ZooKeeper. All of HBase's ZooKeeper
      files that are configured with a relative path will go under this node.
      By default, all of HBase's ZooKeeper file path are configured with a
      relative path, so they will all go under this directory unless changed.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">/hbase</code></p></dd><dt><a name="zookeeper.znode.rootserver"></a><code class="varname">zookeeper.znode.rootserver</code></dt><dd><p>Path to ZNode holding root region location. This is written by
      the master and read by clients and region servers. If a relative path is
      given, the parent folder will be ${zookeeper.znode.parent}. By default,
      this means the root location is stored at /hbase/root-region-server.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">root-region-server</code></p></dd><dt><a name="zookeeper.znode.acl.parent"></a><code class="varname">zookeeper.znode.acl.parent</code></dt><dd><p>Root ZNode for access control lists.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">acl</code></p></dd><dt><a name="hbase.zookeeper.dns.interface"></a><code class="varname">hbase.zookeeper.dns.interface</code></dt><dd><p>The name of the Network Interface from which a ZooKeeper server
      should report its IP address.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.zookeeper.dns.nameserver"></a><code class="varname">hbase.zookeeper.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a ZooKeeper server should use to determine the host name used by the
      master for communication and display purposes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.zookeeper.peerport"></a><code class="varname">hbase.zookeeper.peerport</code></dt><dd><p>Port used by ZooKeeper peers to talk to each other.
    Seehttp://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper
    for more information.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2888</code></p></dd><dt><a name="hbase.zookeeper.leaderport"></a><code class="varname">hbase.zookeeper.leaderport</code></dt><dd><p>Port used by ZooKeeper for leader election.
    See http://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper
    for more information.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3888</code></p></dd><dt><a name="hbase.zookeeper.useMulti"></a><code class="varname">hbase.zookeeper.useMulti</code></dt><dd><p>Instructs HBase to make use of ZooKeeper's multi-update functionality.
    This allows certain ZooKeeper operations to complete more quickly and prevents some issues
    with rare Replication failure scenarios (see the release note of HBASE-2611 for an example).
    IMPORTANT: only set this to true if all ZooKeeper servers in the cluster are on version 3.4+
    and will not be downgraded.  ZooKeeper versions before 3.4 do not support multi-update and
    will not fail gracefully if multi-update is invoked (see ZOOKEEPER-1495).</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.config.read.zookeeper.config"></a><code class="varname">hbase.config.read.zookeeper.config</code></dt><dd><p>
        Set to true to allow HBaseConfiguration to read the
        zoo.cfg file for ZooKeeper properties. Switching this to true
        is not recommended, since the functionality of reading ZK
        properties from a zoo.cfg file has been deprecated.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.zookeeper.property.initLimit"></a><code class="varname">hbase.zookeeper.property.initLimit</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The number of ticks that the initial synchronization phase can take.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.zookeeper.property.syncLimit"></a><code class="varname">hbase.zookeeper.property.syncLimit</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The number of ticks that can pass between sending a request and getting an
    acknowledgment.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">5</code></p></dd><dt><a name="hbase.zookeeper.property.dataDir"></a><code class="varname">hbase.zookeeper.property.dataDir</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The directory where the snapshot is stored.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.tmp.dir}/zookeeper</code></p></dd><dt><a name="hbase.zookeeper.property.clientPort"></a><code class="varname">hbase.zookeeper.property.clientPort</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The port at which the clients will connect.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2181</code></p></dd><dt><a name="hbase.zookeeper.property.maxClientCnxns"></a><code class="varname">hbase.zookeeper.property.maxClientCnxns</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    Limit on number of concurrent connections (at the socket level) that a
    single client, identified by IP address, may make to a single member of
    the ZooKeeper ensemble. Set high to avoid zk connection issues running
    standalone and pseudo-distributed.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">300</code></p></dd><dt><a name="hbase.client.write.buffer"></a><code class="varname">hbase.client.write.buffer</code></dt><dd><p>Default size of the HTable client write buffer in bytes.
    A bigger buffer takes more memory -- on both the client and server
    side since server instantiates the passed write buffer to process
    it -- but a larger buffer size reduces the number of RPCs made.
    For an estimate of server-side memory-used, evaluate
    hbase.client.write.buffer * hbase.regionserver.handler.count</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2097152</code></p></dd><dt><a name="hbase.client.pause"></a><code class="varname">hbase.client.pause</code></dt><dd><p>General client pause value.  Used mostly as value to wait
    before running a retry of a failed get, region lookup, etc.
    See hbase.client.retries.number for description of how we backoff from
    this initial pause amount and how this pause works w/ retries.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.client.retries.number"></a><code class="varname">hbase.client.retries.number</code></dt><dd><p>Maximum retries.  Used as maximum for all retryable
    operations such as the getting of a cell's value, starting a row update,
    etc.  Retry interval is a rough function based on hbase.client.pause.  At
    first we retry at this interval but then with backoff, we pretty quickly reach
    retrying every ten seconds.  See HConstants#RETRY_BACKOFF for how the backup
    ramps up.  Change this setting and hbase.client.pause to suit your workload.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">35</code></p></dd><dt><a name="hbase.client.max.total.tasks"></a><code class="varname">hbase.client.max.total.tasks</code></dt><dd><p>The maximum number of concurrent tasks a single HTable instance will
    send to the cluster.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.client.max.perserver.tasks"></a><code class="varname">hbase.client.max.perserver.tasks</code></dt><dd><p>The maximum number of concurrent tasks a single HTable instance will
    send to a single region server.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">5</code></p></dd><dt><a name="hbase.client.max.perregion.tasks"></a><code class="varname">hbase.client.max.perregion.tasks</code></dt><dd><p>The maximum number of concurrent connections the client will
    maintain to a single Region. That is, if there is already
    hbase.client.max.perregion.tasks writes in progress for this region, new puts
    won't be sent to this region until some writes finishes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1</code></p></dd><dt><a name="hbase.client.scanner.caching"></a><code class="varname">hbase.client.scanner.caching</code></dt><dd><p>Number of rows that will be fetched when calling next
    on a scanner if it is not served from (local, client) memory. Higher
    caching values will enable faster scanners but will eat up more memory
    and some calls of next may take longer and longer times when the cache is empty.
    Do not set this value such that the time between invocations is greater
    than the scanner timeout; i.e. hbase.client.scanner.timeout.period</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.client.keyvalue.maxsize"></a><code class="varname">hbase.client.keyvalue.maxsize</code></dt><dd><p>Specifies the combined maximum allowed size of a KeyValue
    instance. This is to set an upper boundary for a single entry saved in a
    storage file. Since they cannot be split it helps avoiding that a region
    cannot be split any further because the data is too large. It seems wise
    to set this to a fraction of the maximum region size. Setting it to zero
    or less disables the check.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10485760</code></p></dd><dt><a name="hbase.client.scanner.timeout.period"></a><code class="varname">hbase.client.scanner.timeout.period</code></dt><dd><p>Client scanner lease period in milliseconds.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60000</code></p></dd><dt><a name="hbase.client.localityCheck.threadPoolSize"></a><code class="varname">hbase.client.localityCheck.threadPoolSize</code></dt><dd><p></p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.client.prefetch"></a><code class="varname">hbase.client.prefetch</code></dt><dd><p>Toggles region location prefetching on or off.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.client.prefetch.limit"></a><code class="varname">hbase.client.prefetch.limit</code></dt><dd><p>The maximum number of region locations that will be
    prefetched at one time.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.bulkload.retries.number"></a><code class="varname">hbase.bulkload.retries.number</code></dt><dd><p>Maximum retries.  This is maximum number of iterations
    to atomic bulk loads are attempted in the face of splitting operations
    0 means never give up.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0</code></p></dd><dt><a name="hbase.balancer.period%0A    "></a><code class="varname">hbase.balancer.period
    </code></dt><dd><p>Period at which the region balancer runs in the Master.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">300000</code></p></dd><dt><a name="hbase.regions.slop"></a><code class="varname">hbase.regions.slop</code></dt><dd><p>Rebalance if any regionserver has average + (average * slop) regions.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.2</code></p></dd><dt><a name="hbase.server.thread.wakefrequency"></a><code class="varname">hbase.server.thread.wakefrequency</code></dt><dd><p>Time to sleep in between searches for work (in milliseconds).
    Used as sleep interval by service threads such as log roller.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10000</code></p></dd><dt><a name="hbase.server.versionfile.writeattempts"></a><code class="varname">hbase.server.versionfile.writeattempts</code></dt><dd><p>
    How many time to retry attempting to write a version file
    before just aborting. Each attempt is seperated by the
    hbase.server.thread.wakefrequency milliseconds.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3</code></p></dd><dt><a name="hbase.hregion.memstore.flush.size"></a><code class="varname">hbase.hregion.memstore.flush.size</code></dt><dd><p>
    Memstore will be flushed to disk if size of the memstore
    exceeds this number of bytes.  Value is checked by a thread that runs
    every hbase.server.thread.wakefrequency.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">134217728</code></p></dd><dt><a name="hbase.hregion.preclose.flush.size"></a><code class="varname">hbase.hregion.preclose.flush.size</code></dt><dd><p>
      If the memstores in a region are this size or larger when we go
      to close, run a "pre-flush" to clear out memstores before we put up
      the region closed flag and take the region offline.  On close,
      a flush is run under the close flag to empty memory.  During
      this time the region is offline and we are not taking on any writes.
      If the memstore content is large, this flush could take a long time to
      complete.  The preflush is meant to clean out the bulk of the memstore
      before putting up the close flag and taking the region offline so the
      flush that runs under the close flag has little to do.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">5242880</code></p></dd><dt><a name="hbase.hregion.memstore.block.multiplier"></a><code class="varname">hbase.hregion.memstore.block.multiplier</code></dt><dd><p>
    Block updates if memstore has hbase.hregion.memstore.block.multiplier
    times hbase.hregion.memstore.flush.size bytes.  Useful preventing
    runaway memstore during spikes in update traffic.  Without an
    upper-bound, memstore fills such that when it flushes the
    resultant flush files take a long time to compact or split, or
    worse, we OOME.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">4</code></p></dd><dt><a name="hbase.hregion.memstore.mslab.enabled"></a><code class="varname">hbase.hregion.memstore.mslab.enabled</code></dt><dd><p>
      Enables the MemStore-Local Allocation Buffer,
      a feature which works to prevent heap fragmentation under
      heavy write loads. This can reduce the frequency of stop-the-world
      GC pauses on large heaps.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.hregion.max.filesize"></a><code class="varname">hbase.hregion.max.filesize</code></dt><dd><p>
    Maximum HStoreFile size. If any one of a column families' HStoreFiles has
    grown to exceed this value, the hosting HRegion is split in two.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10737418240</code></p></dd><dt><a name="hbase.hregion.majorcompaction"></a><code class="varname">hbase.hregion.majorcompaction</code></dt><dd><p>The time (in miliseconds) between 'major' compactions of all
    HStoreFiles in a region.  Default: Set to 7 days.  Major compactions tend to
    happen exactly when you need them least so enable them such that they run at
    off-peak for your deploy; or, since this setting is on a periodicity that is
    unlikely to match your loading, run the compactions via an external
    invocation out of a cron job or some such.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">604800000</code></p></dd><dt><a name="hbase.hregion.majorcompaction.jitter"></a><code class="varname">hbase.hregion.majorcompaction.jitter</code></dt><dd><p>Jitter outer bound for major compactions.
    On each regionserver, we multiply the hbase.region.majorcompaction
    interval by some random fraction that is inside the bounds of this
    maximum.  We then add this + or - product to when the next
    major compaction is to run.  The idea is that major compaction
    does happen on every regionserver at exactly the same time.  The
    smaller this number, the closer the compactions come together.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.50</code></p></dd><dt><a name="hbase.hstore.compactionThreshold"></a><code class="varname">hbase.hstore.compactionThreshold</code></dt><dd><p>
    If more than this number of HStoreFiles in any one HStore
    (one HStoreFile is written per flush of memstore) then a compaction
    is run to rewrite all HStoreFiles files as one.  Larger numbers
    put off compaction but when it runs, it takes longer to complete.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3</code></p></dd><dt><a name="hbase.hstore.flusher.count"></a><code class="varname">hbase.hstore.flusher.count</code></dt><dd><p>
    The number of flush threads. With less threads, the memstore flushes will be queued. With
    more threads, the flush will be executed in parallel, increasing the hdfs load. This can
    lead as well to more compactions.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.hstore.blockingStoreFiles"></a><code class="varname">hbase.hstore.blockingStoreFiles</code></dt><dd><p>
    If more than this number of StoreFiles in any one Store
    (one StoreFile is written per flush of MemStore) then updates are
    blocked for this HRegion until a compaction is completed, or
    until hbase.hstore.blockingWaitTime has been exceeded.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.hstore.blockingWaitTime"></a><code class="varname">hbase.hstore.blockingWaitTime</code></dt><dd><p>
    The time an HRegion will block updates for after hitting the StoreFile
    limit defined by hbase.hstore.blockingStoreFiles.
    After this time has elapsed, the HRegion will stop blocking updates even
    if a compaction has not been completed.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">90000</code></p></dd><dt><a name="hbase.hstore.compaction.max"></a><code class="varname">hbase.hstore.compaction.max</code></dt><dd><p>Max number of HStoreFiles to compact per 'minor' compaction.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.hstore.compaction.kv.max"></a><code class="varname">hbase.hstore.compaction.kv.max</code></dt><dd><p>How many KeyValues to read and then write in a batch when flushing
        or compacting.  Do less if big KeyValues and problems with OOME.
        Do more if wide, small rows.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.storescanner.parallel.seek.enable"></a><code class="varname">hbase.storescanner.parallel.seek.enable</code></dt><dd><p>
      Enables StoreFileScanner parallel-seeking in StoreScanner,
      a feature which can reduce response latency under special conditions.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.storescanner.parallel.seek.threads"></a><code class="varname">hbase.storescanner.parallel.seek.threads</code></dt><dd><p>
      The default thread pool size if parallel-seeking feature enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hfile.block.cache.size"></a><code class="varname">hfile.block.cache.size</code></dt><dd><p>Percentage of maximum heap (-Xmx setting) to allocate to block cache
        used by HFile/StoreFile. Default of 0.4 means allocate 40%.
        Set to 0 to disable but it's not recommended; you need at least
        enough cache to hold the storefile indices.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.4</code></p></dd><dt><a name="hfile.block.index.cacheonwrite"></a><code class="varname">hfile.block.index.cacheonwrite</code></dt><dd><p>This allows to put non-root multi-level index blocks into the block
          cache at the time the index is being written.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hfile.index.block.max.size"></a><code class="varname">hfile.index.block.max.size</code></dt><dd><p>When the size of a leaf-level, intermediate-level, or root-level
          index block in a multi-level block index grows to this size, the
          block is written out and a new block is started.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">131072</code></p></dd><dt><a name="hfile.format.version"></a><code class="varname">hfile.format.version</code></dt><dd><p>The HFile format version to use for new files. Set this to 1 to test
          backwards-compatibility. The default value of this option should be
          consistent with FixedFileTrailer.MAX_VERSION.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hfile.block.bloom.cacheonwrite"></a><code class="varname">hfile.block.bloom.cacheonwrite</code></dt><dd><p>Enables cache-on-write for inline blocks of a compound Bloom filter.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="io.storefile.bloom.block.size"></a><code class="varname">io.storefile.bloom.block.size</code></dt><dd><p>The size in bytes of a single block ("chunk") of a compound Bloom
          filter. This size is approximate, because Bloom blocks can only be
          inserted at data block boundaries, and the number of keys per data
          block varies.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">131072</code></p></dd><dt><a name="hbase.rs.cacheblocksonwrite"></a><code class="varname">hbase.rs.cacheblocksonwrite</code></dt><dd><p>Whether an HFile block should be added to the block cache when the
          block is finished.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.rpc.server.engine"></a><code class="varname">hbase.rpc.server.engine</code></dt><dd><p>Implementation of org.apache.hadoop.hbase.ipc.RpcServerEngine to be
    used for server RPC call marshalling.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.ipc.ProtobufRpcServerEngine</code></p></dd><dt><a name="hbase.rpc.timeout"></a><code class="varname">hbase.rpc.timeout</code></dt><dd><p>This is for the RPC layer to define how long HBase client applications
        take for a remote call to time out. It uses pings to check connections
        but will eventually throw a TimeoutException.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60000</code></p></dd><dt><a name="hbase.rpc.shortoperation.timeout"></a><code class="varname">hbase.rpc.shortoperation.timeout</code></dt><dd><p>This is another version of "hbase.rpc.timeout". For those RPC operation
        within cluster, we rely on this configuration to set a short timeout limitation
        for short operation. For example, short rpc timeout for region server's trying
        to report to active master can benefit quicker master failover process.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10000</code></p></dd><dt><a name="hbase.ipc.client.tcpnodelay"></a><code class="varname">hbase.ipc.client.tcpnodelay</code></dt><dd><p>Set no delay on rpc socket connections.  See
    http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay()</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.master.keytab.file"></a><code class="varname">hbase.master.keytab.file</code></dt><dd><p>Full path to the kerberos keytab file to use for logging in
    the configured HMaster server principal.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.master.kerberos.principal"></a><code class="varname">hbase.master.kerberos.principal</code></dt><dd><p>Ex. "hbase/_HOST@EXAMPLE.COM".  The kerberos principal name
    that should be used to run the HMaster process.  The principal name should
    be in the form: user/hostname@DOMAIN.  If "_HOST" is used as the hostname
    portion, it will be replaced with the actual hostname of the running
    instance.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.regionserver.keytab.file"></a><code class="varname">hbase.regionserver.keytab.file</code></dt><dd><p>Full path to the kerberos keytab file to use for logging in
    the configured HRegionServer server principal.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.regionserver.kerberos.principal"></a><code class="varname">hbase.regionserver.kerberos.principal</code></dt><dd><p>Ex. "hbase/_HOST@EXAMPLE.COM".  The kerberos principal name
    that should be used to run the HRegionServer process.  The principal name
    should be in the form: user/hostname@DOMAIN.  If "_HOST" is used as the
    hostname portion, it will be replaced with the actual hostname of the
    running instance.  An entry for this principal must exist in the file
    specified in hbase.regionserver.keytab.file</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hadoop.policy.file"></a><code class="varname">hadoop.policy.file</code></dt><dd><p>The policy configuration file used by RPC servers to make
      authorization decisions on client requests.  Only used when HBase
      security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">hbase-policy.xml</code></p></dd><dt><a name="hbase.superuser"></a><code class="varname">hbase.superuser</code></dt><dd><p>List of users or groups (comma-separated), who are allowed
    full privileges, regardless of stored ACLs, across the cluster.
    Only used when HBase security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.auth.key.update.interval"></a><code class="varname">hbase.auth.key.update.interval</code></dt><dd><p>The update interval for master key for authentication tokens
    in servers in milliseconds.  Only used when HBase security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">86400000</code></p></dd><dt><a name="hbase.auth.token.max.lifetime"></a><code class="varname">hbase.auth.token.max.lifetime</code></dt><dd><p>The maximum lifetime in milliseconds after which an
    authentication token expires.  Only used when HBase security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">604800000</code></p></dd><dt><a name="hbase.ipc.client.fallback-to-simple-auth-allowed"></a><code class="varname">hbase.ipc.client.fallback-to-simple-auth-allowed</code></dt><dd><p>When a client is configured to attempt a secure connection, but attempts to
      connect to an insecure server, that server may instruct the client to
      switch to SASL SIMPLE (unsecure) authentication. This setting controls
      whether or not the client will accept this instruction from the server.
      When false (the default), the client will not allow the fallback to SIMPLE
      authentication, and will abort the connection.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.coprocessor.region.classes"></a><code class="varname">hbase.coprocessor.region.classes</code></dt><dd><p>A comma-separated list of Coprocessors that are loaded by
    default on all tables. For any override coprocessor method, these classes
    will be called in order. After implementing your own Coprocessor, just put
    it in HBase's classpath and add the fully qualified class name here.
    A coprocessor can also be loaded on demand by setting HTableDescriptor.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.rest.port"></a><code class="varname">hbase.rest.port</code></dt><dd><p>The port for the HBase REST server.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">8080</code></p></dd><dt><a name="hbase.rest.readonly"></a><code class="varname">hbase.rest.readonly</code></dt><dd><p>Defines the mode the REST server will be started in. Possible values are:
    false: All HTTP methods are permitted - GET/PUT/POST/DELETE.
    true: Only the GET method is permitted.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.rest.threads.max"></a><code class="varname">hbase.rest.threads.max</code></dt><dd><p>The maximum number of threads of the REST server thread pool.
        Threads in the pool are reused to process REST requests. This
        controls the maximum number of requests processed concurrently.
        It may help to control the memory used by the REST server to
        avoid OOM issues. If the thread pool is full, incoming requests
        will be queued up and wait for some free threads.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.rest.threads.min"></a><code class="varname">hbase.rest.threads.min</code></dt><dd><p>The minimum number of threads of the REST server thread pool.
        The thread pool always has at least these number of threads so
        the REST server is ready to serve incoming requests.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.rest.support.proxyuser"></a><code class="varname">hbase.rest.support.proxyuser</code></dt><dd><p>Enables running the REST server to support proxy-user mode.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.defaults.for.version.skip"></a><code class="varname">hbase.defaults.for.version.skip</code></dt><dd><p>Set to true to skip the 'hbase.defaults.for.version' check.
    Setting this to true can be useful in contexts other than
    the other side of a maven generation; i.e. running in an
    ide.  You'll want to set this boolean to true to avoid
    seeing the RuntimException complaint: "hbase-default.xml file
    seems to be for and old version of HBase (\${hbase.version}), this
    version is X.X.X-SNAPSHOT"</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.coprocessor.master.classes"></a><code class="varname">hbase.coprocessor.master.classes</code></dt><dd><p>A comma-separated list of
    org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are
    loaded by default on the active HMaster process. For any implemented
    coprocessor methods, the listed classes will be called in order. After
    implementing your own MasterObserver, just put it in HBase's classpath
    and add the fully qualified class name here.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.coprocessor.abortonerror"></a><code class="varname">hbase.coprocessor.abortonerror</code></dt><dd><p>Set to true to cause the hosting server (master or regionserver)
      to abort if a coprocessor fails to load, fails to initialize, or throws an
      unexpected Throwable object. Setting this to false will allow the server to
      continue execution but the system wide state of the coprocessor in question
      will become inconsistent as it will be properly executing in only a subset
      of servers, so this is most useful for debugging only.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.online.schema.update.enable"></a><code class="varname">hbase.online.schema.update.enable</code></dt><dd><p>Set true to enable online schema changes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.table.lock.enable"></a><code class="varname">hbase.table.lock.enable</code></dt><dd><p>Set to true to enable locking the table in zookeeper for schema change operations.
    Table locking from master prevents concurrent schema modifications to corrupt table
    state.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.thrift.minWorkerThreads"></a><code class="varname">hbase.thrift.minWorkerThreads</code></dt><dd><p>The "core size" of the thread pool. New threads are created on every
    connection until this many threads are created.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">16</code></p></dd><dt><a name="hbase.thrift.maxWorkerThreads"></a><code class="varname">hbase.thrift.maxWorkerThreads</code></dt><dd><p>The maximum size of the thread pool. When the pending request queue
    overflows, new threads are created until their number reaches this number.
    After that, the server starts dropping connections.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.thrift.maxQueuedRequests"></a><code class="varname">hbase.thrift.maxQueuedRequests</code></dt><dd><p>The maximum number of pending Thrift connections waiting in the queue. If
     there are no idle threads in the pool, the server queues requests. Only
     when the queue overflows, new threads are added, up to
     hbase.thrift.maxQueuedRequests threads.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.thrift.htablepool.size.max"></a><code class="varname">hbase.thrift.htablepool.size.max</code></dt><dd><p>The upper bound for the table pool used in the Thrift gateways server.
      Since this is per table name, we assume a single table and so with 1000 default
      worker threads max this is set to a matching number. For other workloads this number
      can be adjusted as needed.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.regionserver.thrift.framed"></a><code class="varname">hbase.regionserver.thrift.framed</code></dt><dd><p>Use Thrift TFramedTransport on the server side.
      This is the recommended transport for thrift servers and requires a similar setting
      on the client side. Changing this to false will select the default transport,
      vulnerable to DoS when malformed requests are issued due to THRIFT-601.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.regionserver.thrift.framed.max_frame_size_in_mb"></a><code class="varname">hbase.regionserver.thrift.framed.max_frame_size_in_mb</code></dt><dd><p>Default frame size when using framed transport</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.regionserver.thrift.compact"></a><code class="varname">hbase.regionserver.thrift.compact</code></dt><dd><p>Use Thrift TCompactProtocol binary serialization protocol.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.offheapcache.percentage"></a><code class="varname">hbase.offheapcache.percentage</code></dt><dd><p>The amount of off heap space to be allocated towards the experimental
     off heap cache. If you desire the cache to be disabled, simply set this
     value to 0.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0</code></p></dd><dt><a name="hbase.data.umask.enable"></a><code class="varname">hbase.data.umask.enable</code></dt><dd><p>Enable, if true, that file permissions should be assigned
      to the files written by the regionserver</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.data.umask"></a><code class="varname">hbase.data.umask</code></dt><dd><p>File permissions that should be used to write data
      files when hbase.data.umask.enable is true</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">000</code></p></dd><dt><a name="hbase.metrics.showTableName"></a><code class="varname">hbase.metrics.showTableName</code></dt><dd><p>Whether to include the prefix "tbl.tablename" in per-column family metrics.
	If true, for each metric M, per-cf metrics will be reported for tbl.T.cf.CF.M, if false,
	per-cf metrics will be aggregated by column-family across tables, and reported for cf.CF.M.
	In both cases, the aggregated metric M across tables and cfs will be reported.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.metrics.exposeOperationTimes"></a><code class="varname">hbase.metrics.exposeOperationTimes</code></dt><dd><p>Whether to report metrics about time taken performing an
      operation on the region server.  Get, Put, Delete, Increment, and Append can all
      have their times exposed through Hadoop metrics per CF and per region.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.enabled"></a><code class="varname">hbase.snapshot.enabled</code></dt><dd><p>Set to true to allow snapshots to be taken / restored / cloned.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.format.version"></a><code class="varname">hbase.snapshot.format.version</code></dt><dd><p>The Snapshot format version to use for new snapshots.
        1 is the old format used by 0.94, 0.96 and 0.98 as default.
        2 is the new format, which should be used if all the clients that are
        accessing snapshots via MR job are updated with the latest hbase jars.
        By switching to version 2, the previous snapshots will still be readable.
      </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1</code></p></dd><dt><a name="hbase.snapshot.restore.take.failsafe.snapshot"></a><code class="varname">hbase.snapshot.restore.take.failsafe.snapshot</code></dt><dd><p>Set to true to take a snapshot before the restore operation.
      The snapshot taken will be used in case of failure, to restore the previous state.
      At the end of the restore operation this snapshot will be deleted</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.restore.failsafe.name"></a><code class="varname">hbase.snapshot.restore.failsafe.name</code></dt><dd><p>Name of the failsafe snapshot taken by the restore operation.
      You can use the {snapshot.name}, {table.name} and {restore.timestamp} variables
      to create a name based on what you are restoring.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">hbase-failsafe-{snapshot.name}-{restore.timestamp}</code></p></dd><dt><a name="hbase.server.compactchecker.interval.multiplier"></a><code class="varname">hbase.server.compactchecker.interval.multiplier</code></dt><dd><p>The number that determines how often we scan to see if compaction is necessary.
        Normally, compactions are done after some events (such as memstore flush), but if
        region didn't receive a lot of writes for some time, or due to different compaction
        policies, it may be necessary to check it periodically. The interval between checks is
        hbase.server.compactchecker.interval.multiplier multiplied by
        hbase.server.thread.wakefrequency.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.lease.recovery.timeout"></a><code class="varname">hbase.lease.recovery.timeout</code></dt><dd><p>How long we wait on dfs lease recovery in total before giving up.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">900000</code></p></dd><dt><a name="hbase.lease.recovery.dfs.timeout"></a><code class="varname">hbase.lease.recovery.dfs.timeout</code></dt><dd><p>How long between dfs recover lease invocations. Should be larger than the sum of
        the time it takes for the namenode to issue a block recovery command as part of
        datanode; dfs.heartbeat.interval and the time it takes for the primary
        datanode, performing block recovery to timeout on a dead datanode; usually
        dfs.socket.timeout. See the end of HBASE-8389 for more.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">64000</code></p></dd><dt><a name="hbase.column.max.version"></a><code class="varname">hbase.column.max.version</code></dt><dd><p>New column family descriptors will use this value as the default number of versions
      to keep.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1</code></p></dd><dt><a name="hbase.dfs.client.read.shortcircuit.buffer.size"></a><code class="varname">hbase.dfs.client.read.shortcircuit.buffer.size</code></dt><dd><p>If the DFSClient configuration
    dfs.client.read.shortcircuit.buffer.size is unset, we will
    use what is configured here as the short circuit read default
    direct byte buffer size. DFSClient native default is 1MB; HBase
    keeps its HDFS files open so number of file blocks * 1MB soon
    starts to add up and threaten OOME because of a shortage of
    direct memory.  So, we set it down from the default.  Make
    it &gt; the default hbase block size set in the HColumnDescriptor
    which is usually 64k.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">131072</code></p></dd><dt><a name="hbase.regionserver.checksum.verify"></a><code class="varname">hbase.regionserver.checksum.verify</code></dt><dd><p>
        If set to true, HBase will read data and then verify checksums for
        hfile blocks. Checksum verification inside HDFS will be switched off.
        If the hbase-checksum verification fails, then it will switch back to
        using HDFS checksums.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.hstore.bytes.per.checksum"></a><code class="varname">hbase.hstore.bytes.per.checksum</code></dt><dd><p>
        Number of bytes in a newly created checksum chunk for HBase-level
        checksums in hfile blocks.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">16384</code></p></dd><dt><a name="hbase.hstore.checksum.algorithm"></a><code class="varname">hbase.hstore.checksum.algorithm</code></dt><dd><p>
      Name of an algorithm that is used to compute checksums. Possible values
      are NULL, CRC32, CRC32C.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">CRC32</code></p></dd><dt><a name="hbase.status.published"></a><code class="varname">hbase.status.published</code></dt><dd><p>
      This setting activates the publication by the master of the status of the region server.
      When a region server dies and its recovery starts, the master will push this information
      to the client application, to let them cut the connection immediately instead of waiting
      for a timeout.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.status.publisher.class"></a><code class="varname">hbase.status.publisher.class</code></dt><dd><p>
      Implementation of the status publication with a multicast message.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.ClusterStatusPublisher$MulticastPublisher</code></p></dd><dt><a name="hbase.status.listener.class"></a><code class="varname">hbase.status.listener.class</code></dt><dd><p>
      Implementation of the status listener with a multicast message.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.client.ClusterStatusListener$MulticastListener</code></p></dd><dt><a name="hbase.status.multicast.address.ip"></a><code class="varname">hbase.status.multicast.address.ip</code></dt><dd><p>
      Multicast address to use for the status publication by multicast.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">226.1.1.3</code></p></dd><dt><a name="hbase.status.multicast.address.port"></a><code class="varname">hbase.status.multicast.address.port</code></dt><dd><p>
      Multicast port to use for the status publication by multicast.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60100</code></p></dd><dt><a name="hbase.dynamic.jars.dir"></a><code class="varname">hbase.dynamic.jars.dir</code></dt><dd><p>
      The directory from which the custom filter/co-processor jars can be loaded
      dynamically by the region server without the need to restart. However,
      an already loaded filter/co-processor class would not be un-loaded. See
      HBASE-1936 for more details.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.rootdir}/lib</code></p></dd><dt><a name="hbase.security.authentication"></a><code class="varname">hbase.security.authentication</code></dt><dd><p>
      Controls whether or not secure authentication is enabled for HBase.
      Possible values are 'simple' (no authentication), and 'kerberos'.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">simple</code></p></dd><dt><a name="hbase.rest.filter.classes"></a><code class="varname">hbase.rest.filter.classes</code></dt><dd><p>
      Servlet filters for REST service.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.rest.filter.GzipFilter</code></p></dd><dt><a name="hbase.rest.filter.classes"></a><code class="varname">hbase.rest.filter.classes</code></dt><dd><p>
      Servlet filters for REST service.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.rest.filter.GzipFilter</code></p></dd><dt><a name="hbase.master.loadbalancer.class"></a><code class="varname">hbase.master.loadbalancer.class</code></dt><dd><p>
      Class used to execute the regions balancing when the period occurs.
      See the class comment for more on how it works
      http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html
      It replaces the DefaultLoadBalancer as the default (since renamed
      as the SimpleLoadBalancer).
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer</code></p></dd><dt><a name="hbase.security.exec.permission.checks"></a><code class="varname">hbase.security.exec.permission.checks</code></dt><dd><p>
      If this setting is enabled and ACL based access control is active (the
      AccessController coprocessor is installed either as a system coprocessor
      or on a table as a table coprocessor) then you must grant all relevant
      users EXEC privilege if they require the ability to execute coprocessor
      endpoint calls. EXEC privilege, like any other permission, can be
      granted globally to a user, or to a user on a per table or per namespace
      basis. For more information on coprocessor endpoints, see the coprocessor
      section of the HBase online manual. For more information on granting or
      revoking permissions using the AccessController, see the security
      section of the HBase online manual.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.procedure.regionserver.classes"></a><code class="varname">hbase.procedure.regionserver.classes</code></dt><dd><p>A comma-separated list of 
    org.apache.hadoop.hbase.procedure.RegionServerProcedureManager procedure managers that are 
    loaded by default on the active HRegionServer process. The lifecycle methods (init/start/stop) 
    will be called by the active HRegionServer process to perform the specific globally barriered 
    procedure. After implementing your own RegionServerProcedureManager, just put it in 
    HBase's classpath and add the fully qualified class name here.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.procedure.master.classes"></a><code class="varname">hbase.procedure.master.classes</code></dt><dd><p>A comma-separated list of
    org.apache.hadoop.hbase.procedure.MasterProcedureManager procedure managers that are
    loaded by default on the active HMaster process. A procedure is identified by its signature and
    users can use the signature and an instant name to trigger an execution of a globally barriered
    procedure. After implementing your own MasterProcedureManager, just put it in HBase's classpath
    and add the fully qualified class name here.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.security.visibility.mutations.checkauths"></a><code class="varname">hbase.security.visibility.mutations.checkauths</code></dt><dd><p>
      This property if enabled, will check whether the labels in the visibility expression are associated
      with the user issuing the mutation
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd></dl></div></div><div class="section" title="2.4.2.&nbsp;hbase-env.sh"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.env.sh"></a>2.4.2.&nbsp;<code class="filename">hbase-env.sh</code></h3></div></div></div><p>Set HBase environment variables in this file. Examples include options to pass the JVM
        on start of an HBase daemon such as heap size and garbage collector configs. You can also
        set configurations for HBase configuration, log directories, niceness, ssh options, where to
        locate process pid files, etc. Open the file at <code class="filename">conf/hbase-env.sh</code> and
        peruse its content. Each option is fairly well documented. Add your own environment
        variables here if you want them read by HBase daemons on startup.</p><p> Changes here will require a cluster restart for HBase to notice the change. </p></div><div class="section" title="2.4.3.&nbsp;log4j.properties"><div class="titlepage"><div><div><h3 class="title"><a name="log4j"></a>2.4.3.&nbsp;<code class="filename">log4j.properties</code></h3></div></div></div><p>Edit this file to change rate at which HBase files are rolled and to change the level at
        which HBase logs messages. </p><p> Changes here will require a cluster restart for HBase to notice the change though log
        levels can be changed for particular daemons via the HBase UI. </p></div><div class="section" title="2.4.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster"><div class="titlepage"><div><div><h3 class="title"><a name="client_dependencies"></a>2.4.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster</h3></div></div></div><p>If you are running HBase in standalone mode, you don't need to configure anything for
        your client to work provided that they are all on the same machine.</p><p> Since the HBase Master may move around, clients bootstrap by looking to ZooKeeper for
        current critical locations. ZooKeeper is where all these values are kept. Thus clients
        require the location of the ZooKeeper ensemble information before they can do anything else.
        Usually this the ensemble location is kept out in the <code class="filename">hbase-site.xml</code>
        and is picked up by the client from the <code class="varname">CLASSPATH</code>.</p><p>If you are configuring an IDE to run a HBase client, you should include the
          <code class="filename">conf/</code> directory on your classpath so
          <code class="filename">hbase-site.xml</code> settings can be found (or add
          <code class="filename">src/test/resources</code> to pick up the hbase-site.xml used by tests). </p><p> Minimally, a client of HBase needs several libraries in its
          <code class="varname">CLASSPATH</code> when connecting to a cluster, including:
        </p><pre class="programlisting">
commons-configuration (commons-configuration-1.6.jar)
commons-lang (commons-lang-2.5.jar)
commons-logging (commons-logging-1.1.1.jar)
hadoop-core (hadoop-core-1.0.0.jar)
hbase (hbase-0.92.0.jar)
log4j (log4j-1.2.16.jar)
slf4j-api (slf4j-api-1.5.8.jar)
slf4j-log4j (slf4j-log4j12-1.5.8.jar)
zookeeper (zookeeper-3.4.2.jar)</pre><p>
      </p><p> An example basic <code class="filename">hbase-site.xml</code> for client only might look as
        follows: </p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by region servers.
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
</pre><p>
      </p><div class="section" title="2.4.4.1.&nbsp;Java client configuration"><div class="titlepage"><div><div><h4 class="title"><a name="java.client.config"></a>2.4.4.1.&nbsp;Java client configuration</h4></div></div></div><p>The configuration used by a Java client is kept in an <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration" target="_top">HBaseConfiguration</a>
          instance. The factory method on HBaseConfiguration,
            <code class="code">HBaseConfiguration.create();</code>, on invocation, will read in the content of
          the first <code class="filename">hbase-site.xml</code> found on the client's
            <code class="varname">CLASSPATH</code>, if one is present (Invocation will also factor in any
            <code class="filename">hbase-default.xml</code> found; an hbase-default.xml ships inside the
            <code class="filename">hbase.X.X.X.jar</code>). It is also possible to specify configuration
          directly without having to read from a <code class="filename">hbase-site.xml</code>. For example,
          to set the ZooKeeper ensemble for the cluster programmatically do as follows:
          </p><pre class="programlisting">Configuration config = HBaseConfiguration.create();
config.set("hbase.zookeeper.quorum", "localhost");  // Here we are running zookeeper locally</pre><p>
          If multiple ZooKeeper instances make up your ZooKeeper ensemble, they may be specified in
          a comma-separated list (just as in the <code class="filename">hbase-site.xml</code> file). This
          populated <code class="classname">Configuration</code> instance can then be passed to an <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>,
          and so on. </p></div></div></div><div class="section" title="2.5.&nbsp;Example Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example_config"></a>2.5.&nbsp;Example Configurations</h2></div></div></div><div class="section" title="2.5.1.&nbsp;Basic Distributed HBase Install"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4110"></a>2.5.1.&nbsp;Basic Distributed HBase Install</h3></div></div></div><p>Here is an example basic configuration for a distributed ten node cluster. The nodes are
        named <code class="varname">example0</code>, <code class="varname">example1</code>, etc., through node
          <code class="varname">example9</code> in this example. The HBase Master and the HDFS namenode are
        running on the node <code class="varname">example0</code>. RegionServers run on nodes
          <code class="varname">example1</code>-<code class="varname">example9</code>. A 3-node ZooKeeper ensemble runs
        on <code class="varname">example1</code>, <code class="varname">example2</code>, and <code class="varname">example3</code>
        on the default ports. ZooKeeper data is persisted to the directory
          <code class="filename">/export/zookeeper</code>. Below we show what the main configuration files --
          <code class="filename">hbase-site.xml</code>, <code class="filename">regionservers</code>, and
          <code class="filename">hbase-env.sh</code> -- found in the HBase <code class="filename">conf</code>
        directory might look like.</p><div class="section" title="2.5.1.1.&nbsp;hbase-site.xml"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_site"></a>2.5.1.1.&nbsp;<code class="filename">hbase-site.xml</code></h4></div></div></div><pre class="programlisting">

&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
    &lt;value&gt;/export/zookeeper&lt;/value&gt;
    &lt;description&gt;Property from ZooKeeper config zoo.cfg.
    The directory where the snapshot is stored.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://example0:8020/hbase&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;The mode the cluster will be in. Possible values are
      false: standalone and pseudo-distributed setups with managed Zookeeper
      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;

        </pre></div><div class="section" title="2.5.1.2.&nbsp;regionservers"><div class="titlepage"><div><div><h4 class="title"><a name="regionservers"></a>2.5.1.2.&nbsp;<code class="filename">regionservers</code></h4></div></div></div><p>In this file you list the nodes that will run RegionServers. In our case, these nodes
          are <code class="varname">example1</code>-<code class="varname">example9</code>. </p><pre class="programlisting">
example1
example2
example3
example4
example5
example6
example7
example8
example9
        </pre></div><div class="section" title="2.5.1.3.&nbsp;hbase-env.sh"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_env"></a>2.5.1.3.&nbsp;<code class="filename">hbase-env.sh</code></h4></div></div></div><p>The following lines in the <code class="filename">hbase-env.sh</code> file show how to set the
            <code class="envar">JAVA_HOME</code> environment variable (required for HBase 0.98.5 and newer) and
          set the heap to 4 GB (rather than the default value of 1 GB). If you copy and paste this
          example, be sure to adjust the <code class="envar">JAVA_HOME</code> to suit your environment.</p><pre class="screen">
# The java implementation to use.
export JAVA_HOME=/usr/java/jdk1.7.0/          

# The maximum amount of heap to use, in MB. Default is 1000.
export HBASE_HEAPSIZE=4096
        </pre><p>Use <span class="command"><strong>rsync</strong></span> to copy the content of the <code class="filename">conf</code>
          directory to all nodes of the cluster.</p></div></div></div><div class="section" title="2.6.&nbsp;The Important Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="important_configurations"></a>2.6.&nbsp;The Important Configurations</h2></div></div></div><p>Below we list what the <span class="emphasis"><em>important</em></span> Configurations. We've divided this
      section into required configuration and worth-a-look recommended configs. </p><div class="section" title="2.6.1.&nbsp;Required Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="required_configuration"></a>2.6.1.&nbsp;Required Configurations</h3></div></div></div><p>Review the <a class="xref" href="#os" title="Operating System Utilities">Operating System Utilities</a> and <a class="xref" href="#hadoop" title="2.1.1.&nbsp;Hadoop">Section&nbsp;2.1.1, &#8220;Hadoop&#8221;</a> sections. </p><div class="section" title="2.6.1.1.&nbsp;Big Cluster Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="big.cluster.config"></a>2.6.1.1.&nbsp;Big Cluster Configurations</h4></div></div></div><p>If a cluster with a lot of regions, it is possible if an eager beaver regionserver
          checks in soon after master start while all the rest in the cluster are laggardly, this
          first server to checkin will be assigned all regions. If lots of regions, this first
          server could buckle under the load. To prevent the above scenario happening up the
            <code class="varname">hbase.master.wait.on.regionservers.mintostart</code> from its default value
          of 1. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-6389" target="_top">HBASE-6389 Modify the
            conditions to ensure that Master waits for sufficient number of Region Servers before
            starting region assignments</a> for more detail. </p></div><div class="section" title="2.6.1.2.&nbsp;If a backup Master, making primary Master fail fast"><div class="titlepage"><div><div><h4 class="title"><a name="backup.master.fail.fast"></a>2.6.1.2.&nbsp;If a backup Master, making primary Master fail fast</h4></div></div></div><p>If the primary Master loses its connection with ZooKeeper, it will fall into a loop
          where it keeps trying to reconnect. Disable this functionality if you are running more
          than one Master: i.e. a backup Master. Failing to do so, the dying Master may continue to
          receive RPCs though another Master has assumed the role of primary. See the configuration <a class="xref" href="#fail.fast.expired.active.master" title="fail.fast.expired.active.master"><code class="varname">fail.fast.expired.active.master</code></a>. </p></div></div><div class="section" title="2.6.2.&nbsp;Recommended Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="recommended_configurations"></a>2.6.2.&nbsp;Recommended Configurations</h3></div></div></div><div class="section" title="2.6.2.1.&nbsp;ZooKeeper Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="recommended_configurations.zk"></a>2.6.2.1.&nbsp;ZooKeeper Configuration</h4></div></div></div><div class="section" title="2.6.2.1.1.&nbsp;zookeeper.session.timeout"><div class="titlepage"><div><div><h5 class="title"><a name="sect.zookeeper.session.timeout"></a>2.6.2.1.1.&nbsp;<code class="varname">zookeeper.session.timeout</code></h5></div></div></div><p>The default timeout is three minutes (specified in milliseconds). This means that if
            a server crashes, it will be three minutes before the Master notices the crash and
            starts recovery. You might like to tune the timeout down to a minute or even less so the
            Master notices failures the sooner. Before changing this value, be sure you have your
            JVM garbage collection configuration under control otherwise, a long garbage collection
            that lasts beyond the ZooKeeper session timeout will take out your RegionServer (You
            might be fine with this -- you probably want recovery to start on the server if a
            RegionServer has been in GC for a long period of time).</p><p>To change this configuration, edit <code class="filename">hbase-site.xml</code>, copy the
            changed file around the cluster and restart.</p><p>We set this value high to save our having to field noob questions up on the mailing
            lists asking why a RegionServer went down during a massive import. The usual cause is
            that their JVM is untuned and they are running into long GC pauses. Our thinking is that
            while users are getting familiar with HBase, we'd save them having to know all of its
            intricacies. Later when they've built some confidence, then they can play with
            configuration such as this. </p></div><div class="section" title="2.6.2.1.2.&nbsp;Number of ZooKeeper Instances"><div class="titlepage"><div><div><h5 class="title"><a name="zookeeper.instances"></a>2.6.2.1.2.&nbsp;Number of ZooKeeper Instances</h5></div></div></div><p>See <a class="xref" href="#zookeeper" title="Chapter&nbsp;20.&nbsp;ZooKeeper">Chapter&nbsp;20, <i>ZooKeeper</i></a>. </p></div></div><div class="section" title="2.6.2.2.&nbsp;HDFS Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="recommended.configurations.hdfs"></a>2.6.2.2.&nbsp;HDFS Configurations</h4></div></div></div><div class="section" title="2.6.2.2.1.&nbsp;dfs.datanode.failed.volumes.tolerated"><div class="titlepage"><div><div><h5 class="title"><a name="dfs.datanode.failed.volumes.tolerated"></a>2.6.2.2.1.&nbsp;dfs.datanode.failed.volumes.tolerated</h5></div></div></div><p>This is the "...number of volumes that are allowed to fail before a datanode stops
            offering service. By default any volume failure will cause a datanode to shutdown" from
            the <code class="filename">hdfs-default.xml</code> description. If you have &gt; three or four
            disks, you might want to set this to 1 or if you have many disks, two or more. </p></div></div><div class="section" title="2.6.2.3.&nbsp;hbase.regionserver.handler.count"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.handler.count-description"></a>2.6.2.3.&nbsp;<code class="varname">hbase.regionserver.handler.count</code></h4></div></div></div><p> This setting defines the number of threads that are kept open to answer incoming
          requests to user tables. The rule of thumb is to keep this number low when the payload per
          request approaches the MB (big puts, scans using a large cache) and high when the payload
          is small (gets, small puts, ICVs, deletes). The total size of the queries in progress is
          limited by the setting "hbase.ipc.server.max.callqueue.size". </p><p> It is safe to set that number to the maximum number of incoming clients if their
          payload is small, the typical example being a cluster that serves a website since puts
          aren't typically buffered and most of the operations are gets. </p><p> The reason why it is dangerous to keep this setting high is that the aggregate size
          of all the puts that are currently happening in a region server may impose too much
          pressure on its memory, or even trigger an OutOfMemoryError. A region server running on
          low memory will trigger its JVM's garbage collector to run more frequently up to a point
          where GC pauses become noticeable (the reason being that all the memory used to keep all
          the requests' payloads cannot be trashed, no matter how hard the garbage collector tries).
          After some time, the overall cluster throughput is affected since every request that hits
          that region server will take longer, which exacerbates the problem even more. </p><p>You can get a sense of whether you have too little or too many handlers by <a class="xref" href="#rpc.logging" title="15.2.2.1.&nbsp;Enabling RPC-level logging">Section&nbsp;15.2.2.1, &#8220;Enabling RPC-level logging&#8221;</a> on an individual RegionServer then tailing its logs (Queued
          requests consume memory). </p></div><div class="section" title="2.6.2.4.&nbsp;Configuration for large memory machines"><div class="titlepage"><div><div><h4 class="title"><a name="big_memory"></a>2.6.2.4.&nbsp;Configuration for large memory machines</h4></div></div></div><p> HBase ships with a reasonable, conservative configuration that will work on nearly
          all machine types that people might want to test with. If you have larger machines --
          HBase has 8G and larger heap -- you might the following configuration options helpful.
          TODO. </p></div><div class="section" title="2.6.2.5.&nbsp;Compression"><div class="titlepage"><div><div><h4 class="title"><a name="config.compression"></a>2.6.2.5.&nbsp;Compression</h4></div></div></div><p>You should consider enabling ColumnFamily compression. There are several options that
          are near-frictionless and in most all cases boost performance by reducing the size of
          StoreFiles and thus reducing I/O. </p><p>See <a class="xref" href="#compression" title="Appendix&nbsp;E.&nbsp;Compression and Data Block Encoding In HBase">Appendix&nbsp;E, <i>Compression and Data Block Encoding In
          HBase</i></a> for more information.</p></div><div class="section" title="2.6.2.6.&nbsp;Configuring the size and number of WAL files"><div class="titlepage"><div><div><h4 class="title"><a name="config.wals"></a>2.6.2.6.&nbsp;Configuring the size and number of WAL files</h4></div></div></div><p>HBase uses <a class="xref" href="#wal" title="9.6.5.&nbsp;Write Ahead Log (WAL)">Section&nbsp;9.6.5, &#8220;Write Ahead Log (WAL)&#8221;</a> to recover the memstore data that has not been flushed to disk in case
          of an RS failure. These WAL files should be configured to be slightly smaller than HDFS
          block (by default, HDFS block is 64Mb and WAL file is ~60Mb).</p><p>HBase also has a limit on number of WAL files, designed to ensure there's never too
          much data that needs to be replayed during recovery. This limit needs to be set according
          to memstore configuration, so that all the necessary data would fit. It is recommended to
          allocated enough WAL files to store at least that much data (when all memstores are close
          to full). For example, with 16Gb RS heap, default memstore settings (0.4), and default WAL
          file size (~60Mb), 16Gb*0.4/60, the starting point for WAL file count is ~109. However, as
          all memstores are not expected to be full all the time, less WAL files can be
          allocated.</p></div><div class="section" title="2.6.2.7.&nbsp;Managed Splitting"><div class="titlepage"><div><div><h4 class="title"><a name="disable.splitting"></a>2.6.2.7.&nbsp;Managed Splitting</h4></div></div></div><p>HBase generally handles splitting your regions, based upon the settings in your
            <code class="filename">hbase-default.xml</code> and <code class="filename">hbase-site.xml</code>
          configuration files. Important settings include
            <code class="varname">hbase.regionserver.region.split.policy</code>,
            <code class="varname">hbase.hregion.max.filesize</code>,
            <code class="varname">hbase.regionserver.regionSplitLimit</code>. A simplistic view of splitting
          is that when a region grows to <code class="varname">hbase.hregion.max.filesize</code>, it is split.
          For most use patterns, most of the time, you should use automatic splitting. See <a class="xref" href="#manual_region_splitting_decisions" title="9.7.5.&nbsp;Manual Region Splitting">Section&nbsp;9.7.5, &#8220;Manual Region Splitting&#8221;</a> for more information about manual region
          splitting.</p><p>Instead of allowing HBase to split your regions automatically, you can choose to
          manage the splitting yourself. This feature was added in HBase 0.90.0. Manually managing
          splits works if you know your keyspace well, otherwise let HBase figure where to split for you.
          Manual splitting can mitigate region creation and movement under load. It also makes it so
          region boundaries are known and invariant (if you disable region splitting). If you use manual
          splits, it is easier doing staggered, time-based major compactions spread out your network IO
          load.</p><p title="Disable Automatic Splitting"><b>Disable Automatic Splitting.&nbsp;</b>To disable automatic splitting, set <code class="varname">hbase.hregion.max.filesize</code> to
            a very large value, such as <code class="literal">100 GB</code> It is not recommended to set it to
            its absolute maximum value of <code class="literal">Long.MAX_VALUE</code>.</p><div class="note" title="Automatic Splitting Is Recommended" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Automatic Splitting Is Recommended</h3><p>If you disable automatic splits to diagnose a problem or during a period of fast
            data growth, it is recommended to re-enable them when your situation becomes more
            stable. The potential benefits of managing region splits yourself are not
            undisputed.</p></div><p title="Determine the Optimal Number of Pre-Split Regions"><b>Determine the Optimal Number of Pre-Split Regions.&nbsp;</b>The optimal number of pre-split regions depends on your application and environment.
            A good rule of thumb is to start with 10 pre-split regions per server and watch as data
            grows over time. It is better to err on the side of too few regions and perform rolling
            splits later. The optimal number of regions depends upon the largest StoreFile in your
            region. The size of the largest StoreFile will increase with time if the amount of data
            grows. The goal is for the largest region to be just large enough that the compaction
            selection algorithm only compacts it during a timed major compaction. Otherwise, the
            cluster can be prone to compaction storms where a large number of regions under
            compaction at the same time. It is important to understand that the data growth causes
            compaction storms, and not the manual split decision.</p><p>If the regions are split into too many large regions, you can increase the major
          compaction interval by configuring <code class="varname">HConstants.MAJOR_COMPACTION_PERIOD</code>.
          HBase 0.90 introduced <code class="classname">org.apache.hadoop.hbase.util.RegionSplitter</code>,
          which provides a network-IO-safe rolling split of all regions.</p></div><div class="section" title="2.6.2.8.&nbsp;Managed Compactions"><div class="titlepage"><div><div><h4 class="title"><a name="managed.compactions"></a>2.6.2.8.&nbsp;Managed Compactions</h4></div></div></div><p>By default, major compactions are scheduled to run once in a 7-day period. Prior to HBase 0.96.x, major
          compactions were scheduled to happen once per day by default.</p><p>If you need to control exactly when and how often major compaction runs, you can
          disable managed major compactions. See the entry for
            <code class="varname">hbase.hregion.majorcompaction</code> in the <a class="xref" href="#compaction.parameters" title="9.7.7.7.1.4.&nbsp;Parameters Used by Compaction Algorithm">Section&nbsp;9.7.7.7.1.4, &#8220;Parameters Used by Compaction Algorithm&#8221;</a> table for details.</p><div class="warning" title="Do Not Disable Major Compactions" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Do Not Disable Major Compactions</h3><p>Major compactions are absolutely necessary for StoreFile clean-up. Do not disable
            them altogether. You can run major compactions manually via the HBase shell or via the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact%28java.lang.String%29" target="_top">HBaseAdmin
              API</a>.</p></div><p>For more information about compactions and the compaction file selection process, see <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a></p></div><div class="section" title="2.6.2.9.&nbsp;Speculative Execution"><div class="titlepage"><div><div><h4 class="title"><a name="spec.ex"></a>2.6.2.9.&nbsp;Speculative Execution</h4></div></div></div><p>Speculative Execution of MapReduce tasks is on by default, and for HBase clusters it
          is generally advised to turn off Speculative Execution at a system-level unless you need
          it for a specific case, where it can be configured per-job. Set the properties
            <code class="varname">mapreduce.map.speculative</code> and
            <code class="varname">mapreduce.reduce.speculative</code> to false. </p></div></div><div class="section" title="2.6.3.&nbsp;Other Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="other_configuration"></a>2.6.3.&nbsp;Other Configurations</h3></div></div></div><div class="section" title="2.6.3.1.&nbsp;Balancer"><div class="titlepage"><div><div><h4 class="title"><a name="balancer_config"></a>2.6.3.1.&nbsp;Balancer</h4></div></div></div><p>The balancer is a periodic operation which is run on the master to redistribute regions on the cluster.  It is configured via
           <code class="varname">hbase.balancer.period</code> and defaults to 300000 (5 minutes). </p><p>See <a class="xref" href="#master.processes.loadbalancer" title="9.5.4.1.&nbsp;LoadBalancer">Section&nbsp;9.5.4.1, &#8220;LoadBalancer&#8221;</a> for more information on the LoadBalancer.
           </p></div><div class="section" title="2.6.3.2.&nbsp;Disabling Blockcache"><div class="titlepage"><div><div><h4 class="title"><a name="disabling.blockcache"></a>2.6.3.2.&nbsp;Disabling Blockcache</h4></div></div></div><p>Do not turn off block cache (You'd do it by setting <code class="varname">hbase.block.cache.size</code> to zero).
          Currently we do not do well if you do this because the regionserver will spend all its time loading hfile
          indices over and over again.  If your working set it such that block cache does you no good, at least
          size the block cache such that hfile indices will stay up in the cache (you can get a rough idea
          on the size you need by surveying regionserver UIs; you'll see index block size accounted near the
          top of the webpage).</p></div><div class="section" title="2.6.3.3.&nbsp;Nagle's or the small package problem"><div class="titlepage"><div><div><h4 class="title"><a name="nagles"></a>2.6.3.3.&nbsp;<a class="link" href="http://en.wikipedia.org/wiki/Nagle's_algorithm" target="_top">Nagle's</a> or the small package problem</h4></div></div></div><p>If a big 40ms or so occasional delay is seen in operations against HBase,
      try the Nagles' setting.  For example, see the user mailing list thread,
      <a class="link" href="http://search-hadoop.com/m/pduLg2fydtE/Inconsistent+scan+performance+with+caching+set+&amp;subj=Re+Inconsistent+scan+performance+with+caching+set+to+1" target="_top">Inconsistent scan performance with caching set to 1</a>
      and the issue cited therein where setting notcpdelay improved scan speeds.  You might also
      see the graphs on the tail of <a class="link" href="https://issues.apache.org/jira/browse/HBASE-7008" target="_top">HBASE-7008 Set scanner caching to a better default</a>
      where our Lars Hofhansl tries various data sizes w/ Nagle's on and off measuring the effect.</p></div><div class="section" title="2.6.3.4.&nbsp;Better Mean Time to Recover (MTTR)"><div class="titlepage"><div><div><h4 class="title"><a name="mttr"></a>2.6.3.4.&nbsp;Better Mean Time to Recover (MTTR)</h4></div></div></div><p>This section is about configurations that will make servers come back faster after a fail.
          See the Deveraj Das an Nicolas Liochon blog post
          <a class="link" href="http://hortonworks.com/blog/introduction-to-hbase-mean-time-to-recover-mttr/" target="_top">Introduction to HBase Mean Time to Recover (MTTR)</a>
          for a brief introduction.</p><p>The issue <a class="link" href="https://issues.apache.org/jira/browse/HBASE-8389" target="_top">HBASE-8354 forces Namenode into loop with lease recovery requests</a>
          is messy but has a bunch of good discussion toward the end on low timeouts and how to effect faster recovery including citation of fixes
          added to HDFS.  Read the Varun Sharma comments.  The below suggested configurations are Varun's suggestions distilled and tested.  Make sure you are
          running on a late-version HDFS so you have the fixes he refers too and himself adds to HDFS that help HBase MTTR
          (e.g. HDFS-3703, HDFS-3712, and HDFS-4791 -- hadoop 2 for sure has them and late hadoop 1 has some).
          Set the following in the RegionServer.</p><pre class="programlisting">
&lt;property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.lease.recovery.dfs.timeout&lt;/name&gt;
    &lt;value&gt;23000&lt;/value&gt;
    &lt;description&gt;How much time we allow elapse between calls to recover lease.
    Should be larger than the dfs timeout.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.client.socket-timeout&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;Down the DFS timeout from 60 to 10 seconds.&lt;/description&gt;
&lt;/property&gt;
</pre><p>And on the namenode/datanode side, set the following to enable 'staleness' introduced
          in HDFS-3703, HDFS-3912. </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;dfs.client.socket-timeout&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;Down the DFS timeout from 60 to 10 seconds.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.datanode.socket.write.timeout&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;Down the DFS timeout from 8 * 60 to 10 seconds.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;ipc.client.connect.timeout&lt;/name&gt;
    &lt;value&gt;3000&lt;/value&gt;
    &lt;description&gt;Down from 60 seconds to 3.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;ipc.client.connect.max.retries.on.timeouts&lt;/name&gt;
    &lt;value&gt;2&lt;/value&gt;
    &lt;description&gt;Down from 45 seconds to 3 (2 == 3 retries).&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.namenode.avoid.read.stale.datanode&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;Enable stale state in hdfs&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.namenode.stale.datanode.interval&lt;/name&gt;
    &lt;value&gt;20000&lt;/value&gt;
    &lt;description&gt;Down from default 30 seconds&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.namenode.avoid.write.stale.datanode&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;Enable stale state in hdfs&lt;/description&gt;
&lt;/property&gt;
</pre></div><div class="section" title="2.6.3.5.&nbsp;JMX"><div class="titlepage"><div><div><h4 class="title"><a name="JMX_config"></a>2.6.3.5.&nbsp;JMX</h4></div></div></div><p>JMX(Java Management Extensions) provides built-in instrumentation that enables you
          to monitor and manage the Java VM. To enable monitoring and management from remote
          systems, you need to set system property com.sun.management.jmxremote.port(the port
          number through which you want to enable JMX RMI connections) when you start the Java VM.
          See <a class="link" href="http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html" target="_top">
          official document</a> for more information. Historically, besides above port mentioned,
          JMX opens 2 additional random TCP listening ports, which could lead to port conflict
          problem.(See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10289" target="_top">HBASE-10289</a>
          for details)
        </p><p>As an alternative, You can use the coprocessor-based JMX implementation provided
          by HBase. To enable it in 0.99 or above, add below property in
          <code class="filename">hbase-site.xml</code>:
        </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.JMXListener&lt;/value&gt;
&lt;/property&gt;
</pre><p>
          NOTE: DO NOT set com.sun.management.jmxremote.port for Java VM at the same time.
        </p><p>Currently it supports Master and RegionServer Java VM. The reason why you only
          configure coprocessor for 'regionserver' is that, starting from HBase 0.99,
          a Master IS also a RegionServer. (See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10569" target="_top">HBASE-10569</a>
          for more information.)
          By default, the JMX listens on TCP port 10102, you can further configure the port
          using below properties:

        </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;regionserver.rmi.registry.port&lt;/name&gt;
    &lt;value&gt;61130&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;regionserver.rmi.connector.port&lt;/name&gt;
    &lt;value&gt;61140&lt;/value&gt;
&lt;/property&gt;
</pre><p>
          The registry port can be shared with connector port in most cases, so you only
          need to configure regionserver.rmi.registry.port. However if you want to use SSL
          communication, the 2 ports must be configured to different values.
        </p><p>By default the password authentication and SSL communication is disabled.
          To enable password authentication, you need to update <code class="filename">hbase-env.sh</code>
          like below:
      </p><pre class="screen">
export HBASE_JMX_BASE="-Dcom.sun.management.jmxremote.authenticate=true                  \
                       -Dcom.sun.management.jmxremote.password.file=your_password_file   \
                       -Dcom.sun.management.jmxremote.access.file=your_access_file"

export HBASE_MASTER_OPTS="$HBASE_MASTER_OPTS $HBASE_JMX_BASE "
export HBASE_REGIONSERVER_OPTS="$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE "
      </pre><p>
          See example password/access file under $JRE_HOME/lib/management.
        </p><p>To enable SSL communication with password authentication, follow below steps:
      </p><pre class="screen">
#1. generate a key pair, stored in myKeyStore
keytool -genkey -alias jconsole -keystore myKeyStore

#2. export it to file jconsole.cert
keytool -export -alias jconsole -keystore myKeyStore -file jconsole.cert

#3. copy jconsole.cert to jconsole client machine, import it to jconsoleKeyStore
keytool -import -alias jconsole -keystore jconsoleKeyStore -file jconsole.cert
      </pre><p>
          And then update <code class="filename">hbase-env.sh</code> like below:
      </p><pre class="screen">
export HBASE_JMX_BASE="-Dcom.sun.management.jmxremote.ssl=true                         \
                       -Djavax.net.ssl.keyStore=/home/tianq/myKeyStore                 \
                       -Djavax.net.ssl.keyStorePassword=your_password_in_step_1       \
                       -Dcom.sun.management.jmxremote.authenticate=true                \
                       -Dcom.sun.management.jmxremote.password.file=your_password file \
                       -Dcom.sun.management.jmxremote.access.file=your_access_file"

export HBASE_MASTER_OPTS="$HBASE_MASTER_OPTS $HBASE_JMX_BASE "
export HBASE_REGIONSERVER_OPTS="$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE "
      </pre><p>

          Finally start jconsole on client using the key store:
      </p><pre class="screen">
jconsole -J-Djavax.net.ssl.trustStore=/home/tianq/jconsoleKeyStore
      </pre><p>
        </p><p>NOTE: for HBase 0.98, To enable the HBase JMX implementation on Master, you also
          need to add below property in <code class="filename">hbase-site.xml</code>:
        </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.JMXListener&lt;/value&gt;
&lt;/property&gt;
</pre><p>
          The corresponding properties for port configuration are master.rmi.registry.port
          (by default 10101) and master.rmi.connector.port(by default the same as registry.port)
        </p></div></div></div><div class="section" title="2.7.&nbsp;Dynamic Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dyn_config"></a>2.7.&nbsp;Dynamic Configuration</h2></div><div><h3 class="subtitle">Changing Configuration Without Restarting Servers</h3></div></div></div><p>Since HBase 1.0.0, it is possible to change a subset of the configuration without
      requiring a server restart. In the hbase shell, there are new operators,
      <span class="command"><strong>update_config</strong></span> and <span class="command"><strong>update_all_config</strong></span> that
      will prompt a server or all servers to reload configuration.</p><p>Only a subset of all configurations can currently be changed in the running server.
      Here is an incomplete list:
      <span class="property">hbase.regionserver.thread.compaction.large</span>,
      <span class="property">hbase.regionserver.thread.compaction.small</span>,
      <span class="property">hbase.regionserver.thread.split</span>,
      <span class="property">hbase.regionserver.thread.merge</span>, as well as compaction
      policy and configurations and adjustment to offpeak hours.
      For the full list consult the patch attached to 
      <a class="link" href="https://issues.apache.org/jira/browse/HBASE-12147" target="_top">HBASE-12147 Porting Online Config Change from 89-fb</a>.
    </p></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Upgrading"><div class="titlepage"><div><div><h2 class="title"><a name="upgrading"></a>Chapter&nbsp;3.&nbsp;Upgrading</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#hbase.versioning">3.1. HBase version numbers</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.development.series">3.1.1. Odd/Even Versioning or "Development"" Series Releases</a></span></dt><dt><span class="section"><a href="#hbase.binary.compatibility">3.1.2. Binary Compatibility</a></span></dt><dt><span class="section"><a href="#hbase.rolling.upgrade">3.1.3. <em class="firstterm">Rolling Upgrades</em></a></span></dt></dl></dd><dt><span class="section"><a href="#upgrade1.0">3.2. Upgrading from 0.98.x to 1.0.x</a></span></dt><dd><dl><dt><span class="section"><a href="#upgrade1.0.changes">3.2.1. Changes of Note!</a></span></dt><dt><span class="section"><a href="#upgrade1.0.rolling.upgrade">3.2.2. Rolling upgrade from 0.98.x to HBase 1.0.0</a></span></dt><dt><span class="section"><a href="#upgrade1.0.from.0.94">3.2.3. Upgrading to 1.0 from 0.94</a></span></dt></dl></dd><dt><span class="section"><a href="#upgrade0.98">3.3. Upgrading from 0.96.x to 0.98.x</a></span></dt><dt><span class="section"><a href="#d2875e4700">3.4. Upgrading from 0.94.x to 0.98.x</a></span></dt><dt><span class="section"><a href="#upgrade0.96">3.5. Upgrading from 0.94.x to 0.96.x</a></span></dt><dd><dl><dt><span class="section"><a href="#executing.the.0.96.upgrade">3.5.1. Executing the 0.96 Upgrade</a></span></dt></dl></dd><dt><span class="section"><a href="#upgrade0.94">3.6. Upgrading from 0.92.x to 0.94.x</a></span></dt><dt><span class="section"><a href="#upgrade0.92">3.7. Upgrading from 0.90.x to 0.92.x</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e4912">3.7.1. You can&#8217;t go back! </a></span></dt><dt><span class="section"><a href="#d2875e4926">3.7.2. MSLAB is ON by default </a></span></dt><dt><span class="section"><a href="#dls">3.7.3. Distributed Log Splitting is on by default </a></span></dt><dt><span class="section"><a href="#d2875e4959">3.7.4. Memory accounting is different now </a></span></dt><dt><span class="section"><a href="#d2875e4968">3.7.5. On the Hadoop version to use </a></span></dt><dt><span class="section"><a href="#d2875e4980">3.7.6. HBase 0.92.0 ships with ZooKeeper 3.4.2 </a></span></dt><dt><span class="section"><a href="#d2875e4985">3.7.7. Online alter is off by default </a></span></dt><dt><span class="section"><a href="#d2875e4992">3.7.8. WebUI </a></span></dt><dt><span class="section"><a href="#d2875e4997">3.7.9. Security tarball </a></span></dt><dt><span class="section"><a href="#d2875e5002">3.7.10. Changes in HBase replication </a></span></dt><dt><span class="section"><a href="#d2875e5007">3.7.11. RegionServer now aborts if OOME </a></span></dt><dt><span class="section"><a href="#d2875e5012">3.7.12. HFile V2 and the &#8220;Bigger, Fewer&#8221; Tendency </a></span></dt></dl></dd><dt><span class="section"><a href="#upgrade0.90">3.8. Upgrading to HBase 0.90.x from 0.20.x or 0.89.x</a></span></dt></dl></div><p>You cannot skip major versions upgrading. If you are upgrading from version 0.90.x to
        0.94.x, you must first go from 0.90.x to 0.92.x and then go from 0.92.x to 0.94.x.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It may be possible to skip across versions -- for example go from 0.92.2 straight to
            0.98.0 just following the 0.96.x upgrade instructions -- but we have not tried it so
            cannot say whether it works or not.</p></div><p> Review <a class="xref" href="#configuration" title="Chapter&nbsp;2.&nbsp;Apache HBase Configuration">Chapter&nbsp;2, <i>Apache HBase Configuration</i></a>, in particular the section on Hadoop version. </p><div class="section" title="3.1.&nbsp;HBase version numbers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.versioning"></a>3.1.&nbsp;HBase version numbers</h2></div></div></div><p>HBase has not walked a straight line where version numbers are concerned. Since we
            came up out of hadoop itself, we originally tracked hadoop versioning. Later we left
            hadoop versioning behind because we were moving at a different rate to that of our
            parent. If you are into the arcane, checkout our old wiki page on <a class="link" href="http://wiki.apache.org/hadoop/Hbase/HBaseVersions" target="_top">HBase
                Versioning</a> which tries to connect the HBase version dots.</p><div class="section" title="3.1.1.&nbsp;Odd/Even Versioning or &#34;Development&#34;&#34; Series Releases"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.development.series"></a>3.1.1.&nbsp;Odd/Even Versioning or "Development"" Series Releases</h3></div></div></div><p>Ahead of big releases, we have been putting up preview versions to start the
                feedback cycle turning-over earlier. These "Development" Series releases, always
                odd-numbered, come with no guarantees, not even regards being able to upgrade
                between two sequential releases (we reserve the right to break compatibility across
                "Development" Series releases). Needless to say, these releases are not for
                production deploys. They are a preview of what is coming in the hope that interested
                parties will take the release for a test drive and flag us early if we there are
                issues we've missed ahead of our rolling a production-worthy release. </p><p>Our first "Development" Series was the 0.89 set that came out ahead of HBase
                0.90.0. HBase 0.95 is another "Development" Series that portends HBase 0.96.0.
            </p></div><div class="section" title="3.1.2.&nbsp;Binary Compatibility"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.binary.compatibility"></a>3.1.2.&nbsp;Binary Compatibility</h3></div></div></div><p>When we say two HBase versions are compatible, we mean that the versions are wire
                and binary compatible. Compatible HBase versions means that clients can talk to
                compatible but differently versioned servers. It means too that you can just swap
                out the jars of one version and replace them with the jars of another, compatible
                version and all will just work. Unless otherwise specified, HBase point versions are
                binary compatible. You can safely do rolling upgrades between binary compatible
                versions; i.e. across point versions: e.g. from 0.94.5 to 0.94.6. See <a class="link" href="http://search-hadoop.com/m/bOOvwHGW981/Does+compatibility+between+versions+also+mean+binary+compatibility%253F&amp;subj=Re+Does+compatibility+between+versions+also+mean+binary+compatibility+" target="_top">Does
                            compatibility between versions also mean binary compatibility?</a>
                        discussion on the hbaes dev mailing list. </p></div><div class="section" title="3.1.3.&nbsp;Rolling Upgrades"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.rolling.upgrade"></a>3.1.3.&nbsp;<em class="firstterm">Rolling Upgrades</em></h3></div></div></div><p>A rolling upgrade is the process by which you update the servers
            in your cluster a server at a time. You can rolling upgrade across HBase versions
            if they are binary or wire compatible.
            See <span style="color: red">&lt;xlnk&gt;&lt;/xlnk&gt;</span> for more on what this means.
            Coarsely, a rolling upgrade is a graceful stop each server,
            update the software, and then restart.  You do this for each server in the cluster.
            Usually you upgrade the Master first and then the regionservers.
            See <span style="color: red">&lt;xlink&gt;&lt;/xlink&gt;</span> for tools that can help use the rolling upgrade process.
          </p><p>For example, in the below, hbase was symlinked to the actual hbase install.
            On upgrade, before running a rolling restart over the cluser, we changed the symlink
            to point at the new HBase software version and then ran 
            </p><pre class="programlisting">$ HADOOP_HOME=~/hadoop-2.6.0-CRC-SNAPSHOT ~/hbase/bin/rolling-restart.sh --config ~/conf_hbase</pre><p>
            The rolling-restart script will first gracefully stop and restart the master, and then
            each of the regionservers in turn. Because the symlink was changed, on restart the
            server will come up using the new hbase version.  Check logs for errors as the
            rolling upgrade proceeds.
          </p><div class="section" title="3.1.3.1.&nbsp;Rolling Upgrade between versions that are Binary/Wire compatibile"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.rolling.restart"></a>3.1.3.1.&nbsp;Rolling Upgrade between versions that are Binary/Wire compatibile</h4></div></div></div><p>Unless otherwise specified, HBase point versions are binary compatible. You can do
              a <span style="color: red">&lt;xlink&gt;&lt;/xlink&gt;</span> between hbase point versions.
                For example, you can go to 0.94.6 from 0.94.5 by doing a rolling upgrade
                across the cluster replacing the 0.94.5 binary with a 0.94.6 binary.</p><p>In the minor version-particular sections below, we call out where the versions
                are wire/protocol compatible and in this case, it is also possible to do a
                <span style="color: red">&lt;xlink&gt;&lt;/xlink&gt;</span>. For example, in
            <span style="color: red">&lt;xlink&gt;&lt;/xlink&gt;</span>, we
              state that it is possible to do a rolling upgrade between hbase-0.98.x and hbase-1.0.0.</p></div></div></div><div class="section" title="3.2.&nbsp;Upgrading from 0.98.x to 1.0.x"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgrade1.0"></a>3.2.&nbsp;Upgrading from 0.98.x to 1.0.x</h2></div></div></div><p>In this section we first note the significant changes that come in with 1.0.0 HBase and then
          we go over the upgrade process.  Be sure to read the significant changes section with care
          so you avoid surprises.
        </p><div class="section" title="3.2.1.&nbsp;Changes of Note!"><div class="titlepage"><div><div><h3 class="title"><a name="upgrade1.0.changes"></a>3.2.1.&nbsp;Changes of Note!</h3></div></div></div><p>In here we list important changes that are in 1.0.0 since 0.98.x., changes you should
            be aware that will go into effect once you upgrade.</p><div class="section" title="3.2.1.1.&nbsp;ZooKeeper 3.4 is required in HBase 1.0.0"><div class="titlepage"><div><div><h4 class="title"><a name="zookeeper.3.4"></a>3.2.1.1.&nbsp;ZooKeeper 3.4 is required in HBase 1.0.0</h4></div></div></div><p>See <a class="xref" href="#zookeeper.requirements" title="2.1.2.&nbsp;ZooKeeper Requirements">Section&nbsp;2.1.2, &#8220;ZooKeeper Requirements&#8221;</a>.</p></div><div class="section" title="3.2.1.2.&nbsp;HBase Default Ports Changed"><div class="titlepage"><div><div><h4 class="title"><a name="default.ports.changed"></a>3.2.1.2.&nbsp;HBase Default Ports Changed</h4></div></div></div><p>The ports used by HBase changed.  The used to be in the 600XX range.  In
                hbase-1.0.0 they have been moved up out of the ephemeral port range and are
                160XX instead (Master web UI was 60010 and is now 16030; the RegionServer
                web UI was 60030 and is now 16030, etc). If you want to keep the old port
                locations, copy the port setting configs from <code class="filename">hbase-default.xml</code>
                into <code class="filename">hbase-site.xml</code>, change them back to the old values
                from hbase-0.98.x era, and ensure you've distributed your configurations before
              you restart.</p></div><div class="section" title="3.2.1.3.&nbsp;hbase.bucketcache.percentage.in.combinedcache configuration has been REMOVED"><div class="titlepage"><div><div><h4 class="title"><a name="upgrade1.0.hbase.bucketcache.percentage.in.combinedcache"></a>3.2.1.3.&nbsp;hbase.bucketcache.percentage.in.combinedcache configuration has been REMOVED</h4></div></div></div><p>You may have made use of this configuration if you are using BucketCache.
                    If NOT using BucketCache, this change does not effect you.
                    Its removal means that your L1 LruBlockCache is now sized
                    using <code class="varname">hfile.block.cache.size</code> -- i.e. the way you
                    would size the onheap L1 LruBlockCache if you were NOT doing
                    BucketCache -- and the BucketCache size is not whatever the
                    setting for hbase.bucketcache.size is.  You may need to adjust
                    configs to get the LruBlockCache and BucketCache sizes set to
                    what they were in 0.98.x and previous.  If you did not set this
                    config., its default value was 0.9.  If you do nothing, your
                    BucketCache will increase in size by 10%.  Your L1 LruBlockCache will
                    become <code class="varname">hfile.block.cache.size</code> times your java
                    heap size (hfile.block.cache.size is a float between 0.0 and 1.0).
                    To read more, see
                    <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11520" target="_top">HBASE-11520 Simplify offheap cache config by removing the confusing "hbase.bucketcache.percentage.in.combinedcache"</a>.
                </p></div><div class="section" title="3.2.1.4.&nbsp;If you have your own customer filters...."><div class="titlepage"><div><div><h4 class="title"><a name="hbase-12068"></a>3.2.1.4.&nbsp;If you have your own customer filters....</h4></div></div></div><p>See the release notes on the issue <a class="link" href="https://issues.apache.org/jira/browse/HBASE-12068" target="_top">HBASE-12068 [Branch-1] Avoid need to always do KeyValueUtil#ensureKeyValue for Filter transformCell</a>;
              be sure to follow the recommendations therein.
            </p></div></div><div class="section" title="3.2.2.&nbsp;Rolling upgrade from 0.98.x to HBase 1.0.0"><div class="titlepage"><div><div><h3 class="title"><a name="upgrade1.0.rolling.upgrade"></a>3.2.2.&nbsp;Rolling upgrade from 0.98.x to HBase 1.0.0</h3></div></div></div><div class="note" title="From 0.96.x to 1.0.0" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">From 0.96.x to 1.0.0</h3><p>You cannot do a <span style="color: red">&lt;xlink&gt;&lt;/xlink&gt;</span> from 0.96.x to 1.0.0 without
              first doing a rolling upgrade to 0.98.x. See comment in
              <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11164?focusedCommentId=14182330&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14182330" target="_top">HBASE-11164 Document and test rolling updates from 0.98 -&gt; 1.0</a> for the why.
              Also because hbase-1.0.0 enables hfilev3 by default,
              <a class="link" href="https://issues.apache.org/jira/browse/HBASE-9801" target="_top">HBASE-9801 Change the default HFile version to V3</a>,
              and support for hfilev3 only arrives in 0.98, this is another reason you cannot rolling upgrade from hbase-0.96.x;
              if the rolling upgrade stalls, the 0.96.x servers cannot open files written by the servers running the newer hbase-1.0.0
              hfilev3 writing servers.
            </p></div><p>There are no known issues running a <span style="color: red">&lt;xlink&gt;&lt;/xlink&gt;</span> from hbase-0.98.x to hbase-1.0.0.
          
          </p></div><div class="section" title="3.2.3.&nbsp;Upgrading to 1.0 from 0.94"><div class="titlepage"><div><div><h3 class="title"><a name="upgrade1.0.from.0.94"></a>3.2.3.&nbsp;Upgrading to 1.0 from 0.94</h3></div></div></div><p>You cannot rolling upgrade from 0.94.x to 1.x.x.  You must stop your cluster,
            install the 1.x.x software, run the migration described at <a class="xref" href="#executing.the.0.96.upgrade" title="3.5.1.&nbsp;Executing the 0.96 Upgrade">Section&nbsp;3.5.1, &#8220;Executing the 0.96 Upgrade&#8221;</a>
            (substituting 1.x.x. wherever we make mention of 0.96.x in the section below),
            and then restart.  Be sure to upgrade your zookeeper if it is a version less than the required 3.4.x.
          </p></div></div><div class="section" title="3.3.&nbsp;Upgrading from 0.96.x to 0.98.x"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgrade0.98"></a>3.3.&nbsp;Upgrading from 0.96.x to 0.98.x</h2></div></div></div><p>A rolling upgrade from 0.96.x to 0.98.x works. The two versions are not binary
            compatible.</p><p>Additional steps are required to take advantage of some of the new features of 0.98.x,
            including cell visibility labels, cell ACLs, and transparent server side encryption. See
            the <a class="xref" href="#security" title="Chapter&nbsp;8.&nbsp;Secure Apache HBase">Chapter&nbsp;8, <i>Secure Apache HBase</i></a> chapter of this guide for more information. Significant
            performance improvements include a change to the write ahead log threading model that
            provides higher transaction throughput under high load, reverse scanners, MapReduce over
            snapshot files, and striped compaction.</p><p>Clients and servers can run with 0.98.x and 0.96.x versions. However, applications may
            need to be recompiled due to changes in the Java API.</p></div><div class="section" title="3.4.&nbsp;Upgrading from 0.94.x to 0.98.x"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e4700"></a>3.4.&nbsp;Upgrading from 0.94.x to 0.98.x</h2></div></div></div><p> A rolling upgrade from 0.94.x directly to 0.98.x does not work. The upgrade path
            follows the same procedures as <a class="xref" href="#upgrade0.96" title="3.5.&nbsp;Upgrading from 0.94.x to 0.96.x">Section&nbsp;3.5, &#8220;Upgrading from 0.94.x to 0.96.x&#8221;</a>. Additional steps are required to use some of the new
            features of 0.98.x. See <a class="xref" href="#upgrade0.98" title="3.3.&nbsp;Upgrading from 0.96.x to 0.98.x">Section&nbsp;3.3, &#8220;Upgrading from 0.96.x to 0.98.x&#8221;</a> for an abbreviated list of these features. </p></div><div class="section" title="3.5.&nbsp;Upgrading from 0.94.x to 0.96.x"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgrade0.96"></a>3.5.&nbsp;Upgrading from 0.94.x to 0.96.x</h2></div><div><h3 class="subtitle">The "Singularity"</h3></div></div></div><div class="note" title="HBase 0.96.x was EOL'd, September 1st, 2014" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">HBase 0.96.x was EOL'd, September 1st, 2014</h3><p>
            Do not deploy 0.96.x  Deploy a 0.98.x at least.
            See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11642" target="_top">EOL 0.96</a>.
        </p></div><p>You will have to stop your old 0.94.x cluster completely to upgrade. If you are
            replicating between clusters, both clusters will have to go down to upgrade. Make sure
            it is a clean shutdown. The less WAL files around, the faster the upgrade will run (the
            upgrade will split any log files it finds in the filesystem as part of the upgrade
            process). All clients must be upgraded to 0.96 too. </p><p>The API has changed. You will need to recompile your code against 0.96 and you may
            need to adjust applications to go against new APIs (TODO: List of changes). </p><div class="section" title="3.5.1.&nbsp;Executing the 0.96 Upgrade"><div class="titlepage"><div><div><h3 class="title"><a name="executing.the.0.96.upgrade"></a>3.5.1.&nbsp;Executing the 0.96 Upgrade</h3></div></div></div><div class="note" title="HDFS and ZooKeeper must be up!" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">HDFS and ZooKeeper must be up!</h3><p>HDFS and ZooKeeper should be up and running during the upgrade process.</p></div><p>hbase-0.96.0 comes with an upgrade script. Run
                </p><pre class="programlisting">$ bin/hbase upgrade</pre><p> to see its usage. The script
                has two main modes: -check, and -execute. </p><div class="section" title="3.5.1.1.&nbsp;check"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e4739"></a>3.5.1.1.&nbsp;check</h4></div></div></div><p>The <span class="emphasis"><em>check</em></span> step is run against a running 0.94 cluster. Run
                    it from a downloaded 0.96.x binary. The <span class="emphasis"><em>check</em></span> step is
                    looking for the presence of <code class="filename">HFileV1</code> files. These are
                    unsupported in hbase-0.96.0. To purge them -- have them rewritten as HFileV2 --
                    you must run a compaction. </p><p>The <span class="emphasis"><em>check</em></span> step prints stats at the end of its run (grep
                    for &#8220;Result:&#8221; in the log) printing absolute path of the tables it scanned, any
                    HFileV1 files found, the regions containing said files (the regions we need to
                    major compact to purge the HFileV1s), and any corrupted files if any found. A
                    corrupt file is unreadable, and so is undefined (neither HFileV1 nor HFileV2). </p><p>To run the check step, run <span class="command"><strong>$ bin/hbase upgrade -check</strong></span>. Here
                    is sample output:</p><pre class="screen">
Tables Processed:
hdfs://localhost:41020/myHBase/.META.
hdfs://localhost:41020/myHBase/usertable
hdfs://localhost:41020/myHBase/TestTable
hdfs://localhost:41020/myHBase/t

Count of HFileV1: 2
HFileV1:
hdfs://localhost:41020/myHBase/usertable    /fa02dac1f38d03577bd0f7e666f12812/family/249450144068442524
hdfs://localhost:41020/myHBase/usertable    /ecdd3eaee2d2fcf8184ac025555bb2af/family/249450144068442512

Count of corrupted files: 1
Corrupted Files:
hdfs://localhost:41020/myHBase/usertable/fa02dac1f38d03577bd0f7e666f12812/family/1
Count of Regions with HFileV1: 2
Regions to Major Compact:
hdfs://localhost:41020/myHBase/usertable/fa02dac1f38d03577bd0f7e666f12812
hdfs://localhost:41020/myHBase/usertable/ecdd3eaee2d2fcf8184ac025555bb2af

There are some HFileV1, or corrupt files (files with incorrect major version)
                </pre><p>In the above sample output, there are two HFileV1 in two regions, and one
                    corrupt file. Corrupt files should probably be removed. The regions that have
                    HFileV1s need to be major compacted. To major compact, start up the hbase shell
                    and review how to compact an individual region. After the major compaction is
                    done, rerun the check step and the HFileV1s shoudl be gone, replaced by HFileV2
                    instances. </p><p>By default, the check step scans the hbase root directory (defined as
                    hbase.rootdir in the configuration). To scan a specific directory only, pass the
                        <span class="emphasis"><em>-dir</em></span> option.</p><pre class="screen">$ bin/hbase upgrade -check -dir /myHBase/testTable</pre><p>The above command would detect HFileV1s in the /myHBase/testTable directory. </p><p> Once the check step reports all the HFileV1 files have been rewritten, it is
                    safe to proceed with the upgrade. </p></div><div class="section" title="3.5.1.2.&nbsp;execute"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e4778"></a>3.5.1.2.&nbsp;execute</h4></div></div></div><p>After the check step shows the cluster is free of HFileV1, it is safe to
                    proceed with the upgrade. Next is the <span class="emphasis"><em>execute</em></span> step. You
                    must <span class="emphasis"><em>SHUTDOWN YOUR 0.94.x CLUSTER</em></span> before you can run the
                        <span class="emphasis"><em>execute</em></span> step. The execute step will not run if it
                    detects running HBase masters or regionservers. </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HDFS and ZooKeeper should be up and running during the upgrade
                            process. If zookeeper is managed by HBase, then you can start zookeeper
                            so it is available to the upgrade by running <span class="command"><strong>$
                                ./hbase/bin/hbase-daemon.sh start zookeeper</strong></span>
                        </p></div><p>
                </p><p> The <span class="emphasis"><em>execute</em></span> upgrade step is made of three substeps. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Namespaces: HBase 0.96.0 has support for namespaces. The upgrade needs
                            to reorder directories in the filesystem for namespaces to work.</p></li><li class="listitem"><p>ZNodes: All znodes are purged so that new ones can be written in their
                            place using a new protobuf'ed format and a few are migrated in place:
                            e.g. replication and table state znodes</p></li><li class="listitem"><p>WAL Log Splitting: If the 0.94.x cluster shutdown was not clean, we'll
                            split WAL logs as part of migration before we startup on 0.96.0. This
                            WAL splitting runs slower than the native distributed WAL splitting
                            because it is all inside the single upgrade process (so try and get a
                            clean shutdown of the 0.94.0 cluster if you can). </p></li></ul></div><p> To run the <span class="emphasis"><em>execute</em></span> step, make sure that first you have
                    copied hbase-0.96.0 binaries everywhere under servers and under clients. Make
                    sure the 0.94.0 cluster is down. Then do as follows:</p><pre class="screen">$ bin/hbase upgrade -execute</pre><p>Here is some sample output.</p><pre class="programlisting">
Starting Namespace upgrade
Created version file at hdfs://localhost:41020/myHBase with version=7
Migrating table testTable to hdfs://localhost:41020/myHBase/.data/default/testTable
&#8230;..
Created version file at hdfs://localhost:41020/myHBase with version=8
Successfully completed NameSpace upgrade.
Starting Znode upgrade
&#8230;.
Successfully completed Znode upgrade

Starting Log splitting
&#8230;
Successfully completed Log splitting
         </pre><p> If the output from the execute step looks good, stop the zookeeper instance
                    you started to do the upgrade:
                    </p><pre class="programlisting">$ ./hbase/bin/hbase-daemon.sh stop zookeeper</pre><p>
                    Now start up hbase-0.96.0. </p></div><div class="section" title="3.5.1.3.&nbsp;Troubleshooting"><div class="titlepage"><div><div><h4 class="title"><a name="s096.migration.troubleshooting"></a>3.5.1.3.&nbsp;Troubleshooting</h4></div></div></div><div class="section" title="3.5.1.3.1.&nbsp;Old Client connecting to 0.96 cluster"><div class="titlepage"><div><div><h5 class="title"><a name="s096.migration.troubleshooting.old.client"></a>3.5.1.3.1.&nbsp;Old Client connecting to 0.96 cluster</h5></div></div></div><p>It will fail with an exception like the below. Upgrade.</p><pre class="screen">17:22:15  Exception in thread "main" java.lang.IllegalArgumentException: Not a host:port pair: PBUF
17:22:15  *
17:22:15   api-compat-8.ent.cloudera.com &#65533;&#65533;  &#65533;&#65533;&#65533;(
17:22:15    at org.apache.hadoop.hbase.util.Addressing.parseHostname(Addressing.java:60)
17:22:15    at org.apache.hadoop.hbase.ServerName.&amp;init&gt;(ServerName.java:101)
17:22:15    at org.apache.hadoop.hbase.ServerName.parseVersionedServerName(ServerName.java:283)
17:22:15    at org.apache.hadoop.hbase.MasterAddressTracker.bytesToServerName(MasterAddressTracker.java:77)
17:22:15    at org.apache.hadoop.hbase.MasterAddressTracker.getMasterAddress(MasterAddressTracker.java:61)
17:22:15    at org.apache.hadoop.hbase.client.HConnectionManager$HConnectionImplementation.getMaster(HConnectionManager.java:703)
17:22:15    at org.apache.hadoop.hbase.client.HBaseAdmin.&amp;init&gt;(HBaseAdmin.java:126)
17:22:15    at Client_4_3_0.setup(Client_4_3_0.java:716)
17:22:15    at Client_4_3_0.main(Client_4_3_0.java:63)</pre></div></div><div class="section" title="3.5.1.4.&nbsp;Upgrading META to use Protocol Buffers (Protobuf)"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e4840"></a>3.5.1.4.&nbsp;Upgrading <code class="code">META</code> to use Protocol Buffers (Protobuf)</h4></div></div></div><p>When you upgrade from versions prior to 0.96, <code class="code">META</code> needs to be
                    converted to use protocol buffers. This is controlled by the configuration
                    option <code class="option">hbase.MetaMigrationConvertingToPB</code>, which is set to
                        <code class="literal">true</code> by default. Therefore, by default, no action is
                    required on your part.</p><p>The migration is a one-time event. However, every time your cluster starts,
                        <code class="code">META</code> is scanned to ensure that it does not need to be
                    converted. If you have a very large number of regions, this scan can take a long
                    time. Starting in 0.98.5, you can set
                        <code class="option">hbase.MetaMigrationConvertingToPB</code> to
                        <code class="literal">false</code> in <code class="filename">hbase-site.xml</code>, to disable
                    this start-up scan. This should be considered an expert-level setting.</p></div></div></div><div class="section" title="3.6.&nbsp;Upgrading from 0.92.x to 0.94.x"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgrade0.94"></a>3.6.&nbsp;Upgrading from 0.92.x to 0.94.x</h2></div></div></div><p>We used to think that 0.92 and 0.94 were interface compatible and that you can do a
            rolling upgrade between these versions but then we figured that <a class="link" href="https://issues.apache.org/jira/browse/HBASE-5357" target="_top">HBASE-5357 Use builder
                pattern in HColumnDescriptor</a> changed method signatures so rather than return
            void they instead return HColumnDescriptor. This will throw</p><pre class="screen">java.lang.NoSuchMethodError: org.apache.hadoop.hbase.HColumnDescriptor.setMaxVersions(I)V</pre><p>.... so 0.92 and 0.94 are NOT compatible. You cannot do a rolling upgrade between them.</p></div><div class="section" title="3.7.&nbsp;Upgrading from 0.90.x to 0.92.x"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgrade0.92"></a>3.7.&nbsp;Upgrading from 0.90.x to 0.92.x</h2></div><div><h3 class="subtitle">Upgrade Guide</h3></div></div></div><p>You will find that 0.92.0 runs a little differently to 0.90.x releases. Here are a few
            things to watch out for upgrading from 0.90.x to 0.92.0. </p><div class="note" title="tl;dr" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">tl;dr</h3><p> If you've not patience, here are the important things to know upgrading. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Once you upgrade, you can&#8217;t go back.</p></li><li class="listitem"><p> MSLAB is on by default. Watch that heap usage if you have a lot of
                            regions.</p></li><li class="listitem"><p> Distributed Log Splitting is on by default. It should make region server
                            failover faster. </p></li><li class="listitem"><p> There&#8217;s a separate tarball for security. </p></li><li class="listitem"><p> If -XX:MaxDirectMemorySize is set in your hbase-env.sh, it&#8217;s going to
                            enable the experimental off-heap cache (You may not want this). </p></li></ol></div><p>
            </p></div><div class="section" title="3.7.1.&nbsp;You can&#8217;t go back!"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4912"></a>3.7.1.&nbsp;You can&#8217;t go back! </h3></div></div></div><p>To move to 0.92.0, all you need to do is shutdown your cluster, replace your hbase
                0.90.x with hbase 0.92.0 binaries (be sure you clear out all 0.90.x instances) and
                restart (You cannot do a rolling restart from 0.90.x to 0.92.x -- you must restart).
                On startup, the <code class="varname">.META.</code> table content is rewritten removing the
                table schema from the <code class="varname">info:regioninfo</code> column. Also, any flushes
                done post first startup will write out data in the new 0.92.0 file format, <a class="link" href="http://hbase.apache.org/book.html#hfilev2" target="_top">HFile V2</a>. This
                means you cannot go back to 0.90.x once you&#8217;ve started HBase 0.92.0 over your HBase
                data directory. </p></div><div class="section" title="3.7.2.&nbsp;MSLAB is ON by default"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4926"></a>3.7.2.&nbsp;MSLAB is ON by default </h3></div></div></div><p>In 0.92.0, the <a class="link" href="http://hbase.apache.org/book.html#hbase.hregion.memstore.mslab.enabled" target="_top">hbase.hregion.memstore.mslab.enabled</a>
                flag is set to true (See <a class="xref" href="#mslab">Section&nbsp;14.3.1.1, &#8220;Long GC pauses&#8221;</a>). In 0.90.x it was <code class="constant">false</code>. When it is
                enabled, memstores will step allocate memory in MSLAB 2MB chunks even if the
                memstore has zero or just a few small elements. This is fine usually but if you had
                lots of regions per regionserver in a 0.90.x cluster (and MSLAB was off), you may
                find yourself OOME'ing on upgrade because the <code class="code">thousands of regions * number of
                    column families * 2MB MSLAB (at a minimum)</code> puts your heap over the top.
                Set <code class="varname">hbase.hregion.memstore.mslab.enabled</code> to
                    <code class="constant">false</code> or set the MSLAB size down from 2MB by setting
                    <code class="varname">hbase.hregion.memstore.mslab.chunksize</code> to something less.
            </p></div><div class="section" title="3.7.3.&nbsp;Distributed Log Splitting is on by default"><div class="titlepage"><div><div><h3 class="title"><a name="dls"></a>3.7.3.&nbsp;Distributed Log Splitting is on by default </h3></div></div></div><p>Previous, WAL logs on crash were split by the Master alone. In 0.92.0, log
                splitting is done by the cluster (See See &#8220;HBASE-1364 [performance] Distributed
                splitting of regionserver commit logs&#8221; or see the blog post
                <a class="link" href="http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/" target="_top">Apache HBase Log Splitting</a>).
                This should cut down significantly on the
                amount of time it takes splitting logs and getting regions back online again.
            </p></div><div class="section" title="3.7.4.&nbsp;Memory accounting is different now"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4959"></a>3.7.4.&nbsp;Memory accounting is different now </h3></div></div></div><p>In 0.92.0, <a class="xref" href="#hfilev2" title="H.2.&nbsp; HBase file format with inline blocks (version 2)">Section&nbsp;H.2, &#8220;
      HBase file format with inline blocks (version 2)
      &#8221;</a> indices and bloom filters take up residence in the same LRU
                used caching blocks that come from the filesystem. In 0.90.x, the HFile v1 indices
                lived outside of the LRU so they took up space even if the index was on a &#8216;cold&#8217;
                file, one that wasn&#8217;t being actively used. With the indices now in the LRU, you may
                find you have less space for block caching. Adjust your block cache accordingly. See
                the <a class="xref" href="#block.cache" title="9.6.4.&nbsp;Block Cache">Section&nbsp;9.6.4, &#8220;Block Cache&#8221;</a> for more detail. The block size default size has been
                changed in 0.92.0 from 0.2 (20 percent of heap) to 0.25. </p></div><div class="section" title="3.7.5.&nbsp;On the Hadoop version to use"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4968"></a>3.7.5.&nbsp;On the Hadoop version to use </h3></div></div></div><p>Run 0.92.0 on Hadoop 1.0.x (or CDH3u3 when it ships). The performance benefits are
                worth making the move. Otherwise, our Hadoop prescription is as it has been; you
                need an Hadoop that supports a working sync. See <a class="xref" href="#hadoop" title="2.1.1.&nbsp;Hadoop">Section&nbsp;2.1.1, &#8220;Hadoop&#8221;</a>. </p><p>If running on Hadoop 1.0.x (or CDH3u3), enable local read. See <a class="link" href="http://files.meetup.com/1350427/hug_ebay_jdcryans.pdf" target="_top">Practical
                    Caching</a> presentation for ruminations on the performance benefits &#8216;going
                local&#8217; (and for how to enable local reads). </p></div><div class="section" title="3.7.6.&nbsp;HBase 0.92.0 ships with ZooKeeper 3.4.2"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4980"></a>3.7.6.&nbsp;HBase 0.92.0 ships with ZooKeeper 3.4.2 </h3></div></div></div><p>If you can, upgrade your zookeeper. If you can&#8217;t, 3.4.2 clients should work
                against 3.3.X ensembles (HBase makes use of 3.4.2 API). </p></div><div class="section" title="3.7.7.&nbsp;Online alter is off by default"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4985"></a>3.7.7.&nbsp;Online alter is off by default </h3></div></div></div><p>In 0.92.0, we&#8217;ve added an experimental online schema alter facility (See <a class="xref" href="#hbase.online.schema.update.enable" title="hbase.online.schema.update.enable"><code class="varname">hbase.online.schema.update.enable</code></a>). Its off by default. Enable it
                at your own risk. Online alter and splitting tables do not play well together so be
                sure your cluster quiescent using this feature (for now). </p></div><div class="section" title="3.7.8.&nbsp;WebUI"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4992"></a>3.7.8.&nbsp;WebUI </h3></div></div></div><p>The webui has had a few additions made in 0.92.0. It now shows a list of the
                regions currently transitioning, recent compactions/flushes, and a process list of
                running processes (usually empty if all is well and requests are being handled
                promptly). Other additions including requests by region, a debugging servlet dump,
                etc. </p></div><div class="section" title="3.7.9.&nbsp;Security tarball"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e4997"></a>3.7.9.&nbsp;Security tarball </h3></div></div></div><p>We now ship with two tarballs; secure and insecure HBase. Documentation on how to
                setup a secure HBase is on the way. </p></div><div class="section" title="3.7.10.&nbsp;Changes in HBase replication"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5002"></a>3.7.10.&nbsp;Changes in HBase replication </h3></div></div></div><p>0.92.0 adds two new features: multi-slave and multi-master replication. The way to
                enable this is the same as adding a new peer, so in order to have multi-master you
                would just run add_peer for each cluster that acts as a master to the other slave
                clusters. Collisions are handled at the timestamp level which may or may not be what
                you want, this needs to be evaluated on a per use case basis. Replication is still
                experimental in 0.92 and is disabled by default, run it at your own risk. </p></div><div class="section" title="3.7.11.&nbsp;RegionServer now aborts if OOME"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5007"></a>3.7.11.&nbsp;RegionServer now aborts if OOME </h3></div></div></div><p>If an OOME, we now have the JVM kill -9 the regionserver process so it goes down
                fast. Previous, a RegionServer might stick around after incurring an OOME limping
                along in some wounded state. To disable this facility, and recommend you leave it in
                place, you&#8217;d need to edit the bin/hbase file. Look for the addition of the
                -XX:OnOutOfMemoryError="kill -9 %p" arguments (See [HBASE-4769] - &#8216;Abort
                RegionServer Immediately on OOME&#8217;) </p></div><div class="section" title="3.7.12.&nbsp;HFile V2 and the &#8220;Bigger, Fewer&#8221; Tendency"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5012"></a>3.7.12.&nbsp;HFile V2 and the &#8220;Bigger, Fewer&#8221; Tendency </h3></div></div></div><p>0.92.0 stores data in a new format, <a class="xref" href="#hfilev2" title="H.2.&nbsp; HBase file format with inline blocks (version 2)">Section&nbsp;H.2, &#8220;
      HBase file format with inline blocks (version 2)
      &#8221;</a>. As HBase runs, it will move all your data from HFile v1 to
                HFile v2 format. This auto-migration will run in the background as flushes and
                compactions run. HFile V2 allows HBase run with larger regions/files. In fact, we
                encourage that all HBasers going forward tend toward Facebook axiom #1, run with
                larger, fewer regions. If you have lots of regions now -- more than 100s per host --
                you should look into setting your region size up after you move to 0.92.0 (In
                0.92.0, default size is now 1G, up from 256M), and then running online merge tool
                (See &#8220;HBASE-1621 merge tool should work on online cluster, but disabled table&#8221;).
            </p></div></div><div class="section" title="3.8.&nbsp;Upgrading to HBase 0.90.x from 0.20.x or 0.89.x"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="upgrade0.90"></a>3.8.&nbsp;Upgrading to HBase 0.90.x from 0.20.x or 0.89.x</h2></div></div></div><p>This version of 0.90.x HBase can be started on data written by HBase 0.20.x or HBase
            0.89.x. There is no need of a migration step. HBase 0.89.x and 0.90.x does write out the
            name of region directories differently -- it names them with a md5 hash of the region
            name rather than a jenkins hash -- so this means that once started, there is no going
            back to HBase 0.20.x. </p><p> Be sure to remove the <code class="filename">hbase-default.xml</code> from your
                <code class="filename">conf</code> directory on upgrade. A 0.20.x version of this file will
            have sub-optimal configurations for 0.90.x HBase. The
                <code class="filename">hbase-default.xml</code> file is now bundled into the HBase jar and
            read from there. If you would like to review the content of this file, see it in the src
            tree at <code class="filename">src/main/resources/hbase-default.xml</code> or see <a class="xref" href="#hbase_default_configurations" title="HBase Default Configuration">HBase Default Configuration</a>. </p><p> Finally, if upgrading from 0.20.x, check your <code class="varname">.META.</code> schema in the
            shell. In the past we would recommend that users run with a 16kb
                <code class="varname">MEMSTORE_FLUSHSIZE</code>. Run <code class="code">hbase&gt; scan '-ROOT-'</code> in the
            shell. This will output the current <code class="varname">.META.</code> schema. Check
                <code class="varname">MEMSTORE_FLUSHSIZE</code> size. Is it 16kb (16384)? If so, you will need
            to change this (The 'normal'/default value is 64MB (67108864)). Run the script
                <code class="filename">bin/set_meta_memstore_size.rb</code>. This will make the necessary
            edit to your <code class="varname">.META.</code> schema. Failure to run this change will make for
            a slow cluster. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3499" target="_top">HBASE-3499
                        Users upgrading to 0.90.0 need to have their .META. table updated with the
                        right MEMSTORE_SIZE</a>
                </p></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;The Apache HBase Shell"><div class="titlepage"><div><div><h2 class="title"><a name="shell"></a>Chapter&nbsp;4.&nbsp;The Apache HBase Shell</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#scripting">4.1. Scripting with Ruby</a></span></dt><dt><span class="section"><a href="#d2875e5109">4.2. Running the Shell in Non-Interactive Mode</a></span></dt><dt><span class="section"><a href="#hbase.shell.noninteractive">4.3. HBase Shell in OS Scripts</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e5180">4.3.1. Checking for Success or Failure In Scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#d2875e5185">4.4. Read HBase Shell Commands from a Command File</a></span></dt><dt><span class="section"><a href="#d2875e5214">4.5. Passing VM Options to the Shell</a></span></dt><dt><span class="section"><a href="#shell_tricks">4.6. Shell Tricks</a></span></dt><dd><dl><dt><span class="section"><a href="#table_variables">4.6.1. Table variables</a></span></dt><dt><span class="section"><a href="#d2875e5257">4.6.2. <code class="filename">irbrc</code></a></span></dt><dt><span class="section"><a href="#d2875e5276">4.6.3. LOG data to timestamp</a></span></dt><dt><span class="section"><a href="#d2875e5292">4.6.4. Debug</a></span></dt><dt><span class="section"><a href="#d2875e5312">4.6.5. Commands</a></span></dt></dl></dd></dl></div><p> The Apache HBase Shell is <a class="link" href="http://jruby.org" target="_top">(J)Ruby</a>'s IRB with some HBase particular commands
        added. Anything you can do in IRB, you should be able to do in the HBase Shell.</p><p>To run the HBase shell, do as follows:</p><pre class="programlisting">$ ./bin/hbase shell</pre><p>Type <span class="command"><strong>help</strong></span> and then <span class="command"><strong>&lt;RETURN&gt;</strong></span> to see a listing
        of shell commands and options. Browse at least the paragraphs at the end of the help
        emission for the gist of how variables and command arguments are entered into the HBase
        shell; in particular note how table names, rows, and columns, etc., must be quoted.</p><p>See <a class="xref" href="#shell_exercises" title="Procedure&nbsp;1.2.&nbsp;Use HBase For the First Time">Procedure&nbsp;1.2, &#8220;Use HBase For the First Time&#8221;</a> for example basic shell operation. </p><p>Here is a nicely formatted listing of <a class="link" href="http://learnhbase.wordpress.com/2013/03/02/hbase-shell-commands/" target="_top">all shell
            commands</a> by Rajeshbabu Chintaguntla. </p><div class="section" title="4.1.&nbsp;Scripting with Ruby"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scripting"></a>4.1.&nbsp;Scripting with Ruby</h2></div></div></div><p>For examples scripting Apache HBase, look in the HBase <code class="filename">bin</code>
            directory. Look at the files that end in <code class="filename">*.rb</code>. To run one of these
            files, do as follows:</p><pre class="programlisting">$ ./bin/hbase org.jruby.Main PATH_TO_SCRIPT</pre></div><div class="section" title="4.2.&nbsp;Running the Shell in Non-Interactive Mode"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e5109"></a>4.2.&nbsp;Running the Shell in Non-Interactive Mode</h2></div></div></div><p>A new non-interactive mode has been added to the HBase Shell (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-11658" target="_top">HBASE-11658)</a>.
            Non-interactive mode captures the exit status (success or failure) of HBase Shell
            commands and passes that status back to the command interpreter. If you use the normal
            interactive mode, the HBase Shell will only ever return its own exit status, which will
            nearly always be <code class="literal">0</code> for success.</p><p>To invoke non-interactive mode, pass the <code class="option">-n</code> or
                <code class="option">--non-interactive</code> option to HBase Shell.</p></div><div class="section" title="4.3.&nbsp;HBase Shell in OS Scripts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.shell.noninteractive"></a>4.3.&nbsp;HBase Shell in OS Scripts</h2></div></div></div><p>You can use the HBase shell from within operating system script interpreters like the
            Bash shell which is the default command interpreter for most Linux and UNIX
            distributions. The following guidelines use Bash syntax, but could be adjusted to work
            with C-style shells such as csh or tcsh, and could probably be modified to work with the
            Microsoft Windows script interpreter as well. Submissions are welcome.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Spawning HBase Shell commands in this way is slow, so keep that in mind when you
                are deciding when combining HBase operations with the operating system command line
                is appropriate.</p></div><div class="example"><a name="d2875e5136"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Passing Commands to the HBase Shell</b></p><div class="example-contents"><p>You can pass commands to the HBase Shell in non-interactive mode (see <a class="xref" href="#">???</a>) using the <span class="command"><strong>echo</strong></span>
                command and the <code class="literal">|</code> (pipe) operator. Be sure to escape characters
                in the HBase commands which would otherwise be interpreted by the shell. Some
                debug-level output has been truncated from the example below.</p><pre class="screen">$ <strong class="userinput"><code>echo "describe 'test1'" | ./hbase shell -n</code></strong>
                <code class="computeroutput">
Version 0.98.3-hadoop2, rd5e65a9144e315bb0a964e7730871af32f5018d5, Sat May 31 19:56:09 PDT 2014

describe 'test1'

DESCRIPTION                                          ENABLED
 'test1', {NAME =&gt; 'cf', DATA_BLOCK_ENCODING =&gt; 'NON true
 E', BLOOMFILTER =&gt; 'ROW', REPLICATION_SCOPE =&gt; '0',
  VERSIONS =&gt; '1', COMPRESSION =&gt; 'NONE', MIN_VERSIO
 NS =&gt; '0', TTL =&gt; 'FOREVER', KEEP_DELETED_CELLS =&gt;
 'false', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'false'
 , BLOCKCACHE =&gt; 'true'}
1 row(s) in 3.2410 seconds    
                </code>            
            </pre><p>To suppress all output, echo it to <code class="filename">/dev/null:</code></p><pre class="screen">$ <strong class="userinput"><code>echo "describe 'test'" | ./hbase shell -n &gt; /dev/null 2&gt;&amp;1</code></strong></pre></div></div><br class="example-break"><div class="example"><a name="d2875e5165"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Checking the Result of a Scripted Command</b></p><div class="example-contents"><p>Since scripts are not designed to be run interactively, you need a way to check
                whether your command failed or succeeded. The HBase shell uses the standard
                convention of returning a value of <code class="literal">0</code> for successful commands, and
                some non-zero value for failed commands. Bash stores a command's return value in a
                special environment variable called <code class="varname">$?</code>. Because that variable is
                overwritten each time the shell runs any command, you should store the result in a
                different, script-defined variable.</p><p>This is a naive script that shows one way to store the return value and make a
                decision based upon it.</p><pre class="programlisting">
#!/bin/bash

echo "describe 'test'" | ./hbase shell -n &gt; /dev/null 2&gt;&amp;1
status=$?
echo "The status was " $status  
if ($status == 0); then
    echo "The command succeeded"
else
    echo "The command may have failed."
fi
return $status
            </pre></div></div><br class="example-break"><div class="section" title="4.3.1.&nbsp;Checking for Success or Failure In Scripts"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5180"></a>4.3.1.&nbsp;Checking for Success or Failure In Scripts</h3></div></div></div><p>Getting an exit code of 0 means that the command you scripted definitely
                succeeded. However, getting a non-zero exit code does not necessarily mean the
                command failed. The command could have succeeded, but the client lost connectivity,
                or some other event obscured its success. This is because RPC commands are
                stateless. The only way to be sure of the status of an operation is to check. For
                instance, if your script creates a table, but returns a non-zero exit value, you
                should check whether the table was actually created before trying again to create
                it.</p></div></div><div class="section" title="4.4.&nbsp;Read HBase Shell Commands from a Command File"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e5185"></a>4.4.&nbsp;Read HBase Shell Commands from a Command File</h2></div></div></div><p>You can enter HBase Shell commands into a text file, one command per line, and pass
            that file to the HBase Shell.</p><div class="example"><a name="d2875e5190"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Example Command File</b></p><div class="example-contents"><pre class="screen">
create 'test', 'cf'
list 'test'
put 'test', 'row1', 'cf:a', 'value1'
put 'test', 'row2', 'cf:b', 'value2'
put 'test', 'row3', 'cf:c', 'value3'
put 'test', 'row4', 'cf:d', 'value4'
scan 'test'
get 'test', 'row1'
disable 'test'
enable 'test'
            </pre></div></div><br class="example-break"><div class="example"><a name="d2875e5195"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Directing HBase Shell to Execute the Commands</b></p><div class="example-contents"><p>Pass the path to the command file as the only argument to the <span class="command"><strong>hbase
                    shell</strong></span> command. Each command is executed and its output is shown. If
                you do not include the <span class="command"><strong>exit</strong></span> command in your script, you are
                returned to the HBase shell prompt. There is no way to programmatically check each
                individual command for success or failure. Also, though you see the output for each
                command, the commands themselves are not echoed to the screen so it can be difficult
                to line up the command with its output.</p><pre class="screen">
$ <strong class="userinput"><code>./hbase shell ./sample_commands.txt</code></strong>
<code class="computeroutput">0 row(s) in 3.4170 seconds

TABLE
test
1 row(s) in 0.0590 seconds

0 row(s) in 0.1540 seconds

0 row(s) in 0.0080 seconds

0 row(s) in 0.0060 seconds

0 row(s) in 0.0060 seconds

ROW                   COLUMN+CELL
 row1                 column=cf:a, timestamp=1407130286968, value=value1
 row2                 column=cf:b, timestamp=1407130286997, value=value2
 row3                 column=cf:c, timestamp=1407130287007, value=value3
 row4                 column=cf:d, timestamp=1407130287015, value=value4
4 row(s) in 0.0420 seconds

COLUMN                CELL
 cf:a                 timestamp=1407130286968, value=value1
1 row(s) in 0.0110 seconds

0 row(s) in 1.5630 seconds

0 row(s) in 0.4360 seconds</code>                
            </pre></div></div><br class="example-break"></div><div class="section" title="4.5.&nbsp;Passing VM Options to the Shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e5214"></a>4.5.&nbsp;Passing VM Options to the Shell</h2></div></div></div><p>You can pass VM options to the HBase Shell using the <code class="code">HBASE_SHELL_OPTS</code>
            environment variable. You can set this in your environment, for instance by editing
                <code class="filename">~/.bashrc</code>, or set it as part of the command to launch HBase
            Shell. The following example sets several garbage-collection-related variables, just for
            the lifetime of the VM running the HBase Shell. The command should be run all on a
            single line, but is broken by the <code class="literal">\</code> character, for
            readability.</p><pre class="screen">
$ <strong class="userinput"><code>HBASE_SHELL_OPTS="-verbose:gc -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCDateStamps \ 
  -XX:+PrintGCDetails -Xloggc:$HBASE_HOME/logs/gc-hbase.log" ./bin/hbase shell</code></strong>            
        </pre></div><div class="section" title="4.6.&nbsp;Shell Tricks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shell_tricks"></a>4.6.&nbsp;Shell Tricks</h2></div></div></div><div class="section" title="4.6.1.&nbsp;Table variables"><div class="titlepage"><div><div><h3 class="title"><a name="table_variables"></a>4.6.1.&nbsp;Table variables</h3></div></div></div><p> HBase 0.95 adds shell commands that provide a jruby-style object-oriented
                references for tables. Previously all of the shell commands that act upon a table
                have a procedural style that always took the name of the table as an argument. HBase
                0.95 introduces the ability to assign a table to a jruby variable. The table
                reference can be used to perform data read write operations such as puts, scans, and
                gets well as admin functionality such as disabling, dropping, describing tables. </p><p> For example, previously you would always specify a table name:</p><pre class="screen">
hbase(main):000:0&gt; create &#8216;t&#8217;, &#8216;f&#8217;
0 row(s) in 1.0970 seconds
hbase(main):001:0&gt; put 't', 'rold', 'f', 'v'
0 row(s) in 0.0080 seconds

hbase(main):002:0&gt; scan 't' 
ROW                                COLUMN+CELL                                                                                      
 rold                              column=f:, timestamp=1378473207660, value=v                                                      
1 row(s) in 0.0130 seconds

hbase(main):003:0&gt; describe 't'
DESCRIPTION                                                                           ENABLED                                       
 't', {NAME =&gt; 'f', DATA_BLOCK_ENCODING =&gt; 'NONE', BLOOMFILTER =&gt; 'ROW', REPLICATION_ true                                          
 SCOPE =&gt; '0', VERSIONS =&gt; '1', COMPRESSION =&gt; 'NONE', MIN_VERSIONS =&gt; '0', TTL =&gt; '2                                               
 147483647', KEEP_DELETED_CELLS =&gt; 'false', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'false                                               
 ', BLOCKCACHE =&gt; 'true'}                                                                                 
1 row(s) in 1.4430 seconds

hbase(main):004:0&gt; disable 't'
0 row(s) in 14.8700 seconds

hbase(main):005:0&gt; drop 't'
0 row(s) in 23.1670 seconds

hbase(main):006:0&gt; 
	  </pre><p> Now you can assign the table to a variable and use the results in jruby shell
                code.</p><pre class="screen">
hbase(main):007 &gt; t = create 't', 'f'
0 row(s) in 1.0970 seconds

=&gt; Hbase::Table - t
hbase(main):008 &gt; t.put 'r', 'f', 'v'
0 row(s) in 0.0640 seconds
hbase(main):009 &gt; t.scan
ROW                           COLUMN+CELL                                                                        
 r                            column=f:, timestamp=1331865816290, value=v                                        
1 row(s) in 0.0110 seconds
hbase(main):010:0&gt; t.describe
DESCRIPTION                                                                           ENABLED                                       
 't', {NAME =&gt; 'f', DATA_BLOCK_ENCODING =&gt; 'NONE', BLOOMFILTER =&gt; 'ROW', REPLICATION_ true                                          
 SCOPE =&gt; '0', VERSIONS =&gt; '1', COMPRESSION =&gt; 'NONE', MIN_VERSIONS =&gt; '0', TTL =&gt; '2                                               
 147483647', KEEP_DELETED_CELLS =&gt; 'false', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'false                                               
 ', BLOCKCACHE =&gt; 'true'}                                                                                 
1 row(s) in 0.0210 seconds
hbase(main):038:0&gt; t.disable
0 row(s) in 6.2350 seconds
hbase(main):039:0&gt; t.drop
0 row(s) in 0.2340 seconds
	  </pre><p> If the table has already been created, you can assign a Table to a variable by
                using the get_table method:</p><pre class="screen">
hbase(main):011 &gt; create 't','f'
0 row(s) in 1.2500 seconds

=&gt; Hbase::Table - t
hbase(main):012:0&gt; tab = get_table 't'
0 row(s) in 0.0010 seconds

=&gt; Hbase::Table - t
hbase(main):013:0&gt; tab.put &#8216;r1&#8217; ,&#8217;f&#8217;, &#8216;v&#8217; 
0 row(s) in 0.0100 seconds
hbase(main):014:0&gt; tab.scan
ROW                                COLUMN+CELL                                                                                      
 r1                                column=f:, timestamp=1378473876949, value=v                                                      
1 row(s) in 0.0240 seconds
hbase(main):015:0&gt; 
	  </pre><p> The list functionality has also been extended so that it returns a list of table
                names as strings. You can then use jruby to script table operations based on these
                names. The list_snapshots command also acts similarly.</p><pre class="screen">
hbase(main):016 &gt; tables = list(&#8216;t.*&#8217;)
TABLE                                                                                                                               
t                                                                                                                                   
1 row(s) in 0.1040 seconds

=&gt; #&lt;#&lt;Class:0x7677ce29&gt;:0x21d377a4&gt;
hbase(main):017:0&gt; tables.map { |t| disable t ; drop  t}
0 row(s) in 2.2510 seconds

=&gt; [nil]
hbase(main):018:0&gt; 
            </pre></div><div class="section" title="4.6.2.&nbsp;irbrc"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5257"></a>4.6.2.&nbsp;<code class="filename">irbrc</code></h3></div></div></div><p>Create an <code class="filename">.irbrc</code> file for yourself in your home directory.
                Add customizations. A useful one is command history so commands are save across
                Shell invocations:</p><pre class="screen">
$ more .irbrc
require 'irb/ext/save-history'
IRB.conf[:SAVE_HISTORY] = 100
IRB.conf[:HISTORY_FILE] = "#{ENV['HOME']}/.irb-save-history"</pre><p>See the <span class="application">ruby</span> documentation of
                    <code class="filename">.irbrc</code> to learn about other possible configurations.
            </p></div><div class="section" title="4.6.3.&nbsp;LOG data to timestamp"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5276"></a>4.6.3.&nbsp;LOG data to timestamp</h3></div></div></div><p> To convert the date '08/08/16 20:56:29' from an hbase log into a timestamp,
                do:</p><pre class="screen">
hbase(main):021:0&gt; import java.text.SimpleDateFormat
hbase(main):022:0&gt; import java.text.ParsePosition
hbase(main):023:0&gt; SimpleDateFormat.new("yy/MM/dd HH:mm:ss").parse("08/08/16 20:56:29", ParsePosition.new(0)).getTime() =&gt; 1218920189000</pre><p> To go the other direction:</p><pre class="screen">
hbase(main):021:0&gt; import java.util.Date
hbase(main):022:0&gt; Date.new(1218920189000).toString() =&gt; "Sat Aug 16 20:56:29 UTC 2008"</pre><p> To output in a format that is exactly like that of the HBase log format will take
                a little messing with <a class="link" href="http://download.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html" target="_top">SimpleDateFormat</a>.
            </p></div><div class="section" title="4.6.4.&nbsp;Debug"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5292"></a>4.6.4.&nbsp;Debug</h3></div></div></div><div class="section" title="4.6.4.1.&nbsp;Shell debug switch"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e5295"></a>4.6.4.1.&nbsp;Shell debug switch</h4></div></div></div><p>You can set a debug switch in the shell to see more output -- e.g. more of the
                    stack trace on exception -- when you run a command:</p><pre class="programlisting">hbase&gt; debug &lt;RETURN&gt;</pre></div><div class="section" title="4.6.4.2.&nbsp;DEBUG log level"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e5302"></a>4.6.4.2.&nbsp;DEBUG log level</h4></div></div></div><p>To enable DEBUG level logging in the shell, launch it with the
                        <span class="command"><strong>-d</strong></span> option.</p><pre class="programlisting">$ ./bin/hbase shell -d</pre></div></div><div class="section" title="4.6.5.&nbsp;Commands"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e5312"></a>4.6.5.&nbsp;Commands</h3></div></div></div><div class="section" title="4.6.5.1.&nbsp;count"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e5315"></a>4.6.5.1.&nbsp;count</h4></div></div></div><p>Count command returns the number of rows in a table. It's quite fast when
                    configured with the right CACHE
                    </p><pre class="programlisting">hbase&gt; count '&lt;tablename&gt;', CACHE =&gt; 1000</pre><p>
                    The above count fetches 1000 rows at a time. Set CACHE lower if your rows are
                    big. Default is to fetch one row at a time. </p></div></div></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Data Model"><div class="titlepage"><div><div><h2 class="title"><a name="datamodel"></a>Chapter&nbsp;5.&nbsp;Data Model</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#conceptual.view">5.1. Conceptual View</a></span></dt><dt><span class="section"><a href="#physical.view">5.2. Physical View</a></span></dt><dt><span class="section"><a href="#namespace">5.3. Namespace</a></span></dt><dd><dl><dt><span class="section"><a href="#namespace_creation">5.3.1. Namespace management</a></span></dt><dt><span class="section"><a href="#namespace_special">5.3.2. Predefined namespaces</a></span></dt></dl></dd><dt><span class="section"><a href="#table">5.4. Table</a></span></dt><dt><span class="section"><a href="#row">5.5. Row</a></span></dt><dt><span class="section"><a href="#columnfamily">5.6. Column Family</a></span></dt><dt><span class="section"><a href="#cells">5.7. Cells</a></span></dt><dt><span class="section"><a href="#data_model_operations">5.8. Data Model Operations</a></span></dt><dd><dl><dt><span class="section"><a href="#get">5.8.1. Get</a></span></dt><dt><span class="section"><a href="#put">5.8.2. Put</a></span></dt><dt><span class="section"><a href="#scan">5.8.3. Scans</a></span></dt><dt><span class="section"><a href="#delete">5.8.4. Delete</a></span></dt></dl></dd><dt><span class="section"><a href="#versions">5.9. Versions</a></span></dt><dd><dl><dt><span class="section"><a href="#specify.number.of.versions">5.9.1. Specifying the Number of Versions to Store</a></span></dt><dt><span class="section"><a href="#versions.ops">5.9.2. Versions and HBase Operations</a></span></dt><dt><span class="section"><a href="#d2875e6141">5.9.3. Current Limitations</a></span></dt></dl></dd><dt><span class="section"><a href="#dm.sort">5.10. Sort Order</a></span></dt><dt><span class="section"><a href="#dm.column.metadata">5.11. Column Metadata</a></span></dt><dt><span class="section"><a href="#joins">5.12. Joins</a></span></dt><dt><span class="section"><a href="#acid">5.13. ACID</a></span></dt></dl></div><p>In HBase, data is stored in tables, which have rows and columns. This is a terminology
      overlap with relational databases (RDBMSs), but this is not a helpful analogy. Instead, it can
    be helpful to think of an HBase table as a multi-dimensional map.</p><div class="variablelist" title="HBase Data Model Terminology"><p class="title"><b>HBase Data Model Terminology</b></p><dl><dt><span class="term">Table</span></dt><dd><p>An HBase table consists of multiple rows.</p></dd><dt><span class="term">Row</span></dt><dd><p>A row in HBase consists of a row key and one or more columns with values associated
            with them. Rows are sorted alphabetically by the row key as they are stored. For this
            reason, the design of the row key is very important. The goal is to store data in such a
            way that related rows are near each other. A common row key pattern is a website domain.
            If your row keys are domains, you should probably store them in reverse (org.apache.www,
            org.apache.mail, org.apache.jira). This way, all of the Apache domains are near each
            other in the table, rather than being spread out based on the first letter of the
            subdomain.</p></dd><dt><span class="term">Column</span></dt><dd><p>A column in HBase consists of a column family and a column qualifier, which are
            delimited by a <code class="literal">:</code> (colon) character.</p></dd><dt><span class="term">Column Family</span></dt><dd><p>Column families physically colocate a set of columns and their values, often for
            performance reasons. Each column family has a set of storage properties, such as whether
            its values should be cached in memory, how its data is compressed or its row keys are
            encoded, and others. Each row in a table has the same column
            families, though a given row might not store anything in a given column family.</p><p>Column families are specified when you create your table, and influence the way your
            data is stored in the underlying filesystem. Therefore, the column families should be
            considered carefully during schema design.</p></dd><dt><span class="term">Column Qualifier</span></dt><dd><p>A column qualifier is added to a column family to provide the index for a given
            piece of data. Given a column family <code class="literal">content</code>, a column qualifier
            might be <code class="literal">content:html</code>, and another might be
            <code class="literal">content:pdf</code>. Though column families are fixed at table creation,
            column qualifiers are mutable and may differ greatly between rows.</p></dd><dt><span class="term">Cell</span></dt><dd><p>A cell is a combination of row, column family, and column qualifier, and contains a
            value and a timestamp, which represents the value's version.</p><p>A cell's value is an uninterpreted array of bytes.</p></dd><dt><span class="term">Timestamp</span></dt><dd><p>A timestamp is written alongside each value, and is the identifier for a given
            version of a value. By default, the timestamp represents the time on the RegionServer
            when the data was written, but you can specify a different timestamp value when you put
            data into the cell.</p><div class="caution" title="Caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>Direct manipulation of timestamps is an advanced feature which is only exposed for
              special cases that are deeply integrated with HBase, and is discouraged in general.
              Encoding a timestamp at the application level is the preferred pattern.</p></div><p>You can specify the maximum number of versions of a value that HBase retains, per column
            family. When the maximum number of versions is reached, the oldest versions are 
            eventually deleted. By default, only the newest version is kept.</p></dd></dl></div><div class="section" title="5.1.&nbsp;Conceptual View"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="conceptual.view"></a>5.1.&nbsp;Conceptual View</h2></div></div></div><p>You can read a very understandable explanation of the HBase data model in the blog post <a class="link" href="http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable" target="_top">Understanding
          HBase and BigTable</a> by Jim R. Wilson. Another good explanation is available in the
        PDF <a class="link" href="http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf" target="_top">Introduction
          to Basic Schema Design</a> by Amandeep Khurana. It may help to read different
        perspectives to get a solid understanding of HBase schema design. The linked articles cover
        the same ground as the information in this section.</p><p> The following example is a slightly modified form of the one on page 2 of the <a class="link" href="http://research.google.com/archive/bigtable.html" target="_top">BigTable</a> paper. There
        is a table called <code class="varname">webtable</code> that contains two rows
        (<code class="literal">com.cnn.www</code>
          and <code class="literal">com.example.www</code>), three column families named
          <code class="varname">contents</code>, <code class="varname">anchor</code>, and <code class="varname">people</code>. In
          this example, for the first row (<code class="literal">com.cnn.www</code>), 
          <code class="varname">anchor</code> contains two columns (<code class="varname">anchor:cssnsi.com</code>,
          <code class="varname">anchor:my.look.ca</code>) and <code class="varname">contents</code> contains one column
          (<code class="varname">contents:html</code>). This example contains 5 versions of the row with the
        row key <code class="literal">com.cnn.www</code>, and one version of the row with the row key
        <code class="literal">com.example.www</code>. The <code class="varname">contents:html</code> column qualifier contains the entire
        HTML of a given website. Qualifiers of the <code class="varname">anchor</code> column family each
        contain the external site which links to the site represented by the row, along with the
        text it used in the anchor of its link. The <code class="varname">people</code> column family represents
        people associated with the site.
      </p><div class="note" title="Column Names" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Column Names</h3><p> By convention, a column name is made of its column family prefix and a
            <span class="emphasis"><em>qualifier</em></span>. For example, the column
            <span class="emphasis"><em>contents:html</em></span> is made up of the column family
            <code class="varname">contents</code> and the <code class="varname">html</code> qualifier. The colon
          character (<code class="literal">:</code>) delimits the column family from the column family
            <span class="emphasis"><em>qualifier</em></span>. </p></div><div class="table"><a name="d2875e5484"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Table <code class="varname">webtable</code></b></p><div class="table-contents"><table summary="Table webtable" border="1"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"><col align="left" class="c4"><col align="left" class="c5"></colgroup><thead><tr><th align="left">Row Key</th><th align="left">Time Stamp</th><th align="left">ColumnFamily <code class="varname">contents</code></th><th align="left">ColumnFamily <code class="varname">anchor</code></th><th align="left">ColumnFamily <code class="varname">people</code></th></tr></thead><tbody><tr><td align="left">"com.cnn.www"</td><td align="left">t9</td><td align="left">&nbsp;</td><td align="left"><code class="varname">anchor:cnnsi.com</code> = "CNN"</td><td align="left">&nbsp;</td></tr><tr><td align="left">"com.cnn.www"</td><td align="left">t8</td><td align="left">&nbsp;</td><td align="left"><code class="varname">anchor:my.look.ca</code> = "CNN.com"</td><td align="left">&nbsp;</td></tr><tr><td align="left">"com.cnn.www"</td><td align="left">t6</td><td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">"com.cnn.www"</td><td align="left">t5</td><td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">"com.cnn.www"</td><td align="left">t3</td><td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td><td align="left">&nbsp;</td><td align="left">&nbsp;</td></tr><tr><td align="left">"com.example.www"</td><td align="left">t5</td><td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td><td align="left">&nbsp;</td><td align="left">people:author = "John Doe"</td></tr></tbody></table></div></div><br class="table-break"><p>Cells in this table that appear to be empty do not take space, or in fact exist, in
        HBase. This is what makes HBase "sparse." A tabular view is not the only possible way to
        look at data in HBase, or even the most accurate. The following represents the same
        information as a multi-dimensional map. This is only a mock-up for illustrative
        purposes and may not be strictly accurate.</p><pre class="programlisting">
{
	"com.cnn.www": {
		contents: {
			t6: contents:html: "&lt;html&gt;..."
			t5: contents:html: "&lt;html&gt;..."
			t3: contents:html: "&lt;html&gt;..."
		}
		anchor: {
			t9: anchor:cnnsi.com = "CNN"
			t8: anchor:my.look.ca = "CNN.com"
		}
		people: {}
	}
	"com.example.www": {
		contents: {
			t5: contents:html: "&lt;html&gt;..."
		}
		anchor: {}
		people: {
			t5: people:author: "John Doe"
		}
	}
}        
        </pre></div><div class="section" title="5.2.&nbsp;Physical View"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="physical.view"></a>5.2.&nbsp;Physical View</h2></div></div></div><p> Although at a conceptual level tables may be viewed as a sparse set of rows, they are
        physically stored by column family. A new column qualifier (column_family:column_qualifier)
        can be added to an existing column family at any time.</p><div class="table"><a name="d2875e5590"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;ColumnFamily <code class="varname">anchor</code></b></p><div class="table-contents"><table summary="ColumnFamily anchor" border="1"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Row Key</th><th align="left">Time Stamp</th><th align="left">Column Family <code class="varname">anchor</code></th></tr></thead><tbody><tr><td align="left">"com.cnn.www"</td><td align="left">t9</td><td align="left"><code class="varname">anchor:cnnsi.com</code> = "CNN"</td></tr><tr><td align="left">"com.cnn.www"</td><td align="left">t8</td><td align="left"><code class="varname">anchor:my.look.ca</code> = "CNN.com"</td></tr></tbody></table></div></div><br class="table-break"><div class="table"><a name="d2875e5628"></a><p class="title"><b>Table&nbsp;5.3.&nbsp;ColumnFamily <code class="varname">contents</code></b></p><div class="table-contents"><table summary="ColumnFamily contents" border="1"><colgroup><col align="left" class="c1"><col align="left" class="c2"><col align="left" class="c3"></colgroup><thead><tr><th align="left">Row Key</th><th align="left">Time Stamp</th><th align="left">ColumnFamily "contents:"</th></tr></thead><tbody><tr><td align="left">"com.cnn.www"</td><td align="left">t6</td><td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td></tr><tr><td align="left">"com.cnn.www"</td><td align="left">t5</td><td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td></tr><tr><td align="left">"com.cnn.www"</td><td align="left">t3</td><td align="left"><code class="varname">contents:html</code> = "&lt;html&gt;..."</td></tr></tbody></table></div></div><br class="table-break"><p>The empty cells shown in the
        conceptual view are not stored at all.
        Thus a request for the value of the <code class="varname">contents:html</code> column at time stamp
          <code class="literal">t8</code> would return no value. Similarly, a request for an
          <code class="varname">anchor:my.look.ca</code> value at time stamp <code class="literal">t9</code> would
        return no value. However, if no timestamp is supplied, the most recent value for a
        particular column would be returned. Given multiple versions, the most recent is also the
        first one found,  since timestamps
        are stored in descending order. Thus a request for the values of all columns in the row
          <code class="varname">com.cnn.www</code> if no timestamp is specified would be: the value of
          <code class="varname">contents:html</code> from timestamp <code class="literal">t6</code>, the value of
          <code class="varname">anchor:cnnsi.com</code> from timestamp <code class="literal">t9</code>, the value of
          <code class="varname">anchor:my.look.ca</code> from timestamp <code class="literal">t8</code>. </p><p>For more information about the internals of how Apache HBase stores data, see <a class="xref" href="#regions.arch" title="9.7.&nbsp;Regions">Section&nbsp;9.7, &#8220;Regions&#8221;</a>. </p></div><div class="section" title="5.3.&nbsp;Namespace"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="namespace"></a>5.3.&nbsp;Namespace</h2></div></div></div><p> A namespace is a logical grouping of tables analogous to a database in relation
        database systems. This abstraction lays the groundwork for upcoming multi-tenancy related
        features: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Quota Management (HBASE-8410) - Restrict the amount of resources (ie regions,
              tables) a namespace can consume.</p></li><li class="listitem"><p>Namespace Security Administration (HBASE-9206) - provide another level of security
              administration for tenants.</p></li><li class="listitem"><p>Region server groups (HBASE-6721) - A namespace/table can be pinned onto a subset
              of regionservers thus guaranteeing a course level of isolation.</p></li></ul></div><p>
      </p><div class="section" title="5.3.1.&nbsp;Namespace management"><div class="titlepage"><div><div><h3 class="title"><a name="namespace_creation"></a>5.3.1.&nbsp;Namespace management</h3></div></div></div><p> A namespace can be created, removed or altered. Namespace membership is determined
          during table creation by specifying a fully-qualified table name of the form:</p><pre class="programlisting">&lt;table namespace&gt;:&lt;table qualifier&gt;</pre><div class="example"><a name="d2875e5735"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;Examples</b></p><div class="example-contents"><pre class="programlisting">
#Create a namespace
create_namespace 'my_ns'
            </pre><pre class="programlisting">
#create my_table in my_ns namespace
create 'my_ns:my_table', 'fam'
          </pre><pre class="programlisting">
#drop namespace
drop_namespace 'my_ns'
          </pre><pre class="programlisting">
#alter namespace
alter_namespace 'my_ns', {METHOD =&gt; 'set', 'PROPERTY_NAME' =&gt; 'PROPERTY_VALUE'}
        </pre></div></div><br class="example-break"></div><div class="section" title="5.3.2.&nbsp;Predefined namespaces"><div class="titlepage"><div><div><h3 class="title"><a name="namespace_special"></a>5.3.2.&nbsp;Predefined namespaces</h3></div></div></div><p> There are two predefined special namespaces: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>hbase - system namespace, used to contain hbase internal tables</p></li><li class="listitem"><p>default - tables with no explicit specified namespace will automatically fall into
              this namespace.</p></li></ul></div><div class="example"><a name="d2875e5758"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Examples</b></p><div class="example-contents"><pre class="programlisting">
#namespace=foo and table qualifier=bar
create 'foo:bar', 'fam'

#namespace=default and table qualifier=bar
create 'bar', 'fam'
</pre></div></div><br class="example-break"></div></div><div class="section" title="5.4.&nbsp;Table"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table"></a>5.4.&nbsp;Table</h2></div></div></div><p> Tables are declared up front at schema definition time. </p></div><div class="section" title="5.5.&nbsp;Row"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="row"></a>5.5.&nbsp;Row</h2></div></div></div><p>Row keys are uninterrpreted bytes. Rows are lexicographically sorted with the lowest
        order appearing first in a table. The empty byte array is used to denote both the start and
        end of a tables' namespace.</p></div><div class="section" title="5.6.&nbsp;Column Family"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="columnfamily"></a>5.6.&nbsp;Column Family<a class="indexterm" name="d2875e5776"></a></h2></div></div></div><p> Columns in Apache HBase are grouped into <span class="emphasis"><em>column families</em></span>. All
        column members of a column family have the same prefix. For example, the columns
          <span class="emphasis"><em>courses:history</em></span> and <span class="emphasis"><em>courses:math</em></span> are both
        members of the <span class="emphasis"><em>courses</em></span> column family. The colon character
          (<code class="literal">:</code>) delimits the column family from the <a class="indexterm" name="d2875e5796"></a>.
        The column family prefix must be composed of <span class="emphasis"><em>printable</em></span> characters. The
        qualifying tail, the column family <span class="emphasis"><em>qualifier</em></span>, can be made of any
        arbitrary bytes. Column families must be declared up front at schema definition time whereas
        columns do not need to be defined at schema time but can be conjured on the fly while the
        table is up an running.</p><p>Physically, all column family members are stored together on the filesystem. Because
        tunings and storage specifications are done at the column family level, it is advised that
        all column family members have the same general access pattern and size
        characteristics.</p></div><div class="section" title="5.7.&nbsp;Cells"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cells"></a>5.7.&nbsp;Cells<a class="indexterm" name="d2875e5813"></a></h2></div></div></div><p>A <span class="emphasis"><em>{row, column, version} </em></span>tuple exactly specifies a
          <code class="literal">cell</code> in HBase. Cell content is uninterrpreted bytes</p></div><div class="section" title="5.8.&nbsp;Data Model Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="data_model_operations"></a>5.8.&nbsp;Data Model Operations</h2></div></div></div><p>The four primary data model operations are Get, Put, Scan, and Delete. Operations are
        applied via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>
        instances. </p><div class="section" title="5.8.1.&nbsp;Get"><div class="titlepage"><div><div><h3 class="title"><a name="get"></a>5.8.1.&nbsp;Get</h3></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a>
          returns attributes for a specified row. Gets are executed via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#get%28org.apache.hadoop.hbase.client.Get%29" target="_top">
            HTable.get</a>. </p></div><div class="section" title="5.8.2.&nbsp;Put"><div class="titlepage"><div><div><h3 class="title"><a name="put"></a>5.8.2.&nbsp;Put</h3></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Put.html" target="_top">Put</a>
          either adds new rows to a table (if the key is new) or can update existing rows (if the
          key already exists). Puts are executed via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#put%28org.apache.hadoop.hbase.client.Put%29" target="_top">
            HTable.put</a> (writeBuffer) or <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29" target="_top">
            HTable.batch</a> (non-writeBuffer). </p></div><div class="section" title="5.8.3.&nbsp;Scans"><div class="titlepage"><div><div><h3 class="title"><a name="scan"></a>5.8.3.&nbsp;Scans</h3></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a>
          allow iteration over multiple rows for specified attributes. </p><p>The following is an example of a on an HTable table instance. Assume that a table is
          populated with rows with keys "row1", "row2", "row3", and then another set of rows with
          the keys "abc1", "abc2", and "abc3". The following example shows how to set a Scan
          instance to return the rows beginning with "row".</p><pre class="programlisting">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...

HTable htable = ...      // instantiate HTable

Scan scan = new Scan();
scan.addColumn(CF, ATTR);
scan.setRowPrefixFilter(Bytes.toBytes("row"));
ResultScanner rs = htable.getScanner(scan);
try {
  for (Result r = rs.next(); r != null; r = rs.next()) {
  // process result...
} finally {
  rs.close();  // always close the ResultScanner!
}
</pre><p>Note that generally the easiest way to specify a specific stop point for a scan is by
          using the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/InclusiveStopFilter.html" target="_top">InclusiveStopFilter</a>
          class. </p></div><div class="section" title="5.8.4.&nbsp;Delete"><div class="titlepage"><div><div><h3 class="title"><a name="delete"></a>5.8.4.&nbsp;Delete</h3></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Delete.html" target="_top">Delete</a>
          removes a row from a table. Deletes are executed via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29" target="_top">
            HTable.delete</a>. </p><p>HBase does not modify data in place, and so deletes are handled by creating new
          markers called <span class="emphasis"><em>tombstones</em></span>. These tombstones, along with the dead
          values, are cleaned up on major compactions. </p><p>See <a class="xref" href="#version.delete" title="5.9.2.5.&nbsp;Delete">Section&nbsp;5.9.2.5, &#8220;Delete&#8221;</a> for more information on deleting versions of columns, and
          see <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a> for more information on compactions. </p></div></div><div class="section" title="5.9.&nbsp;Versions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="versions"></a>5.9.&nbsp;Versions<a class="indexterm" name="d2875e5895"></a></h2></div></div></div><p>A <span class="emphasis"><em>{row, column, version} </em></span>tuple exactly specifies a
          <code class="literal">cell</code> in HBase. It's possible to have an unbounded number of cells where
        the row and column are the same but the cell address differs only in its version
        dimension.</p><p>While rows and column keys are expressed as bytes, the version is specified using a long
        integer. Typically this long contains time instances such as those returned by
          <code class="code">java.util.Date.getTime()</code> or <code class="code">System.currentTimeMillis()</code>, that is:
          <span class="quote">&#8220;<span class="quote">the difference, measured in milliseconds, between the current time and midnight,
          January 1, 1970 UTC</span>&#8221;</span>.</p><p>The HBase version dimension is stored in decreasing order, so that when reading from a
        store file, the most recent values are found first.</p><p>There is a lot of confusion over the semantics of <code class="literal">cell</code> versions, in
        HBase. In particular:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If multiple writes to a cell have the same version, only the last written is
            fetchable.</p></li><li class="listitem"><p>It is OK to write cells in a non-increasing version order.</p></li></ul></div><p>Below we describe how the version dimension in HBase currently works. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2406" target="_top">HBASE-2406</a> for
            discussion of HBase versions. <a class="link" href="http://outerthought.org/blog/417-ot.html" target="_top">Bending time in HBase</a>
            makes for a good read on the version, or time, dimension in HBase. It has more detail on
            versioning than is provided here. As of this writing, the limiitation
              <span class="emphasis"><em>Overwriting values at existing timestamps</em></span> mentioned in the
            article no longer holds in HBase. This section is basically a synopsis of this article
            by Bruno Dumon.</p><div class="section" title="5.9.1.&nbsp;Specifying the Number of Versions to Store"><div class="titlepage"><div><div><h3 class="title"><a name="specify.number.of.versions"></a>5.9.1.&nbsp;Specifying the Number of Versions to Store</h3></div></div></div><p>The maximum number of versions to store for a given column is part of the column
          schema and is specified at table creation, or via an <span class="command"><strong>alter</strong></span> command, via
            <code class="code">HColumnDescriptor.DEFAULT_VERSIONS</code>. Prior to HBase 0.96, the default number
          of versions kept was <code class="literal">3</code>, but in 0.96 and newer has been changed to
            <code class="literal">1</code>.</p><div class="example"><a name="d2875e5959"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;Modify the Maximum Number of Versions for a Column</b></p><div class="example-contents"><p>This example uses HBase Shell to keep a maximum of 5 versions of column
              <code class="code">f1</code>. You could also use <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>.</p><pre class="screen">hbase&gt; alter &#8216;t1&#8242;, NAME =&gt; &#8216;f1&#8242;, VERSIONS =&gt; 5</pre></div></div><br class="example-break"><div class="example"><a name="d2875e5972"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Modify the Minimum Number of Versions for a Column</b></p><div class="example-contents"><p>You can also specify the minimum number of versions to store. By default, this is
            set to 0, which means the feature is disabled. The following example sets the minimum
            number of versions on field <code class="code">f1</code> to <code class="literal">2</code>, via HBase Shell.
            You could also use <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>.</p><pre class="screen">hbase&gt; alter &#8216;t1&#8242;, NAME =&gt; &#8216;f1&#8242;, MIN_VERSIONS =&gt; 2</pre></div></div><br class="example-break"><p>Starting with HBase 0.98.2, you can specify a global default for the maximum number of
          versions kept for all newly-created columns, by setting
            <code class="option">hbase.column.max.version</code> in <code class="filename">hbase-site.xml</code>. See
            <a class="xref" href="#hbase.column.max.version" title="hbase.column.max.version"><code class="varname">hbase.column.max.version</code></a>.</p></div><div class="section" title="5.9.2.&nbsp;Versions and HBase Operations"><div class="titlepage"><div><div><h3 class="title"><a name="versions.ops"></a>5.9.2.&nbsp;Versions and HBase Operations</h3></div></div></div><p>In this section we look at the behavior of the version dimension for each of the core
          HBase operations.</p><div class="section" title="5.9.2.1.&nbsp;Get/Scan"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e6003"></a>5.9.2.1.&nbsp;Get/Scan</h4></div></div></div><p>Gets are implemented on top of Scans. The below discussion of <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a>
            applies equally to <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scans</a>.</p><p>By default, i.e. if you specify no explicit version, when doing a
              <code class="literal">get</code>, the cell whose version has the largest value is returned
            (which may or may not be the latest one written, see later). The default behavior can be
            modified in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>to return more than one version, see <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setMaxVersions()" target="_top">Get.setMaxVersions()</a></p></li><li class="listitem"><p>to return versions other than the latest, see <a class="link" href="???" target="_top">Get.setTimeRange()</a></p><p>To retrieve the latest version that is less than or equal to a given value, thus
                giving the 'latest' state of the record at a certain point in time, just use a range
                from 0 to the desired version and set the max versions to 1.</p></li></ul></div></div><div class="section" title="5.9.2.2.&nbsp;Default Get Example"><div class="titlepage"><div><div><h4 class="title"><a name="default_get_example"></a>5.9.2.2.&nbsp;Default Get Example</h4></div></div></div><p>The following Get will only retrieve the current version of the row</p><pre class="programlisting">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Get get = new Get(Bytes.toBytes("row1"));
Result r = htable.get(get);
byte[] b = r.getValue(CF, ATTR);  // returns current version of value
</pre></div><div class="section" title="5.9.2.3.&nbsp;Versioned Get Example"><div class="titlepage"><div><div><h4 class="title"><a name="versioned_get_example"></a>5.9.2.3.&nbsp;Versioned Get Example</h4></div></div></div><p>The following Get will return the last 3 versions of the row.</p><pre class="programlisting">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Get get = new Get(Bytes.toBytes("row1"));
get.setMaxVersions(3);  // will return last 3 versions of row
Result r = htable.get(get);
byte[] b = r.getValue(CF, ATTR);  // returns current version of value
List&lt;KeyValue&gt; kv = r.getColumn(CF, ATTR);  // returns all versions of this column
</pre></div><div class="section" title="5.9.2.4.&nbsp;Put"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e6046"></a>5.9.2.4.&nbsp;Put</h4></div></div></div><p>Doing a put always creates a new version of a <code class="literal">cell</code>, at a certain
            timestamp. By default the system uses the server's <code class="literal">currentTimeMillis</code>,
            but you can specify the version (= the long integer) yourself, on a per-column level.
            This means you could assign a time in the past or the future, or use the long value for
            non-time purposes.</p><p>To overwrite an existing value, do a put at exactly the same row, column, and
            version as that of the cell you would overshadow.</p><div class="section" title="5.9.2.4.1.&nbsp;Implicit Version Example"><div class="titlepage"><div><div><h5 class="title"><a name="implicit_version_example"></a>5.9.2.4.1.&nbsp;Implicit Version Example</h5></div></div></div><p>The following Put will be implicitly versioned by HBase with the current
              time.</p><pre class="programlisting">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Put put = new Put(Bytes.toBytes(row));
put.add(CF, ATTR, Bytes.toBytes( data));
htable.put(put);
</pre></div><div class="section" title="5.9.2.4.2.&nbsp;Explicit Version Example"><div class="titlepage"><div><div><h5 class="title"><a name="explicit_version_example"></a>5.9.2.4.2.&nbsp;Explicit Version Example</h5></div></div></div><p>The following Put has the version timestamp explicitly set.</p><pre class="programlisting">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Put put = new Put( Bytes.toBytes(row));
long explicitTimeInMs = 555;  // just an example
put.add(CF, ATTR, explicitTimeInMs, Bytes.toBytes(data));
htable.put(put);
</pre><p>Caution: the version timestamp is internally by HBase for things like time-to-live
              calculations. It's usually best to avoid setting this timestamp yourself. Prefer using
              a separate timestamp attribute of the row, or have the timestamp a part of the rowkey,
              or both. </p></div></div><div class="section" title="5.9.2.5.&nbsp;Delete"><div class="titlepage"><div><div><h4 class="title"><a name="version.delete"></a>5.9.2.5.&nbsp;Delete</h4></div></div></div><p>There are three different types of internal delete markers. See Lars Hofhansl's blog
            for discussion of his attempt adding another, <a class="link" href="http://hadoop-hbase.blogspot.com/2012/01/scanning-in-hbase.html" target="_top">Scanning
              in HBase: Prefix Delete Marker</a>. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Delete: for a specific version of a column.</p></li><li class="listitem"><p>Delete column: for all versions of a column.</p></li><li class="listitem"><p>Delete family: for all columns of a particular ColumnFamily</p></li></ul></div><p>When deleting an entire row, HBase will internally create a tombstone for each
            ColumnFamily (i.e., not each individual column). </p><p>Deletes work by creating <span class="emphasis"><em>tombstone</em></span> markers. For example, let's
            suppose we want to delete a row. For this you can specify a version, or else by default
            the <code class="literal">currentTimeMillis</code> is used. What this means is <span class="quote">&#8220;<span class="quote">delete all
              cells where the version is less than or equal to this version</span>&#8221;</span>. HBase never
            modifies data in place, so for example a delete will not immediately delete (or mark as
            deleted) the entries in the storage file that correspond to the delete condition.
            Rather, a so-called <span class="emphasis"><em>tombstone</em></span> is written, which will mask the
            deleted values. When HBase does a major compaction, the tombstones are processed to
            actually remove the dead values, together with the tombstones themselves. If the version
            you specified when deleting a row is larger than the version of any value in the row,
            then you can consider the complete row to be deleted.</p><p>For an informative discussion on how deletes and versioning interact, see the thread <a class="link" href="http://comments.gmane.org/gmane.comp.java.hadoop.hbase.user/28421" target="_top">Put w/
              timestamp -&gt; Deleteall -&gt; Put w/ timestamp fails</a> up on the user mailing
            list.</p><p>Also see <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a> for more information on the internal KeyValue format. </p><p>Delete markers are purged during the next major compaction of the store, unless the
              <code class="option">KEEP_DELETED_CELLS</code> option is set in the column family. To keep the
            deletes for a configurable amount of time, you can set the delete TTL via the
              <code class="option">hbase.hstore.time.to.purge.deletes</code> property in
              <code class="filename">hbase-site.xml</code>. If
              <code class="option">hbase.hstore.time.to.purge.deletes</code> is not set, or set to 0, all
            delete markers, including those with timestamps in the future, are purged during the
            next major compaction. Otherwise, a delete marker with a timestamp in the future is kept
            until the major compaction which occurs after the time represented by the marker's
            timestamp plus the value of <code class="option">hbase.hstore.time.to.purge.deletes</code>, in
            milliseconds. </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This behavior represents a fix for an unexpected change that was introduced in
              HBase 0.94, and was fixed in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10118" target="_top">HBASE-10118</a>.
              The change has been backported to HBase 0.94 and newer branches.</p></div></div></div><div class="section" title="5.9.3.&nbsp;Current Limitations"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e6141"></a>5.9.3.&nbsp;Current Limitations</h3></div></div></div><div class="section" title="5.9.3.1.&nbsp;Deletes mask Puts"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e6144"></a>5.9.3.1.&nbsp;Deletes mask Puts</h4></div></div></div><p>Deletes mask puts, even puts that happened after the delete
          was entered. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2256" target="_top">HBASE-2256</a>. Remember that a delete writes a tombstone, which only
          disappears after then next major compaction has run. Suppose you do
          a delete of everything &lt;= T. After this you do a new put with a
          timestamp &lt;= T. This put, even if it happened after the delete,
          will be masked by the delete tombstone. Performing the put will not
          fail, but when you do a get you will notice the put did have no
          effect. It will start working again after the major compaction has
          run. These issues should not be a problem if you use
          always-increasing versions for new puts to a row. But they can occur
          even if you do not care about time: just do delete and put
          immediately after each other, and there is some chance they happen
          within the same millisecond.</p></div><div class="section" title="5.9.3.2.&nbsp;Major compactions change query results"><div class="titlepage"><div><div><h4 class="title"><a name="major.compactions.change.query.results"></a>5.9.3.2.&nbsp;Major compactions change query results</h4></div></div></div><p><span class="quote">&#8220;<span class="quote">...create three cell versions at t1, t2 and t3, with a maximum-versions
              setting of 2. So when getting all versions, only the values at t2 and t3 will be
              returned. But if you delete the version at t2 or t3, the one at t1 will appear again.
              Obviously, once a major compaction has run, such behavior will not be the case
              anymore...</span>&#8221;</span> (See <span class="emphasis"><em>Garbage Collection</em></span> in <a class="link" href="http://outerthought.org/blog/417-ot.html" target="_top">Bending time in
            HBase</a>.)</p></div></div></div><div class="section" title="5.10.&nbsp;Sort Order"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dm.sort"></a>5.10.&nbsp;Sort Order</h2></div></div></div><p>All data model operations HBase return data in sorted order.  First by row,
      then by ColumnFamily, followed by column qualifier, and finally timestamp (sorted
      in reverse, so newest records are returned first).
      </p></div><div class="section" title="5.11.&nbsp;Column Metadata"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dm.column.metadata"></a>5.11.&nbsp;Column Metadata</h2></div></div></div><p>There is no store of column metadata outside of the internal KeyValue instances for a ColumnFamily.
      Thus, while HBase can support not only a wide number of columns per row, but a heterogenous set of columns
      between rows as well, it is your responsibility to keep track of the column names.
      </p><p>The only way to get a complete set of columns that exist for a ColumnFamily is to process all the rows.
      For more information about how HBase stores data internally, see <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a>.
	  </p></div><div class="section" title="5.12.&nbsp;Joins"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="joins"></a>5.12.&nbsp;Joins</h2></div></div></div><p>Whether HBase supports joins is a common question on the dist-list, and there is a simple answer:  it doesn't,
      at not least in the way that RDBMS' support them (e.g., with equi-joins or outer-joins in SQL).  As has been illustrated
      in this chapter, the read data model operations in HBase are Get and Scan.
      </p><p>However, that doesn't mean that equivalent join functionality can't be supported in your application, but
      you have to do it yourself.  The two primary strategies are either denormalizing the data upon writing to HBase,
      or to have lookup tables and do the join between HBase tables in your application or MapReduce code (and as RDBMS'
      demonstrate, there are several strategies for this depending on the size of the tables, e.g., nested loops vs.
      hash-joins).  So which is the best approach?  It depends on what you are trying to do, and as such there isn't a single
      answer that works for every use case.
      </p></div><div class="section" title="5.13.&nbsp;ACID"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="acid"></a>5.13.&nbsp;ACID</h2></div></div></div><p>See <a class="link" href="http://hbase.apache.org/acid-semantics.html" target="_top">ACID Semantics</a>.
            Lars Hofhansl has also written a note on
            <a class="link" href="http://hadoop-hbase.blogspot.com/2012/03/acid-in-hbase.html" target="_top">ACID in HBase</a>.</p></div></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;HBase and Schema Design"><div class="titlepage"><div><div><h2 class="title"><a name="schema"></a>Chapter&nbsp;6.&nbsp;HBase and Schema Design</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#schema.creation">6.1.  Schema Creation </a></span></dt><dd><dl><dt><span class="section"><a href="#schema.updates">6.1.1. Schema Updates</a></span></dt></dl></dd><dt><span class="section"><a href="#number.of.cfs">6.2.  On the number of column families </a></span></dt><dd><dl><dt><span class="section"><a href="#number.of.cfs.card">6.2.1. Cardinality of ColumnFamilies</a></span></dt></dl></dd><dt><span class="section"><a href="#rowkey.design">6.3. Rowkey Design</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e6258">6.3.1. Hotspotting</a></span></dt><dt><span class="section"><a href="#timeseries">6.3.2.  Monotonically Increasing Row Keys/Timeseries Data </a></span></dt><dt><span class="section"><a href="#keysize">6.3.3. Try to minimize row and column sizes</a></span></dt><dt><span class="section"><a href="#reverse.timestamp">6.3.4. Reverse Timestamps</a></span></dt><dt><span class="section"><a href="#rowkey.scope">6.3.5. Rowkeys and ColumnFamilies</a></span></dt><dt><span class="section"><a href="#changing.rowkeys">6.3.6. Immutability of Rowkeys</a></span></dt><dt><span class="section"><a href="#rowkey.regionsplits">6.3.7. Relationship Between RowKeys and Region Splits</a></span></dt></dl></dd><dt><span class="section"><a href="#schema.versions">6.4.  Number of Versions </a></span></dt><dd><dl><dt><span class="section"><a href="#schema.versions.max">6.4.1. Maximum Number of Versions</a></span></dt><dt><span class="section"><a href="#schema.minversions">6.4.2.  Minimum Number of Versions </a></span></dt></dl></dd><dt><span class="section"><a href="#supported.datatypes">6.5.  Supported Datatypes </a></span></dt><dd><dl><dt><span class="section"><a href="#counters">6.5.1. Counters</a></span></dt></dl></dd><dt><span class="section"><a href="#schema.joins">6.6. Joins</a></span></dt><dt><span class="section"><a href="#ttl">6.7. Time To Live (TTL)</a></span></dt><dt><span class="section"><a href="#cf.keep.deleted">6.8.  Keeping Deleted Cells </a></span></dt><dt><span class="section"><a href="#secondary.indexes">6.9.  Secondary Indexes and Alternate Query Paths </a></span></dt><dd><dl><dt><span class="section"><a href="#secondary.indexes.filter">6.9.1.  Filter Query </a></span></dt><dt><span class="section"><a href="#secondary.indexes.periodic">6.9.2.  Periodic-Update Secondary Index </a></span></dt><dt><span class="section"><a href="#secondary.indexes.dualwrite">6.9.3.  Dual-Write Secondary Index </a></span></dt><dt><span class="section"><a href="#secondary.indexes.summary">6.9.4.  Summary Tables </a></span></dt><dt><span class="section"><a href="#secondary.indexes.coproc">6.9.5.  Coprocessor Secondary Index </a></span></dt></dl></dd><dt><span class="section"><a href="#constraints">6.10. Constraints</a></span></dt><dt><span class="section"><a href="#schema.casestudies">6.11. Schema Design Case Studies</a></span></dt><dd><dl><dt><span class="section"><a href="#schema.casestudies.log-timeseries">6.11.1. Case Study - Log Data and Timeseries Data</a></span></dt><dt><span class="section"><a href="#schema.casestudies.log-steroids">6.11.2. Case Study - Log Data and Timeseries Data on Steroids</a></span></dt><dt><span class="section"><a href="#schema.casestudies.custorder">6.11.3. Case Study - Customer/Order</a></span></dt><dt><span class="section"><a href="#schema.smackdown">6.11.4. Case Study - "Tall/Wide/Middle" Schema Design Smackdown</a></span></dt><dt><span class="section"><a href="#casestudies.schema.listdata">6.11.5. Case Study - List Data</a></span></dt></dl></dd><dt><span class="section"><a href="#schema.ops">6.12. Operational and Performance Configuration Options</a></span></dt></dl></div><p>A good general introduction on the strength and weaknesses modelling on the various
    non-rdbms datastores is Ian Varley's Master thesis, <a class="link" href="http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf" target="_top">No Relation:
      The Mixed Blessings of Non-Relational Databases</a>. Recommended. Also, read <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a> for how HBase stores data internally, and the section on <a class="xref" href="#schema.casestudies" title="6.11.&nbsp;Schema Design Case Studies">Section&nbsp;6.11, &#8220;Schema Design Case Studies&#8221;</a>. </p><div class="section" title="6.1.&nbsp; Schema Creation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="schema.creation"></a>6.1.&nbsp; Schema Creation </h2></div></div></div><p>HBase schemas can be created or updated with <a class="xref" href="#shell" title="Chapter&nbsp;4.&nbsp;The Apache HBase Shell">Chapter&nbsp;4, <i>The Apache HBase Shell</i></a> or by using <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html" target="_top">HBaseAdmin</a>
      in the Java API. </p><p>Tables must be disabled when making ColumnFamily modifications, for example:</p><pre class="programlisting">
Configuration config = HBaseConfiguration.create();
HBaseAdmin admin = new HBaseAdmin(conf);
String table = "myTable";

admin.disableTable(table);

HColumnDescriptor cf1 = ...;
admin.addColumn(table, cf1);      // adding new ColumnFamily
HColumnDescriptor cf2 = ...;
admin.modifyColumn(table, cf2);    // modifying existing ColumnFamily

admin.enableTable(table);
    </pre><p>See <a class="xref" href="#client_dependencies" title="2.4.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster">Section&nbsp;2.4.4, &#8220;Client configuration and dependencies connecting to an HBase cluster&#8221;</a> for more information about configuring client
      connections.</p><p>Note: online schema changes are supported in the 0.92.x codebase, but the 0.90.x codebase
      requires the table to be disabled. </p><div class="section" title="6.1.1.&nbsp;Schema Updates"><div class="titlepage"><div><div><h3 class="title"><a name="schema.updates"></a>6.1.1.&nbsp;Schema Updates</h3></div></div></div><p>When changes are made to either Tables or ColumnFamilies (e.g., region size, block
        size), these changes take effect the next time there is a major compaction and the
        StoreFiles get re-written. </p><p>See <a class="xref" href="#store" title="9.7.7.&nbsp;Store">Section&nbsp;9.7.7, &#8220;Store&#8221;</a> for more information on StoreFiles. </p></div></div><div class="section" title="6.2.&nbsp; On the number of column families"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="number.of.cfs"></a>6.2.&nbsp; On the number of column families </h2></div></div></div><p> HBase currently does not do well with anything above two or three column families so keep
      the number of column families in your schema low. Currently, flushing and compactions are done
      on a per Region basis so if one column family is carrying the bulk of the data bringing on
      flushes, the adjacent families will also be flushed though the amount of data they carry is
      small. When many column families the flushing and compaction interaction can make for a bunch
      of needless i/o loading (To be addressed by changing flushing and compaction to work on a per
      column family basis). For more information on compactions, see <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a>. </p><p>Try to make do with one column family if you can in your schemas. Only introduce a second
      and third column family in the case where data access is usually column scoped; i.e. you query
      one column family or the other but usually not both at the one time. </p><div class="section" title="6.2.1.&nbsp;Cardinality of ColumnFamilies"><div class="titlepage"><div><div><h3 class="title"><a name="number.of.cfs.card"></a>6.2.1.&nbsp;Cardinality of ColumnFamilies</h3></div></div></div><p>Where multiple ColumnFamilies exist in a single table, be aware of the cardinality
        (i.e., number of rows). If ColumnFamilyA has 1 million rows and ColumnFamilyB has 1 billion
        rows, ColumnFamilyA's data will likely be spread across many, many regions (and
        RegionServers). This makes mass scans for ColumnFamilyA less efficient. </p></div></div><div class="section" title="6.3.&nbsp;Rowkey Design"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rowkey.design"></a>6.3.&nbsp;Rowkey Design</h2></div></div></div><div class="section" title="6.3.1.&nbsp;Hotspotting"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e6258"></a>6.3.1.&nbsp;Hotspotting</h3></div></div></div><p>Rows in HBase are sorted lexicographically by row key. This design optimizes for scans,
        allowing you to store related rows, or rows that will be read together, near each other.
        However, poorly designed row keys are a common source of <em class="firstterm">hotspotting</em>.
        Hotspotting occurs when a large amount of client traffic is directed at one node, or only a
        few nodes, of a cluster. This traffic may represent reads, writes, or other operations. The
        traffic overwhelms the single machine responsible for hosting that region, causing
        performance degradation and potentially leading to region unavailability. This can also have
        adverse effects on other regions hosted by the same region server as that host is unable to
        service the requested load. It is important to design data access patterns such that the
        cluster is fully and evenly utilized.</p><p>To prevent hotspotting on writes, design your row keys such that rows that truly do need
        to be in the same region are, but in the bigger picture, data is being written to multiple
        regions across the cluster, rather than one at a time. Some common techniques for avoiding
        hotspotting are described below, along with some of their advantages and drawbacks.</p><p title="Salting"><b>Salting.&nbsp;</b>Salting in this sense has nothing to do with cryptography, but refers to adding random
          data to the start of a row key. In this case, salting refers to adding a randomly-assigned
          prefix to the row key to cause it to sort differently than it otherwise would. The number
          of possible prefixes correspond to the number of regions you want to spread the data
          across. Salting can be helpful if you have a few "hot" row key patterns which come up over
          and over amongst other more evenly-distributed rows. Consider the following example, which
          shows that salting can spread write load across multiple regionservers, and illustrates
          some of the negative implications for reads.</p><div class="example"><a name="d2875e6273"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;Salting Example</b></p><div class="example-contents"><p>Suppose you have the following list of row keys, and your table is split such that
          there is one region for each letter of the alphabet. Prefix 'a' is one region, prefix 'b'
          is another. In this table, all rows starting with 'f' are in the same region. This example
          focuses on rows with keys like the following:</p><pre class="screen">
foo0001
foo0002
foo0003
foo0004          
        </pre><p>Now, imagine that you would like to spread these across four different regions. You
          decide to use four different salts: <code class="literal">a</code>, <code class="literal">b</code>,
            <code class="literal">c</code>, and <code class="literal">d</code>. In this scenario, each of these letter
          prefixes will be on a different region. After applying the salts, you have the following
          rowkeys instead. Since you can now write to four separate regions, you theoretically have
          four times the throughput when writing that you would have if all the writes were going to
          the same region.</p><pre class="screen">
a-foo0003
b-foo0001
c-foo0004
d-foo0002          
        </pre><p>Then, if you add another row, it will randomly be assigned one of the four possible
          salt values and end up near one of the existing rows.</p><pre class="screen">
a-foo0003
b-foo0001
<span class="emphasis"><em>c-foo0003</em></span>
c-foo0004
d-foo0002        
        </pre><p>Since this assignment will be random, you will need to do more work if you want to
          retrieve the rows in lexicographic order. In this way, salting attempts to increase
          throughput on writes, but has a cost during reads.</p></div></div><br class="example-break"><p></p><p title="Hashing"><b>Hashing.&nbsp;</b>Instead of a random assignment, you could use a one-way <em class="firstterm">hash</em>
          that would cause a given row to always be "salted" with the same prefix, in a way that
          would spread the load across the regionservers, but allow for predictability during reads.
          Using a deterministic hash allows the client to reconstruct the complete rowkey and use a
          Get operation to retrieve that row as normal.</p><div class="example"><a name="d2875e6314"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;Hashing Example</b></p><div class="example-contents"><p>Given the same situation in the salting example above, you could instead apply a
          one-way hash that would cause the row with key <code class="literal">foo0003</code> to always, and
          predictably, receive the <code class="literal">a</code> prefix. Then, to retrieve that row, you
          would already know the key. You could also optimize things so that certain pairs of keys
          were always in the same region, for instance.</p></div></div><br class="example-break"><p title="Reversing the Key"><b>Reversing the Key.&nbsp;</b>A third common trick for preventing hotspotting is to reverse a fixed-width or numeric
        row key so that the part that changes the most often (the least significant digit) is first.
        This effectively randomizes row keys, but sacrifices row ordering properties.</p><p>See <a class="link" href="https://communities.intel.com/community/itpeernetwork/datastack/blog/2013/11/10/discussion-on-designing-hbase-tables" target="_top">https://communities.intel.com/community/itpeernetwork/datastack/blog/2013/11/10/discussion-on-designing-hbase-tables</a>,
        and <a class="link" href="http://phoenix.apache.org/salted.html" target="_top">article on Salted Tables</a>
        from the Phoenix project, and the discussion in the comments of <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11682" target="_top">HBASE-11682</a> for more
        information about avoiding hotspotting.</p></div><div class="section" title="6.3.2.&nbsp; Monotonically Increasing Row Keys/Timeseries Data"><div class="titlepage"><div><div><h3 class="title"><a name="timeseries"></a>6.3.2.&nbsp; Monotonically Increasing Row Keys/Timeseries Data </h3></div></div></div><p> In the HBase chapter of Tom White's book <a class="link" href="http://oreilly.com/catalog/9780596521981" target="_top">Hadoop: The Definitive Guide</a>
        (O'Reilly) there is a an optimization note on watching out for a phenomenon where an import
        process walks in lock-step with all clients in concert pounding one of the table's regions
        (and thus, a single node), then moving onto the next region, etc. With monotonically
        increasing row-keys (i.e., using a timestamp), this will happen. See this comic by IKai Lan
        on why monotonically increasing row keys are problematic in BigTable-like datastores: <a class="link" href="http://ikaisays.com/2011/01/25/app-engine-datastore-tip-monotonically-increasing-values-are-bad/" target="_top">monotonically
          increasing values are bad</a>. The pile-up on a single region brought on by
        monotonically increasing keys can be mitigated by randomizing the input records to not be in
        sorted order, but in general it's best to avoid using a timestamp or a sequence (e.g. 1, 2,
        3) as the row-key. </p><p>If you do need to upload time series data into HBase, you should study <a class="link" href="http://opentsdb.net/" target="_top">OpenTSDB</a> as a successful example. It has a page
        describing the <a class="link" href=" http://opentsdb.net/schema.html" target="_top">schema</a> it uses in HBase. The key
        format in OpenTSDB is effectively [metric_type][event_timestamp], which would appear at
        first glance to contradict the previous advice about not using a timestamp as the key.
        However, the difference is that the timestamp is not in the <span class="emphasis"><em>lead</em></span>
        position of the key, and the design assumption is that there are dozens or hundreds (or
        more) of different metric types. Thus, even with a continual stream of input data with a mix
        of metric types, the Puts are distributed across various points of regions in the table. </p><p>See <a class="xref" href="#schema.casestudies" title="6.11.&nbsp;Schema Design Case Studies">Section&nbsp;6.11, &#8220;Schema Design Case Studies&#8221;</a> for some rowkey design examples. </p></div><div class="section" title="6.3.3.&nbsp;Try to minimize row and column sizes"><div class="titlepage"><div><div><h3 class="title"><a name="keysize"></a>6.3.3.&nbsp;Try to minimize row and column sizes</h3></div><div><h4 class="subtitle">Or why are my StoreFile indices large?</h4></div></div></div><p>In HBase, values are always freighted with their coordinates; as a cell value passes
        through the system, it'll be accompanied by its row, column name, and timestamp - always. If
        your rows and column names are large, especially compared to the size of the cell value,
        then you may run up against some interesting scenarios. One such is the case described by
        Marc Limotte at the tail of <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3551?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel&amp;focusedCommentId=13005272#comment-13005272" target="_top">HBASE-3551</a>
        (recommended!). Therein, the indices that are kept on HBase storefiles (<a class="xref" href="#hfile" title="9.7.7.4.&nbsp;StoreFile (HFile)">Section&nbsp;9.7.7.4, &#8220;StoreFile (HFile)&#8221;</a>) to facilitate random access may end up occupyng large chunks of the
        HBase allotted RAM because the cell value coordinates are large. Mark in the above cited
        comment suggests upping the block size so entries in the store file index happen at a larger
        interval or modify the table schema so it makes for smaller rows and column names.
        Compression will also make for larger indices. See the thread <a class="link" href="http://search-hadoop.com/m/hemBv1LiN4Q1/a+question+storefileIndexSize&amp;subj=a+question+storefileIndexSize" target="_top">a
          question storefileIndexSize</a> up on the user mailing list. </p><p>Most of the time small inefficiencies don't matter all that much. Unfortunately, this is
        a case where they do. Whatever patterns are selected for ColumnFamilies, attributes, and
        rowkeys they could be repeated several billion times in your data. </p><p>See <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a> for more information on HBase stores data internally to see why this
        is important.</p><div class="section" title="6.3.3.1.&nbsp;Column Families"><div class="titlepage"><div><div><h4 class="title"><a name="keysize.cf"></a>6.3.3.1.&nbsp;Column Families</h4></div></div></div><p>Try to keep the ColumnFamily names as small as possible, preferably one character
          (e.g. "d" for data/default). </p><p>See <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a> for more information on HBase stores data internally to see why
          this is important.</p></div><div class="section" title="6.3.3.2.&nbsp;Attributes"><div class="titlepage"><div><div><h4 class="title"><a name="keysize.attributes"></a>6.3.3.2.&nbsp;Attributes</h4></div></div></div><p>Although verbose attribute names (e.g., "myVeryImportantAttribute") are easier to
          read, prefer shorter attribute names (e.g., "via") to store in HBase. </p><p>See <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a> for more information on HBase stores data internally to see why
          this is important.</p></div><div class="section" title="6.3.3.3.&nbsp;Rowkey Length"><div class="titlepage"><div><div><h4 class="title"><a name="keysize.row"></a>6.3.3.3.&nbsp;Rowkey Length</h4></div></div></div><p>Keep them as short as is reasonable such that they can still be useful for required
          data access (e.g., Get vs. Scan). A short key that is useless for data access is not
          better than a longer key with better get/scan properties. Expect tradeoffs when designing
          rowkeys. </p></div><div class="section" title="6.3.3.4.&nbsp;Byte Patterns"><div class="titlepage"><div><div><h4 class="title"><a name="keysize.patterns"></a>6.3.3.4.&nbsp;Byte Patterns</h4></div></div></div><p>A long is 8 bytes. You can store an unsigned number up to 18,446,744,073,709,551,615
          in those eight bytes. If you stored this number as a String -- presuming a byte per
          character -- you need nearly 3x the bytes. </p><p>Not convinced? Below is some sample code that you can run on your own.</p><pre class="programlisting">
// long
//
long l = 1234567890L;
byte[] lb = Bytes.toBytes(l);
System.out.println("long bytes length: " + lb.length);   // returns 8

String s = "" + l;
byte[] sb = Bytes.toBytes(s);
System.out.println("long as string length: " + sb.length);    // returns 10

// hash
//
MessageDigest md = MessageDigest.getInstance("MD5");
byte[] digest = md.digest(Bytes.toBytes(s));
System.out.println("md5 digest bytes length: " + digest.length);    // returns 16

String sDigest = new String(digest);
byte[] sbDigest = Bytes.toBytes(sDigest);
System.out.println("md5 digest as string length: " + sbDigest.length);    // returns 26
        </pre><p>Unfortunately, using a binary representation of a type will make your data harder to
          read outside of your code. For example, this is what you will see in the shell when you
          increment a value:</p><pre class="programlisting">
hbase(main):001:0&gt; incr 't', 'r', 'f:q', 1
COUNTER VALUE = 1

hbase(main):002:0&gt; get 't', 'r'
COLUMN                                        CELL
 f:q                                          timestamp=1369163040570, value=\x00\x00\x00\x00\x00\x00\x00\x01
1 row(s) in 0.0310 seconds
        </pre><p>The shell makes a best effort to print a string, and it this case it decided to just
          print the hex. The same will happen to your row keys inside the region names. It can be
          okay if you know what's being stored, but it might also be unreadable if arbitrary data
          can be put in the same cells. This is the main trade-off. </p></div></div><div class="section" title="6.3.4.&nbsp;Reverse Timestamps"><div class="titlepage"><div><div><h3 class="title"><a name="reverse.timestamp"></a>6.3.4.&nbsp;Reverse Timestamps</h3></div></div></div><div class="note" title="Reverse Scan API" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Reverse Scan API</h3><p>
          <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4811" target="_top">HBASE-4811</a>
          implements an API to scan a table or a range within a table in reverse, reducing the need
          to optimize your schema for forward or reverse scanning. This feature is available in
          HBase 0.98 and later. See <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed%28boolean" target="_top">https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed%28boolean</a>
          for more information. </p></div><p>A common problem in database processing is quickly finding the most recent version of a
        value. A technique using reverse timestamps as a part of the key can help greatly with a
        special case of this problem. Also found in the HBase chapter of Tom White's book Hadoop:
        The Definitive Guide (O'Reilly), the technique involves appending (<code class="code">Long.MAX_VALUE -
          timestamp</code>) to the end of any key, e.g., [key][reverse_timestamp]. </p><p>The most recent value for [key] in a table can be found by performing a Scan for [key]
        and obtaining the first record. Since HBase keys are in sorted order, this key sorts before
        any older row-keys for [key] and thus is first. </p><p>This technique would be used instead of using <a class="xref" href="#schema.versions" title="6.4.&nbsp; Number of Versions">Section&nbsp;6.4, &#8220; Number of Versions &#8221;</a> where the intent is to hold onto all versions "forever" (or a
        very long time) and at the same time quickly obtain access to any other version by using the
        same Scan technique. </p></div><div class="section" title="6.3.5.&nbsp;Rowkeys and ColumnFamilies"><div class="titlepage"><div><div><h3 class="title"><a name="rowkey.scope"></a>6.3.5.&nbsp;Rowkeys and ColumnFamilies</h3></div></div></div><p>Rowkeys are scoped to ColumnFamilies. Thus, the same rowkey could exist in each
        ColumnFamily that exists in a table without collision. </p></div><div class="section" title="6.3.6.&nbsp;Immutability of Rowkeys"><div class="titlepage"><div><div><h3 class="title"><a name="changing.rowkeys"></a>6.3.6.&nbsp;Immutability of Rowkeys</h3></div></div></div><p>Rowkeys cannot be changed. The only way they can be "changed" in a table is if the row
        is deleted and then re-inserted. This is a fairly common question on the HBase dist-list so
        it pays to get the rowkeys right the first time (and/or before you've inserted a lot of
        data). </p></div><div class="section" title="6.3.7.&nbsp;Relationship Between RowKeys and Region Splits"><div class="titlepage"><div><div><h3 class="title"><a name="rowkey.regionsplits"></a>6.3.7.&nbsp;Relationship Between RowKeys and Region Splits</h3></div></div></div><p>If you pre-split your table, it is <span class="emphasis"><em>critical</em></span> to understand how your
        rowkey will be distributed across the region boundaries. As an example of why this is
        important, consider the example of using displayable hex characters as the lead position of
        the key (e.g., "0000000000000000" to "ffffffffffffffff"). Running those key ranges through
          <code class="code">Bytes.split</code> (which is the split strategy used when creating regions in
          <code class="code">HBaseAdmin.createTable(byte[] startKey, byte[] endKey, numRegions)</code> for 10
        regions will generate the following splits...</p><pre class="screen">
48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48                                // 0
54 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10                 // 6
61 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -67 -68                 // =
68 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -124 -126  // D
75 75 75 75 75 75 75 75 75 75 75 75 75 75 75 72                                // K
82 18 18 18 18 18 18 18 18 18 18 18 18 18 18 14                                // R
88 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -40 -44                 // X
95 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -97 -102                // _
102 102 102 102 102 102 102 102 102 102 102 102 102 102 102 102                // f
      </pre><p>... (note: the lead byte is listed to the right as a comment.) Given that the first
        split is a '0' and the last split is an 'f', everything is great, right? Not so fast. </p><p>The problem is that all the data is going to pile up in the first 2 regions and the last
        region thus creating a "lumpy" (and possibly "hot") region problem. To understand why, refer
        to an <a class="link" href="http://www.asciitable.com" target="_top">ASCII Table</a>. '0' is byte 48, and 'f' is byte
        102, but there is a huge gap in byte values (bytes 58 to 96) that will <span class="emphasis"><em>never
          appear in this keyspace</em></span> because the only values are [0-9] and [a-f]. Thus, the
        middle regions regions will never be used. To make pre-spliting work with this example
        keyspace, a custom definition of splits (i.e., and not relying on the built-in split method)
        is required. </p><p>Lesson #1: Pre-splitting tables is generally a best practice, but you need to pre-split
        them in such a way that all the regions are accessible in the keyspace. While this example
        demonstrated the problem with a hex-key keyspace, the same problem can happen with
          <span class="emphasis"><em>any</em></span> keyspace. Know your data. </p><p>Lesson #2: While generally not advisable, using hex-keys (and more generally,
        displayable data) can still work with pre-split tables as long as all the created regions
        are accessible in the keyspace. </p><p>To conclude this example, the following is an example of how appropriate splits can be
        pre-created for hex-keys:. </p><pre class="programlisting">public static boolean createTable(HBaseAdmin admin, HTableDescriptor table, byte[][] splits)
throws IOException {
  try {
    admin.createTable( table, splits );
    return true;
  } catch (TableExistsException e) {
    logger.info("table " + table.getNameAsString() + " already exists");
    // the table already exists...
    return false;
  }
}

public static byte[][] getHexSplits(String startKey, String endKey, int numRegions) {
  byte[][] splits = new byte[numRegions-1][];
  BigInteger lowestKey = new BigInteger(startKey, 16);
  BigInteger highestKey = new BigInteger(endKey, 16);
  BigInteger range = highestKey.subtract(lowestKey);
  BigInteger regionIncrement = range.divide(BigInteger.valueOf(numRegions));
  lowestKey = lowestKey.add(regionIncrement);
  for(int i=0; i &lt; numRegions-1;i++) {
    BigInteger key = lowestKey.add(regionIncrement.multiply(BigInteger.valueOf(i)));
    byte[] b = String.format("%016x", key).getBytes();
    splits[i] = b;
  }
  return splits;
}</pre></div></div><div class="section" title="6.4.&nbsp; Number of Versions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="schema.versions"></a>6.4.&nbsp; Number of Versions </h2></div></div></div><div class="section" title="6.4.1.&nbsp;Maximum Number of Versions"><div class="titlepage"><div><div><h3 class="title"><a name="schema.versions.max"></a>6.4.1.&nbsp;Maximum Number of Versions</h3></div></div></div><p>The maximum number of row versions to store is configured per column family via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>.
        The default for max versions is 1. This is an important parameter because as described in <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a> section HBase does <span class="emphasis"><em>not</em></span> overwrite row values,
        but rather stores different values per row by time (and qualifier). Excess versions are
        removed during major compactions. The number of max versions may need to be increased or
        decreased depending on application needs. </p><p>It is not recommended setting the number of max versions to an exceedingly high level
        (e.g., hundreds or more) unless those old values are very dear to you because this will
        greatly increase StoreFile size. </p></div><div class="section" title="6.4.2.&nbsp; Minimum Number of Versions"><div class="titlepage"><div><div><h3 class="title"><a name="schema.minversions"></a>6.4.2.&nbsp; Minimum Number of Versions </h3></div></div></div><p>Like maximum number of row versions, the minimum number of row versions to keep is
        configured per column family via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>.
        The default for min versions is 0, which means the feature is disabled. The minimum number
        of row versions parameter is used together with the time-to-live parameter and can be
        combined with the number of row versions parameter to allow configurations such as "keep the
        last T minutes worth of data, at most N versions, <span class="emphasis"><em>but keep at least M versions
          around</em></span>" (where M is the value for minimum number of row versions, M&lt;N). This
        parameter should only be set when time-to-live is enabled for a column family and must be
        less than the number of row versions. </p></div></div><div class="section" title="6.5.&nbsp; Supported Datatypes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="supported.datatypes"></a>6.5.&nbsp; Supported Datatypes </h2></div></div></div><p>HBase supports a "bytes-in/bytes-out" interface via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Put.html" target="_top">Put</a>
      and <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Result.html" target="_top">Result</a>,
      so anything that can be converted to an array of bytes can be stored as a value. Input could
      be strings, numbers, complex objects, or even images as long as they can rendered as bytes. </p><p>There are practical limits to the size of values (e.g., storing 10-50MB objects in HBase
      would probably be too much to ask); search the mailling list for conversations on this topic.
      All rows in HBase conform to the <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a>, and that includes versioning. Take that into consideration when
      making your design, as well as block size for the ColumnFamily. </p><div class="section" title="6.5.1.&nbsp;Counters"><div class="titlepage"><div><div><h3 class="title"><a name="counters"></a>6.5.1.&nbsp;Counters</h3></div></div></div><p> One supported datatype that deserves special mention are "counters" (i.e., the ability
        to do atomic increments of numbers). See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#increment%28org.apache.hadoop.hbase.client.Increment%29" target="_top">Increment</a>
        in HTable. </p><p>Synchronization on counters are done on the RegionServer, not in the client. </p></div></div><div class="section" title="6.6.&nbsp;Joins"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="schema.joins"></a>6.6.&nbsp;Joins</h2></div></div></div><p>If you have multiple tables, don't forget to factor in the potential for <a class="xref" href="#joins" title="5.12.&nbsp;Joins">Section&nbsp;5.12, &#8220;Joins&#8221;</a> into the schema design. </p></div><div class="section" title="6.7.&nbsp;Time To Live (TTL)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ttl"></a>6.7.&nbsp;Time To Live (TTL)</h2></div></div></div><p> ColumnFamilies can set a TTL length in seconds, and HBase will automatically delete rows
      once the expiration time is reached. This applies to <span class="emphasis"><em>all</em></span> versions of a
      row - even the current one. The TTL time encoded in the HBase for the row is specified in UTC.
    </p><p> Store files which contains only expired rows are deleted on minor compaction. Setting
        <code class="varname">hbase.store.delete.expired.storefile</code> to <code class="code">false</code> disables this
      feature. Setting <a class="link" href="#schema.minversions" title="6.4.2.&nbsp; Minimum Number of Versions">minimum number of versions</a> to other
      than 0 also disables this.</p><p> See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a> for more information. </p></div><div class="section" title="6.8.&nbsp; Keeping Deleted Cells"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cf.keep.deleted"></a>6.8.&nbsp; Keeping Deleted Cells </h2></div></div></div><p>By default, delete markers extend back to the beginning of time. Therefore, <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a>
      or <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a>
      operations will not see a deleted cell (row or column), even when the Get or Scan operation
      indicates a time range
      before the delete marker was placed.</p><p>ColumnFamilies can optionally keep deleted cells. In this case, deleted cells can still be
      retrieved, as long as these operations specify a time range that ends before the timestamp of
      any delete that would affect the cells. This allows for point-in-time queries even in the
      presence of deletes. </p><p> Deleted cells are still subject to TTL and there will never be more than "maximum number
      of versions" deleted cells. A new "raw" scan options returns all deleted rows and the delete
      markers. </p><div class="example"><a name="d2875e6598"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;Change the Value of <code class="code">KEEP_DELETED_CELLS</code> Using HBase Shell</b></p><div class="example-contents"><pre class="screen">hbase&gt; hbase&gt; alter &#8216;t1&#8242;, NAME =&gt; &#8216;f1&#8242;, KEEP_DELETED_CELLS =&gt; true</pre></div></div><br class="example-break"><div class="example"><a name="d2875e6606"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;Change the Value of <code class="code">KEEP_DELETED_CELLS</code> Using the API</b></p><div class="example-contents"><pre class="programlisting">...
HColumnDescriptor.setKeepDeletedCells(true);
...
      </pre></div></div><br class="example-break"><p>See the API documentation for <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html#KEEP_DELETED_CELLS" target="_top">KEEP_DELETED_CELLS</a> for more information. </p></div><div class="section" title="6.9.&nbsp; Secondary Indexes and Alternate Query Paths"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="secondary.indexes"></a>6.9.&nbsp; Secondary Indexes and Alternate Query Paths </h2></div></div></div><p>This section could also be titled "what if my table rowkey looks like
        <span class="emphasis"><em>this</em></span> but I also want to query my table like <span class="emphasis"><em>that</em></span>."
      A common example on the dist-list is where a row-key is of the format "user-timestamp" but
      there are reporting requirements on activity across users for certain time ranges. Thus,
      selecting by user is easy because it is in the lead position of the key, but time is not. </p><p>There is no single answer on the best way to handle this because it depends on... </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Number of users</p></li><li class="listitem"><p>Data size and data arrival rate</p></li><li class="listitem"><p>Flexibility of reporting requirements (e.g., completely ad-hoc date selection vs.
          pre-configured ranges) </p></li><li class="listitem"><p>Desired execution speed of query (e.g., 90 seconds may be reasonable to some for an
          ad-hoc report, whereas it may be too long for others) </p></li></ul></div><p>... and solutions are also influenced by the size of the cluster and how much processing
      power you have to throw at the solution. Common techniques are in sub-sections below. This is
      a comprehensive, but not exhaustive, list of approaches. </p><p>It should not be a surprise that secondary indexes require additional cluster space and
      processing. This is precisely what happens in an RDBMS because the act of creating an
      alternate index requires both space and processing cycles to update. RDBMS products are more
      advanced in this regard to handle alternative index management out of the box. However, HBase
      scales better at larger data volumes, so this is a feature trade-off. </p><p>Pay attention to <a class="xref" href="#performance" title="Chapter&nbsp;14.&nbsp;Apache HBase Performance Tuning">Chapter&nbsp;14, <i>Apache HBase Performance Tuning</i></a> when implementing any of these approaches.</p><p>Additionally, see the David Butler response in this dist-list thread <a class="link" href="http://search-hadoop.com/m/nvbiBp2TDP/Stargate%252Bhbase&amp;subj=Stargate+hbase" target="_top">HBase,
        mail # user - Stargate+hbase</a>
    </p><div class="section" title="6.9.1.&nbsp; Filter Query"><div class="titlepage"><div><div><h3 class="title"><a name="secondary.indexes.filter"></a>6.9.1.&nbsp; Filter Query </h3></div></div></div><p>Depending on the case, it may be appropriate to use <a class="xref" href="#client.filter" title="9.4.&nbsp;Client Request Filters">Section&nbsp;9.4, &#8220;Client Request Filters&#8221;</a>. In this case, no secondary index is created. However, don't
        try a full-scan on a large table like this from an application (i.e., single-threaded
        client). </p></div><div class="section" title="6.9.2.&nbsp; Periodic-Update Secondary Index"><div class="titlepage"><div><div><h3 class="title"><a name="secondary.indexes.periodic"></a>6.9.2.&nbsp; Periodic-Update Secondary Index </h3></div></div></div><p>A secondary index could be created in an other table which is periodically updated via a
        MapReduce job. The job could be executed intra-day, but depending on load-strategy it could
        still potentially be out of sync with the main data table.</p><p>See <a class="xref" href="#mapreduce.example.readwrite" title="7.8.2.&nbsp;HBase MapReduce Read/Write Example">Section&nbsp;7.8.2, &#8220;HBase MapReduce Read/Write Example&#8221;</a> for more information.</p></div><div class="section" title="6.9.3.&nbsp; Dual-Write Secondary Index"><div class="titlepage"><div><div><h3 class="title"><a name="secondary.indexes.dualwrite"></a>6.9.3.&nbsp; Dual-Write Secondary Index </h3></div></div></div><p>Another strategy is to build the secondary index while publishing data to the cluster
        (e.g., write to data table, write to index table). If this is approach is taken after a data
        table already exists, then bootstrapping will be needed for the secondary index with a
        MapReduce job (see <a class="xref" href="#secondary.indexes.periodic" title="6.9.2.&nbsp; Periodic-Update Secondary Index">Section&nbsp;6.9.2, &#8220; Periodic-Update Secondary Index &#8221;</a>).</p></div><div class="section" title="6.9.4.&nbsp; Summary Tables"><div class="titlepage"><div><div><h3 class="title"><a name="secondary.indexes.summary"></a>6.9.4.&nbsp; Summary Tables </h3></div></div></div><p>Where time-ranges are very wide (e.g., year-long report) and where the data is
        voluminous, summary tables are a common approach. These would be generated with MapReduce
        jobs into another table.</p><p>See <a class="xref" href="#mapreduce.example.summary" title="7.8.4.&nbsp;HBase MapReduce Summary to HBase Example">Section&nbsp;7.8.4, &#8220;HBase MapReduce Summary to HBase Example&#8221;</a> for more information.</p></div><div class="section" title="6.9.5.&nbsp; Coprocessor Secondary Index"><div class="titlepage"><div><div><h3 class="title"><a name="secondary.indexes.coproc"></a>6.9.5.&nbsp; Coprocessor Secondary Index </h3></div></div></div><p>Coprocessors act like RDBMS triggers. These were added in 0.92. For more information,
        see <a class="xref" href="#coprocessors" title="9.6.3.&nbsp;Coprocessors">Section&nbsp;9.6.3, &#8220;Coprocessors&#8221;</a>
      </p></div></div><div class="section" title="6.10.&nbsp;Constraints"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="constraints"></a>6.10.&nbsp;Constraints</h2></div></div></div><p>HBase currently supports 'constraints' in traditional (SQL) database parlance. The advised
      usage for Constraints is in enforcing business rules for attributes in the table (eg. make
      sure values are in the range 1-10). Constraints could also be used to enforce referential
      integrity, but this is strongly discouraged as it will dramatically decrease the write
      throughput of the tables where integrity checking is enabled. Extensive documentation on using
      Constraints can be found at: <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/constraint" target="_top">Constraint</a>
      since version 0.94. </p></div><div class="section" title="6.11.&nbsp;Schema Design Case Studies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="schema.casestudies"></a>6.11.&nbsp;Schema Design Case Studies</h2></div></div></div><p>The following will describe some typical data ingestion use-cases with HBase, and how the
      rowkey design and construction can be approached. Note: this is just an illustration of
      potential approaches, not an exhaustive list. Know your data, and know your processing
      requirements. </p><p>It is highly recommended that you read the rest of the <a class="xref" href="#schema" title="Chapter&nbsp;6.&nbsp;HBase and Schema Design">Chapter&nbsp;6, <i>HBase and Schema Design</i></a> first, before reading these case studies. </p><p>The following case studies are described: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Log Data / Timeseries Data</p></li><li class="listitem"><p>Log Data / Timeseries on Steroids</p></li><li class="listitem"><p>Customer/Order</p></li><li class="listitem"><p>Tall/Wide/Middle Schema Design</p></li><li class="listitem"><p>List Data</p></li></ul></div><div class="section" title="6.11.1.&nbsp;Case Study - Log Data and Timeseries Data"><div class="titlepage"><div><div><h3 class="title"><a name="schema.casestudies.log-timeseries"></a>6.11.1.&nbsp;Case Study - Log Data and Timeseries Data</h3></div></div></div><p>Assume that the following data elements are being collected. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Hostname</p></li><li class="listitem"><p>Timestamp</p></li><li class="listitem"><p>Log event</p></li><li class="listitem"><p>Value/message</p></li></ul></div><p>We can store them in an HBase table called LOG_DATA, but what will the rowkey be? From
        these attributes the rowkey will be some combination of hostname, timestamp, and log-event -
        but what specifically? </p><div class="section" title="6.11.1.1.&nbsp;Timestamp In The Rowkey Lead Position"><div class="titlepage"><div><div><h4 class="title"><a name="schema.casestudies.log-timeseries.tslead"></a>6.11.1.1.&nbsp;Timestamp In The Rowkey Lead Position</h4></div></div></div><p>The rowkey <code class="code">[timestamp][hostname][log-event]</code> suffers from the
          monotonically increasing rowkey problem described in <a class="xref" href="#timeseries" title="6.3.2.&nbsp; Monotonically Increasing Row Keys/Timeseries Data">Section&nbsp;6.3.2, &#8220; Monotonically Increasing Row Keys/Timeseries Data &#8221;</a>. </p><p>There is another pattern frequently mentioned in the dist-lists about &#8220;bucketing&#8221;
          timestamps, by performing a mod operation on the timestamp. If time-oriented scans are
          important, this could be a useful approach. Attention must be paid to the number of
          buckets, because this will require the same number of scans to return results.</p><pre class="programlisting">
long bucket = timestamp % numBuckets;
        </pre><p>&#8230; to construct:</p><pre class="programlisting">
[bucket][timestamp][hostname][log-event]
        </pre><p>As stated above, to select data for a particular timerange, a Scan will need to be
          performed for each bucket. 100 buckets, for example, will provide a wide distribution in
          the keyspace but it will require 100 Scans to obtain data for a single timestamp, so there
          are trade-offs. </p></div><div class="section" title="6.11.1.2.&nbsp;Host In The Rowkey Lead Position"><div class="titlepage"><div><div><h4 class="title"><a name="schema.casestudies.log-timeseries.hostlead"></a>6.11.1.2.&nbsp;Host In The Rowkey Lead Position</h4></div></div></div><p>The rowkey <code class="code">[hostname][log-event][timestamp]</code> is a candidate if there is a
          large-ish number of hosts to spread the writes and reads across the keyspace. This
          approach would be useful if scanning by hostname was a priority. </p></div><div class="section" title="6.11.1.3.&nbsp;Timestamp, or Reverse Timestamp?"><div class="titlepage"><div><div><h4 class="title"><a name="schema.casestudies.log-timeseries.revts"></a>6.11.1.3.&nbsp;Timestamp, or Reverse Timestamp?</h4></div></div></div><p>If the most important access path is to pull most recent events, then storing the
          timestamps as reverse-timestamps (e.g., <code class="code">timestamp = Long.MAX_VALUE &#8211;
            timestamp</code>) will create the property of being able to do a Scan on
            <code class="code">[hostname][log-event]</code> to obtain the quickly obtain the most recently
          captured events. </p><p>Neither approach is wrong, it just depends on what is most appropriate for the
          situation. </p><div class="note" title="Reverse Scan API" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Reverse Scan API</h3><p>
            <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4811" target="_top">HBASE-4811</a>
            implements an API to scan a table or a range within a table in reverse, reducing the
            need to optimize your schema for forward or reverse scanning. This feature is available
            in HBase 0.98 and later. See <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed%28boolean" target="_top">https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html#setReversed%28boolean</a>
            for more information. </p></div></div><div class="section" title="6.11.1.4.&nbsp;Variangle Length or Fixed Length Rowkeys?"><div class="titlepage"><div><div><h4 class="title"><a name="schema.casestudies.log-timeseries.varkeys"></a>6.11.1.4.&nbsp;Variangle Length or Fixed Length Rowkeys?</h4></div></div></div><p>It is critical to remember that rowkeys are stamped on every column in HBase. If the
          hostname is &#8220;a&#8221; and the event type is &#8220;e1&#8221; then the resulting rowkey would be quite small.
          However, what if the ingested hostname is &#8220;myserver1.mycompany.com&#8221; and the event type is
          &#8220;com.package1.subpackage2.subsubpackage3.ImportantService&#8221;? </p><p>It might make sense to use some substitution in the rowkey. There are at least two
          approaches: hashed and numeric. In the Hostname In The Rowkey Lead Position example, it
          might look like this: </p><p>Composite Rowkey With Hashes:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[MD5 hash of hostname] = 16 bytes</p></li><li class="listitem"><p>[MD5 hash of event-type] = 16 bytes</p></li><li class="listitem"><p>[timestamp] = 8 bytes</p></li></ul></div><p>Composite Rowkey With Numeric Substitution: </p><p>For this approach another lookup table would be needed in addition to LOG_DATA, called
          LOG_TYPES. The rowkey of LOG_TYPES would be: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[type] (e.g., byte indicating hostname vs. event-type)</p></li><li class="listitem"><p>[bytes] variable length bytes for raw hostname or event-type.</p></li></ul></div><p>A column for this rowkey could be a long with an assigned number, which could be
          obtained by using an <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#incrementColumnValue%28byte[],%20byte[],%20byte[],%20long%29" target="_top">HBase
            counter</a>. </p><p>So the resulting composite rowkey would be: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[substituted long for hostname] = 8 bytes</p></li><li class="listitem"><p>[substituted long for event type] = 8 bytes</p></li><li class="listitem"><p>[timestamp] = 8 bytes</p></li></ul></div><p>In either the Hash or Numeric substitution approach, the raw values for hostname and
          event-type can be stored as columns. </p></div></div><div class="section" title="6.11.2.&nbsp;Case Study - Log Data and Timeseries Data on Steroids"><div class="titlepage"><div><div><h3 class="title"><a name="schema.casestudies.log-steroids"></a>6.11.2.&nbsp;Case Study - Log Data and Timeseries Data on Steroids</h3></div></div></div><p>This effectively is the OpenTSDB approach. What OpenTSDB does is re-write data and pack
        rows into columns for certain time-periods. For a detailed explanation, see: <a class="link" href="http://opentsdb.net/schema.html" target="_top">http://opentsdb.net/schema.html</a>, and <a class="link" href="http://www.cloudera.com/content/cloudera/en/resources/library/hbasecon/video-hbasecon-2012-lessons-learned-from-opentsdb.html" target="_top">Lessons
          Learned from OpenTSDB</a> from HBaseCon2012. </p><p>But this is how the general concept works: data is ingested, for example, in this
        manner&#8230;</p><pre class="screen">
[hostname][log-event][timestamp1]
[hostname][log-event][timestamp2]
[hostname][log-event][timestamp3]
        </pre><p>&#8230; with separate rowkeys for each detailed event, but is re-written like this&#8230; </p><pre class="screen">[hostname][log-event][timerange]</pre><p>&#8230; and each of the above events are converted into columns stored with a time-offset
        relative to the beginning timerange (e.g., every 5 minutes). This is obviously a very
        advanced processing technique, but HBase makes this possible. </p></div><div class="section" title="6.11.3.&nbsp;Case Study - Customer/Order"><div class="titlepage"><div><div><h3 class="title"><a name="schema.casestudies.custorder"></a>6.11.3.&nbsp;Case Study - Customer/Order</h3></div></div></div><p>Assume that HBase is used to store customer and order information. There are two core
        record-types being ingested: a Customer record type, and Order record type. </p><p>The Customer record type would include all the things that you&#8217;d typically expect: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Customer number</p></li><li class="listitem"><p>Customer name</p></li><li class="listitem"><p>Address (e.g., city, state, zip)</p></li><li class="listitem"><p>Phone numbers, etc.</p></li></ul></div><p>The Order record type would include things like: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Customer number</p></li><li class="listitem"><p>Order number</p></li><li class="listitem"><p>Sales date</p></li><li class="listitem"><p>A series of nested objects for shipping locations and line-items (see <a class="xref" href="#schema.casestudies.custorder.obj" title="6.11.3.2.&nbsp;Order Object Design">Section&nbsp;6.11.3.2, &#8220;Order Object Design&#8221;</a> for details)</p></li></ul></div><p>Assuming that the combination of customer number and sales order uniquely identify an
        order, these two attributes will compose the rowkey, and specifically a composite key such
        as: </p><pre class="screen">[customer number][order number]</pre><p>&#8230; for a ORDER table. However, there are more design decisions to make: are the
          <span class="emphasis"><em>raw</em></span> values the best choices for rowkeys? </p><p>The same design questions in the Log Data use-case confront us here. What is the
        keyspace of the customer number, and what is the format (e.g., numeric? alphanumeric?) As it
        is advantageous to use fixed-length keys in HBase, as well as keys that can support a
        reasonable spread in the keyspace, similar options appear: </p><p>Composite Rowkey With Hashes: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[MD5 of customer number] = 16 bytes</p></li><li class="listitem"><p>[MD5 of order number] = 16 bytes</p></li></ul></div><p>Composite Numeric/Hash Combo Rowkey: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[substituted long for customer number] = 8 bytes</p></li><li class="listitem"><p>[MD5 of order number] = 16 bytes</p></li></ul></div><div class="section" title="6.11.3.1.&nbsp;Single Table? Multiple Tables?"><div class="titlepage"><div><div><h4 class="title"><a name="schema.casestudies.custorder.tables"></a>6.11.3.1.&nbsp;Single Table? Multiple Tables?</h4></div></div></div><p>A traditional design approach would have separate tables for CUSTOMER and SALES.
          Another option is to pack multiple record types into a single table (e.g., CUSTOMER++). </p><p>Customer Record Type Rowkey: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[customer-id]</p></li><li class="listitem"><p>[type] = type indicating &#8216;1&#8217; for customer record type</p></li></ul></div><p>Order Record Type Rowkey: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[customer-id]</p></li><li class="listitem"><p>[type] = type indicating &#8216;2&#8217; for order record type</p></li><li class="listitem"><p>[order]</p></li></ul></div><p>The advantage of this particular CUSTOMER++ approach is that organizes many different
          record-types by customer-id (e.g., a single scan could get you everything about that
          customer). The disadvantage is that it&#8217;s not as easy to scan for a particular record-type.
        </p></div><div class="section" title="6.11.3.2.&nbsp;Order Object Design"><div class="titlepage"><div><div><h4 class="title"><a name="schema.casestudies.custorder.obj"></a>6.11.3.2.&nbsp;Order Object Design</h4></div></div></div><p>Now we need to address how to model the Order object. Assume that the class structure
          is as follows:</p><div class="variablelist"><dl><dt><span class="term">Order</span></dt><dd><p>(an Order can have multiple ShippingLocations</p></dd><dt><span class="term">LineItem</span></dt><dd><p>(a ShippingLocation can have multiple LineItems</p></dd></dl></div><p>... there are multiple options on storing this data. </p><div class="section" title="6.11.3.2.1.&nbsp;Completely Normalized"><div class="titlepage"><div><div><h5 class="title"><a name="schema.casestudies.custorder.obj.norm"></a>6.11.3.2.1.&nbsp;Completely Normalized</h5></div></div></div><p>With this approach, there would be separate tables for ORDER, SHIPPING_LOCATION, and
            LINE_ITEM. </p><p>The ORDER table's rowkey was described above: <a class="xref" href="#schema.casestudies.custorder" title="6.11.3.&nbsp;Case Study - Customer/Order">Section&nbsp;6.11.3, &#8220;Case Study - Customer/Order&#8221;</a>
          </p><p>The SHIPPING_LOCATION's composite rowkey would be something like this: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[order-rowkey]</p></li><li class="listitem"><p>[shipping location number] (e.g., 1st location, 2nd, etc.)</p></li></ul></div><p>The LINE_ITEM table's composite rowkey would be something like this: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[order-rowkey]</p></li><li class="listitem"><p>[shipping location number] (e.g., 1st location, 2nd, etc.)</p></li><li class="listitem"><p>[line item number] (e.g., 1st lineitem, 2nd, etc.)</p></li></ul></div><p>Such a normalized model is likely to be the approach with an RDBMS, but that's not
            your only option with HBase. The cons of such an approach is that to retrieve
            information about any Order, you will need: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Get on the ORDER table for the Order</p></li><li class="listitem"><p>Scan on the SHIPPING_LOCATION table for that order to get the ShippingLocation
                instances</p></li><li class="listitem"><p>Scan on the LINE_ITEM for each ShippingLocation</p></li></ul></div><p>... granted, this is what an RDBMS would do under the covers anyway, but since there
            are no joins in HBase you're just more aware of this fact. </p></div><div class="section" title="6.11.3.2.2.&nbsp;Single Table With Record Types"><div class="titlepage"><div><div><h5 class="title"><a name="schema.casestudies.custorder.obj.rectype"></a>6.11.3.2.2.&nbsp;Single Table With Record Types</h5></div></div></div><p>With this approach, there would exist a single table ORDER that would contain </p><p>The Order rowkey was described above: <a class="xref" href="#schema.casestudies.custorder" title="6.11.3.&nbsp;Case Study - Customer/Order">Section&nbsp;6.11.3, &#8220;Case Study - Customer/Order&#8221;</a></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[order-rowkey]</p></li><li class="listitem"><p>[ORDER record type]</p></li></ul></div><p>The ShippingLocation composite rowkey would be something like this: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[order-rowkey]</p></li><li class="listitem"><p>[SHIPPING record type]</p></li><li class="listitem"><p>[shipping location number] (e.g., 1st location, 2nd, etc.)</p></li></ul></div><p>The LineItem composite rowkey would be something like this: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[order-rowkey]</p></li><li class="listitem"><p>[LINE record type]</p></li><li class="listitem"><p>[shipping location number] (e.g., 1st location, 2nd, etc.)</p></li><li class="listitem"><p>[line item number] (e.g., 1st lineitem, 2nd, etc.)</p></li></ul></div></div><div class="section" title="6.11.3.2.3.&nbsp;Denormalized"><div class="titlepage"><div><div><h5 class="title"><a name="schema.casestudies.custorder.obj.denorm"></a>6.11.3.2.3.&nbsp;Denormalized</h5></div></div></div><p>A variant of the Single Table With Record Types approach is to denormalize and
            flatten some of the object hierarchy, such as collapsing the ShippingLocation attributes
            onto each LineItem instance. </p><p>The LineItem composite rowkey would be something like this: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>[order-rowkey]</p></li><li class="listitem"><p>[LINE record type]</p></li><li class="listitem"><p>[line item number] (e.g., 1st lineitem, 2nd, etc. - care must be taken that
                there are unique across the entire order)</p></li></ul></div><p>... and the LineItem columns would be something like this: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>itemNumber</p></li><li class="listitem"><p>quantity</p></li><li class="listitem"><p>price</p></li><li class="listitem"><p>shipToLine1 (denormalized from ShippingLocation)</p></li><li class="listitem"><p>shipToLine2 (denormalized from ShippingLocation)</p></li><li class="listitem"><p>shipToCity (denormalized from ShippingLocation)</p></li><li class="listitem"><p>shipToState (denormalized from ShippingLocation)</p></li><li class="listitem"><p>shipToZip (denormalized from ShippingLocation)</p></li></ul></div><p>The pros of this approach include a less complex object heirarchy, but one of the
            cons is that updating gets more complicated in case any of this information changes.
          </p></div><div class="section" title="6.11.3.2.4.&nbsp;Object BLOB"><div class="titlepage"><div><div><h5 class="title"><a name="schema.casestudies.custorder.obj.singleobj"></a>6.11.3.2.4.&nbsp;Object BLOB</h5></div></div></div><p>With this approach, the entire Order object graph is treated, in one way or another,
            as a BLOB. For example, the ORDER table's rowkey was described above: <a class="xref" href="#schema.casestudies.custorder" title="6.11.3.&nbsp;Case Study - Customer/Order">Section&nbsp;6.11.3, &#8220;Case Study - Customer/Order&#8221;</a>, and a single column called "order" would
            contain an object that could be deserialized that contained a container Order,
            ShippingLocations, and LineItems. </p><p>There are many options here: JSON, XML, Java Serialization, Avro, Hadoop Writables,
            etc. All of them are variants of the same approach: encode the object graph to a
            byte-array. Care should be taken with this approach to ensure backward compatibilty in
            case the object model changes such that older persisted structures can still be read
            back out of HBase. </p><p>Pros are being able to manage complex object graphs with minimal I/O (e.g., a single
            HBase Get per Order in this example), but the cons include the aforementioned warning
            about backward compatiblity of serialization, language dependencies of serialization
            (e.g., Java Serialization only works with Java clients), the fact that you have to
            deserialize the entire object to get any piece of information inside the BLOB, and the
            difficulty in getting frameworks like Hive to work with custom objects like this.
          </p></div></div></div><div class="section" title="6.11.4.&nbsp;Case Study - &#34;Tall/Wide/Middle&#34; Schema Design Smackdown"><div class="titlepage"><div><div><h3 class="title"><a name="schema.smackdown"></a>6.11.4.&nbsp;Case Study - "Tall/Wide/Middle" Schema Design Smackdown</h3></div></div></div><p>This section will describe additional schema design questions that appear on the
        dist-list, specifically about tall and wide tables. These are general guidelines and not
        laws - each application must consider its own needs. </p><div class="section" title="6.11.4.1.&nbsp;Rows vs. Versions"><div class="titlepage"><div><div><h4 class="title"><a name="schema.smackdown.rowsversions"></a>6.11.4.1.&nbsp;Rows vs. Versions</h4></div></div></div><p>A common question is whether one should prefer rows or HBase's built-in-versioning.
          The context is typically where there are "a lot" of versions of a row to be retained
          (e.g., where it is significantly above the HBase default of 1 max versions). The
          rows-approach would require storing a timestamp in some portion of the rowkey so that they
          would not overwite with each successive update. </p><p>Preference: Rows (generally speaking). </p></div><div class="section" title="6.11.4.2.&nbsp;Rows vs. Columns"><div class="titlepage"><div><div><h4 class="title"><a name="schema.smackdown.rowscols"></a>6.11.4.2.&nbsp;Rows vs. Columns</h4></div></div></div><p>Another common question is whether one should prefer rows or columns. The context is
          typically in extreme cases of wide tables, such as having 1 row with 1 million attributes,
          or 1 million rows with 1 columns apiece. </p><p>Preference: Rows (generally speaking). To be clear, this guideline is in the context
          is in extremely wide cases, not in the standard use-case where one needs to store a few
          dozen or hundred columns. But there is also a middle path between these two options, and
          that is "Rows as Columns." </p></div><div class="section" title="6.11.4.3.&nbsp;Rows as Columns"><div class="titlepage"><div><div><h4 class="title"><a name="schema.smackdown.rowsascols"></a>6.11.4.3.&nbsp;Rows as Columns</h4></div></div></div><p>The middle path between Rows vs. Columns is packing data that would be a separate row
          into columns, for certain rows. OpenTSDB is the best example of this case where a single
          row represents a defined time-range, and then discrete events are treated as columns. This
          approach is often more complex, and may require the additional complexity of re-writing
          your data, but has the advantage of being I/O efficient. For an overview of this approach,
          see <a class="xref" href="#schema.casestudies.log-steroids" title="6.11.2.&nbsp;Case Study - Log Data and Timeseries Data on Steroids">Section&nbsp;6.11.2, &#8220;Case Study - Log Data and Timeseries Data on Steroids&#8221;</a>. </p></div></div><div class="section" title="6.11.5.&nbsp;Case Study - List Data"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.schema.listdata"></a>6.11.5.&nbsp;Case Study - List Data</h3></div></div></div><p>The following is an exchange from the user dist-list regarding a fairly common question:
        how to handle per-user list data in Apache HBase. </p><p>*** QUESTION ***</p><p> We're looking at how to store a large amount of (per-user) list data in HBase, and we
        were trying to figure out what kind of access pattern made the most sense. One option is
        store the majority of the data in a key, so we could have something like: </p><pre class="programlisting">
&lt;FixedWidthUserName&gt;&lt;FixedWidthValueId1&gt;:"" (no value)
&lt;FixedWidthUserName&gt;&lt;FixedWidthValueId2&gt;:"" (no value)
&lt;FixedWidthUserName&gt;&lt;FixedWidthValueId3&gt;:"" (no value)
</pre><p>The other option we had was to do this entirely using:</p><pre class="programlisting">
&lt;FixedWidthUserName&gt;&lt;FixedWidthPageNum0&gt;:&lt;FixedWidthLength&gt;&lt;FixedIdNextPageNum&gt;&lt;ValueId1&gt;&lt;ValueId2&gt;&lt;ValueId3&gt;...
&lt;FixedWidthUserName&gt;&lt;FixedWidthPageNum1&gt;:&lt;FixedWidthLength&gt;&lt;FixedIdNextPageNum&gt;&lt;ValueId1&gt;&lt;ValueId2&gt;&lt;ValueId3&gt;...
    		</pre><p> where each row would contain multiple values. So in one case reading the first thirty
        values would be: </p><pre class="programlisting">
scan { STARTROW =&gt; 'FixedWidthUsername' LIMIT =&gt; 30}
    		</pre><p>And in the second case it would be </p><pre class="programlisting">
get 'FixedWidthUserName\x00\x00\x00\x00'
    		</pre><p> The general usage pattern would be to read only the first 30 values of these lists,
        with infrequent access reading deeper into the lists. Some users would have &lt;= 30 total
        values in these lists, and some users would have millions (i.e. power-law distribution) </p><p> The single-value format seems like it would take up more space on HBase, but would
        offer some improved retrieval / pagination flexibility. Would there be any significant
        performance advantages to be able to paginate via gets vs paginating with scans? </p><p> My initial understanding was that doing a scan should be faster if our paging size is
        unknown (and caching is set appropriately), but that gets should be faster if we'll always
        need the same page size. I've ended up hearing different people tell me opposite things
        about performance. I assume the page sizes would be relatively consistent, so for most use
        cases we could guarantee that we only wanted one page of data in the fixed-page-length case.
        I would also assume that we would have infrequent updates, but may have inserts into the
        middle of these lists (meaning we'd need to update all subsequent rows). </p><p> Thanks for help / suggestions / follow-up questions. </p><p>*** ANSWER ***</p><p> If I understand you correctly, you're ultimately trying to store triples in the form
        "user, valueid, value", right? E.g., something like: </p><pre class="programlisting">
"user123, firstname, Paul",
"user234, lastname, Smith"
			</pre><p> (But the usernames are fixed width, and the valueids are fixed width). </p><p> And, your access pattern is along the lines of: "for user X, list the next 30 values,
        starting with valueid Y". Is that right? And these values should be returned sorted by
        valueid? </p><p> The tl;dr version is that you should probably go with one row per user+value, and not
        build a complicated intra-row pagination scheme on your own unless you're really sure it is
        needed. </p><p> Your two options mirror a common question people have when designing HBase schemas:
        should I go "tall" or "wide"? Your first schema is "tall": each row represents one value for
        one user, and so there are many rows in the table for each user; the row key is user +
        valueid, and there would be (presumably) a single column qualifier that means "the value".
        This is great if you want to scan over rows in sorted order by row key (thus my question
        above, about whether these ids are sorted correctly). You can start a scan at any
        user+valueid, read the next 30, and be done. What you're giving up is the ability to have
        transactional guarantees around all the rows for one user, but it doesn't sound like you
        need that. Doing it this way is generally recommended (see here <a class="link" href="http://hbase.apache.org/book.html#schema.smackdown" target="_top">http://hbase.apache.org/book.html#schema.smackdown</a>). </p><p> Your second option is "wide": you store a bunch of values in one row, using different
        qualifiers (where the qualifier is the valueid). The simple way to do that would be to just
        store ALL values for one user in a single row. I'm guessing you jumped to the "paginated"
        version because you're assuming that storing millions of columns in a single row would be
        bad for performance, which may or may not be true; as long as you're not trying to do too
        much in a single request, or do things like scanning over and returning all of the cells in
        the row, it shouldn't be fundamentally worse. The client has methods that allow you to get
        specific slices of columns. </p><p> Note that neither case fundamentally uses more disk space than the other; you're just
        "shifting" part of the identifying information for a value either to the left (into the row
        key, in option one) or to the right (into the column qualifiers in option 2). Under the
        covers, every key/value still stores the whole row key, and column family name. (If this is
        a bit confusing, take an hour and watch Lars George's excellent video about understanding
        HBase schema design: <a class="link" href="http://www.youtube.com/watch?v=_HLoH_PgrLk)" target="_top">http://www.youtube.com/watch?v=_HLoH_PgrLk)</a>. </p><p> A manually paginated version has lots more complexities, as you note, like having to
        keep track of how many things are in each page, re-shuffling if new values are inserted,
        etc. That seems significantly more complex. It might have some slight speed advantages (or
        disadvantages!) at extremely high throughput, and the only way to really know that would be
        to try it out. If you don't have time to build it both ways and compare, my advice would be
        to start with the simplest option (one row per user+value). Start simple and iterate! :)
      </p></div></div><div class="section" title="6.12.&nbsp;Operational and Performance Configuration Options"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="schema.ops"></a>6.12.&nbsp;Operational and Performance Configuration Options</h2></div></div></div><p>See the Performance section <a class="xref" href="#perf.schema" title="14.6.&nbsp;Schema Design">Section&nbsp;14.6, &#8220;Schema Design&#8221;</a> for more information operational and performance schema design
      options, such as Bloom Filters, Table-configured regionsizes, compression, and blocksizes.
    </p></div></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;HBase and MapReduce"><div class="titlepage"><div><div><h2 class="title"><a name="mapreduce"></a>Chapter&nbsp;7.&nbsp;HBase and MapReduce</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#hbase.mapreduce.classpath">7.1. HBase, MapReduce, and the CLASSPATH</a></span></dt><dt><span class="section"><a href="#d2875e7384">7.2. MapReduce Scan Caching</a></span></dt><dt><span class="section"><a href="#d2875e7426">7.3. Bundled HBase MapReduce Jobs</a></span></dt><dt><span class="section"><a href="#d2875e7445">7.4. HBase as a MapReduce Job Data Source and Data Sink</a></span></dt><dt><span class="section"><a href="#d2875e7498">7.5. Writing HFiles Directly During Bulk Import</a></span></dt><dt><span class="section"><a href="#d2875e7505">7.6. RowCounter Example</a></span></dt><dt><span class="section"><a href="#splitter">7.7. Map-Task Splitting</a></span></dt><dd><dl><dt><span class="section"><a href="#splitter.default">7.7.1. The Default HBase MapReduce Splitter</a></span></dt><dt><span class="section"><a href="#splitter.custom">7.7.2. Custom Splitters</a></span></dt></dl></dd><dt><span class="section"><a href="#mapreduce.example">7.8. HBase MapReduce Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#mapreduce.example.read">7.8.1. HBase MapReduce Read Example</a></span></dt><dt><span class="section"><a href="#mapreduce.example.readwrite">7.8.2. HBase MapReduce Read/Write Example</a></span></dt><dt><span class="section"><a href="#mapreduce.example.readwrite.multi">7.8.3. HBase MapReduce Read/Write Example With Multi-Table Output</a></span></dt><dt><span class="section"><a href="#mapreduce.example.summary">7.8.4. HBase MapReduce Summary to HBase Example</a></span></dt><dt><span class="section"><a href="#mapreduce.example.summary.file">7.8.5. HBase MapReduce Summary to File Example</a></span></dt><dt><span class="section"><a href="#mapreduce.example.summary.noreducer">7.8.6. HBase MapReduce Summary to HBase Without Reducer</a></span></dt><dt><span class="section"><a href="#mapreduce.example.summary.rdbms">7.8.7. HBase MapReduce Summary to RDBMS</a></span></dt></dl></dd><dt><span class="section"><a href="#mapreduce.htable.access">7.9. Accessing Other HBase Tables in a MapReduce Job</a></span></dt><dt><span class="section"><a href="#mapreduce.specex">7.10. Speculative Execution</a></span></dt></dl></div><p>Apache MapReduce is a software framework used to analyze large amounts of data, and is
      the framework used most often with <a class="link" href="http://hadoop.apache.org/" target="_top">Apache Hadoop</a>. MapReduce itself is out of the
      scope of this document. A good place to get started with MapReduce is <a class="link" href="http://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html" target="_top">http://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html</a>. MapReduce version
      2 (MR2)is now part of <a class="link" href="http://hadoop.apache.org/docs/r2.3.0/hadoop-yarn/hadoop-yarn-site/" target="_top">YARN</a>. </p><p> This chapter discusses specific configuration steps you need to take to use MapReduce on
      data within HBase. In addition, it discusses other interactions and issues between HBase and
      MapReduce jobs.
      </p><div class="note" title="mapred and mapreduce" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">mapred and mapreduce</h3><p>There are two mapreduce packages in HBase as in MapReduce itself: <code class="filename">org.apache.hadoop.hbase.mapred</code>
      and <code class="filename">org.apache.hadoop.hbase.mapreduce</code>. The former does old-style API and the latter
      the new style.  The latter has more facility though you can usually find an equivalent in the older
      package.  Pick the package that goes with your mapreduce deploy.  When in doubt or starting over, pick the
      <code class="filename">org.apache.hadoop.hbase.mapreduce</code>.  In the notes below, we refer to
      o.a.h.h.mapreduce but replace with the o.a.h.h.mapred if that is what you are using.
      </p></div><p> 
    </p><div class="section" title="7.1.&nbsp;HBase, MapReduce, and the CLASSPATH"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.mapreduce.classpath"></a>7.1.&nbsp;HBase, MapReduce, and the CLASSPATH</h2></div></div></div><p>Ny default, MapReduce jobs deployed to a MapReduce cluster do not have access to either
        the HBase configuration under <code class="envar">$HBASE_CONF_DIR</code> or the HBase classes.</p><p>To give the MapReduce jobs the access they need, you could add
          <code class="filename">hbase-site.xml</code> to the
            <code class="filename"><em class="replaceable"><code>$HADOOP_HOME</code></em>/conf/</code> directory and add the
        HBase JARs to the <code class="filename"><em class="replaceable"><code>HADOOP_HOME</code></em>/conf/</code>
        directory, then copy these changes across your cluster. You could add hbase-site.xml to
        $HADOOP_HOME/conf and add HBase jars to the $HADOOP_HOME/lib. You would then need to copy
        these changes across your cluster or edit
          <code class="filename"><em class="replaceable"><code>$HADOOP_HOME</code></em>conf/hadoop-env.sh</code> and add
        them to the <code class="envar">HADOOP_CLASSPATH</code> variable. However, this approach is not
        recommended because it will pollute your Hadoop install with HBase references. It also
        requires you to restart the Hadoop cluster before Hadoop can use the HBase data.</p><p> Since HBase 0.90.x, HBase adds its dependency JARs to the job configuration itself. The
        dependencies only need to be available on the local CLASSPATH. The following example runs
        the bundled HBase <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html" target="_top">RowCounter</a>
        MapReduce job against a table named <code class="systemitem">usertable</code> If you have not set
        the environment variables expected in the command (the parts prefixed by a
          <code class="literal">$</code> sign and curly braces), you can use the actual system paths instead.
        Be sure to use the correct version of the HBase JAR for your system. The backticks
          (<code class="literal">`</code> symbols) cause ths shell to execute the sub-commands, setting the
        CLASSPATH as part of the command. This example assumes you use a BASH-compatible shell. </p><pre class="screen">$ <strong class="userinput"><code>HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar rowcounter usertable</code></strong></pre><p>When the command runs, internally, the HBase JAR finds the dependencies it needs for
        zookeeper, guava, and its other dependencies on the passed <code class="envar">HADOOP_CLASSPATH</code>
        and adds the JARs to the MapReduce job configuration. See the source at
        TableMapReduceUtil#addDependencyJars(org.apache.hadoop.mapreduce.Job) for how this is done. </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> The example may not work if you are running HBase from its build directory rather
          than an installed location. You may see an error like the following:</p><pre class="screen">java.lang.RuntimeException: java.lang.ClassNotFoundException: org.apache.hadoop.hbase.mapreduce.RowCounter$RowCounterMapper</pre><p>If this occurs, try modifying the command as follows, so that it uses the HBase JARs
          from the <code class="filename">target/</code> directory within the build environment.</p><pre class="screen">$ <strong class="userinput"><code>HADOOP_CLASSPATH=${HBASE_HOME}/hbase-server/target/hbase-server-VERSION-SNAPSHOT.jar:`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server/target/hbase-server-VERSION-SNAPSHOT.jar rowcounter usertable</code></strong></pre></div><div class="caution" title="Notice to Mapreduce users of HBase 0.96.1 and above" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Notice to Mapreduce users of HBase 0.96.1 and above</h3><p>Some mapreduce jobs that use HBase fail to launch. The symptom is an exception similar
          to the following:</p><pre class="screen">
Exception in thread "main" java.lang.IllegalAccessError: class
    com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass
    com.google.protobuf.LiteralByteString
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:792)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    at
    org.apache.hadoop.hbase.protobuf.ProtobufUtil.toScan(ProtobufUtil.java:818)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.convertScanToString(TableMapReduceUtil.java:433)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:186)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:147)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:270)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:100)
...
</pre><p>This is caused by an optimization introduced in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-9867" target="_top">HBASE-9867</a> that
          inadvertently introduced a classloader dependency. </p><p>This affects both jobs using the <code class="code">-libjars</code> option and "fat jar," those
          which package their runtime dependencies in a nested <code class="code">lib</code> folder.</p><p>In order to satisfy the new classloader requirements, hbase-protocol.jar must be
          included in Hadoop's classpath. See <a class="xref" href="#hbase.mapreduce.classpath" title="7.1.&nbsp;HBase, MapReduce, and the CLASSPATH">Section&nbsp;7.1, &#8220;HBase, MapReduce, and the CLASSPATH&#8221;</a> for current recommendations for resolving
          classpath errors. The following is included for historical purposes.</p><p>This can be resolved system-wide by including a reference to the hbase-protocol.jar in
          hadoop's lib directory, via a symlink or by copying the jar into the new location.</p><p>This can also be achieved on a per-job launch basis by including it in the
            <code class="code">HADOOP_CLASSPATH</code> environment variable at job submission time. When
          launching jobs that package their dependencies, all three of the following job launching
          commands satisfy this requirement:</p><pre class="screen">
$ <strong class="userinput"><code>HADOOP_CLASSPATH=/path/to/hbase-protocol.jar:/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass</code></strong>
$ <strong class="userinput"><code>HADOOP_CLASSPATH=$(hbase mapredcp):/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass</code></strong>
$ <strong class="userinput"><code>HADOOP_CLASSPATH=$(hbase classpath) hadoop jar MyJob.jar MyJobMainClass</code></strong>
        </pre><p>For jars that do not package their dependencies, the following command structure is
          necessary:</p><pre class="screen">
$ <strong class="userinput"><code>HADOOP_CLASSPATH=$(hbase mapredcp):/etc/hbase/conf hadoop jar MyApp.jar MyJobMainClass -libjars $(hbase mapredcp | tr ':' ',')</code></strong> ...
        </pre><p>See also <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10304" target="_top">HBASE-10304</a> for
          further discussion of this issue.</p></div></div><div class="section" title="7.2.&nbsp;MapReduce Scan Caching"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e7384"></a>7.2.&nbsp;MapReduce Scan Caching</h2></div></div></div><p>TableMapReduceUtil now restores the option to set scanner caching (the number of rows
        which are cached before returning the result to the client) on the Scan object that is
        passed in. This functionality was lost due to a bug in HBase 0.95 (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-11558" target="_top">HBASE-11558</a>), which
        is fixed for HBase 0.98.5 and 0.96.3. The priority order for choosing the scanner caching is
        as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Caching settings which are set on the scan object.</p></li><li class="listitem"><p>Caching settings which are specified via the configuration option
              <code class="option">hbase.client.scanner.caching</code>, which can either be set manually in
              <code class="filename">hbase-site.xml</code> or via the helper method
              <code class="code">TableMapReduceUtil.setScannerCaching()</code>.</p></li><li class="listitem"><p>The default value <code class="code">HConstants.DEFAULT_HBASE_CLIENT_SCANNER_CACHING</code>, which is set to
            <code class="literal">100</code>.</p></li></ol></div><p>Optimizing the caching settings is a balance between the time the client waits for a
        result and the number of sets of results the client needs to receive. If the caching setting
        is too large, the client could end up waiting for a long time or the request could even time
        out. If the setting is too small, the scan needs to return results in several pieces.
        If you think of the scan as a shovel, a bigger cache setting is analogous to a bigger
        shovel, and a smaller cache setting is equivalent to more shoveling in order to fill the
        bucket.</p><p>The list of priorities mentioned above allows you to set a reasonable default, and
        override it for specific operations.</p><p>See the API documentation for <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a> for more details.</p></div><div class="section" title="7.3.&nbsp;Bundled HBase MapReduce Jobs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e7426"></a>7.3.&nbsp;Bundled HBase MapReduce Jobs</h2></div></div></div><p>The HBase JAR also serves as a Driver for some bundled mapreduce jobs. To learn about
        the bundled MapReduce jobs, run the following command.</p><pre class="screen">$ <strong class="userinput"><code>${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar</code></strong>
<code class="computeroutput">An example program must be given as the first argument.
Valid program names are:
  copytable: Export a table from local cluster to peer cluster
  completebulkload: Complete a bulk data load.
  export: Write table data to HDFS.
  import: Import data written by Export.
  importtsv: Import data in TSV format.
  rowcounter: Count rows in HBase table</code>
    </pre><p>Each of the valid program names are bundled MapReduce jobs. To run one of the jobs,
        model your command after the following example.</p><pre class="screen">$ <strong class="userinput"><code>${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar rowcounter myTable</code></strong></pre></div><div class="section" title="7.4.&nbsp;HBase as a MapReduce Job Data Source and Data Sink"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e7445"></a>7.4.&nbsp;HBase as a MapReduce Job Data Source and Data Sink</h2></div></div></div><p>HBase can be used as a data source, <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html" target="_top">TableInputFormat</a>,
        and data sink, <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html" target="_top">TableOutputFormat</a>
        or <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.html" target="_top">MultiTableOutputFormat</a>,
        for MapReduce jobs. Writing MapReduce jobs that read or write HBase, it is advisable to
        subclass <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html" target="_top">TableMapper</a>
        and/or <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableReducer.html" target="_top">TableReducer</a>.
        See the do-nothing pass-through classes <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableMapper.html" target="_top">IdentityTableMapper</a>
        and <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableReducer.html" target="_top">IdentityTableReducer</a>
        for basic usage. For a more involved example, see <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html" target="_top">RowCounter</a>
        or review the <code class="code">org.apache.hadoop.hbase.mapreduce.TestTableMapReduce</code> unit test. </p><p>If you run MapReduce jobs that use HBase as source or sink, need to specify source and
        sink table and column names in your configuration.</p><p>When you read from HBase, the <code class="code">TableInputFormat</code> requests the list of regions
        from HBase and makes a map, which is either a <code class="code">map-per-region</code> or
          <code class="code">mapreduce.job.maps</code> map, whichever is smaller. If your job only has two maps,
        raise <code class="code">mapreduce.job.maps</code> to a number greater than the number of regions. Maps
        will run on the adjacent TaskTracker if you are running a TaskTracer and RegionServer per
        node. When writing to HBase, it may make sense to avoid the Reduce step and write back into
        HBase from within your map. This approach works when your job does not need the sort and
        collation that MapReduce does on the map-emitted data. On insert, HBase 'sorts' so there is
        no point double-sorting (and shuffling data around your MapReduce cluster) unless you need
        to. If you do not need the Reduce, you myour map might emit counts of records processed for
        reporting at the end of the jobj, or set the number of Reduces to zero and use
        TableOutputFormat. If running the Reduce step makes sense in your case, you should typically
        use multiple reducers so that load is spread across the HBase cluster.</p><p>A new HBase partitioner, the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/HRegionPartitioner.html" target="_top">HRegionPartitioner</a>,
        can run as many reducers the number of existing regions. The HRegionPartitioner is suitable
        when your table is large and your upload will not greatly alter the number of existing
        regions upon completion. Otherwise use the default partitioner. </p></div><div class="section" title="7.5.&nbsp;Writing HFiles Directly During Bulk Import"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e7498"></a>7.5.&nbsp;Writing HFiles Directly During Bulk Import</h2></div></div></div><p>If you are importing into a new table, you can bypass the HBase API and write your
        content directly to the filesystem, formatted into HBase data files (HFiles). Your import
        will run faster, perhaps an order of magnitude faster. For more on how this mechanism works,
        see <a class="xref" href="#arch.bulk.load" title="9.8.&nbsp;Bulk Loading">Section&nbsp;9.8, &#8220;Bulk Loading&#8221;</a>.</p></div><div class="section" title="7.6.&nbsp;RowCounter Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e7505"></a>7.6.&nbsp;RowCounter Example</h2></div></div></div><p>The included <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html" target="_top">RowCounter</a>
        MapReduce job uses <code class="code">TableInputFormat</code> and does a count of all rows in the specified
        table. To run it, use the following command: </p><pre class="screen">$ <strong class="userinput"><code>./bin/hadoop jar hbase-X.X.X.jar</code></strong></pre><p>This will
        invoke the HBase MapReduce Driver class. Select <code class="literal">rowcounter</code> from the choice of jobs
        offered. This will print rowcouner usage advice to standard output. Specify the tablename,
        column to count, and output
        directory. If you have classpath errors, see <a class="xref" href="#hbase.mapreduce.classpath" title="7.1.&nbsp;HBase, MapReduce, and the CLASSPATH">Section&nbsp;7.1, &#8220;HBase, MapReduce, and the CLASSPATH&#8221;</a>.</p></div><div class="section" title="7.7.&nbsp;Map-Task Splitting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="splitter"></a>7.7.&nbsp;Map-Task Splitting</h2></div></div></div><div class="section" title="7.7.1.&nbsp;The Default HBase MapReduce Splitter"><div class="titlepage"><div><div><h3 class="title"><a name="splitter.default"></a>7.7.1.&nbsp;The Default HBase MapReduce Splitter</h3></div></div></div><p>When <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html" target="_top">TableInputFormat</a>
          is used to source an HBase table in a MapReduce job, its splitter will make a map task for
          each region of the table. Thus, if there are 100 regions in the table, there will be 100
          map-tasks for the job - regardless of how many column families are selected in the
          Scan.</p></div><div class="section" title="7.7.2.&nbsp;Custom Splitters"><div class="titlepage"><div><div><h3 class="title"><a name="splitter.custom"></a>7.7.2.&nbsp;Custom Splitters</h3></div></div></div><p>For those interested in implementing custom splitters, see the method
            <code class="code">getSplits</code> in <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.html" target="_top">TableInputFormatBase</a>.
          That is where the logic for map-task assignment resides. </p></div></div><div class="section" title="7.8.&nbsp;HBase MapReduce Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapreduce.example"></a>7.8.&nbsp;HBase MapReduce Examples</h2></div></div></div><div class="section" title="7.8.1.&nbsp;HBase MapReduce Read Example"><div class="titlepage"><div><div><h3 class="title"><a name="mapreduce.example.read"></a>7.8.1.&nbsp;HBase MapReduce Read Example</h3></div></div></div><p>The following is an example of using HBase as a MapReduce source in read-only manner.
          Specifically, there is a Mapper instance but no Reducer, and nothing is being emitted from
          the Mapper. There job would be defined as follows...</p><pre class="programlisting">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config, "ExampleRead");
job.setJarByClass(MyReadJob.class);     // class that contains mapper

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs
...

TableMapReduceUtil.initTableMapperJob(
  tableName,        // input HBase table name
  scan,             // Scan instance to control CF and attribute selection
  MyMapper.class,   // mapper
  null,             // mapper output key
  null,             // mapper output value
  job);
job.setOutputFormatClass(NullOutputFormat.class);   // because we aren't emitting anything from mapper

boolean b = job.waitForCompletion(true);
if (!b) {
  throw new IOException("error with job!");
}
  </pre><p>...and the mapper instance would extend <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html" target="_top">TableMapper</a>...</p><pre class="programlisting">
public static class MyMapper extends TableMapper&lt;Text, Text&gt; {

  public void map(ImmutableBytesWritable row, Result value, Context context) throws InterruptedException, IOException {
    // process data for the row from the Result instance.
   }
}
    </pre></div><div class="section" title="7.8.2.&nbsp;HBase MapReduce Read/Write Example"><div class="titlepage"><div><div><h3 class="title"><a name="mapreduce.example.readwrite"></a>7.8.2.&nbsp;HBase MapReduce Read/Write Example</h3></div></div></div><p>The following is an example of using HBase both as a source and as a sink with
          MapReduce. This example will simply copy data from one table to another.</p><pre class="programlisting">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleReadWrite");
job.setJarByClass(MyReadWriteJob.class);    // class that contains mapper

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,      // input table
	scan,	          // Scan instance to control CF and attribute selection
	MyMapper.class,   // mapper class
	null,	          // mapper output key
	null,	          // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,      // output table
	null,             // reducer class
	job);
job.setNumReduceTasks(0);

boolean b = job.waitForCompletion(true);
if (!b) {
    throw new IOException("error with job!");
}
    </pre><p>An explanation is required of what <code class="classname">TableMapReduceUtil</code> is doing,
          especially with the reducer. <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html" target="_top">TableOutputFormat</a>
          is being used as the outputFormat class, and several parameters are being set on the
          config (e.g., TableOutputFormat.OUTPUT_TABLE), as well as setting the reducer output key
          to <code class="classname">ImmutableBytesWritable</code> and reducer value to
            <code class="classname">Writable</code>. These could be set by the programmer on the job and
          conf, but <code class="classname">TableMapReduceUtil</code> tries to make things easier.</p><p>The following is the example mapper, which will create a <code class="classname">Put</code>
          and matching the input <code class="classname">Result</code> and emit it. Note: this is what the
          CopyTable utility does. </p><pre class="programlisting">
public static class MyMapper extends TableMapper&lt;ImmutableBytesWritable, Put&gt;  {

	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
		// this example is just copying the data from the source table...
   		context.write(row, resultToPut(row,value));
   	}

  	private static Put resultToPut(ImmutableBytesWritable key, Result result) throws IOException {
  		Put put = new Put(key.get());
 		for (KeyValue kv : result.raw()) {
			put.add(kv);
		}
		return put;
   	}
}
    </pre><p>There isn't actually a reducer step, so <code class="classname">TableOutputFormat</code> takes
          care of sending the <code class="classname">Put</code> to the target table. </p><p>This is just an example, developers could choose not to use
            <code class="classname">TableOutputFormat</code> and connect to the target table themselves.
        </p></div><div class="section" title="7.8.3.&nbsp;HBase MapReduce Read/Write Example With Multi-Table Output"><div class="titlepage"><div><div><h3 class="title"><a name="mapreduce.example.readwrite.multi"></a>7.8.3.&nbsp;HBase MapReduce Read/Write Example With Multi-Table Output</h3></div></div></div><p>TODO: example for <code class="classname">MultiTableOutputFormat</code>. </p></div><div class="section" title="7.8.4.&nbsp;HBase MapReduce Summary to HBase Example"><div class="titlepage"><div><div><h3 class="title"><a name="mapreduce.example.summary"></a>7.8.4.&nbsp;HBase MapReduce Summary to HBase Example</h3></div></div></div><p>The following example uses HBase as a MapReduce source and sink with a summarization
          step. This example will count the number of distinct instances of a value in a table and
          write those summarized counts in another table.
          </p><pre class="programlisting">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummary");
job.setJarByClass(MySummaryJob.class);     // class that contains mapper and reducer

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,        // output table
	MyTableReducer.class,    // reducer class
	job);
job.setNumReduceTasks(1);   // at least one, adjust as required

boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}
    </pre><p>
          In this example mapper a column with a String-value is chosen as the value to summarize
          upon. This value is used as the key to emit from the mapper, and an
            <code class="classname">IntWritable</code> represents an instance counter.
          </p><pre class="programlisting">
public static class MyMapper extends TableMapper&lt;Text, IntWritable&gt;  {
	public static final byte[] CF = "cf".getBytes();
	public static final byte[] ATTR1 = "attr1".getBytes();

	private final IntWritable ONE = new IntWritable(1);
   	private Text text = new Text();

   	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
        	String val = new String(value.getValue(CF, ATTR1));
          	text.set(val);     // we can only emit Writables...

        	context.write(text, ONE);
   	}
}
    </pre><p>
          In the reducer, the "ones" are counted (just like any other MR example that does this),
          and then emits a <code class="classname">Put</code>.
          </p><pre class="programlisting">
public static class MyTableReducer extends TableReducer&lt;Text, IntWritable, ImmutableBytesWritable&gt;  {
	public static final byte[] CF = "cf".getBytes();
	public static final byte[] COUNT = "count".getBytes();

 	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
    		int i = 0;
    		for (IntWritable val : values) {
    			i += val.get();
    		}
    		Put put = new Put(Bytes.toBytes(key.toString()));
    		put.add(CF, COUNT, Bytes.toBytes(i));

    		context.write(null, put);
   	}
}
    </pre><p>
        </p></div><div class="section" title="7.8.5.&nbsp;HBase MapReduce Summary to File Example"><div class="titlepage"><div><div><h3 class="title"><a name="mapreduce.example.summary.file"></a>7.8.5.&nbsp;HBase MapReduce Summary to File Example</h3></div></div></div><p>This very similar to the summary example above, with exception that this is using
          HBase as a MapReduce source but HDFS as the sink. The differences are in the job setup and
          in the reducer. The mapper remains the same. </p><pre class="programlisting">
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummaryToFile");
job.setJarByClass(MySummaryFileJob.class);     // class that contains mapper and reducer

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
job.setReducerClass(MyReducer.class);    // reducer class
job.setNumReduceTasks(1);    // at least one, adjust as required
FileOutputFormat.setOutputPath(job, new Path("/tmp/mr/mySummaryFile"));  // adjust directories as required

boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}
    </pre><p>As stated above, the previous Mapper can run unchanged with this example. As for the
          Reducer, it is a "generic" Reducer instead of extending TableMapper and emitting
          Puts.</p><pre class="programlisting">
 public static class MyReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {

	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		int i = 0;
		for (IntWritable val : values) {
			i += val.get();
		}
		context.write(key, new IntWritable(i));
	}
}
    </pre></div><div class="section" title="7.8.6.&nbsp;HBase MapReduce Summary to HBase Without Reducer"><div class="titlepage"><div><div><h3 class="title"><a name="mapreduce.example.summary.noreducer"></a>7.8.6.&nbsp;HBase MapReduce Summary to HBase Without Reducer</h3></div></div></div><p>It is also possible to perform summaries without a reducer - if you use HBase as the
          reducer. </p><p>An HBase target table would need to exist for the job summary. The HTable method
            <code class="code">incrementColumnValue</code> would be used to atomically increment values. From a
          performance perspective, it might make sense to keep a Map of values with their values to
          be incremeneted for each map-task, and make one update per key at during the <code class="code">
            cleanup</code> method of the mapper. However, your milage may vary depending on the
          number of rows to be processed and unique keys. </p><p>In the end, the summary results are in HBase. </p></div><div class="section" title="7.8.7.&nbsp;HBase MapReduce Summary to RDBMS"><div class="titlepage"><div><div><h3 class="title"><a name="mapreduce.example.summary.rdbms"></a>7.8.7.&nbsp;HBase MapReduce Summary to RDBMS</h3></div></div></div><p>Sometimes it is more appropriate to generate summaries to an RDBMS. For these cases,
          it is possible to generate summaries directly to an RDBMS via a custom reducer. The
            <code class="code">setup</code> method can connect to an RDBMS (the connection information can be
          passed via custom parameters in the context) and the cleanup method can close the
          connection. </p><p>It is critical to understand that number of reducers for the job affects the
          summarization implementation, and you'll have to design this into your reducer.
          Specifically, whether it is designed to run as a singleton (one reducer) or multiple
          reducers. Neither is right or wrong, it depends on your use-case. Recognize that the more
          reducers that are assigned to the job, the more simultaneous connections to the RDBMS will
          be created - this will scale, but only to a point. </p><pre class="programlisting">
 public static class MyRdbmsReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {

	private Connection c = null;

	public void setup(Context context) {
  		// create DB connection...
  	}

	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		// do summarization
		// in this example the keys are Text, but this is just an example
	}

	public void cleanup(Context context) {
  		// close db connection
  	}

}
    </pre><p>In the end, the summary results are written to your RDBMS table/s. </p></div></div><div class="section" title="7.9.&nbsp;Accessing Other HBase Tables in a MapReduce Job"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapreduce.htable.access"></a>7.9.&nbsp;Accessing Other HBase Tables in a MapReduce Job</h2></div></div></div><p>Although the framework currently allows one HBase table as input to a MapReduce job,
        other HBase tables can be accessed as lookup tables, etc., in a MapReduce job via creating
        an HTable instance in the setup method of the Mapper.
        </p><pre class="programlisting">public class MyMapper extends TableMapper&lt;Text, LongWritable&gt; {
  private HTable myOtherTable;

  public void setup(Context context) {
    myOtherTable = new HTable("myOtherTable");
  }

  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
	// process Result...
	// use 'myOtherTable' for lookups
  }

  </pre><p>
      </p></div><div class="section" title="7.10.&nbsp;Speculative Execution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mapreduce.specex"></a>7.10.&nbsp;Speculative Execution</h2></div></div></div><p>It is generally advisable to turn off speculative execution for MapReduce jobs that use
        HBase as a source. This can either be done on a per-Job basis through properties, on on the
        entire cluster. Especially for longer running jobs, speculative execution will create
        duplicate map-tasks which will double-write your data to HBase; this is probably not what
        you want. </p><p>See <a class="xref" href="#spec.ex" title="2.6.2.9.&nbsp;Speculative Execution">Section&nbsp;2.6.2.9, &#8220;Speculative Execution&#8221;</a> for more information. </p></div></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Secure Apache HBase"><div class="titlepage"><div><div><h2 class="title"><a name="security"></a>Chapter&nbsp;8.&nbsp;Secure Apache HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#hbase.secure.configuration">8.1. Secure Client Access to Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#security.prerequisites">8.1.1. Prerequisites</a></span></dt><dt><span class="section"><a href="#d2875e7778">8.1.2. Server-side Configuration for Secure Operation</a></span></dt><dt><span class="section"><a href="#d2875e7794">8.1.3. Client-side Configuration for Secure Operation</a></span></dt><dt><span class="section"><a href="#security.client.thrift">8.1.4. Client-side Configuration for Secure Operation - Thrift Gateway</a></span></dt><dt><span class="section"><a href="#security.gateway.thrift">8.1.5. Configure the Thrift Gateway to Authenticate on Behalf of the Client</a></span></dt><dt><span class="section"><a href="#d2875e7946">8.1.6. Client-side Configuration for Secure Operation - REST Gateway</a></span></dt><dt><span class="section"><a href="#security.rest.gateway">8.1.7. REST Gateway Impersonation Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.secure.simpleconfiguration">8.2. Simple User Access to Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e8022">8.2.1. Simple Versus Secure Access</a></span></dt></dl></dd><dt><span class="section"><a href="#d2875e8115">8.3. Securing Access To Your Data</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.tags">8.3.1. Tags</a></span></dt><dt><span class="section"><a href="#hbase.accesscontrol.configuration">8.3.2. Access Control Labels (ACLs)</a></span></dt><dt><span class="section"><a href="#d2875e8681">8.3.3. Visibility Labels</a></span></dt><dt><span class="section"><a href="#hbase.encryption.server">8.3.4. Transparent Encryption of Data At Rest</a></span></dt><dt><span class="section"><a href="#hbase.secure.bulkload">8.3.5. Secure Bulk Load</a></span></dt></dl></dd><dt><span class="section"><a href="#security.example.config">8.4. Security Configuration Example</a></span></dt></dl></div><div class="section" title="8.1.&nbsp;Secure Client Access to Apache HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.secure.configuration"></a>8.1.&nbsp;Secure Client Access to Apache HBase</h2></div></div></div><p>Newer releases of Apache HBase (&gt;= 0.92) support optional SASL authentication of clients. See also Matteo Bertozzi's article on <a class="link" href="http://www.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/" target="_top">Understanding
            User Authentication and Authorization in Apache HBase</a>.</p><p>This describes how to set up Apache HBase and clients for connection to secure HBase
      resources.</p><div class="section" title="8.1.1.&nbsp;Prerequisites"><div class="titlepage"><div><div><h3 class="title"><a name="security.prerequisites"></a>8.1.1.&nbsp;Prerequisites</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Hadoop Authentication Configuration</span></dt><dd><p>To run HBase RPC with strong authentication, you must set
                <code class="code">hbase.security.authentication</code> to <code class="literal">true</code>. In this case,
              you must also set <code class="code">hadoop.security.authentication</code> to
                <code class="literal">true</code>. Otherwise, you would be using strong authentication for
              HBase but not for the underlying HDFS, which would cancel out any benefit.</p></dd><dt><span class="term">Kerberos KDC</span></dt><dd><p> You need to have a working Kerberos KDC. </p><p> A HBase configured for secure client access is expected to be running on top of a
              secured HDFS cluster. HBase must be able to authenticate to HDFS services. HBase needs
              Kerberos credentials to interact with the Kerberos-enabled HDFS daemons.
              Authenticating a service should be done using a keytab file. The procedure for
              creating keytabs for HBase service is the same as for creating keytabs for Hadoop.
              Those steps are omitted here. Copy the resulting keytab files to wherever HBase Master
              and RegionServer processes are deployed and make them readable only to the user
              account under which the HBase daemons will run. </p><p> A Kerberos principal has three parts, with the form
                <code class="code">username/fully.qualified.domain.name@YOUR-REALM.COM</code>. We recommend using
                <code class="code">hbase</code> as the username portion. </p><p> The following is an example of the configuration properties for Kerberos
              operation that must be added to the <code class="code">hbase-site.xml</code> file on every server
              machine in the cluster. Required for even the most basic interactions with a secure
              Hadoop configuration, independent of HBase security. </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.regionserver.kerberos.principal&lt;/name&gt;
  &lt;value&gt;hbase/_HOST@YOUR-REALM.COM&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.regionserver.keytab.file&lt;/name&gt;
  &lt;value&gt;/etc/hbase/conf/keytab.krb5&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.master.kerberos.principal&lt;/name&gt;
  &lt;value&gt;hbase/_HOST@YOUR-REALM.COM&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.master.keytab.file&lt;/name&gt;
  &lt;value&gt;/etc/hbase/conf/keytab.krb5&lt;/value&gt;
&lt;/property&gt;
    </pre><p> Each HBase client user should also be given a Kerberos principal. This principal
              should have a password assigned to it (as opposed to a keytab file). The client
              principal's <code class="code">maxrenewlife</code> should be set so that it can be renewed enough
              times for the HBase client process to complete. For example, if a user runs a
              long-running HBase client process that takes at most 3 days, we might create this
              user's principal within <code class="code">kadmin</code> with: <code class="code">addprinc -maxrenewlife
                3days</code>
            </p><p> Long running daemons with indefinite lifetimes that require client access to
              HBase can instead be configured to log in from a keytab. For each host running such
              daemons, create a keytab with <code class="code">kadmin</code> or <code class="code">kadmin.local</code>. The
              procedure for creating keytabs for HBase service is the same as for creating keytabs
              for Hadoop. Those steps are omitted here. Copy the resulting keytab files to where the
              client daemon will execute and make them readable only to the user account under which
              the daemon will run. </p></dd></dl></div></div><div class="section" title="8.1.2.&nbsp;Server-side Configuration for Secure Operation"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e7778"></a>8.1.2.&nbsp;Server-side Configuration for Secure Operation</h3></div></div></div><p>First, refer to <a class="xref" href="#security.prerequisites" title="8.1.1.&nbsp;Prerequisites">Section&nbsp;8.1.1, &#8220;Prerequisites&#8221;</a> and ensure that your
        underlying HDFS configuration is secure.</p><p> Add the following to the <code class="code">hbase-site.xml</code> file on every server machine in
        the cluster: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.security.authentication&lt;/name&gt;
  &lt;value&gt;kerberos&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.security.authorization&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
&lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider&lt;/value&gt;
&lt;/property&gt;
    </pre><p> A full shutdown and restart of HBase service is required when deploying these
        configuration changes. </p></div><div class="section" title="8.1.3.&nbsp;Client-side Configuration for Secure Operation"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e7794"></a>8.1.3.&nbsp;Client-side Configuration for Secure Operation</h3></div></div></div><p>First, refer to <a class="xref" href="#security.prerequisites" title="8.1.1.&nbsp;Prerequisites">Section&nbsp;8.1.1, &#8220;Prerequisites&#8221;</a> and ensure that your
        underlying HDFS configuration is secure.</p><p> Add the following to the <code class="code">hbase-site.xml</code> file on every client: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.security.authentication&lt;/name&gt;
  &lt;value&gt;kerberos&lt;/value&gt;
&lt;/property&gt;
    </pre><p> The client environment must be logged in to Kerberos from KDC or keytab via the
          <code class="code">kinit</code> command before communication with the HBase cluster will be possible. </p><p> Be advised that if the <code class="code">hbase.security.authentication</code> in the client- and
        server-side site files do not match, the client will not be able to communicate with the
        cluster. </p><p> Once HBase is configured for secure RPC it is possible to optionally configure
        encrypted communication. To do so, add the following to the <code class="code">hbase-site.xml</code> file
        on every client: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.rpc.protection&lt;/name&gt;
  &lt;value&gt;privacy&lt;/value&gt;
&lt;/property&gt;
    </pre><p> This configuration property can also be set on a per connection basis. Set it in the
          <code class="code">Configuration</code> supplied to <code class="code">HTable</code>: </p><pre class="programlisting">
Configuration conf = HBaseConfiguration.create();
conf.set("hbase.rpc.protection", "privacy");
HTable table = new HTable(conf, tablename);
    </pre><p> Expect a ~10% performance penalty for encrypted communication. </p></div><div class="section" title="8.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway"><div class="titlepage"><div><div><h3 class="title"><a name="security.client.thrift"></a>8.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway</h3></div></div></div><p> Add the following to the <code class="code">hbase-site.xml</code> file for every Thrift gateway: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.thrift.keytab.file&lt;/name&gt;
  &lt;value&gt;/etc/hbase/conf/hbase.keytab&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.thrift.kerberos.principal&lt;/name&gt;
  &lt;value&gt;$USER/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
  &lt;!-- TODO: This may need to be  HTTP/_HOST@&lt;REALM&gt; and _HOST may not work.
   You may have  to put the concrete full hostname.
   --&gt;
&lt;/property&gt;
    </pre><p>
      </p><p> Substitute the appropriate credential and keytab for <em class="replaceable"><code>$USER</code></em>
        and <em class="replaceable"><code>$KEYTAB</code></em> respectively. </p><p>In order to use the Thrift API principal to interact with HBase, it is also necessary to
        add the <code class="code">hbase.thrift.kerberos.principal</code> to the <code class="code">_acl_</code> table. For
        example, to give the Thrift API principal, <code class="code">thrift_server</code>, administrative
        access, a command such as this one will suffice: </p><pre class="programlisting">
grant 'thrift_server', 'RWCA'
    </pre><p>For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="8.3.2.&nbsp;Access Control Labels (ACLs)">Access Control</a> section </p><p> The Thrift gateway will authenticate with HBase using the supplied credential. No
        authentication will be performed by the Thrift gateway itself. All client access via the
        Thrift gateway will use the Thrift gateway's credential and have its privilege. </p></div><div class="section" title="8.1.5.&nbsp;Configure the Thrift Gateway to Authenticate on Behalf of the Client"><div class="titlepage"><div><div><h3 class="title"><a name="security.gateway.thrift"></a>8.1.5.&nbsp;Configure the Thrift Gateway to Authenticate on Behalf of the Client</h3></div></div></div><p><a class="xref" href="#security.client.thrift" title="8.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway">Section&nbsp;8.1.4, &#8220;Client-side Configuration for Secure Operation - Thrift Gateway&#8221;</a> describes how to authenticate a Thrift client
        to HBase using a fixed user. As an alternative, you can configure the Thrift gateway to
        authenticate to HBase on the client's behalf, and to access HBase using a proxy user. This
        was implemented in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11349" target="_top">HBASE-11349</a> for Thrift 1, and <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11474" target="_top">HBASE-11474</a> for
        Thrift 2.</p><div class="note" title="Limitations with Thrift Framed Transport" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Limitations with Thrift Framed Transport</h3><p>If you use framed transport, you cannot yet take advantage of this feature, because
          SASL does not work with Thrift framed transport at this time.</p></div><p>To enable it, do the following.</p><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Be sure Thrift is running in secure mode, by following the procedure described in
              <a class="xref" href="#security.client.thrift" title="8.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway">Section&nbsp;8.1.4, &#8220;Client-side Configuration for Secure Operation - Thrift Gateway&#8221;</a>.</p></li><li class="step" title="Step 2"><p>Be sure that HBase is configured to allow proxy users, as described in <a class="xref" href="#security.rest.gateway" title="8.1.7.&nbsp;REST Gateway Impersonation Configuration">Section&nbsp;8.1.7, &#8220;REST Gateway Impersonation Configuration&#8221;</a>.</p></li><li class="step" title="Step 3"><p>In <code class="filename">hbase-site.xml</code> for each cluster node running a Thrift
            gateway, set the property <code class="code">hbase.thrift.security.qop</code> to one of the following
            three values:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">auth-conf</code> - authentication, integrity, and confidentiality
                checking</p></li><li class="listitem"><p><code class="literal">auth-int</code> - authentication and integrity checking</p></li><li class="listitem"><p><code class="literal">auth</code> - authentication checking only</p></li></ul></div></li><li class="step" title="Step 4"><p>Restart the Thrift gateway processes for the changes to take effect. If a node is
            running Thrift, the output of the <span class="command"><strong>jps</strong></span> command will list a
              <code class="code">ThriftServer</code> process. To stop Thrift on a node, run the command
              <span class="command"><strong>bin/hbase-daemon.sh stop thrift</strong></span>. To start Thrift on a node, run the
            command <span class="command"><strong>bin/hbase-daemon.sh start thrift</strong></span>.</p></li></ol></div></div><div class="section" title="8.1.6.&nbsp;Client-side Configuration for Secure Operation - REST Gateway"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e7946"></a>8.1.6.&nbsp;Client-side Configuration for Secure Operation - REST Gateway</h3></div></div></div><p> Add the following to the <code class="code">hbase-site.xml</code> file for every REST gateway: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.rest.keytab.file&lt;/name&gt;
  &lt;value&gt;$KEYTAB&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.rest.kerberos.principal&lt;/name&gt;
  &lt;value&gt;$USER/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
&lt;/property&gt;
    </pre><p> Substitute the appropriate credential and keytab for <em class="replaceable"><code>$USER</code></em>
        and <em class="replaceable"><code>$KEYTAB</code></em> respectively. </p><p> The REST gateway will authenticate with HBase using the supplied credential. No
        authentication will be performed by the REST gateway itself. All client access via the REST
        gateway will use the REST gateway's credential and have its privilege. </p><p>In order to use the REST API principal to interact with HBase, it is also necessary to
        add the <code class="code">hbase.rest.kerberos.principal</code> to the <code class="code">_acl_</code> table. For
        example, to give the REST API principal, <code class="code">rest_server</code>, administrative access, a
        command such as this one will suffice: </p><pre class="programlisting">
grant 'rest_server', 'RWCA'
    </pre><p>For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="8.3.2.&nbsp;Access Control Labels (ACLs)">Access Control</a> section </p><p> It should be possible for clients to authenticate with the HBase cluster through the
        REST gateway in a pass-through manner via SPEGNO HTTP authentication. This is future work.
      </p></div><div class="section" title="8.1.7.&nbsp;REST Gateway Impersonation Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="security.rest.gateway"></a>8.1.7.&nbsp;REST Gateway Impersonation Configuration</h3></div></div></div><p> By default, the REST gateway doesn't support impersonation. It accesses the HBase on
        behalf of clients as the user configured as in the previous section. To the HBase server,
        all requests are from the REST gateway user. The actual users are unknown. You can turn on
        the impersonation support. With impersonation, the REST gateway user is a proxy user. The
        HBase server knows the acutal/real user of each request. So it can apply proper
        authorizations. </p><p> To turn on REST gateway impersonation, we need to configure HBase servers (masters and
        region servers) to allow proxy users; configure REST gateway to enable impersonation. </p><p> To allow proxy users, add the following to the <code class="code">hbase-site.xml</code> file for
        every HBase server: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hadoop.security.authorization&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.proxyuser.$USER.groups&lt;/name&gt;
  &lt;value&gt;$GROUPS&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.proxyuser.$USER.hosts&lt;/name&gt;
  &lt;value&gt;$GROUPS&lt;/value&gt;
&lt;/property&gt;
    </pre><p> Substitute the REST gateway proxy user for $USER, and the allowed group list for
        $GROUPS. </p><p> To enable REST gateway impersonation, add the following to the
          <code class="code">hbase-site.xml</code> file for every REST gateway. </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.rest.authentication.type&lt;/name&gt;
  &lt;value&gt;kerberos&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.rest.authentication.kerberos.principal&lt;/name&gt;
  &lt;value&gt;HTTP/_HOST@HADOOP.LOCALDOMAIN&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.rest.authentication.kerberos.keytab&lt;/name&gt;
  &lt;value&gt;$KEYTAB&lt;/value&gt;
&lt;/property&gt;
    </pre><p> Substitute the keytab for HTTP for $KEYTAB. </p></div></div><div class="section" title="8.2.&nbsp;Simple User Access to Apache HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.secure.simpleconfiguration"></a>8.2.&nbsp;Simple User Access to Apache HBase</h2></div></div></div><p>Newer releases of Apache HBase (&gt;= 0.92) support optional SASL authentication of clients. See also Matteo Bertozzi's article on <a class="link" href="http://www.cloudera.com/blog/2012/09/understanding-user-authentication-and-authorization-in-apache-hbase/" target="_top">Understanding
            User Authentication and Authorization in Apache HBase</a>.</p><p>This describes how to set up Apache HBase and clients for simple user access to HBase
      resources.</p><div class="section" title="8.2.1.&nbsp;Simple Versus Secure Access"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e8022"></a>8.2.1.&nbsp;Simple Versus Secure Access</h3></div></div></div><p> The following section shows how to set up simple user access. Simple user access is not
        a secure method of operating HBase. This method is used to prevent users from making
        mistakes. It can be used to mimic the Access Control using on a development system without
        having to set up Kerberos. </p><p> This method is not used to prevent malicious or hacking attempts. To make HBase secure
        against these types of attacks, you must configure HBase for secure operation. Refer to the
        section <a class="link" href="#hbase.accesscontrol.configuration" title="8.3.2.&nbsp;Access Control Labels (ACLs)">Secure Client Access to HBase</a> and
        complete all of the steps described there. </p><div class="section" title="8.2.1.1.&nbsp;Prerequisites"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8032"></a>8.2.1.1.&nbsp;Prerequisites</h4></div></div></div><p> None </p><div class="section" title="8.2.1.1.1.&nbsp;Server-side Configuration for Simple User Access Operation"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e8037"></a>8.2.1.1.1.&nbsp;Server-side Configuration for Simple User Access Operation</h5></div></div></div><p> Add the following to the <code class="code">hbase-site.xml</code> file on every server machine
            in the cluster: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.security.authentication&lt;/name&gt;
  &lt;value&gt;simple&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.security.authorization&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt;
    </pre><p> For 0.94, add the following to the <code class="code">hbase-site.xml</code> file on every server
            machine in the cluster: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.rpc.engine&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.ipc.SecureRpcEngine&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt; 
    </pre><p> A full shutdown and restart of HBase service is required when deploying these
            configuration changes. </p></div><div class="section" title="8.2.1.1.2.&nbsp;Client-side Configuration for Simple User Access Operation"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e8056"></a>8.2.1.1.2.&nbsp;Client-side Configuration for Simple User Access Operation</h5></div></div></div><p> Add the following to the <code class="code">hbase-site.xml</code> file on every client: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.security.authentication&lt;/name&gt;
  &lt;value&gt;simple&lt;/value&gt;
&lt;/property&gt;
    </pre><p> For 0.94, add the following to the <code class="code">hbase-site.xml</code> file on every server
            machine in the cluster: </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.rpc.engine&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.ipc.SecureRpcEngine&lt;/value&gt;
&lt;/property&gt;
    </pre><p> Be advised that if the <code class="code">hbase.security.authentication</code> in the client-
            and server-side site files do not match, the client will not be able to communicate with
            the cluster. </p></div><div class="section" title="8.2.1.1.3.&nbsp;Client-side Configuration for Simple User Access Operation - Thrift Gateway"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e8078"></a>8.2.1.1.3.&nbsp;Client-side Configuration for Simple User Access Operation - Thrift Gateway</h5></div></div></div><p>The Thrift gateway user will need access. For example, to give the Thrift API user,
              <code class="code">thrift_server</code>, administrative access, a command such as this one will
            suffice: </p><pre class="programlisting">
grant 'thrift_server', 'RWCA'
    </pre><p>For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="8.3.2.&nbsp;Access Control Labels (ACLs)">Access Control</a> section </p><p> The Thrift gateway will authenticate with HBase using the supplied credential. No
            authentication will be performed by the Thrift gateway itself. All client access via the
            Thrift gateway will use the Thrift gateway's credential and have its privilege. </p></div><div class="section" title="8.2.1.1.4.&nbsp;Client-side Configuration for Simple User Access Operation - REST Gateway"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e8095"></a>8.2.1.1.4.&nbsp;Client-side Configuration for Simple User Access Operation - REST Gateway</h5></div></div></div><p> The REST gateway will authenticate with HBase using the supplied credential. No
            authentication will be performed by the REST gateway itself. All client access via the
            REST gateway will use the REST gateway's credential and have its privilege. </p><p>The REST gateway user will need access. For example, to give the REST API user,
              <code class="code">rest_server</code>, administrative access, a command such as this one will
            suffice: </p><pre class="programlisting">
grant 'rest_server', 'RWCA'
    </pre><p>For more information about ACLs, please see the <a class="link" href="#hbase.accesscontrol.configuration" title="8.3.2.&nbsp;Access Control Labels (ACLs)">Access Control</a> section </p><p> It should be possible for clients to authenticate with the HBase cluster through
            the REST gateway in a pass-through manner via SPEGNO HTTP authentication. This is future
            work. </p></div></div></div></div><div class="section" title="8.3.&nbsp;Securing Access To Your Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e8115"></a>8.3.&nbsp;Securing Access To Your Data</h2></div></div></div><p>After you have configured secure authentication between HBase client and server processes
      and gateways, you need to consider the security of your data itself. HBase provides several
      strategies for securing your data:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Role-based Access Control (RBAC) controls which users or groups can read and write to
          a given HBase resource or execute a coprocessor endpoint, using the familiar paradigm of
          roles.</p></li><li class="listitem"><p>Visibility Labels which allow you to label cells and control access to labelled cells,
          to further restrict who can read or write to certain subsets of your data. Visibility
          labels are stored as tags. See <a class="xref" href="#hbase.tags" title="8.3.1.&nbsp;Tags">Section&nbsp;8.3.1, &#8220;Tags&#8221;</a> for more information.</p></li><li class="listitem"><p>Transparent encryption of data at rest on the underlying filesystem, both in HFiles
          and in the WAL. This protects your data at rest from an attacker who has access to the
          underlying filesystem, without the need to change the implementation of the client. It can
          also protect against data leakage from improperly disposed disks, which can be important
          for legal and regulatory compliance.</p></li></ul></div><p>Server-side configuration, administration, and implementation details of each of these
      features are discussed below, along with any performance trade-offs. An example security
      configuration is given at the end, to show these features all used together, as they might be
      in a real-world scenario.</p><div class="caution" title="Caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>All aspects of security in HBase are in active development and evolving rapidly. Any
        strategy you employ for security of your data should be thoroughly tested. In addition, some
        of these features are still in the experimental stage of development. To take advantage of
        many of these features, you must be running HBase 0.98+ and using the HFile v3 file
        format.</p></div><div class="warning" title="Protecting Sensitive Files" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Protecting Sensitive Files</h3><p>Several procedures in this section require you to copy files between cluster nodes. When
        copying keys, configuration files, or other files containing sensitive strings, use a secure
        method, such as <code class="code">ssh</code>, to avoid leaking sensitive data.</p></div><div class="procedure" title="Procedure&nbsp;8.1.&nbsp;Basic Server-Side Configuration"><a name="security.data.basic.server.side"></a><p class="title"><b>Procedure&nbsp;8.1.&nbsp;Basic Server-Side Configuration</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Enable HFile v3, by setting <code class="option">hfile.format.version </code>to 3 in
            <code class="filename">hbase-site.xml</code>. This is the default for HBase 1.0 and
          newer.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hfile.format.version&lt;/name&gt;
  &lt;value&gt;3&lt;/value&gt;
&lt;/property&gt;
          </pre></li><li class="step" title="Step 2"><p>Enable SASL and Kerberos authentication for RPC and ZooKeeper, as described in <a class="xref" href="#security.prerequisites" title="8.1.1.&nbsp;Prerequisites">Section&nbsp;8.1.1, &#8220;Prerequisites&#8221;</a> and <a class="xref" href="#zk.sasl.auth" title="20.2.&nbsp;SASL Authentication with ZooKeeper">Section&nbsp;20.2, &#8220;SASL Authentication with ZooKeeper&#8221;</a>.</p></li></ol></div><div class="section" title="8.3.1.&nbsp;Tags"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.tags"></a>8.3.1.&nbsp;Tags</h3></div></div></div><p><em class="firstterm">Tags</em> are a feature of HFile v3. A tag is a piece of metadata
        which is part of a cell, separate from the key, value, and version. Tags are an
        implementation detail which provides a foundation for other security-related features such
        as cell-level ACLs and visibility labels. Tags are stored in the HFiles themselves. It is
        possible that in the future, tags will be used to implement other HBase features. You don't
        need to know a lot about tags in order to use the security features they enable.</p><div class="section" title="8.3.1.1.&nbsp;Implementation Details"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8173"></a>8.3.1.1.&nbsp;Implementation Details</h4></div></div></div><p> Every cell can have zero or more tags. Every tag has a type and the actual tag byte
          array.</p><p> Just as row keys, column families, qualifiers and values can be encoded (see <a class="xref" href="#data.block.encoding.types" title="Data Block Encoding Types">Data Block Encoding Types</a>), tags can also be encoded as well. You can enable
          or disable tag encoding at the level of the column family, and it is enabled by default.
          Use the <code class="code">HColumnDescriptor#setCompressionTags(boolean compressTags)</code> method to
          manage encoding settings on a column family. You also need to enable the DataBlockEncoder
          for the column family, for encoding of tags to take effect.</p><p>You can enable compression of each tag in the WAL, if WAL compression is also enabled,
          by setting the value of <code class="option">hbase.regionserver.wal.tags.enablecompression</code> to
            <code class="literal">true</code> in <code class="filename">hbase-site.xml</code>. Tag compression uses
          dictionary encoding.</p><p>Tag compression is not supported when using WAL encryption.</p></div></div><div class="section" title="8.3.2.&nbsp;Access Control Labels (ACLs)"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.accesscontrol.configuration"></a>8.3.2.&nbsp;Access Control Labels (ACLs)</h3></div></div></div><div class="section" title="8.3.2.1.&nbsp;How It Works"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8201"></a>8.3.2.1.&nbsp;How It Works</h4></div></div></div><p>ACLs in HBase are based upon a user's membership in or exclusion from groups, and a
          given group's permissions to access a given resource. ACLs are implemented as a
          coprocessor called AccessController.</p><p>HBase does not maintain a private group mapping, but relies on a <em class="firstterm">Hadoop
            group mapper</em>, which maps between entities in a directory such as LDAP or
          Active Directory, and HBase users. Any supported Hadoop group mapper will work. Users are
          then granted specific permissions (Read, Write, Execute, Create, Admin) against resources
          (global, namespaces, tables, cells, or endpoints).</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p> With Kerberos and Access Control enabled, client access to HBase is authenticated
            and user data is private unless access has been explicitly granted.</p></div><p>HBase has a simpler security model than relational databases, especially in terms of
          client operations. No distinction is made between an insert (new record) and update (of
          existing record), for example, as both collapse down into a Put. Accordingly, the
          important operations condense to four permissions: READ, WRITE, CREATE, and ADMIN.</p><div class="table"><a name="d2875e8216"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Operation To Permission Mapping</b></p><div class="table-contents"><table summary="Operation To Permission Mapping" border="1"><colgroup><col align="center" class="c1"><col align="left" class="c2"></colgroup><thead><tr><th align="center">Permission</th><th align="left">Operation</th></tr></thead><tbody><tr><td align="center">Read</td><td align="left">Get</td></tr><tr><td align="center">&nbsp;</td><td align="left">Exists</td></tr><tr><td align="center">&nbsp;</td><td align="left">Scan</td></tr><tr><td align="center">Write</td><td align="left">Put</td></tr><tr><td align="center">&nbsp;</td><td align="left">Delete</td></tr><tr><td align="center">&nbsp;</td><td align="left">IncrementColumnValue</td></tr><tr><td align="center">&nbsp;</td><td align="left">CheckAndDelete/Put</td></tr><tr><td align="center">Create</td><td align="left">Create</td></tr><tr><td align="center">&nbsp;</td><td align="left">Alter</td></tr><tr><td align="center">&nbsp;</td><td align="left">Drop</td></tr><tr><td align="center">&nbsp;</td><td align="left">Bulk Load</td></tr><tr><td align="center">Admin</td><td align="left">Enable/Disable</td></tr><tr><td align="center">&nbsp;</td><td align="left">Snapshot/Restore/Clone</td></tr><tr><td align="center">&nbsp;</td><td align="left">Split</td></tr><tr><td align="center">&nbsp;</td><td align="left">Flush</td></tr><tr><td align="center">&nbsp;</td><td align="left">Compact</td></tr><tr><td align="center">&nbsp;</td><td align="left">Major Compact</td></tr><tr><td align="center">&nbsp;</td><td align="left">Roll HLog</td></tr><tr><td align="center">&nbsp;</td><td align="left">Grant</td></tr><tr><td align="center">&nbsp;</td><td align="left">Revoke</td></tr><tr><td align="center">&nbsp;</td><td align="left">Shutdown</td></tr><tr><td align="center">Execute</td><td align="left">Execute coprocessor endpoints</td></tr></tbody></table></div></div><br class="table-break"><p> Permissions can be granted in any of the following scopes, though CREATE and ADMIN
          permissions are effective only at table, namespace, and global scopes. </p><div class="variablelist"><dl><dt><span class="term">Namespace</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Read: User can read any table in the namespace.</p></li><li class="listitem"><p>Write: User can write to any table in the namespace.</p></li><li class="listitem"><p>Create: User can create tables in the namespace.</p></li><li class="listitem"><p>Admin: User can alter table attributes; add, alter, or drop column families;
                    and enable, disable, or drop the table. User can also trigger region
                    (re)assignments or relocation.</p></li></ul></div></dd><dt><span class="term">Table</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Read: User can read from any column family in table</p></li><li class="listitem"><p>Write: User can write to any column family in table</p></li><li class="listitem"><p>Create: User can alter table attributes; add, alter, or drop column
                    families; and drop the table.</p></li><li class="listitem"><p>Admin: User can alter table attributes; add, alter, or drop column families;
                    and enable, disable, or drop the table. User can also trigger region
                    (re)assignments or relocation.</p></li></ul></div></dd><dt><span class="term">Column Family / Column Qualifier / Cell</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Read: User can read at the specified scope.</p></li><li class="listitem"><p>Write: User can write at the specified scope.</p></li></ul></div></dd><dt><span class="term">Coprocessor Endpoint</span></dt><dd><p>Execute: the user can execute the coprocessor endpoint.</p></dd><dt><span class="term">Global</span></dt><dd><p>Superusers are specified as a comma-separated list of users and groups, in the
                  <code class="option">hbase.superuser</code> option in <code class="filename">hbase-site.xml</code>.
                The superuser is equivalent to the <code class="literal">root</code> user in a UNIX
                environment. As a minimum, the superuser should include the principal used to run
                the HMaster process. Global admin privileges, which are implicitly granted to the
                superuser, are required to create namespaces, switch the balancer on and off, or
                take other actions with global consequences. The superuser can also grant all
                permissions to all resources.</p></dd></dl></div><p title="ACL Matrix"><b>ACL Matrix.&nbsp;</b>For more details on how ACLs map to specific HBase operations and tasks, see <a class="xref" href="#appendix_acl_matrix" title="Appendix&nbsp;D.&nbsp;Access Control Matrix">Appendix&nbsp;D, <i>Access Control Matrix</i></a>.</p><p>Cell-level ACLs are implemented using tags (see <a class="xref" href="#hbase.tags" title="8.3.1.&nbsp;Tags">Section&nbsp;8.3.1, &#8220;Tags&#8221;</a>). In
          order to use cell-level ACLs, you must be using HFile v3 and HBase 0.98 or newer.</p><div class="orderedlist" title="ACL Implementation Caveats"><p class="title"><b>ACL Implementation Caveats</b></p><ol class="orderedlist" type="1"><li class="listitem"><p>Files created by HBase are owned by the operating system user running the HBase
              process. To interact with HBase files, you should use the API or bulk load
              facility.</p></li><li class="listitem"><p>HBase does not model "roles" internally in HBase. Instead, group names can be
              granted permissions. This allows external modeling of roles via group membership.
              Groups are created and manipulated externally to HBase, via the Hadoop group mapping
              service.</p></li></ol></div></div><div class="section" title="8.3.2.2.&nbsp;Server-Side Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8415"></a>8.3.2.2.&nbsp;Server-Side Configuration</h4></div></div></div><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p>As a prerequisite, perform the steps in <a class="xref" href="#security.data.basic.server.side" title="Procedure&nbsp;8.1.&nbsp;Basic Server-Side Configuration">Procedure&nbsp;8.1, &#8220;Basic Server-Side Configuration&#8221;</a>.</p></li><li class="step" title="Step 2"><p>Install and configure the AccessController coprocessor, by setting the following
              properties in <code class="filename">hbase-site.xml</code>. These properties take a list of
              classes. </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you use the AccessController along with the VisibilityController, the
                AccessController must come first in the list, because with both components active,
                the VisibilityController will delegate access control on its system tables to the
                AccessController. For an example of using both together, see <a class="xref" href="#security.example.config" title="8.4.&nbsp;Security Configuration Example">Section&nbsp;8.4, &#8220;Security Configuration Example&#8221;</a>.</p></div><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController, org.apache.hadoop.hbase.security.token.TokenProvider&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.security.exec.permission.checks&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
          </pre><p>Optionally, you can enable transport security, by setting
              <code class="option">hbase.rpc.protection</code> to <code class="literal">auth-conf</code>. This requires
              HBase 0.98.4 or newer.</p></li><li class="step" title="Step 3"><p>Set up the Hadoop group mapper in the Hadoop namenode's
                <code class="filename">core-site.xml</code>. This is a Hadoop file, not an HBase file.
              Customize it to your site's needs. Following is an example.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.security.LdapGroupsMapping&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.url&lt;/name&gt;
  &lt;value&gt;ldap://server&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.bind.user&lt;/name&gt;
  &lt;value&gt;Administrator@example-ad.local&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.bind.password&lt;/name&gt;
  &lt;value&gt;****&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.base&lt;/name&gt;
  &lt;value&gt;dc=example-ad,dc=local&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.filter.user&lt;/name&gt;
  &lt;value&gt;(&amp;amp;(objectClass=user)(sAMAccountName={0}))&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.filter.group&lt;/name&gt;
  &lt;value&gt;(objectClass=group)&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.attr.member&lt;/name&gt;
  &lt;value&gt;member&lt;/value&gt;
&lt;/property&gt;

&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.attr.group.name&lt;/name&gt;
  &lt;value&gt;cn&lt;/value&gt;
&lt;/property&gt;
            </pre></li><li class="step" title="Step 4"><p>Optionally, enable the early-out evaluation strategy. Prior to HBase 0.98.0, if a
              user was not granted access to a column family, or at least a column qualifier, an
              AccessDeniedException would be thrown. HBase 0.98.0 removed this exception in order to
              allow cell-level exceptional grants. To restore the old behavior in HBase
              0.98.0-0.98.6, set <code class="option">hbase.security.access.early_out</code> to
                <code class="literal">true</code> in <code class="filename">hbase-site.xml</code>. In HBase 0.98.6, the
              default has been returned to <code class="literal">true</code>.</p></li><li class="step" title="Step 5"><p>Distribute your configuration and restart your cluster for changes to take
              effect.</p></li><li class="step" title="Step 6"><p>To test your configuration, log into HBase Shell as a given user and use the
                <span class="command"><strong>whoami</strong></span> command to report the groups your user is part of. In this
              example, the user is reported as being a member of the <code class="code">services</code>
              group.</p><pre class="screen">
hbase&gt; <strong class="userinput"><code>whoami</code></strong>
<code class="computeroutput">service (auth:KERBEROS)
    groups: services</code>
            </pre></li></ol></div></div><div class="section" title="8.3.2.3.&nbsp;Administration"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8488"></a>8.3.2.3.&nbsp;Administration</h4></div></div></div><p>Administration tasks can be performed from HBase Shell or via an API.</p><div class="caution" title="API Examples" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">API Examples</h3><p>Many of the API examples below are taken from source files
            <code class="filename">hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/TestAccessController.java</code>
            and
            <code class="filename">hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/SecureTestUtil.java</code>.</p><p>Neither the examples, nor the source files they are taken from, are part of the
            public HBase API, and are provided for illustration only. Refer to the
            official API for usage instructions.</p></div><div class="procedure"><ol class="procedure" type="1"><li class="step" title="User and Group Administration"><p class="title"><b>User and Group Administration</b></p><p>Users and groups are maintained external to HBase, in your directory.</p></li><li class="step" title="Granting Access To A Namespace, Table, Column Family, or Cell"><p class="title"><b>Granting Access To A Namespace, Table, Column Family, or Cell</b></p><p>There are a few different types of syntax for grant statements. The first, and
              most familiar, is as follows, with the table and column family being optional:</p><pre class="screen">grant 'user', 'RWXCA', 'TABLE', 'CF', 'CQ'</pre><p>Groups and users are granted access in the same way, but groups are prefixed with
              an <code class="literal">@</code> symbol. In the same way, tables and namespaces are specified
              in the same way, but namespaces are prefixed with an <code class="literal">@</code>
              symbol.</p><p>It is also possible to grant multiple permissions against the same resource in a
              single statement, as in this example. The first sub-clause maps users to
              ACLs and the second sub-clause specifies the resource.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HBase Shell support for granting and revoking access at the cell level is for
                testing and verification support, and should not be employed for production use
                because it won't apply the permissions to cells that don't exist yet. The correct
                way to apply cell level permissions is to do so in the application code when storing
                the values.</p></div><p title="ACL Granularity and Evaluation Order"><b>ACL Granularity and Evaluation Order.&nbsp;</b>ACLs are evaluated from least granular to most granular, and when an ACL is
                reached that grants permission, evaluation stops. This means that cell ACLs do not
                override ACLs at less granularity.</p><div class="example"><a name="d2875e8537"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;HBase Shell</b></p><div class="example-contents"><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Global:</p><pre class="screen">hbase&gt; <strong class="userinput"><code>grant '@admins', 'RWXCA'</code></strong></pre></li><li class="listitem"><p>Namespace:</p><pre class="screen">hbase&gt; <strong class="userinput"><code>grant 'service', 'RWXCA', '@test-NS'</code></strong></pre></li><li class="listitem"><p>Table:</p><pre class="screen">hbase&gt; <strong class="userinput"><code>grant 'service', 'RWXCA', 'user'</code></strong></pre></li><li class="listitem"><p>Column Family:</p><pre class="screen">hbase&gt; <strong class="userinput"><code>grant '@developers', 'RW', 'user', 'i'</code></strong></pre></li><li class="listitem"><p>Column Qualifier:</p><pre class="screen">hbase&gt; <strong class="userinput"><code>grant 'service, 'RW', 'user', 'i', 'foo'</code></strong></pre></li><li class="listitem"><p>Cell:</p><p>The syntax for granting cell ACLs uses the following syntax:</p><pre class="screen">grant <em class="replaceable"><code>&lt;table&gt;</code></em>, \
  { '<em class="replaceable"><code>&lt;user-or-group&gt;</code></em>' =&gt; \
    '<em class="replaceable"><code>&lt;permissions&gt;</code></em>', ... }, \
  { <em class="replaceable"><code>&lt;scanner-specification&gt;</code></em> }</pre><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><em class="replaceable"><code>&lt;user-or-group&gt;</code></em> is the user or group
                        name, prefixed with <code class="literal">@</code> in the case of a group.</p></li><li class="listitem"><p><em class="replaceable"><code>&lt;permissions&gt;</code></em> is a string containing
                        any or all of "RWXCA", though only R and W are meaningful at cell
                        scope.</p></li><li class="listitem"><p><em class="replaceable"><code>&lt;scanner-specification&gt;</code></em> is the scanner
                        specification syntax and conventions used by the 'scan' shell command. For
                        some examples of scanner specifications, issue the following HBase Shell
                        command.</p><pre class="screen">hbase&gt; help "scan"</pre></li></ul></div><p>This example grants read access to the 'testuser' user and read/write access
                    to the 'developers' group, on cells in the 'pii' column which match the
                    filter.</p><pre class="screen">hbase&gt; grant 'user', \
  { '@developers' =&gt; 'RW', 'testuser' =&gt; 'R' }, \
  { COLUMNS =&gt; 'pii', FILTER =&gt; "(PrefixFilter ('test'))" }</pre><p>The shell will run a scanner with the given criteria, rewrite the found
                    cells with new ACLs, and store them back to their exact coordinates.</p></li></ul></div></div></div><br class="example-break"><div class="example"><a name="d2875e8622"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;API</b></p><div class="example-contents"><p>The following example shows how to grant access at the
                table level.</p><pre class="programlisting">
public static void grantOnTable(final HBaseTestingUtility util, final String user,
    final TableName table, final byte[] family, final byte[] qualifier,
    final Permission.Action... actions) throws Exception {
  SecureTestUtil.updateACLs(util, new Callable&lt;Void&gt;() {
    @Override
    public Void call() throws Exception {
      HTable acl = new HTable(util.getConfiguration(), AccessControlLists.ACL_TABLE_NAME);
      try {
        BlockingRpcChannel service = acl.coprocessorService(HConstants.EMPTY_START_ROW);
        AccessControlService.BlockingInterface protocol =
            AccessControlService.newBlockingStub(service);
        ProtobufUtil.grant(protocol, user, table, family, qualifier, actions);
      } finally {
        acl.close();
      }
      return null;
    }
  });
}               
              </pre><p>To grant permissions at the cell level, you can use the
                  <code class="code">Mutation.setACL</code> method:</p><pre class="programlisting">
Mutation.setACL(String user, Permission perms)
Mutation.setACL(Map&lt;String, Permission&gt; perms)
    
              </pre><p>Specifically, this example provides read permission to a user called
                  <code class="literal">user1</code> on any cells contained in a particular Put
                operation:</p><pre class="programlisting">
put.setACL(&#8220;user1&#8221;, new Permission(Permission.Action.READ))
    </pre></div></div><br class="example-break"></li><li class="step" title="Revoking Access Control From a Namespace, Table, Column Family, or Cell"><p class="title"><b>Revoking Access Control From a Namespace, Table, Column Family, or Cell</b></p><p>The <span class="command"><strong>revoke</strong></span> command and API are twins of the grant command and
              API, and the syntax is exactly the same. The only exception is that you cannot revoke
              permissions at the cell level. You can only revoke access that has previously been
              granted, and a <span class="command"><strong>revoke</strong></span> statement is not the same thing as explicit
              denial to a resource.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HBase Shell support for granting and revoking access is for testing and verification
                support, and should not be employed for production use because it won't apply the
                permissions to cells that don't exist yet. The correct way to apply cell-level
                permissions is to do so in the application code when storing the values.</p></div><div class="example"><a name="d2875e8657"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Revoking Access To a Table</b></p><div class="example-contents"><pre class="programlisting">
public static void revokeFromTable(final HBaseTestingUtility util, final String user,
    final TableName table, final byte[] family, final byte[] qualifier,
    final Permission.Action... actions) throws Exception {
  SecureTestUtil.updateACLs(util, new Callable&lt;Void&gt;() {
    @Override
    public Void call() throws Exception {
      HTable acl = new HTable(util.getConfiguration(), AccessControlLists.ACL_TABLE_NAME);
      try {
        BlockingRpcChannel service = acl.coprocessorService(HConstants.EMPTY_START_ROW);
        AccessControlService.BlockingInterface protocol =
            AccessControlService.newBlockingStub(service);
        ProtobufUtil.revoke(protocol, user, table, family, qualifier, actions);
      } finally {
        acl.close();
      }
      return null;
    }
  });
} 
              </pre></div></div><br class="example-break"></li><li class="step" title="Showing a User's Effective Permissions"><p class="title"><b>Showing a User's Effective Permissions</b></p><div class="example"><a name="d2875e8665"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;HBase Shell</b></p><div class="example-contents"><pre class="screen">hbase&gt; user_permission 'user'</pre><pre class="screen">hbase&gt; user_permission '.*'</pre><pre class="screen">hbase&gt; user_permission <em class="replaceable"><code>JAVA_REGEX</code></em></pre></div></div><br class="example-break"><div class="example"><a name="d2875e8676"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;API</b></p><div class="example-contents"><pre class="programlisting">
public static void verifyAllowed(User user, AccessTestAction action, int count) throws Exception {
  try {
    Object obj = user.runAs(action);
    if (obj != null &amp;&amp; obj instanceof List&lt;?&gt;) {
      List&lt;?&gt; results = (List&lt;?&gt;) obj;
      if (results != null &amp;&amp; results.isEmpty()) {
        fail("Empty non null results from action for user '" + user.getShortName() + "'");
      }
      assertEquals(count, results.size());
    }
  } catch (AccessDeniedException ade) {
    fail("Expected action to pass for user '" + user.getShortName() + "' but was denied");
  }
}
              </pre></div></div><br class="example-break"></li></ol></div></div></div><div class="section" title="8.3.3.&nbsp;Visibility Labels"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e8681"></a>8.3.3.&nbsp;Visibility Labels</h3></div></div></div><p>Visibility labels control can be used to only permit users or principals associated with
        a given label to read or access cells with that label. For instance, you might label a cell
          <code class="literal">top-secret</code>, and only grant access to that label to the
          <code class="literal">managers</code> group. Visibility labels are implemented using Tags, which are
        a feature of HFile v3, and allow you to store metadata on a per-cell basis. A label is a
        string, and labels can be combined into expressions by using logical operators (&amp;, |, or
        !), and using parentheses for grouping. HBase does not do any kind of validation of
        expressions beyond basic well-formedness. Visibility labels have no meaning on their own,
        and may be used to denote sensitivity level, privilege level, or any other arbitrary
        semantic meaning.</p><p>If a user's labels do not match a cell's label or expression, the user is
        denied access to the cell.</p><p>In HBase 0.98.6 and newer, UTF-8 encoding is supported for visibility labels and
        expressions. When creating labels using the <code class="code">addLabels(conf, labels)</code> method
        provided by the <code class="code">org.apache.hadoop.hbase.security.visibility.VisibilityClient</code>
        class and passing labels in Authorizations via Scan or Get, labels can contain UTF-8
        characters, as well as the logical operators normally used in visibility labels, with normal
        Java notations, without needing any escaping method. However, when you pass a CellVisibility
        expression via a Mutation, you must enclose the expression with the
          <code class="code">CellVisibility.quote()</code> method if you use UTF-8 characters or logical
        operators. See <code class="code">TestExpressionParser</code> and the source file
          <code class="filename">hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestScan.java</code>.
      </p><p>A user adds visibility expressions to a cell during a Put operation. In the default
        configuration, the user does not need to access to a label in order to label cells with it.
        This behavior is controlled by the configuration option
          <code class="option">hbase.security.visibility.mutations.checkauths</code>. If you set this option to
          <code class="literal">true</code>, the labels the user is modifying as part of the mutation must be
        associated with the user, or the mutation will fail. Whether a user is authorized to read a
        labelled cell is determined during a Get or Scan, and results which the user is not allowed
        to read are filtered out. This incurs the same I/O penalty as if the results were returned,
        but reduces load on the network.</p><p>Visibility labels can also be specified during Delete operations. For details about
        visibility labels and Deletes, see <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10885" target="_top">HBASE-10885</a>. </p><p>The user's effective label set is built in the RPC context when a request is first
        received by the RegionServer. The way that users are associated with labels is pluggable.
        The default plugin passes through labels specified in Authorizations added to the Get or
        Scan and checks those against the calling user's authenticated labels list. When the client
        passes labels for which the user is not authenticated, the default plugin drops them. You
        can pass a subset of user authenticated labels via the
          <code class="code">Get#setAuthorizations(Authorizations(String,...))</code> and
          <code class="code">Scan#setAuthorizations(Authorizations(String,...));</code> methods. </p><p>Visibility label access checking is performed by the VisibilityController coprocessor.
        You can use interface <code class="code">VisibilityLabelService</code> to provide a custom implementation
        and/or control the way that visibility labels are stored with cells. See the source file
          <code class="filename">hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabelsWithCustomVisLabService.java</code>
        for one example.</p><p>Visibility labels can be used in conjunction with ACLs.</p><div class="table"><a name="d2875e8742"></a><p class="title"><b>Table&nbsp;8.2.&nbsp;Examples of Visibility Expressions</b></p><div class="table-contents"><table summary="Examples of Visibility Expressions" border="1"><colgroup><col><col></colgroup><thead><tr><th>Expression</th><th>Interpretation</th></tr></thead><tbody><tr><td><pre class="screen">fulltime</pre></td><td><p>Allow accesss to users associated with the
                <code class="code">fulltime</code> label.</p></td></tr><tr><td><pre class="screen">!public</pre></td><td><p>Allow access to users not associated with the
                <code class="code">public</code> label.</p></td></tr><tr><td><pre class="screen">( secret | topsecret ) &amp; !probationary</pre></td><td><p>Allow access to users associated with either the 
                <code class="code">secret</code> or <code class="code">topsecret</code> label and not 
                associated with the <code class="code">probationary</code> label.</p></td></tr></tbody></table></div></div><br class="table-break"><div class="section" title="8.3.3.1.&nbsp;Server-Side Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8789"></a>8.3.3.1.&nbsp;Server-Side Configuration</h4></div></div></div><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p>As a prerequisite, perform the steps in <a class="xref" href="#security.data.basic.server.side" title="Procedure&nbsp;8.1.&nbsp;Basic Server-Side Configuration">Procedure&nbsp;8.1, &#8220;Basic Server-Side Configuration&#8221;</a>.</p></li><li class="step" title="Step 2"><p>Install and configure the VisibilityController coprocessor by setting the
              following properties in <code class="filename">hbase-site.xml</code>. These properties take a
              list of class names.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.visibility.VisibilityController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.visibility.VisibilityController&lt;/value&gt;
&lt;/property&gt;
          </pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you use the AccessController and VisibilityController coprocessors together,
                the AccessController must come first in the list, because with both components
                active, the VisibilityController will delegate access control on its system tables
                to the AccessController.</p></div></li><li class="step" title="Adjust Configuration"><p class="title"><b>Adjust Configuration</b></p><p>By default, users can label cells with any label, including labels they are not
              associated with, which means that a user can Put data that he cannot read. For
              example, a user could label a cell with the (hypothetical) 'topsecret' label even if
              the user is not associated with that label. If you only want users to be able to label
              cells with labels they are associated with, set
                <span class="property">hbase.security.visibility.mutations.checkauths</span> to
                <code class="literal">true</code>. In that case, the mutation will fail if it makes use of
              labels the user is not associated with.</p></li><li class="step" title="Step 4"><p>Distribute your configuration and restart your cluster for changes to take
              effect.</p></li></ol></div></div><div class="section" title="8.3.3.2.&nbsp;Administration"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8823"></a>8.3.3.2.&nbsp;Administration</h4></div></div></div><p>Administration tasks can be performed using the HBase Shell or the Java API. For
          defining the list of visibility labels and associating labels with users, the
          HBase Shell is probably simpler.</p><div class="caution" title="API Examples" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">API Examples</h3><p>Many of the Java API examples in this section are taken from the source file 
            <code class="filename">hbase-server/src/test/java/org/apache/hadoop/hbase/security/visibility/TestVisibilityLabels.java</code>.
            Refer to that file or the API documentation for more context.</p><p>Neither these examples, nor the source file they were taken from, are part of the
            public HBase API, and are provided for illustration only. Refer to the official API
            for usage instructions.</p></div><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Define the List of Visibility Labels"><p class="title"><b>Define the List of Visibility Labels</b></p><div class="example"><a name="d2875e8842"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;HBase Shell</b></p><div class="example-contents"><pre class="screen">hbase&lt; <strong class="userinput"><code>add_labels [ 'admin', 'service', 'developer', 'test' ]</code></strong></pre></div></div><br class="example-break"><div class="example"><a name="d2875e8849"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;Java API</b></p><div class="example-contents"><pre class="programlisting">
public static void addLabels() throws Exception {
  PrivilegedExceptionAction&lt;VisibilityLabelsResponse&gt; action =
      new PrivilegedExceptionAction&lt;VisibilityLabelsResponse&gt;() {
    public VisibilityLabelsResponse run() throws Exception {
      String[] labels = { SECRET, TOPSECRET, CONFIDENTIAL, PUBLIC, PRIVATE, COPYRIGHT, ACCENT,
          UNICODE_VIS_TAG, UC1, UC2 };
      try {
        VisibilityClient.addLabels(conf, labels);
      } catch (Throwable t) {
        throw new IOException(t);
      }
      return null;
    }
  };
  SUPERUSER.runAs(action);
}
                </pre></div></div><br class="example-break"></li><li class="step" title="Associate Labels with Users"><p class="title"><b>Associate Labels with Users</b></p><div class="example"><a name="d2875e8857"></a><p class="title"><b>Example&nbsp;8.8.&nbsp;HBase Shell</b></p><div class="example-contents"><pre class="screen">hbase&lt; <strong class="userinput"><code>set_auths 'service', [ 'service' ]</code></strong></pre><pre class="screen">hbase&lt; <strong class="userinput"><code>set_auths 'testuser', [ 'test' ]</code></strong></pre><pre class="screen">hbase&lt; <strong class="userinput"><code>set_auths 'qa', [ 'test', 'developer' ]</code></strong></pre></div></div><br class="example-break"><div class="example"><a name="d2875e8872"></a><p class="title"><b>Example&nbsp;8.9.&nbsp;Java API</b></p><div class="example-contents"><pre class="programlisting">
public void testSetAndGetUserAuths() throws Throwable {
  final String user = "user1";
  PrivilegedExceptionAction&lt;Void&gt; action = new PrivilegedExceptionAction&lt;Void&gt;() {
    public Void run() throws Exception {
      String[] auths = { SECRET, CONFIDENTIAL };
      try {
        VisibilityClient.setAuths(conf, auths, user);
      } catch (Throwable e) {
      }
      return null;
    }
    ...
                </pre></div></div><br class="example-break"></li><li class="step" title="Clear Labels From Users"><p class="title"><b>Clear Labels From Users</b></p><div class="example"><a name="d2875e8880"></a><p class="title"><b>Example&nbsp;8.10.&nbsp;HBase Shell</b></p><div class="example-contents"><pre class="screen">hbase&lt; <strong class="userinput"><code>clear_auths 'service', [ 'service' ]</code></strong></pre><pre class="screen">hbase&lt; <strong class="userinput"><code>clear_auths 'testuser', [ 'test' ]</code></strong></pre><pre class="screen">hbase&lt; <strong class="userinput"><code>clear_auths 'qa', [ 'test', 'developer' ]</code></strong></pre></div></div><br class="example-break"><div class="example"><a name="d2875e8895"></a><p class="title"><b>Example&nbsp;8.11.&nbsp;Java API</b></p><div class="example-contents"><pre class="programlisting">
...
auths = new String[] { SECRET, PUBLIC, CONFIDENTIAL };
VisibilityLabelsResponse response = null;
try {
  response = VisibilityClient.clearAuths(conf, auths, user);
} catch (Throwable e) {
  fail("Should not have failed");
...
                </pre></div></div><br class="example-break"></li><li class="step" title="Apply a Label or Expression to a Cell"><p class="title"><b>Apply a Label or Expression to a Cell</b></p><p>The label is only applied when data is written. The label is associated with a
              given version of the cell.</p><div class="example"><a name="d2875e8905"></a><p class="title"><b>Example&nbsp;8.12.&nbsp;HBase Shell</b></p><div class="example-contents"><pre class="screen">hbase&lt; <strong class="userinput"><code>set_visibility 'user', 'admin|service|developer', \
  { COLUMNS =&gt; 'i' }</code></strong></pre><pre class="screen">hbase&lt; <strong class="userinput"><code>set_visibility 'user', 'admin|service', \
  { COLUMNS =&gt; ' pii' }</code></strong></pre><pre class="screen">hbase&lt; <strong class="userinput"><code>COLUMNS =&gt; [ 'i', 'pii' ], \
    FILTER =&gt; "(PrefixFilter ('test'))" }</code></strong></pre></div></div><br class="example-break"><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>HBase Shell support for applying labels or permissions to cells is for testing
                and verification support, and should not be employed for production use because it
                won't apply the labels to cells that don't exist yet. The correct way to apply cell
                level labels is to do so in the application code when storing the values.</p></div><div class="example"><a name="d2875e8923"></a><p class="title"><b>Example&nbsp;8.13.&nbsp;Java API</b></p><div class="example-contents"><pre class="programlisting">
static HTable createTableAndWriteDataWithLabels(TableName tableName, String... labelExps)
    throws Exception {
  HTable table = null;
  try {
    table = TEST_UTIL.createTable(tableName, fam);
    int i = 1;
    List&lt;Put&gt; puts = new ArrayList&lt;Put&gt;();
    for (String labelExp : labelExps) {
      Put put = new Put(Bytes.toBytes("row" + i));
      put.add(fam, qual, HConstants.LATEST_TIMESTAMP, value);
      put.setCellVisibility(new CellVisibility(labelExp));
      puts.add(put);
      i++;
    }
    table.put(puts);
  } finally {
    if (table != null) {
      table.flushCommits();
    }
  }
                </pre></div></div><br class="example-break"></li></ol></div></div><div class="section" title="8.3.3.3.&nbsp;Implementing Your Own Visibility Label Algorithm"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8928"></a>8.3.3.3.&nbsp;Implementing Your Own Visibility Label Algorithm</h4></div></div></div><p>Interpreting the labels authenticated for a given get/scan request is a pluggable
          algorithm. You can specify a custom plugin by using the property
            <code class="code">hbase.regionserver.scan.visibility.label.generator.class</code>. The default
          implementation class is
            <code class="code">org.apache.hadoop.hbase.security.visibility.DefaultScanLabelGenerator</code>. You
          can also configure a set of <code class="code">ScanLabelGenerators</code> to be used by the system, as
          a comma-separated list.</p></div></div><div class="section" title="8.3.4.&nbsp;Transparent Encryption of Data At Rest"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.encryption.server"></a>8.3.4.&nbsp;Transparent Encryption of Data At Rest</h3></div></div></div><p>HBase provides a mechanism for protecting your data at rest, in HFiles and the WAL, which
        reside within HDFS or another distributed filesystem. A two-tier architecture is used for
        flexible and non-intrusive key rotation. "Transparent" means that no implementation changes
        are needed on the client side. When data is written, it is encrypted. When it is read, it is
        decrypted on demand.</p><div class="section" title="8.3.4.1.&nbsp;How It Works"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8947"></a>8.3.4.1.&nbsp;How It Works</h4></div></div></div><p>The administrator provisions a master key for the cluster, which is stored in a key
          provider accessible to every trusted HBase process, including the HMaster, RegionServers,
          and clients (such as HBase Shell) on administrative workstations. The default key provider
          is integrated with the Java KeyStore API and any key management systems with support for
          it. Other custom key provider implementations are possible. The key retrieval mechanism is
          configured in the <code class="filename">hbase-site.xml</code> configuration file. The master key
          may be stored on the cluster servers, protected by a secure KeyStore file, or on an
          external keyserver, or in a hardware security module. This master key is resolved as
          needed by HBase processes through the configured key provider.</p><p>Next, encryption use can be specified in the schema, per column family, by creating
          or modifying a column descriptor to include two additional attributes: the name of the
          encryption algorithm to use (currently only "AES" is supported), and optionally, a data
          key wrapped (encrypted) with the cluster master key. If a data key is not explictly
          configured for a ColumnFamily, HBase will create a random data key per HFile. This
          provides an incremental improvement in security over the alternative. Unless you need to
          supply an explicit data key, such as in a case where you are generating encrypted HFiles
          for bulk import with a given data key, only specify the encryption algorithm in the
          ColumnFamily schema metadata and let HBase create data keys on demand. Per Column Family
          keys facilitate low impact incremental key rotation and reduce the scope of any external
          leak of key material. The wrapped data key is stored in the ColumnFamily schema metadata,
          and in each HFile for the Column Family, encrypted with the cluster master key. After the
          Column Family is configured for encryption, any new HFiles will be written encrypted. To
          ensure encryption of all HFiles, trigger a major compaction after enabling this
          feature.</p><p>When the HFile is opened, the data key is extracted from the HFile, decrypted with the
          cluster master key, and used for decryption of the remainder of the HFile. The HFile will
          be unreadable if the master key is not available. If a remote user somehow acquires access
          to the HFile data because of some lapse in HDFS permissions, or from inappropriately
          discarded media, it will not be possible to decrypt either the data key or the file
          data.</p><p>It is also possible to encrypt the WAL. Even though WALs are transient, it is
          necessary to encrypt the WALEdits to avoid circumventing HFile protections for encrypted
          column families, in the event that the underlying filesystem is compromised. When WAL
          encryption is enabled, all WALs are encrypted, regardless of whether the relevant HFiles
          are encrypted.</p></div><div class="section" title="8.3.4.2.&nbsp;Server-Side Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e8961"></a>8.3.4.2.&nbsp;Server-Side Configuration</h4></div></div></div><p>This procedure assumes you are using the default Java keystore implementation. If you
          are using a custom implementation, check its documentation and adjust accordingly.</p><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Create a secret key of appropriate length for AES encryption, using the keytool utility."><p class="title"><b>Create a secret key of appropriate length for AES encryption, using the
                <code class="code">keytool</code> utility.</b></p><pre class="screen">$ <strong class="userinput"><code>keytool -keystore /path/to/hbase/conf/hbase.jks \
  -storetype jceks -storepass **** \
  -genseckey -keyalg AES -keysize 128 \
  -alias &lt;alias&gt;</code></strong></pre><p>Replace <em class="replaceable"><code>****</code></em> with the password for the keystore file
              and &lt;alias&gt; with the username of the HBase service account, or an arbitrary
              string. If you use an arbitrary string, you will need to configure HBase to use it,
              and that is covered below. Specify a keysize that is appropriate. Do not specify a
              separate password for the key, but press <span class="keycap"><strong>Return</strong></span> when prompted.</p></li><li class="step" title="Set appropriate permissions on the keyfile and distribute it to all the HBase servers."><p class="title"><b>Set appropriate permissions on the keyfile and distribute it to all the HBase
              servers.</b></p><p>The previous command created a file called <code class="filename">hbase.jks</code> in the
              HBase <code class="filename">conf/</code> directory. Set the permissions and ownership on this
              file such that only the HBase service account user can read the file, and securely
              distribute the key to all HBase servers.</p></li><li class="step" title="Configure the HBase daemons."><p class="title"><b>Configure the HBase daemons.</b></p><p>Set the following properties in <code class="filename">hbase-site.xml</code> on the region
              servers, to configure HBase daemons to use a key provider backed by the KeyStore file
              or retrieving the cluster master key. In the example below, replace
                <em class="replaceable"><code>****</code></em> with the password.</p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.crypto.keyprovider&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.crypto.keyprovider.parameters&lt;/name&gt;
    &lt;value&gt;jceks:///path/to/hbase/conf/hbase.jks?password=****&lt;/value&gt;
&lt;/property&gt;
            </pre><p>By default, the HBase service account name will be used to resolve the cluster
              master key. However, you can store it with an arbitrary alias (in the
                <span class="command"><strong>keytool</strong></span> command). In that case, set the following property to the
              alias you used.</p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.crypto.master.key.name&lt;/name&gt;
    &lt;value&gt;my-alias&lt;/value&gt;
&lt;/property&gt;
            </pre><p>You also need to be sure your HFiles use HFile v3, in order to use transparent
              encryption. This is the default configuration for HBase 1.0 onward. For previous
              versions, set the following property in your <code class="filename">hbase-site.xml</code>
              file.</p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hfile.format.version&lt;/name&gt;
    &lt;value&gt;3&lt;/value&gt;
&lt;/property&gt;
            </pre><p>Optionally, you can use a different cipher provider, either a Java Cryptography
              Encryption (JCE) algorithm provider or a custom HBase cipher implementation. </p><ol type="a" class="substeps"><li class="step" title="JCE:"><p class="title"><b>JCE: </b></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Install a signed JCE provider (supporting &#8220;AES/CTR/NoPadding&#8221; mode with
                      128 bit keys) </p></li><li class="listitem"><p>Add it with highest preference to the JCE site configuration file
                        <code class="filename">$JAVA_HOME/lib/security/java.security</code>.</p></li><li class="listitem"><p>Update <code class="option">hbase.crypto.algorithm.aes.provider</code> and
                        <code class="option">hbase.crypto.algorithm.rng.provider</code> options in
                        <code class="filename">hbase-site.xml</code>. </p></li></ul></div></li><li class="step" title="Custom HBase Cipher:"><p class="title"><b>Custom HBase Cipher: </b></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Implement
                      <code class="code">org.apache.hadoop.hbase.io.crypto.CipherProvider</code>.</p></li><li class="listitem"><p>Add the implementation to the server classpath.</p></li><li class="listitem"><p>Update <code class="option">hbase.crypto.cipherprovider</code> in
                        <code class="filename">hbase-site.xml</code>.</p></li></ul></div></li></ol></li><li class="step" title="Configure WAL encryption."><p class="title"><b>Configure WAL encryption.</b></p><p>Configure WAL encryption in every RegionServer's
                <code class="filename">hbase-site.xml</code>, by setting the following properties. You can
              include these in the HMaster's <code class="filename">hbase-site.xml</code> as well, but the
              HMaster does not have a WAL and will not use them.</p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.regionserver.hlog.reader.impl&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.regionserver.hlog.writer.impl&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.regionserver.wal.encryption&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
              </pre></li><li class="step" title="Configure permissions on the hbase-site.xml file."><p class="title"><b>Configure permissions on the <code class="filename">hbase-site.xml</code> file.</b></p><p>Because the keystore password is stored in the hbase-site.xml, you need to ensure
              that only the HBase user can read the <code class="filename">hbase-site.xml</code> file, using
              file ownership and permissions.</p></li><li class="step" title="Restart your cluster."><p class="title"><b>Restart your cluster.</b></p><p>Distribute the new configuration file to all nodes and restart your
              cluster.</p></li></ol></div></div><div class="section" title="8.3.4.3.&nbsp;Administration"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e9102"></a>8.3.4.3.&nbsp;Administration</h4></div></div></div><p>Administrative tasks can be performed in HBase Shell or the Java API.</p><div class="caution" title="Java API" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Java API</h3><p>Java API examples in this section are taken from the source file
              <code class="filename">hbase-server/src/test/java/org/apache/hadoop/hbase/util/TestHBaseFsckEncryption.java</code>.
            .</p><p>Neither these examples, nor the source files they are taken from, are part of the
            public HBase API, and are provided for illustration only. Refer to the official API
            for usage instructions.</p></div><div class="variablelist"><dl><dt><span class="term">Enable Encryption on a Column Family</span></dt><dd><p>To enable encryption on a column family, you can either use HBase Shell or the
                Java API. After enabling encryption, trigger a major compaction. When the major
                compaction completes, the HFiles will be encrypted.</p><div class="example"><a name="d2875e9124"></a><p class="title"><b>Example&nbsp;8.14.&nbsp;HBase Shell</b></p><div class="example-contents"><pre class="screen">
hbase&gt; disable 'mytable'
hbase&gt; alter 'mytable', 'mycf', {ENCRYPTION =&gt; AES}
hbase&gt; enable 'mytable'
                </pre></div></div><br class="example-break"><div class="example"><a name="d2875e9129"></a><p class="title"><b>Example&nbsp;8.15.&nbsp;Java API</b></p><div class="example-contents"><p>You can use the <code class="code">HBaseAdmin#modifyColumn</code> API to modify the
                    <span class="property">ENCRYPTION</span> attribute on a Column Family. Additionally, you
                  can specify the specific key to use as the wrapper, by setting the
                    <span class="property">ENCRYPTION_KEY</span> attribute. This is only possible via the
                  Java API, and not the HBase Shell. The default behavior if you do not specify an
                    <span class="property">ENCRYPTION_KEY</span> for a column family is for a random key to
                  be generated for each encrypted column family (per HFile). This provides
                  additional defense in the (unlikely, but theoretically possible) occurrence of
                  storing the same data in multiple HFiles with exactly the same block layout, the
                  same data key, and the same randomly-generated initialization vector.</p><p>This example shows how to programmatically set the transparent encryption both
                  in the server configuration and at the column family, as part of a test which uses
                  the Minicluster configuration.</p><pre class="programlisting">
@Before
public void setUp() throws Exception {
  conf = TEST_UTIL.getConfiguration();
  conf.setInt("hfile.format.version", 3);
  conf.set(HConstants.CRYPTO_KEYPROVIDER_CONF_KEY, KeyProviderForTesting.class.getName());
  conf.set(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY, "hbase");

  // Create the test encryption key
  SecureRandom rng = new SecureRandom();
  byte[] keyBytes = new byte[AES.KEY_LENGTH];
  rng.nextBytes(keyBytes);
  cfKey = new SecretKeySpec(keyBytes, "AES");

  // Start the minicluster
  TEST_UTIL.startMiniCluster(3);

  // Create the table
  htd = new HTableDescriptor(TableName.valueOf("default", "TestHBaseFsckEncryption"));
  HColumnDescriptor hcd = new HColumnDescriptor("cf");
  hcd.setEncryptionType("AES");
  hcd.setEncryptionKey(EncryptionUtil.wrapKey(conf,
    conf.get(HConstants.CRYPTO_MASTERKEY_NAME_CONF_KEY, User.getCurrent().getShortName()),
    cfKey));
  htd.addFamily(hcd);
  TEST_UTIL.getHBaseAdmin().createTable(htd);
  TEST_UTIL.waitTableAvailable(htd.getName(), 5000);
}
                </pre></div></div><br class="example-break"></dd><dt><span class="term">Rotate the Data Key</span></dt><dd><p>To rotate the data key, first change the ColumnFamily key in the column
                descriptor, then trigger a major compaction. When compaction is complete, all HFiles
                will be re-encrypted using the new data key. Until the compaction completes, the
                old HFiles will still be readable using the old key.</p><p>If you rely on HBase's default behavior of generating a random key for each
                HFile, there is no need to rotate data keys. A major compaction will re-encrypt the
                HFile with a new key.</p></dd><dt><span class="term">Switching Between Using a Random Data Key and Specifying A Key</span></dt><dd><p>If you configured a column family to use a specific key and you want to return
                to the default behavior of using a randomly-generated key for that column family,
                use the Java API to alter the <code class="code">HColumnDescriptor</code> so that no value is
                sent with the key <code class="literal">ENCRYPTION_KEY</code>.</p></dd><dt><span class="term">Rotate the Master Key</span></dt><dd><p>To rotate the master key, first generate and distribute the new key. Then update
                the KeyStore to contain a new master key, and keep the old master key in the
                KeyStore using a different alias. Next, configure fallback to the old master key in
                the <code class="filename">hbase-site.xml</code> file.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.crypto.master.alternate.key.name&lt;/name&gt;
  &lt;value&gt;hbase.old&lt;/value&gt;
&lt;/property&gt;
                </pre><p>Rolling restart your cluster for this change to take effect. Trigger a major
                compaction on each table. At the end of the major compaction, all HFiles will be
                re-encrypted with data keys wrapped by the new cluster key. At this point, you can
                remove the old master key from the KeyStore, remove the configuration for the
                fallback master key from the <code class="filename">hbase-site.xml</code>, and perform a
                second rolling restart at some point. This second rolling restart is not
                time-sensitive.</p></dd><dt><span class="term"></span></dt><dd><p></p></dd></dl></div></div></div><div class="section" title="8.3.5.&nbsp;Secure Bulk Load"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.secure.bulkload"></a>8.3.5.&nbsp;Secure Bulk Load</h3></div></div></div><p> Bulk loading in secure mode is a bit more involved than normal setup, since the client
        has to transfer the ownership of the files generated from the mapreduce job to HBase. Secure
        bulk loading is implemented by a coprocessor, named <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/security/access/SecureBulkLoadEndpoint.html" target="_top">SecureBulkLoadEndpoint</a>, which uses a staging directory configured by the
        configuration property <code class="option">hbase.bulkload.staging.dir</code>, which defaults to
          <code class="filename">/tmp/hbase-staging/</code>.</p><div class="itemizedlist" title="Secure Bulk Load Algorithm"><p class="title"><b>Secure Bulk Load Algorithm</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>One time only, create a staging directory which is world-traversable and owned by
            the user which runs HBase (mode 711, or <code class="literal">rwx--x--x</code>). A listing of this
            directory will look similar to the following: </p><pre class="screen">$ <strong class="userinput"><code>ls -ld /tmp/hbase-staging</code></strong>
drwx--x--x  2 hbase  hbase  68  3 Sep 14:54 /tmp/hbase-staging
          </pre></li><li class="listitem"><p>A user writes out data to a secure output directory owned by that user. For example,
              <code class="filename">/user/foo/data</code>.</p></li><li class="listitem"><p>Internally, HBase creates a secret staging directory which is globally
            readable/writable (<code class="code">-rwxrwxrwx, 777</code>). For example,
              <code class="filename">/tmp/hbase-staging/averylongandrandomdirectoryname</code>. The name and
            location of this directory is not exposed to the user. HBase manages creation and
            deletion of this directory.</p></li><li class="listitem"><p>The user makes the data world-readable and world-writable, moves it into the random
            staging directory, then calls the <code class="code">SecureBulkLoadClient#bulkLoadHFiles</code>
            method.</p></li></ul></div><p>The strength of the security lies in the length and randomness of the secret
        directory.</p><p>To enable secure bulk load, add the following properties to
          <code class="filename">hbase-site.xml</code>.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.bulkload.staging.dir&lt;/name&gt;
  &lt;value&gt;/tmp/hbase-staging&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider,
  org.apache.hadoop.hbase.security.access.AccessController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider,
  org.apache.hadoop.hbase.security.access.AccessController,org.apache.hadoop.hbase.security.access.SecureBulkLoadEndpoint&lt;/value&gt;
&lt;/property&gt;
    </pre></div></div><div class="section" title="8.4.&nbsp;Security Configuration Example"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="security.example.config"></a>8.4.&nbsp;Security Configuration Example</h2></div></div></div><p>This configuration example includes support for HFile v3, ACLs, Visibility Labels, and
      transparent encryption of data at rest and the WAL. All options have been discussed separately
      in the sections above.</p><div class="example"><a name="d2875e9254"></a><p class="title"><b>Example&nbsp;8.16.&nbsp;Example Security Settings in <code class="filename">hbase-site.xml</code></b></p><div class="example-contents"><pre class="programlisting">
&lt;!-- HFile v3 Support --&gt;
&lt;property&gt;
  &lt;name&gt;hfile.format.version&lt;/name&gt;
  &lt;value&gt;3&lt;/value&gt;
&lt;/property&gt;
&lt;!-- HBase Superuser --&gt;
&lt;property&gt;
  &lt;name&gt;hbase.superuser&lt;/name&gt;
  &lt;value&gt;hbase, admin&lt;/value&gt;
&lt;/property&gt;
&lt;!-- Coprocessors for ACLs and Visibility Tags --&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController,
  org.apache.hadoop.hbase.security.visibility.VisibilityController,
  org.apache.hadoop.hbase.security.token.TokenProvider&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.access.AccessController,
  org.apache.hadoop.hbase.security.visibility.VisibilityController&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop/hbase.security.access.AccessController,
  org.apache.hadoop.hbase.security.access.VisibilityController&lt;/value&gt;
&lt;/property&gt;
&lt;!-- Executable ACL for Coprocessor Endpoints --&gt;
&lt;property&gt;
  &lt;name&gt;hbase.security.exec.permission.checks&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
&lt;!-- Whether a user needs authorization for a visibility tag to set it on a cell --&gt;
&lt;property&gt;
  &lt;name&gt;hbase.security.visibility.mutations.checkauth&lt;/name&gt;
  &lt;value&gt;false&lt;/value&gt;
&lt;/property&gt;
&lt;!-- Secure RPC Transport --&gt;
&lt;property&gt;
  &lt;name&gt;hbase.rpc.protection&lt;/name&gt;
  &lt;value&gt;auth-conf&lt;/value&gt;
 &lt;/property&gt;
 &lt;!-- Transparent Encryption --&gt;
&lt;property&gt;
    &lt;name&gt;hbase.crypto.keyprovider&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.io.crypto.KeyStoreKeyProvider&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.crypto.keyprovider.parameters&lt;/name&gt;
    &lt;value&gt;jceks:///path/to/hbase/conf/hbase.jks?password=***&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.crypto.master.key.name&lt;/name&gt;
    &lt;value&gt;hbase&lt;/value&gt;
&lt;/property&gt;
&lt;!-- WAL Encryption --&gt;
&lt;property&gt;
    &lt;name&gt;hbase.regionserver.hlog.reader.impl&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogReader&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.regionserver.hlog.writer.impl&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.regionserver.wal.SecureProtobufLogWriter&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.regionserver.wal.encryption&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;
&lt;!-- For key rotation --&gt;
&lt;property&gt;
  &lt;name&gt;hbase.crypto.master.alternate.key.name&lt;/name&gt;
  &lt;value&gt;hbase.old&lt;/value&gt;
&lt;/property&gt;
&lt;!-- Secure Bulk Load --&gt;
&lt;property&gt;
  &lt;name&gt;hbase.bulkload.staging.dir&lt;/name&gt;
  &lt;value&gt;/tmp/hbase-staging&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.hbase.security.token.TokenProvider,
  org.apache.hadoop.hbase.security.access.AccessController,org.apache.hadoop.hbase.security.access.SecureBulkLoadEndpoint&lt;/value&gt;
&lt;/property&gt;
        </pre></div></div><br class="example-break"><div class="example"><a name="d2875e9261"></a><p class="title"><b>Example&nbsp;8.17.&nbsp;Example Group Mapper in Hadoop <code class="filename">core-site.xml</code></b></p><div class="example-contents"><p>Adjust these settings to suit your environment.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping&lt;/name&gt;
  &lt;value&gt;org.apache.hadoop.security.LdapGroupsMapping&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.url&lt;/name&gt;
  &lt;value&gt;ldap://server&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.bind.user&lt;/name&gt;
  &lt;value&gt;Administrator@example-ad.local&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.bind.password&lt;/name&gt;
  &lt;value&gt;****&lt;/value&gt; &lt;!-- Replace with the actual password --&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.base&lt;/name&gt;
  &lt;value&gt;dc=example-ad,dc=local&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.filter.user&lt;/name&gt;
  &lt;value&gt;(&amp;amp;(objectClass=user)(sAMAccountName={0}))&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.filter.group&lt;/name&gt;
  &lt;value&gt;(objectClass=group)&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.attr.member&lt;/name&gt;
  &lt;value&gt;member&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hadoop.security.group.mapping.ldap.search.attr.group.name&lt;/name&gt;
  &lt;value&gt;cn&lt;/value&gt;
&lt;/property&gt;
        </pre></div></div><br class="example-break"></div></div><div class="chapter" title="Chapter&nbsp;9.&nbsp;Architecture"><div class="titlepage"><div><div><h2 class="title"><a name="architecture"></a>Chapter&nbsp;9.&nbsp;Architecture</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#arch.overview">9.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#arch.overview.nosql">9.1.1. NoSQL?</a></span></dt><dt><span class="section"><a href="#arch.overview.when">9.1.2. When Should I Use HBase?</a></span></dt><dt><span class="section"><a href="#arch.overview.hbasehdfs">9.1.3. What Is The Difference Between HBase and Hadoop/HDFS?</a></span></dt></dl></dd><dt><span class="section"><a href="#arch.catalog">9.2. Catalog Tables</a></span></dt><dd><dl><dt><span class="section"><a href="#arch.catalog.root">9.2.1. -ROOT-</a></span></dt><dt><span class="section"><a href="#arch.catalog.meta">9.2.2. hbase:meta</a></span></dt><dt><span class="section"><a href="#arch.catalog.startup">9.2.3. Startup Sequencing</a></span></dt></dl></dd><dt><span class="section"><a href="#client">9.3. Client</a></span></dt><dd><dl><dt><span class="section"><a href="#client.connections">9.3.1. Connections</a></span></dt><dt><span class="section"><a href="#client.writebuffer">9.3.2. WriteBuffer and Batch Methods</a></span></dt><dt><span class="section"><a href="#client.external">9.3.3. External Clients</a></span></dt></dl></dd><dt><span class="section"><a href="#client.filter">9.4. Client Request Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#client.filter.structural">9.4.1. Structural</a></span></dt><dt><span class="section"><a href="#client.filter.cv">9.4.2. Column Value</a></span></dt><dt><span class="section"><a href="#client.filter.cvp">9.4.3. Column Value Comparators</a></span></dt><dt><span class="section"><a href="#client.filter.kvm">9.4.4. KeyValue Metadata</a></span></dt><dt><span class="section"><a href="#client.filter.row">9.4.5. RowKey</a></span></dt><dt><span class="section"><a href="#client.filter.utility">9.4.6. Utility</a></span></dt></dl></dd><dt><span class="section"><a href="#master">9.5. Master</a></span></dt><dd><dl><dt><span class="section"><a href="#master.startup">9.5.1. Startup Behavior</a></span></dt><dt><span class="section"><a href="#master.runtime">9.5.2. Runtime Impact</a></span></dt><dt><span class="section"><a href="#master.api">9.5.3. Interface</a></span></dt><dt><span class="section"><a href="#master.processes">9.5.4. Processes</a></span></dt></dl></dd><dt><span class="section"><a href="#regionserver.arch">9.6. RegionServer</a></span></dt><dd><dl><dt><span class="section"><a href="#regionserver.arch.api">9.6.1. Interface</a></span></dt><dt><span class="section"><a href="#regionserver.arch.processes">9.6.2. Processes</a></span></dt><dt><span class="section"><a href="#coprocessors">9.6.3. Coprocessors</a></span></dt><dt><span class="section"><a href="#block.cache">9.6.4. Block Cache</a></span></dt><dt><span class="section"><a href="#wal">9.6.5. Write Ahead Log (WAL)</a></span></dt></dl></dd><dt><span class="section"><a href="#regions.arch">9.7. Regions</a></span></dt><dd><dl><dt><span class="section"><a href="#arch.regions.size">9.7.1. Considerations for Number of Regions</a></span></dt><dt><span class="section"><a href="#regions.arch.assignment">9.7.2. Region-RegionServer Assignment</a></span></dt><dt><span class="section"><a href="#regions.arch.locality">9.7.3. Region-RegionServer Locality</a></span></dt><dt><span class="section"><a href="#arch.region.splits">9.7.4. Region Splits</a></span></dt><dt><span class="section"><a href="#manual_region_splitting_decisions">9.7.5. Manual Region Splitting</a></span></dt><dt><span class="section"><a href="#d2875e11210">9.7.6. Online Region Merges</a></span></dt><dt><span class="section"><a href="#store">9.7.7. Store</a></span></dt></dl></dd><dt><span class="section"><a href="#arch.bulk.load">9.8. Bulk Loading</a></span></dt><dd><dl><dt><span class="section"><a href="#arch.bulk.load.overview">9.8.1. Overview</a></span></dt><dt><span class="section"><a href="#arch.bulk.load.limitations">9.8.2. Bulk Load Limitations</a></span></dt><dt><span class="section"><a href="#arch.bulk.load.arch">9.8.3. Bulk Load Architecture</a></span></dt><dt><span class="section"><a href="#arch.bulk.load.import">9.8.4. Importing the prepared data using the completebulkload tool</a></span></dt><dt><span class="section"><a href="#arch.bulk.load.also">9.8.5. See Also</a></span></dt><dt><span class="section"><a href="#arch.bulk.load.adv">9.8.6. Advanced Usage</a></span></dt></dl></dd><dt><span class="section"><a href="#arch.hdfs">9.9. HDFS</a></span></dt><dd><dl><dt><span class="section"><a href="#arch.hdfs.nn">9.9.1. NameNode</a></span></dt><dt><span class="section"><a href="#arch.hdfs.dn">9.9.2. DataNode</a></span></dt></dl></dd><dt><span class="section"><a href="#arch.timelineconsistent.reads">9.10. Timeline-consistent High Available Reads</a></span></dt><dd><dl><dt><span class="section"><a href="#casestudies.timelineconsistent.intro">9.10.1. Introduction</a></span></dt><dt><span class="section"><a href="#d2875e12656">9.10.2. Timeline Consistency </a></span></dt><dt><span class="section"><a href="#d2875e12703">9.10.3. Tradeoffs</a></span></dt><dt><span class="section"><a href="#d2875e12737">9.10.4. Configuration properties</a></span></dt><dt><span class="section"><a href="#d2875e12762">9.10.5. Creating a table with region replication</a></span></dt><dt><span class="section"><a href="#d2875e12782">9.10.6. Region splits and merges</a></span></dt><dt><span class="section"><a href="#d2875e12787">9.10.7. User Interface</a></span></dt><dt><span class="section"><a href="#d2875e12792">9.10.8. API and Usage</a></span></dt><dt><span class="section"><a href="#d2875e12829">9.10.9. Resources</a></span></dt></dl></dd></dl></div><div class="section" title="9.1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch.overview"></a>9.1.&nbsp;Overview</h2></div></div></div><div class="section" title="9.1.1.&nbsp;NoSQL?"><div class="titlepage"><div><div><h3 class="title"><a name="arch.overview.nosql"></a>9.1.1.&nbsp;NoSQL?</h3></div></div></div><p>HBase is a type of "NoSQL" database.  "NoSQL" is a general term meaning that the database isn't an RDBMS which
	  supports SQL as its primary access language, but there are many types of NoSQL databases:  BerkeleyDB is an
	  example of a local NoSQL database, whereas HBase is very much a distributed database.  Technically speaking,
	  HBase is really more a "Data Store" than "Data Base" because it lacks many of the features you find in an RDBMS,
	  such as typed columns, secondary indexes, triggers, and advanced query languages, etc.
	  </p><p>However, HBase has many features which supports both linear and modular scaling.  HBase clusters expand
	  by adding RegionServers that are hosted on commodity class servers. If a cluster expands from 10 to 20
	  RegionServers, for example, it doubles both in terms of storage and as well as processing capacity.
	  RDBMS can scale well, but only up to a point - specifically, the size of a single database server - and for the best
	  performance requires specialized hardware and storage devices.  HBase features of note are:
	        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Strongly consistent reads/writes:  HBase is not an "eventually consistent" DataStore.  This
              makes it very suitable for tasks such as high-speed counter aggregation.</p></li><li class="listitem"><p>Automatic sharding:  HBase tables are distributed on the cluster via regions, and regions are
              automatically split and re-distributed as your data grows.</p></li><li class="listitem"><p>Automatic RegionServer failover</p></li><li class="listitem"><p>Hadoop/HDFS Integration:  HBase supports HDFS out of the box as its distributed file system.</p></li><li class="listitem"><p>MapReduce:  HBase supports massively parallelized processing via MapReduce for using HBase as both
              source and sink.</p></li><li class="listitem"><p>Java Client API:  HBase supports an easy to use Java API for programmatic access.</p></li><li class="listitem"><p>Thrift/REST API:  HBase also supports Thrift and REST for non-Java front-ends.</p></li><li class="listitem"><p>Block Cache and Bloom Filters:  HBase supports a Block Cache and Bloom Filters for high volume query optimization.</p></li><li class="listitem"><p>Operational Management:  HBase provides build-in web-pages for operational insight as well as JMX metrics.</p></li></ul></div><p>
	  </p></div><div class="section" title="9.1.2.&nbsp;When Should I Use HBase?"><div class="titlepage"><div><div><h3 class="title"><a name="arch.overview.when"></a>9.1.2.&nbsp;When Should I Use HBase?</h3></div></div></div><p>HBase isn't suitable for every problem.</p><p>First, make sure you have enough data.  If you have hundreds of millions or billions of rows, then
	            HBase is a good candidate.  If you only have a few thousand/million rows, then using a traditional RDBMS
	            might be a better choice due to the fact that all of your data might wind up on a single node (or two) and
	            the rest of the cluster may be sitting idle.
	          </p><p>Second, make sure you can live without all the extra features that an RDBMS provides (e.g., typed columns,
	          secondary indexes, transactions, advanced query languages, etc.)  An application built against an RDBMS cannot be
	          "ported" to HBase by simply changing a JDBC driver, for example.  Consider moving from an RDBMS to HBase as a
	          complete redesign as opposed to a port.
              </p><p>Third, make sure you have enough hardware.  Even HDFS doesn't do well with anything less than
                5 DataNodes (due to things such as HDFS block replication which has a default of 3), plus a NameNode.
                </p><p>HBase can run quite well stand-alone on a laptop - but this should be considered a development
                configuration only.
                </p></div><div class="section" title="9.1.3.&nbsp;What Is The Difference Between HBase and Hadoop/HDFS?"><div class="titlepage"><div><div><h3 class="title"><a name="arch.overview.hbasehdfs"></a>9.1.3.&nbsp;What Is The Difference Between HBase and Hadoop/HDFS?</h3></div></div></div><p><a class="link" href="http://hadoop.apache.org/hdfs/" target="_top">HDFS</a> is a distributed file system that is well suited for the storage of large files.
          Its documentation states that it is not, however, a general purpose file system, and does not provide fast individual record lookups in files.
          HBase, on the other hand, is built on top of HDFS and provides fast record lookups (and updates) for large tables.
          This can sometimes be a point of conceptual confusion.  HBase internally puts your data in indexed "StoreFiles" that exist
          on HDFS for high-speed lookups.  See the <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a> and the rest of this chapter for more information on how HBase achieves its goals.
         </p></div></div><div class="section" title="9.2.&nbsp;Catalog Tables"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch.catalog"></a>9.2.&nbsp;Catalog Tables</h2></div></div></div><p>The catalog table <code class="code">hbase:meta</code> exists as an HBase table and is filtered out of the HBase
        shell's <code class="code">list</code> command, but is in fact a table just like any other. </p><div class="section" title="9.2.1.&nbsp;-ROOT-"><div class="titlepage"><div><div><h3 class="title"><a name="arch.catalog.root"></a>9.2.1.&nbsp;-ROOT-</h3></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="code">-ROOT-</code> table was removed in HBase 0.96.0. Information here should
            be considered historical.</p></div><p>The <code class="code">-ROOT-</code> table kept track of the location of the
            <code class="code">.META</code> table (the previous name for the table now called <code class="code">hbase:meta</code>) prior to HBase
          0.96. The <code class="code">-ROOT-</code> table structure was as follows: </p><div class="itemizedlist" title="Key"><p class="title"><b>Key</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>.META. region key (<code class="code">.META.,,1</code>)</p></li></ul></div><div class="itemizedlist" title="Values"><p class="title"><b>Values</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">info:regioninfo</code> (serialized <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html" target="_top">HRegionInfo</a>
              instance of hbase:meta)</p></li><li class="listitem"><p><code class="code">info:server</code> (server:port of the RegionServer holding
              hbase:meta)</p></li><li class="listitem"><p><code class="code">info:serverstartcode</code> (start-time of the RegionServer process holding
              hbase:meta)</p></li></ul></div></div><div class="section" title="9.2.2.&nbsp;hbase:meta"><div class="titlepage"><div><div><h3 class="title"><a name="arch.catalog.meta"></a>9.2.2.&nbsp;hbase:meta</h3></div></div></div><p>The <code class="code">hbase:meta</code> table (previously called <code class="code">.META.</code>) keeps a list
          of all regions in the system. The location of <code class="code">hbase:meta</code> was previously
          tracked within the <code class="code">-ROOT-</code> table, but is now stored in Zookeeper.</p><p>The <code class="code">hbase:meta</code> table structure is as follows: </p><div class="itemizedlist" title="Key"><p class="title"><b>Key</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Region key of the format (<code class="code">[table],[region start key],[region
              id]</code>)</p></li></ul></div><div class="itemizedlist" title="Values"><p class="title"><b>Values</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">info:regioninfo</code> (serialized <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html" target="_top">
                HRegionInfo</a> instance for this region)</p></li><li class="listitem"><p><code class="code">info:server</code> (server:port of the RegionServer containing this
              region)</p></li><li class="listitem"><p><code class="code">info:serverstartcode</code> (start-time of the RegionServer process
              containing this region)</p></li></ul></div><p>When a table is in the process of splitting, two other columns will be created, called
            <code class="code">info:splitA</code> and <code class="code">info:splitB</code>. These columns represent the two
          daughter regions. The values for these columns are also serialized HRegionInfo instances.
          After the region has been split, eventually this row will be deleted. </p><div class="note" title="Note on HRegionInfo" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note on HRegionInfo</h3><p>The empty key is used to denote table start and table end. A region with an empty
            start key is the first region in a table. If a region has both an empty start and an
            empty end key, it is the only region in the table </p></div><p>In the (hopefully unlikely) event that programmatic processing of catalog metadata is
          required, see the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/Writables.html#getHRegionInfo%28byte[]%29" target="_top">Writables</a>
          utility. </p></div><div class="section" title="9.2.3.&nbsp;Startup Sequencing"><div class="titlepage"><div><div><h3 class="title"><a name="arch.catalog.startup"></a>9.2.3.&nbsp;Startup Sequencing</h3></div></div></div><p>First, the location of <code class="code">hbase:meta</code> is looked up in Zookeeper. Next,
          <code class="code">hbase:meta</code> is updated with server and startcode values.</p><p>For information on region-RegionServer assignment, see <a class="xref" href="#regions.arch.assignment" title="9.7.2.&nbsp;Region-RegionServer Assignment">Section&nbsp;9.7.2, &#8220;Region-RegionServer Assignment&#8221;</a>. </p></div></div><div class="section" title="9.3.&nbsp;Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="client"></a>9.3.&nbsp;Client</h2></div></div></div><p>The HBase client <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>
        is responsible for finding RegionServers that are serving the particular row range of
        interest. It does this by querying the <code class="code">hbase:meta</code> table. See <a class="xref" href="#arch.catalog.meta" title="9.2.2.&nbsp;hbase:meta">Section&nbsp;9.2.2, &#8220;hbase:meta&#8221;</a> for details. After locating the required region(s), the
        client contacts the RegionServer serving that region, rather than going through the master,
        and issues the read or write request. This information is cached in the client so that
        subsequent requests need not go through the lookup process. Should a region be reassigned
        either by the master load balancer or because a RegionServer has died, the client will
        requery the catalog tables to determine the new location of the user region. </p><p>See <a class="xref" href="#master.runtime" title="9.5.2.&nbsp;Runtime Impact">Section&nbsp;9.5.2, &#8220;Runtime Impact&#8221;</a> for more information about the impact of the Master on HBase
        Client communication. </p><p>Administrative functions are handled through <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html" target="_top">HBaseAdmin</a>
      </p><div class="section" title="9.3.1.&nbsp;Connections"><div class="titlepage"><div><div><h3 class="title"><a name="client.connections"></a>9.3.1.&nbsp;Connections</h3></div></div></div><p>For connection configuration information, see <a class="xref" href="#client_dependencies" title="2.4.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster">Section&nbsp;2.4.4, &#8220;Client configuration and dependencies connecting to an HBase cluster&#8221;</a>. </p><p><span class="emphasis"><em><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>
            instances are not thread-safe</em></span>. Only one thread use an instance of HTable at
          any given time. When creating HTable instances, it is advisable to use the same <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration" target="_top">HBaseConfiguration</a>
          instance. This will ensure sharing of ZooKeeper and socket instances to the RegionServers
          which is usually what you want. For example, this is preferred:</p><pre class="programlisting">HBaseConfiguration conf = HBaseConfiguration.create();
HTable table1 = new HTable(conf, "myTable");
HTable table2 = new HTable(conf, "myTable");</pre><p>as opposed to this:</p><pre class="programlisting">HBaseConfiguration conf1 = HBaseConfiguration.create();
HTable table1 = new HTable(conf1, "myTable");
HBaseConfiguration conf2 = HBaseConfiguration.create();
HTable table2 = new HTable(conf2, "myTable");</pre><p>For more information about how connections are handled in the HBase client,
        see <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnectionManager.html" target="_top">HConnectionManager</a>.
          </p><div class="section" title="9.3.1.1.&nbsp;Connection Pooling"><div class="titlepage"><div><div><h4 class="title"><a name="client.connection.pooling"></a>9.3.1.1.&nbsp;Connection Pooling</h4></div></div></div><p>For applications which require high-end multithreaded access (e.g., web-servers or application servers that may serve many application threads
            in a single JVM), you can pre-create an <code class="classname">HConnection</code>, as shown in
              the following example:</p><div class="example"><a name="d2875e9541"></a><p class="title"><b>Example&nbsp;9.1.&nbsp;Pre-Creating a <code class="code">HConnection</code></b></p><div class="example-contents"><pre class="programlisting">// Create a connection to the cluster.
HConnection connection = HConnectionManager.createConnection(Configuration);
HTableInterface table = connection.getTable("myTable");
// use table as needed, the table returned is lightweight
table.close();
// use the connection for other access to the cluster
connection.close();</pre></div></div><br class="example-break"><p>Constructing HTableInterface implementation is very lightweight and resources are
            controlled.</p><div class="warning" title="HTablePool is Deprecated" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><code class="code">HTablePool</code> is Deprecated</h3><p>Previous versions of this guide discussed <code class="code">HTablePool</code>, which was
                deprecated in HBase 0.94, 0.95, and 0.96, and removed in 0.98.1, by <a class="link" href="https://issues.apache.org/jira/browse/HBASE-6580" target="_top">HBASE-6500</a>.
                Please use <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnection.html" target="_top"><code class="code">HConnection</code></a> instead.</p></div></div></div><div class="section" title="9.3.2.&nbsp;WriteBuffer and Batch Methods"><div class="titlepage"><div><div><h3 class="title"><a name="client.writebuffer"></a>9.3.2.&nbsp;WriteBuffer and Batch Methods</h3></div></div></div><p>If <a class="xref" href="#perf.hbase.client.autoflush" title="14.8.4.&nbsp;HBase Client: AutoFlush">Section&nbsp;14.8.4, &#8220;HBase Client: AutoFlush&#8221;</a> is turned off on
               <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>,
               <code class="classname">Put</code>s are sent to RegionServers when the writebuffer
               is filled.  The writebuffer is 2MB by default.  Before an HTable instance is
               discarded, either <code class="methodname">close()</code> or
               <code class="methodname">flushCommits()</code> should be invoked so Puts
               will not be lost.
	      </p><p>Note: <code class="code">htable.delete(Delete);</code> does not go in the writebuffer!  This only applies to Puts.
	      </p><p>For additional information on write durability, review the <a class="link" href="../acid-semantics.html" target="_top">ACID semantics</a> page.
	      </p><p>For fine-grained control of batching of
           <code class="classname">Put</code>s or <code class="classname">Delete</code>s,
           see the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29" target="_top">batch</a> methods on HTable.
	   </p></div><div class="section" title="9.3.3.&nbsp;External Clients"><div class="titlepage"><div><div><h3 class="title"><a name="client.external"></a>9.3.3.&nbsp;External Clients</h3></div></div></div><p>Information on non-Java clients and custom protocols is covered in <a class="xref" href="#external_apis" title="Chapter&nbsp;11.&nbsp;Apache HBase External APIs">Chapter&nbsp;11, <i>Apache HBase External APIs</i></a>
           </p></div></div><div class="section" title="9.4.&nbsp;Client Request Filters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="client.filter"></a>9.4.&nbsp;Client Request Filters</h2></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html" target="_top">Get</a> and <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a> instances can be
       optionally configured with <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/Filter.html" target="_top">filters</a> which are applied on the RegionServer.
      </p><p>Filters can be confusing because there are many different types, and it is best to approach them by understanding the groups
      of Filter functionality.
      </p><div class="section" title="9.4.1.&nbsp;Structural"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.structural"></a>9.4.1.&nbsp;Structural</h3></div></div></div><p>Structural Filters contain other Filters.</p><div class="section" title="9.4.1.1.&nbsp;FilterList"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.structural.fl"></a>9.4.1.1.&nbsp;FilterList</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FilterList.html" target="_top">FilterList</a>
          represents a list of Filters with a relationship of <code class="code">FilterList.Operator.MUST_PASS_ALL</code> or
          <code class="code">FilterList.Operator.MUST_PASS_ONE</code> between the Filters.  The following example shows an 'or' between two
          Filters (checking for either 'my value' or 'my other value' on the same attribute).</p><pre class="programlisting">
FilterList list = new FilterList(FilterList.Operator.MUST_PASS_ONE);
SingleColumnValueFilter filter1 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
list.add(filter1);
SingleColumnValueFilter filter2 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my other value")
	);
list.add(filter2);
scan.setFilter(list);
</pre></div></div><div class="section" title="9.4.2.&nbsp;Column Value"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.cv"></a>9.4.2.&nbsp;Column Value</h3></div></div></div><div class="section" title="9.4.2.1.&nbsp;SingleColumnValueFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cv.scvf"></a>9.4.2.1.&nbsp;SingleColumnValueFilter</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html" target="_top">SingleColumnValueFilter</a>
            can be used to test column values for equivalence (<code class="code"><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/CompareFilter.CompareOp.html" target="_top">CompareOp.EQUAL</a>
            </code>), inequality (<code class="code">CompareOp.NOT_EQUAL</code>), or ranges (e.g.,
              <code class="code">CompareOp.GREATER</code>). The following is example of testing equivalence a
            column to a String value "my value"...</p><pre class="programlisting">
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
scan.setFilter(filter);
</pre></div></div><div class="section" title="9.4.3.&nbsp;Column Value Comparators"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.cvp"></a>9.4.3.&nbsp;Column Value Comparators</h3></div></div></div><p>There are several Comparator classes in the Filter package that deserve special
          mention. These Comparators are used in concert with other Filters, such as <a class="xref" href="#client.filter.cv.scvf" title="9.4.2.1.&nbsp;SingleColumnValueFilter">Section&nbsp;9.4.2.1, &#8220;SingleColumnValueFilter&#8221;</a>. </p><div class="section" title="9.4.3.1.&nbsp;RegexStringComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.rcs"></a>9.4.3.1.&nbsp;RegexStringComparator</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RegexStringComparator.html" target="_top">RegexStringComparator</a>
            supports regular expressions for value comparisons.</p><pre class="programlisting">
RegexStringComparator comp = new RegexStringComparator("my.");   // any value that starts with 'my'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</pre><p>See the Oracle JavaDoc for <a class="link" href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_top">supported
              RegEx patterns in Java</a>. </p></div><div class="section" title="9.4.3.2.&nbsp;SubstringComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.SubStringComparator"></a>9.4.3.2.&nbsp;SubstringComparator</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SubstringComparator.html" target="_top">SubstringComparator</a>
            can be used to determine if a given substring exists in a value. The comparison is
            case-insensitive. </p><pre class="programlisting">
SubstringComparator comp = new SubstringComparator("y val");   // looking for 'my value'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</pre></div><div class="section" title="9.4.3.3.&nbsp;BinaryPrefixComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.bfp"></a>9.4.3.3.&nbsp;BinaryPrefixComparator</h4></div></div></div><p>See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryPrefixComparator.html" target="_top">BinaryPrefixComparator</a>.</p></div><div class="section" title="9.4.3.4.&nbsp;BinaryComparator"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.cvp.bc"></a>9.4.3.4.&nbsp;BinaryComparator</h4></div></div></div><p>See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryComparator.html" target="_top">BinaryComparator</a>.</p></div></div><div class="section" title="9.4.4.&nbsp;KeyValue Metadata"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.kvm"></a>9.4.4.&nbsp;KeyValue Metadata</h3></div></div></div><p>As HBase stores data internally as KeyValue pairs, KeyValue Metadata Filters evaluate
          the existence of keys (i.e., ColumnFamily:Column qualifiers) for a row, as opposed to
          values the previous section. </p><div class="section" title="9.4.4.1.&nbsp;FamilyFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.ff"></a>9.4.4.1.&nbsp;FamilyFilter</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FamilyFilter.html" target="_top">FamilyFilter</a>
            can be used to filter on the ColumnFamily. It is generally a better idea to select
            ColumnFamilies in the Scan than to do it with a Filter.</p></div><div class="section" title="9.4.4.2.&nbsp;QualifierFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.qf"></a>9.4.4.2.&nbsp;QualifierFilter</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/QualifierFilter.html" target="_top">QualifierFilter</a>
            can be used to filter based on Column (aka Qualifier) name. </p></div><div class="section" title="9.4.4.3.&nbsp;ColumnPrefixFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.cpf"></a>9.4.4.3.&nbsp;ColumnPrefixFilter</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.html" target="_top">ColumnPrefixFilter</a>
            can be used to filter based on the lead portion of Column (aka Qualifier) names. </p><p>A ColumnPrefixFilter seeks ahead to the first column matching the prefix in each row
            and for each involved column family. It can be used to efficiently get a subset of the
            columns in very wide rows. </p><p>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </p><p>Example: Find all columns in a row and family that start with "abc"</p><pre class="programlisting">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] prefix = Bytes.toBytes("abc");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnPrefixFilter(prefix);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</pre></div><div class="section" title="9.4.4.4.&nbsp;MultipleColumnPrefixFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.mcpf"></a>9.4.4.4.&nbsp;MultipleColumnPrefixFilter</h4></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.html" target="_top">MultipleColumnPrefixFilter</a>
            behaves like ColumnPrefixFilter but allows specifying multiple prefixes. </p><p>Like ColumnPrefixFilter, MultipleColumnPrefixFilter efficiently seeks ahead to the
            first column matching the lowest prefix and also seeks past ranges of columns between
            prefixes. It can be used to efficiently get discontinuous sets of columns from very wide
            rows. </p><p>Example: Find all columns in a row and family that start with "abc" or "xyz"</p><pre class="programlisting">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[][] prefixes = new byte[][] {Bytes.toBytes("abc"), Bytes.toBytes("xyz")};
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new MultipleColumnPrefixFilter(prefixes);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</pre></div><div class="section" title="9.4.4.5.&nbsp;ColumnRangeFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.kvm.crf "></a>9.4.4.5.&nbsp;ColumnRangeFilter</h4></div></div></div><p>A <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnRangeFilter.html" target="_top">ColumnRangeFilter</a>
            allows efficient intra row scanning. </p><p>A ColumnRangeFilter can seek ahead to the first matching column for each involved
            column family. It can be used to efficiently get a 'slice' of the columns of a very wide
            row. i.e. you have a million columns in a row but you only want to look at columns
            bbbb-bbdd. </p><p>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </p><p>Example: Find all columns in a row and family between "bbbb" (inclusive) and "bbdd"
            (inclusive)</p><pre class="programlisting">
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] startColumn = Bytes.toBytes("bbbb");
byte[] endColumn = Bytes.toBytes("bbdd");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnRangeFilter(startColumn, true, endColumn, true);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</pre><p>Note:  Introduced in HBase 0.92</p></div></div><div class="section" title="9.4.5.&nbsp;RowKey"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.row"></a>9.4.5.&nbsp;RowKey</h3></div></div></div><div class="section" title="9.4.5.1.&nbsp;RowFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.row.rf"></a>9.4.5.1.&nbsp;RowFilter</h4></div></div></div><p>It is generally a better idea to use the startRow/stopRow methods on Scan for row selection, however
          <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RowFilter.html" target="_top">RowFilter</a> can also be used.</p></div></div><div class="section" title="9.4.6.&nbsp;Utility"><div class="titlepage"><div><div><h3 class="title"><a name="client.filter.utility"></a>9.4.6.&nbsp;Utility</h3></div></div></div><div class="section" title="9.4.6.1.&nbsp;FirstKeyOnlyFilter"><div class="titlepage"><div><div><h4 class="title"><a name="client.filter.utility.fkof"></a>9.4.6.1.&nbsp;FirstKeyOnlyFilter</h4></div></div></div><p>This is primarily used for rowcount jobs.
          See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html" target="_top">FirstKeyOnlyFilter</a>.</p></div></div></div><div class="section" title="9.5.&nbsp;Master"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="master"></a>9.5.&nbsp;Master</h2></div></div></div><p><code class="code">HMaster</code> is the implementation of the Master Server. The Master server is
        responsible for monitoring all RegionServer instances in the cluster, and is the interface
        for all metadata changes. In a distributed cluster, the Master typically runs on the <a class="xref" href="#arch.hdfs.nn" title="9.9.1.&nbsp;NameNode">Section&nbsp;9.9.1, &#8220;NameNode&#8221;</a>. J Mohamed Zahoor goes into some more detail on the Master
        Architecture in this blog posting, <a class="link" href="http://blog.zahoor.in/2012/08/hbase-hmaster-architecture/" target="_top">HBase HMaster
          Architecture </a>.</p><div class="section" title="9.5.1.&nbsp;Startup Behavior"><div class="titlepage"><div><div><h3 class="title"><a name="master.startup"></a>9.5.1.&nbsp;Startup Behavior</h3></div></div></div><p>If run in a multi-Master environment, all Masters compete to run the cluster.  If the active
         Master loses its lease in ZooKeeper (or the Master shuts down), then then the remaining Masters jostle to
         take over the Master role.
         </p></div><div class="section" title="9.5.2.&nbsp;Runtime Impact"><div class="titlepage"><div><div><h3 class="title"><a name="master.runtime"></a>9.5.2.&nbsp;Runtime Impact</h3></div></div></div><p>A common dist-list question involves what happens to an HBase cluster when the Master
          goes down. Because the HBase client talks directly to the RegionServers, the cluster can
          still function in a "steady state." Additionally, per <a class="xref" href="#arch.catalog" title="9.2.&nbsp;Catalog Tables">Section&nbsp;9.2, &#8220;Catalog Tables&#8221;</a>, <code class="code">hbase:meta</code> exists as an HBase table and is not
          resident in the Master. However, the Master controls critical functions such as
          RegionServer failover and completing region splits. So while the cluster can still run for
          a short time without the Master, the Master should be restarted as soon as possible.
        </p></div><div class="section" title="9.5.3.&nbsp;Interface"><div class="titlepage"><div><div><h3 class="title"><a name="master.api"></a>9.5.3.&nbsp;Interface</h3></div></div></div><p>The methods exposed by <code class="code">HMasterInterface</code> are primarily metadata-oriented methods:
         </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Table (createTable, modifyTable, removeTable, enable, disable)
            </p></li><li class="listitem"><p>ColumnFamily (addColumn, modifyColumn, removeColumn)
            </p></li><li class="listitem"><p>Region (move, assign, unassign)
            </p></li></ul></div><p>
         For example, when the <code class="code">HBaseAdmin</code> method <code class="code">disableTable</code> is invoked, it is serviced by the Master server.
         </p></div><div class="section" title="9.5.4.&nbsp;Processes"><div class="titlepage"><div><div><h3 class="title"><a name="master.processes"></a>9.5.4.&nbsp;Processes</h3></div></div></div><p>The Master runs several background threads:
         </p><div class="section" title="9.5.4.1.&nbsp;LoadBalancer"><div class="titlepage"><div><div><h4 class="title"><a name="master.processes.loadbalancer"></a>9.5.4.1.&nbsp;LoadBalancer</h4></div></div></div><p>Periodically, and when there are no regions in transition,
             a load balancer will run and move regions around to balance the cluster's load.
             See <a class="xref" href="#balancer_config" title="2.6.3.1.&nbsp;Balancer">Section&nbsp;2.6.3.1, &#8220;Balancer&#8221;</a> for configuring this property.</p><p>See <a class="xref" href="#regions.arch.assignment" title="9.7.2.&nbsp;Region-RegionServer Assignment">Section&nbsp;9.7.2, &#8220;Region-RegionServer Assignment&#8221;</a> for more information on region assignment.
             </p></div><div class="section" title="9.5.4.2.&nbsp;CatalogJanitor"><div class="titlepage"><div><div><h4 class="title"><a name="master.processes.catalog"></a>9.5.4.2.&nbsp;CatalogJanitor</h4></div></div></div><p>Periodically checks and cleans up the hbase:meta table.  See <a class="xref" href="#arch.catalog.meta" title="9.2.2.&nbsp;hbase:meta">Section&nbsp;9.2.2, &#8220;hbase:meta&#8221;</a> for more information on META.</p></div></div></div><div class="section" title="9.6.&nbsp;RegionServer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="regionserver.arch"></a>9.6.&nbsp;RegionServer</h2></div></div></div><p><code class="code">HRegionServer</code> is the RegionServer implementation. It is responsible for
        serving and managing regions. In a distributed cluster, a RegionServer runs on a <a class="xref" href="#arch.hdfs.dn" title="9.9.2.&nbsp;DataNode">Section&nbsp;9.9.2, &#8220;DataNode&#8221;</a>. </p><div class="section" title="9.6.1.&nbsp;Interface"><div class="titlepage"><div><div><h3 class="title"><a name="regionserver.arch.api"></a>9.6.1.&nbsp;Interface</h3></div></div></div><p>The methods exposed by <code class="code">HRegionRegionInterface</code> contain both data-oriented
          and region-maintenance methods: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Data (get, put, delete, next, etc.)</p></li><li class="listitem"><p>Region (splitRegion, compactRegion, etc.)</p></li></ul></div><p> For example, when the <code class="code">HBaseAdmin</code> method
            <code class="code">majorCompact</code> is invoked on a table, the client is actually iterating
          through all regions for the specified table and requesting a major compaction directly to
          each region. </p></div><div class="section" title="9.6.2.&nbsp;Processes"><div class="titlepage"><div><div><h3 class="title"><a name="regionserver.arch.processes"></a>9.6.2.&nbsp;Processes</h3></div></div></div><p>The RegionServer runs a variety of background threads:</p><div class="section" title="9.6.2.1.&nbsp;CompactSplitThread"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.compactsplit"></a>9.6.2.1.&nbsp;CompactSplitThread</h4></div></div></div><p>Checks for splits and handle minor compactions.</p></div><div class="section" title="9.6.2.2.&nbsp;MajorCompactionChecker"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.majorcompact"></a>9.6.2.2.&nbsp;MajorCompactionChecker</h4></div></div></div><p>Checks for major compactions.</p></div><div class="section" title="9.6.2.3.&nbsp;MemStoreFlusher"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.memstore"></a>9.6.2.3.&nbsp;MemStoreFlusher</h4></div></div></div><p>Periodically flushes in-memory writes in the MemStore to StoreFiles.</p></div><div class="section" title="9.6.2.4.&nbsp;LogRoller"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.log"></a>9.6.2.4.&nbsp;LogRoller</h4></div></div></div><p>Periodically checks the RegionServer's HLog.</p></div></div><div class="section" title="9.6.3.&nbsp;Coprocessors"><div class="titlepage"><div><div><h3 class="title"><a name="coprocessors"></a>9.6.3.&nbsp;Coprocessors</h3></div></div></div><p>Coprocessors were added in 0.92. There is a thorough <a class="link" href="https://blogs.apache.org/hbase/entry/coprocessor_introduction" target="_top">Blog Overview
            of CoProcessors</a> posted. Documentation will eventually move to this reference
          guide, but the blog is the most current information available at this time. </p></div><div class="section" title="9.6.4.&nbsp;Block Cache"><div class="titlepage"><div><div><h3 class="title"><a name="block.cache"></a>9.6.4.&nbsp;Block Cache</h3></div></div></div><p>HBase provides two different BlockCache implementations: the default onheap
          LruBlockCache and BucketCache, which is (usually) offheap. This section
          discusses benefits and drawbacks of each implementation, how to choose the appropriate
          option, and configuration options for each.</p><div class="note" title="Block Cache Reporting: UI" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Block Cache Reporting: UI</h3><p>See the RegionServer UI for detail on caching deploy.  Since HBase-0.98.4, the
          Block Cache detail has been significantly extended showing configurations,
          sizings, current usage, time-in-the-cache, and even detail on block counts and types.</p></div><div class="section" title="9.6.4.1.&nbsp;Cache Choices"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e9955"></a>9.6.4.1.&nbsp;Cache Choices</h4></div></div></div><p><code class="classname">LruBlockCache</code> is the original implementation, and is
              entirely within the Java heap. <code class="classname">BucketCache</code> is mainly
              intended for keeping blockcache data offheap, although BucketCache can also
              keep data onheap and serve from a file-backed cache.
              </p><div class="note" title="BucketCache is production ready as of hbase-0.98.6" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">BucketCache is production ready as of hbase-0.98.6</h3><p>To run with BucketCache, you need HBASE-11678. This was included in
                  hbase-0.98.6.
                </p></div><p>
          </p><p>Fetching will always be slower when fetching from BucketCache,
              as compared to the native onheap LruBlockCache. However, latencies tend to be
              less erratic across time, because there is less garbage collection when you use
              BucketCache since it is managing BlockCache allocations, not the GC. If the
              BucketCache is deployed in offheap mode, this memory is not managed by the
              GC at all. This is why you'd use BucketCache, so your latencies are less erratic and to mitigate GCs
              and heap fragmentation.  See Nick Dimiduk's <a class="link" href="http://www.n10k.com/blog/blockcache-101/" target="_top">BlockCache 101</a> for
            comparisons running onheap vs offheap tests. Also see
            <a class="link" href="http://people.apache.org/~stack/bc/" target="_top">Comparing BlockCache Deploys</a>
            which finds that if your dataset fits inside your LruBlockCache deploy, use it otherwise
            if you are experiencing cache churn (or you want your cache to exist beyond the
            vagaries of java GC), use BucketCache.
              </p><p>When you enable BucketCache, you are enabling a two tier caching
              system, an L1 cache which is implemented by an instance of LruBlockCache and
              an offheap L2 cache which is implemented by BucketCache.  Management of these
              two tiers and the policy that dictates how blocks move between them is done by
              <code class="classname">CombinedBlockCache</code>. It keeps all DATA blocks in the L2
              BucketCache and meta blocks -- INDEX and BLOOM blocks --
              onheap in the L1 <code class="classname">LruBlockCache</code>.
              See <a class="xref" href="#offheap.blockcache" title="9.6.4.5.&nbsp;Offheap Block Cache">Section&nbsp;9.6.4.5, &#8220;Offheap Block Cache&#8221;</a> for more detail on going offheap.</p></div><div class="section" title="9.6.4.2.&nbsp;General Cache Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="cache.configurations"></a>9.6.4.2.&nbsp;General Cache Configurations</h4></div></div></div><p>Apart from the cache implementation itself, you can set some general configuration
            options to control how the cache performs. See <a class="link" href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html" target="_top">http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html</a>. After setting any of these options, restart or rolling restart your cluster for the
            configuration to take effect. Check logs for errors or unexpected behavior.</p><p>See also <a class="xref" href="#blockcache.prefetch" title="14.4.4.&nbsp;Prefetch Option for Blockcache">Section&nbsp;14.4.4, &#8220;Prefetch Option for Blockcache&#8221;</a>, which discusses a new option
            introduced in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-9857" target="_top">HBASE-9857</a>.</p></div><div class="section" title="9.6.4.3.&nbsp;LruBlockCache Design"><div class="titlepage"><div><div><h4 class="title"><a name="block.cache.design"></a>9.6.4.3.&nbsp;LruBlockCache Design</h4></div></div></div><p>The LruBlockCache is an LRU cache that contains three levels of block priority to
            allow for scan-resistance and in-memory ColumnFamilies: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Single access priority: The first time a block is loaded from HDFS it normally
                has this priority and it will be part of the first group to be considered during
                evictions. The advantage is that scanned blocks are more likely to get evicted than
                blocks that are getting more usage.</p></li><li class="listitem"><p>Mutli access priority: If a block in the previous priority group is accessed
                again, it upgrades to this priority. It is thus part of the second group considered
                during evictions.</p></li><li class="listitem"><p><a name="hbase.cache.inmemory"></a>In-memory access priority: If the block's family was configured to be
                "in-memory", it will be part of this priority disregarding the number of times it
                was accessed. Catalog tables are configured like this. This group is the last one
                considered during evictions.</p><p>To mark a column family as in-memory, call
                </p><pre class="programlisting">HColumnDescriptor.setInMemory(true);</pre><p> if creating a table from java,
                or set <span class="command"><strong>IN_MEMORY =&gt; true</strong></span> when creating or altering a table in
                the shell: e.g.  </p><pre class="programlisting">hbase(main):003:0&gt; create  't', {NAME =&gt; 'f', IN_MEMORY =&gt; 'true'}</pre></li></ul></div><p> For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/LruBlockCache.html" target="_top">LruBlockCache
              source</a>
          </p></div><div class="section" title="9.6.4.4.&nbsp;LruBlockCache Usage"><div class="titlepage"><div><div><h4 class="title"><a name="block.cache.usage"></a>9.6.4.4.&nbsp;LruBlockCache Usage</h4></div></div></div><p>Block caching is enabled by default for all the user tables which means that any
            read operation will load the LRU cache. This might be good for a large number of use
            cases, but further tunings are usually required in order to achieve better performance.
            An important concept is the <a class="link" href="http://en.wikipedia.org/wiki/Working_set_size" target="_top">working set size</a>, or
            WSS, which is: "the amount of memory needed to compute the answer to a problem". For a
            website, this would be the data that's needed to answer the queries over a short amount
            of time. </p><p>The way to calculate how much memory is available in HBase for caching is: </p><pre class="programlisting">
            number of region servers * heap size * hfile.block.cache.size * 0.99
        </pre><p>The default value for the block cache is 0.25 which represents 25% of the available
            heap. The last value (99%) is the default acceptable loading factor in the LRU cache
            after which eviction is started. The reason it is included in this equation is that it
            would be unrealistic to say that it is possible to use 100% of the available memory
            since this would make the process blocking from the point where it loads new blocks.
            Here are some examples: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>One region server with the default heap size (1 GB) and the default block cache
                size will have 253 MB of block cache available.</p></li><li class="listitem"><p>20 region servers with the heap size set to 8 GB and a default block cache size
                will have 39.6 of block cache.</p></li><li class="listitem"><p>100 region servers with the heap size set to 24 GB and a block cache size of 0.5
                will have about 1.16 TB of block cache.</p></li></ul></div><p>Your data is not the only resident of the block cache. Here are others that you may have to take into account:
        </p><div class="variablelist"><dl><dt><span class="term">Catalog Tables</span></dt><dd><p>The <code class="code">-ROOT-</code> (prior to HBase 0.96. See <a class="xref" href="#arch.catalog.root" title="9.2.1.&nbsp;-ROOT-">Section&nbsp;9.2.1, &#8220;-ROOT-&#8221;</a>) and <code class="code">hbase:meta</code> tables are forced
                  into the block cache and have the in-memory priority which means that they are
                  harder to evict. The former never uses more than a few hundreds of bytes while the
                  latter can occupy a few MBs (depending on the number of regions).</p></dd><dt><span class="term">HFiles Indexes</span></dt><dd><p>An <em class="firstterm">hfile</em> is the file format that HBase uses to store
                  data in HDFS. It contains a multi-layered index which allows HBase to seek to the
                  data without having to read the whole file. The size of those indexes is a factor
                  of the block size (64KB by default), the size of your keys and the amount of data
                  you are storing. For big data sets it's not unusual to see numbers around 1GB per
                  region server, although not all of it will be in cache because the LRU will evict
                  indexes that aren't used.</p></dd><dt><span class="term">Keys</span></dt><dd><p>The values that are stored are only half the picture, since each value is
                  stored along with its keys (row key, family qualifier, and timestamp). See <a class="xref" href="#keysize" title="6.3.3.&nbsp;Try to minimize row and column sizes">Section&nbsp;6.3.3, &#8220;Try to minimize row and column sizes&#8221;</a>.</p></dd><dt><span class="term">Bloom Filters</span></dt><dd><p>Just like the HFile indexes, those data structures (when enabled) are stored
                  in the LRU.</p></dd></dl></div><p>Currently the recommended way to measure HFile indexes and bloom filters sizes is to
            look at the region server web UI and checkout the relevant metrics. For keys, sampling
            can be done by using the HFile command line tool and look for the average key size
            metric. Since HBase 0.98.3, you can view detail on BlockCache stats and metrics
            in a special Block Cache section in the UI.</p><p>It's generally bad to use block caching when the WSS doesn't fit in memory. This is
            the case when you have for example 40GB available across all your region servers' block
            caches but you need to process 1TB of data. One of the reasons is that the churn
            generated by the evictions will trigger more garbage collections unnecessarily. Here are
            two use cases: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Fully random reading pattern: This is a case where you almost never access the
                same row twice within a short amount of time such that the chance of hitting a
                cached block is close to 0. Setting block caching on such a table is a waste of
                memory and CPU cycles, more so that it will generate more garbage to pick up by the
                JVM. For more information on monitoring GC, see <a class="xref" href="#trouble.log.gc" title="15.2.3.&nbsp;JVM Garbage Collection Logs">Section&nbsp;15.2.3, &#8220;JVM Garbage Collection Logs&#8221;</a>.</p></li><li class="listitem"><p>Mapping a table: In a typical MapReduce job that takes a table in input, every
                row will be read only once so there's no need to put them into the block cache. The
                Scan object has the option of turning this off via the setCaching method (set it to
                false). You can still keep block caching turned on on this table if you need fast
                random read access. An example would be counting the number of rows in a table that
                serves live traffic, caching every block of that table would create massive churn
                and would surely evict data that's currently in use. </p></li></ul></div><div class="section" title="9.6.4.4.1.&nbsp;Caching META blocks only (DATA blocks in fscache)"><div class="titlepage"><div><div><h5 class="title"><a name="data.blocks.in.fscache"></a>9.6.4.4.1.&nbsp;Caching META blocks only (DATA blocks in fscache)</h5></div></div></div><p>An interesting setup is one where we cache META blocks only and we read DATA
              blocks in on each access. If the DATA blocks fit inside fscache, this alternative
              may make sense when access is completely random across a very large dataset.
              To enable this setup, alter your table and for each column family
              set <code class="varname">BLOCKCACHE =&gt; 'false'</code>.  You are 'disabling' the
              BlockCache for this column family only you can never disable the caching of
              META blocks. Since
              <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4683" target="_top">HBASE-4683 Always cache index and bloom blocks</a>,
              we will cache META blocks even if the BlockCache is disabled.
            </p></div></div><div class="section" title="9.6.4.5.&nbsp;Offheap Block Cache"><div class="titlepage"><div><div><h4 class="title"><a name="offheap.blockcache"></a>9.6.4.5.&nbsp;Offheap Block Cache</h4></div></div></div><div class="section" title="9.6.4.5.1.&nbsp;How to Enable BucketCache"><div class="titlepage"><div><div><h5 class="title"><a name="enable.bucketcache"></a>9.6.4.5.1.&nbsp;How to Enable BucketCache</h5></div></div></div><p>The usual deploy of BucketCache is via a managing class that sets up two caching tiers: an L1 onheap cache
                    implemented by LruBlockCache and a second L2 cache implemented with BucketCache. The managing class is <a class="link" href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.html" target="_top">CombinedBlockCache</a> by default.
            The just-previous link describes the caching 'policy' implemented by CombinedBlockCache. In short, it works
            by keeping meta blocks -- INDEX and BLOOM in the L1, onheap LruBlockCache tier -- and DATA
            blocks are kept in the L2, BucketCache tier. It is possible to amend this behavior in
            HBase since version 1.0 and ask that a column family have both its meta and DATA blocks hosted onheap in the L1 tier by
            setting <code class="varname">cacheDataInL1</code> via
                  <code class="code">(HColumnDescriptor.setCacheDataInL1(true)</code>
            or in the shell, creating or amending column families setting <code class="varname">CACHE_DATA_IN_L1</code>
            to true: e.g. </p><pre class="programlisting">hbase(main):003:0&gt; create 't', {NAME =&gt; 't', CONFIGURATION =&gt; {CACHE_DATA_IN_L1 =&gt; 'true'}}</pre><p>The BucketCache Block Cache can be deployed onheap, offheap, or file based.
            You set which via the
            <code class="varname">hbase.bucketcache.ioengine</code> setting.  Setting it to
            <code class="varname">heap</code> will have BucketCache deployed inside the 
            allocated java heap. Setting it to <code class="varname">offheap</code> will have
            BucketCache make its allocations offheap,
            and an ioengine setting of <code class="varname">file:PATH_TO_FILE</code> will direct
            BucketCache to use a file caching (Useful in particular if you have some fast i/o attached to the box such
            as SSDs).
        </p><p><a name="raw.l1.l2"></a>It is possible to deploy an L1+L2 setup where we bypass the CombinedBlockCache
            policy and have BucketCache working as a strict L2 cache to the L1
              LruBlockCache. For such a setup, set <code class="varname">CacheConfig.BUCKET_CACHE_COMBINED_KEY</code> to
              <code class="literal">false</code>. In this mode, on eviction from L1, blocks go to L2.
              When a block is cached, it is cached first in L1. When we go to look for a cached block,
              we look first in L1 and if none found, then search L2.  Let us call this deploy format,
              <span class="emphasis"><em><a class="indexterm" name="d2875e10166"></a></em></span>.</p><p>Other BucketCache configs include: specifying a location to persist cache to across
              restarts, how many threads to use writing the cache, etc.  See the
              <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html" target="_top">CacheConfig.html</a>
              class for configuration options and descriptions.</p><div class="procedure" title="Procedure&nbsp;9.1.&nbsp;BucketCache Example Configuration"><a name="d2875e10175"></a><p class="title"><b>Procedure&nbsp;9.1.&nbsp;BucketCache Example Configuration</b></p><p>This sample provides a configuration for a 4 GB offheap BucketCache with a 1 GB
                  onheap cache. Configuration is performed on the RegionServer.  Setting
                  <code class="varname">hbase.bucketcache.ioengine</code> and 
                  <code class="varname">hbase.bucketcache.size</code> &gt; 0 enables CombinedBlockCache.
                  Let us presume that the RegionServer has been set to run with a 5G heap:
                  i.e. HBASE_HEAPSIZE=5g.
              </p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>First, edit the RegionServer's <code class="filename">hbase-env.sh</code> and set
                  <code class="varname">-XX:MaxDirectMemorySize</code> to a value greater than the offheap size wanted, in
                  this case, 4 GB (expressed as 4G).  Lets set it to 5G.  That'll be 4G
                  for our offheap cache and 1G for any other uses of offheap memory (there are
                  other users of offheap memory other than BlockCache; e.g. DFSClient 
                  in RegionServer can make use of offheap memory). See <a class="xref" href="#direct.memory" title="Direct Memory Usage In HBase">Direct Memory Usage In HBase</a>.</p><pre class="programlisting">-XX:MaxDirectMemorySize=5G</pre></li><li class="step" title="Step 2"><p>Next, add the following configuration to the RegionServer's
                    <code class="filename">hbase-site.xml</code>.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.bucketcache.ioengine&lt;/name&gt;
  &lt;value&gt;offheap&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hfile.block.cache.size&lt;/name&gt;
  &lt;value&gt;0.2&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.bucketcache.size&lt;/name&gt;
  &lt;value&gt;4196&lt;/value&gt;
&lt;/property&gt;
          </pre></li><li class="step" title="Step 3"><p>Restart or rolling restart your cluster, and check the logs for any
                  issues.</p></li></ol></div><p>In the above, we set bucketcache to be 4G.  The onheap lrublockcache we
                configured to have 0.2 of the RegionServer's heap size (0.2 * 5G = 1G).
                In other words, you configure the L1 LruBlockCache as you would normally,
                as you would when there is no L2 BucketCache present.
            </p><p><a class="link" href="https://issues.apache.org/jira/browse/HBASE-10641" target="_top">HBASE-10641</a> introduced the ability to configure multiple sizes for the
              buckets of the bucketcache, in HBase 0.98 and newer. To configurable multiple bucket
              sizes, configure the new property <code class="option">hfile.block.cache.sizes</code> (instead of
                <code class="option">hfile.block.cache.size</code>) to a comma-separated list of block sizes,
              ordered from smallest to largest, with no spaces. The goal is to optimize the bucket
              sizes based on your data access patterns. The following example configures buckets of
              size 4096 and 8192.</p><pre class="screen">
&lt;property&gt;
  &lt;name&gt;hfile.block.cache.sizes&lt;/name&gt;
  &lt;value&gt;4096,8192&lt;/value&gt;
&lt;/property&gt;
              </pre><div class="note" title="Direct Memory Usage In HBase" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="direct.memory"></a>Direct Memory Usage In HBase</h3><p>The default maximum direct memory varies by JVM.  Traditionally it is 64M
                    or some relation to allocated heap size (-Xmx) or no limit at all (JDK7 apparently).
                    HBase servers use direct memory, in particular short-circuit reading, the hosted DFSClient will
                    allocate direct memory buffers.  If you do offheap block caching, you'll
                    be making use of direct memory.  Starting your JVM, make sure
                    the <code class="varname">-XX:MaxDirectMemorySize</code> setting in
                    <code class="filename">conf/hbase-env.sh</code> is set to some value that is
                    higher than what you have allocated to your offheap blockcache
                    (<code class="varname">hbase.bucketcache.size</code>).  It should be larger than your offheap block
                    cache and then some for DFSClient usage (How much the DFSClient uses is not
                    easy to quantify; it is the number of open hfiles * <code class="varname">hbase.dfs.client.read.shortcircuit.buffer.size</code>
                    where hbase.dfs.client.read.shortcircuit.buffer.size is set to 128k in HBase -- see <code class="filename">hbase-default.xml</code>
                    default configurations).
                        Direct memory, which is part of the Java process heap, is separate from the object
                        heap allocated by -Xmx. The value allocated by MaxDirectMemorySize must not exceed
                        physical RAM, and is likely to be less than the total available RAM due to other
                        memory requirements and system constraints.
                </p><p>You can see how much memory -- onheap and offheap/direct -- a RegionServer is
                configured to use and how much it is using at any one time by looking at the
                  <span class="emphasis"><em>Server Metrics: Memory</em></span> tab in the UI. It can also be gotten
                via JMX. In particular the direct memory currently used by the server can be found
                on the <code class="varname">java.nio.type=BufferPool,name=direct</code> bean. Terracotta has
                a <a class="link" href="http://terracotta.org/documentation/4.0/bigmemorygo/configuration/storage-options" target="_top">good write up</a> on using offheap memory in java. It is for their product
                BigMemory but alot of the issues noted apply in general to any attempt at going
                offheap. Check it out.</p></div><div class="note" title="hbase.bucketcache.percentage.in.combinedcache" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="hbase.bucketcache.percentage.in.combinedcache"></a>hbase.bucketcache.percentage.in.combinedcache</h3><p>This is a pre-HBase 1.0 configuration removed because it
                      was confusing. It was a float that you would set to some value
                      between 0.0 and 1.0.  Its default was 0.9. If the deploy was using
                      CombinedBlockCache, then the LruBlockCache L1 size was calculated to
                      be (1 - <code class="varname">hbase.bucketcache.percentage.in.combinedcache</code>) * <code class="varname">size-of-bucketcache</code> 
                      and the BucketCache size was <code class="varname">hbase.bucketcache.percentage.in.combinedcache</code> * size-of-bucket-cache.
                      where size-of-bucket-cache itself is EITHER the value of the configuration hbase.bucketcache.size
                      IF it was specified as megabytes OR <code class="varname">hbase.bucketcache.size</code> * <code class="varname">-XX:MaxDirectMemorySize</code> if
                      <code class="varname">hbase.bucketcache.size</code> between 0 and 1.0.
                  </p><p>In 1.0, it should be more straight-forward. L1 LruBlockCache size
                      is set as a fraction of java heap using hfile.block.cache.size setting
                      (not the best name) and L2 is set as above either in absolute
                      megabytes or as a fraction of allocated maximum direct memory.
                  </p></div></div></div></div><div class="section" title="9.6.5.&nbsp;Write Ahead Log (WAL)"><div class="titlepage"><div><div><h3 class="title"><a name="wal"></a>9.6.5.&nbsp;Write Ahead Log (WAL)</h3></div></div></div><div class="section" title="9.6.5.1.&nbsp;Purpose"><div class="titlepage"><div><div><h4 class="title"><a name="purpose.wal"></a>9.6.5.1.&nbsp;Purpose</h4></div></div></div><p>The <em class="firstterm">Write Ahead Log (WAL)</em> records all changes to data in
            HBase, to file-based storage. Under normal operations, the WAL is not needed because
            data changes move from the MemStore to StoreFiles. However, if a RegionServer crashes or
          becomes unavailable before the MemStore is flushed, the WAL ensures that the changes to
          the data can be replayed. If writing to the WAL fails, the entire operation to modify the
          data fails.</p><p>HBase uses an implementation of the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/wal/HLog.html" target="_top">HLog</a>
            interface for the WAL.
            Usually, there is only one instance of a WAL per RegionServer. The RegionServer records Puts and Deletes to
            it, before recording them to the <a class="xref" href="#store.memstore" title="9.7.7.1.&nbsp;MemStore">Section&nbsp;9.7.7.1, &#8220;MemStore&#8221;</a> for the affected <a class="xref" href="#store" title="9.7.7.&nbsp;Store">Section&nbsp;9.7.7, &#8220;Store&#8221;</a>.</p><p>The WAL resides in HDFS in the <code class="filename">/hbase/WALs/</code> directory (prior to
            HBase 0.94, they were stored in <code class="filename">/hbase/.logs/</code>), with subdirectories per
            region.</p><p> For more general information about the concept of write ahead logs, see the
            Wikipedia <a class="link" href="http://en.wikipedia.org/wiki/Write-ahead_logging" target="_top">Write-Ahead Log</a>
            article. </p></div><div class="section" title="9.6.5.2.&nbsp;WAL Flushing"><div class="titlepage"><div><div><h4 class="title"><a name="wal_flush"></a>9.6.5.2.&nbsp;WAL Flushing</h4></div></div></div><p>TODO (describe). </p></div><div class="section" title="9.6.5.3.&nbsp;WAL Splitting"><div class="titlepage"><div><div><h4 class="title"><a name="wal_splitting"></a>9.6.5.3.&nbsp;WAL Splitting</h4></div></div></div><p>A RegionServer serves many regions. All of the regions in a region server share the
            same active WAL file. Each edit in the WAL file includes information about which region
            it belongs to. When a region is opened, the edits in the WAL file which belong to that
            region need to be replayed. Therefore, edits in the WAL file must be grouped by region
            so that particular sets can be replayed to regenerate the data in a particular region.
            The process of grouping the WAL edits by region is called <em class="firstterm">log
              splitting</em>. It is a critical process for recovering data if a region server
            fails.</p><p>Log splitting is done by the HMaster during cluster start-up or by the ServerShutdownHandler
            as a region server shuts down. So that consistency is guaranteed, affected regions
            are unavailable until data is restored. All WAL edits need to be recovered and replayed
            before a given region can become available again. As a result, regions affected by
            log splitting are unavailable until the process completes.</p><div class="procedure" title="Procedure&nbsp;9.2.&nbsp;Log Splitting, Step by Step"><a name="log.splitting.step.by.step"></a><p class="title"><b>Procedure&nbsp;9.2.&nbsp;Log Splitting, Step by Step</b></p><ol class="procedure" type="1"><li class="step" title="The /hbase/WALs/<host&gt;,<port&gt;,<startcode&gt; directory is renamed."><p class="title"><b>The <code class="filename">/hbase/WALs/&lt;host&gt;,&lt;port&gt;,&lt;startcode&gt;</code> directory is renamed.</b></p><p>Renaming the directory is important because a RegionServer may still be up and
                accepting requests even if the HMaster thinks it is down. If the RegionServer does
                not respond immediately and does not heartbeat its ZooKeeper session, the HMaster
                may interpret this as a RegionServer failure. Renaming the logs directory ensures
                that existing, valid WAL files which are still in use by an active but busy
                RegionServer are not written to by accident.</p><p>The new directory is named according to the following pattern:</p><pre class="screen">/hbase/WALs/&lt;host&gt;,&lt;port&gt;,&lt;startcode&gt;-splitting</pre><p>An example of such a renamed directory might look like the following:</p><pre class="screen">/hbase/WALs/srv.example.com,60020,1254173957298-splitting</pre></li><li class="step" title="Each log file is split, one at a time."><p class="title"><b>Each log file is split, one at a time.</b></p><p>The log splitter reads the log file one edit entry at a time and puts each edit
                entry into the buffer corresponding to the edit&#8217;s region. At the same time, the
                splitter starts several writer threads. Writer threads pick up a corresponding
                buffer and write the edit entries in the buffer to a temporary recovered edit
                file. The temporary edit file is stored to disk with the following naming pattern:</p><pre class="screen">/hbase/&lt;table_name&gt;/&lt;region_id&gt;/recovered.edits/.temp</pre><p>This file is used to store all the edits in the WAL log for this region. After
                log splitting completes, the <code class="filename">.temp</code> file is renamed to the
                sequence ID of the first log written to the file.</p><p>To determine whether all edits have been written, the sequence ID is compared to
                the sequence of the last edit that was written to the HFile. If the sequence of the
                last edit is greater than or equal to the sequence ID included in the file name, it
                is clear that all writes from the edit file have been completed.</p></li><li class="step" title="After log splitting is complete, each affected region is assigned to a RegionServer."><p class="title"><b>After log splitting is complete, each affected region is assigned to a
                RegionServer.</b></p><p> When the region is opened, the <code class="filename">recovered.edits</code> folder is checked for recovered
                edits files. If any such files are present, they are replayed by reading the edits
                and saving them to the MemStore. After all edit files are replayed, the contents of
                the MemStore are written to disk (HFile) and the edit files are deleted.</p></li></ol></div><div class="section" title="9.6.5.3.1.&nbsp;Handling of Errors During Log Splitting"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e10369"></a>9.6.5.3.1.&nbsp;Handling of Errors During Log Splitting</h5></div></div></div><p>If you set the <code class="varname">hbase.hlog.split.skip.errors</code> option to
                <code class="constant">true</code>, errors are treated as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Any error encountered during splitting will be logged.</p></li><li class="listitem"><p>The problematic WAL log will be moved into the <code class="filename">.corrupt</code>
                  directory under the hbase <code class="varname">rootdir</code>,</p></li><li class="listitem"><p>Processing of the WAL will continue</p></li></ul></div><p>If the <code class="varname">hbase.hlog.split.skip.errors</code> optionset to
                <code class="literal">false</code>, the default, the exception will be propagated and the
              split will be logged as failed. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2958" target="_top">HBASE-2958 When
                    hbase.hlog.split.skip.errors is set to false, we fail the split but thats
                    it</a>. We need to do more than just fail split if this flag is set.</p><div class="section" title="9.6.5.3.1.1.&nbsp;How EOFExceptions are treated when splitting a crashed RegionServers' WALs"><div class="titlepage"><div><div><h6 class="title"><a name="d2875e10407"></a>9.6.5.3.1.1.&nbsp;How EOFExceptions are treated when splitting a crashed RegionServers'
                WALs</h6></div></div></div><p>If an EOFException occurs while splitting logs, the split proceeds even when
                  <code class="varname">hbase.hlog.split.skip.errors</code> is set to
                <code class="literal">false</code>. An EOFException while reading the last log in the set of
                files to split is likely, because the RegionServer is likely to be in the process of
                writing a record at the time of a crash. For background, see <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2643" target="_top">HBASE-2643
                      Figure how to deal with eof splitting logs</a></p></div></div><div class="section" title="9.6.5.3.2.&nbsp;Performance Improvements during Log Splitting"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e10420"></a>9.6.5.3.2.&nbsp;Performance Improvements during Log Splitting</h5></div></div></div><p>
              WAL log splitting and recovery can be resource intensive and take a long time,
              depending on the number of RegionServers involved in the crash and the size of the
              regions. <a class="xref" href="#distributed.log.splitting" title="9.6.5.3.2.1.&nbsp;Distributed Log Splitting">Section&nbsp;9.6.5.3.2.1, &#8220;Distributed Log Splitting&#8221;</a> and <a class="xref" href="#distributed.log.replay" title="9.6.5.3.2.2.&nbsp;Distributed Log Replay">Section&nbsp;9.6.5.3.2.2, &#8220;Distributed Log Replay&#8221;</a> were developed to improve
              performance during log splitting.
            </p><div class="section" title="9.6.5.3.2.1.&nbsp;Distributed Log Splitting"><div class="titlepage"><div><div><h6 class="title"><a name="distributed.log.splitting"></a>9.6.5.3.2.1.&nbsp;Distributed Log Splitting</h6></div></div></div><p><em class="firstterm">Distributed Log Splitting</em> was added in HBase version 0.92
                (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-1364" target="_top">HBASE-1364</a>) 
                by Prakash Khemani from Facebook. It reduces the time to complete log splitting
                dramatically, improving the availability of regions and tables. For
                example, recovering a crashed cluster took around 9 hours with single-threaded log
                splitting, but only about six minutes with distributed log splitting.</p><p>The information in this section is sourced from Jimmy Xiang's blog post at <a class="link" href="http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/" target="_top">http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/</a>.</p><p title="Enabling or Disabling Distributed Log Splitting"><b>Enabling or Disabling Distributed Log Splitting.&nbsp;</b>Distributed log processing is enabled by default since HBase 0.92. The setting
                  is controlled by the <span class="property">hbase.master.distributed.log.splitting</span>
                  property, which can be set to <code class="literal">true</code> or <code class="literal">false</code>,
                  but defaults to <code class="literal">true</code>. </p><div class="procedure" title="Procedure&nbsp;9.3.&nbsp;Distributed Log Splitting, Step by Step"><a name="d2875e10460"></a><p class="title"><b>Procedure&nbsp;9.3.&nbsp;Distributed Log Splitting, Step by Step</b></p><p>After configuring distributed log splitting, the HMaster controls the process.
                  The HMaster enrolls each RegionServer in the log splitting process, and the actual
                  work of splitting the logs is done by the RegionServers. The general process for
                  log splitting, as described in <a class="xref" href="#log.splitting.step.by.step" title="Procedure&nbsp;9.2.&nbsp;Log Splitting, Step by Step">Procedure&nbsp;9.2, &#8220;Log Splitting, Step by Step&#8221;</a> still applies here.</p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>If distributed log processing is enabled, the HMaster creates a
                    <em class="firstterm">split log manager</em> instance when the cluster is started.
                    The split log manager manages all log files which need
                    to be scanned and split. The split log manager places all the logs into the
                    ZooKeeper splitlog node (<code class="filename">/hbase/splitlog</code>) as tasks. You can
                  view the contents of the splitlog by issuing the following
                    <span class="command"><strong>zkcli</strong></span> command. Example output is shown.</p><pre class="screen">ls /hbase/splitlog
[hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost8.sample.com%2C57020%2C1340474893275-splitting%2Fhost8.sample.com%253A57020.1340474893900, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost3.sample.com%2C57020%2C1340474893299-splitting%2Fhost3.sample.com%253A57020.1340474893931, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost4.sample.com%2C57020%2C1340474893287-splitting%2Fhost4.sample.com%253A57020.1340474893946]                  
                  </pre><p>The output contains some non-ASCII characters. When decoded, it looks much
                    more simple:</p><pre class="screen">
[hdfs://host2.sample.com:56020/hbase/.logs
/host8.sample.com,57020,1340474893275-splitting
/host8.sample.com%3A57020.1340474893900, 
hdfs://host2.sample.com:56020/hbase/.logs
/host3.sample.com,57020,1340474893299-splitting
/host3.sample.com%3A57020.1340474893931, 
hdfs://host2.sample.com:56020/hbase/.logs
/host4.sample.com,57020,1340474893287-splitting
/host4.sample.com%3A57020.1340474893946]                    
                  </pre><p>The listing represents WAL file names to be scanned and split, which is a
                    list of log splitting tasks.</p></li><li class="step" title="The split log manager monitors the log-splitting tasks and workers."><p class="title"><b>The split log manager monitors the log-splitting tasks and workers.</b></p><p>The split log manager is responsible for the following ongoing tasks:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Once the split log manager publishes all the tasks to the splitlog
                        znode, it monitors these task nodes and waits for them to be
                        processed.</p></li><li class="listitem"><p>Checks to see if there are any dead split log
                        workers queued up. If it finds tasks claimed by unresponsive workers, it
                        will resubmit those tasks. If the resubmit fails due to some ZooKeeper
                        exception, the dead worker is queued up again for retry.</p></li><li class="listitem"><p>Checks to see if there are any unassigned
                        tasks. If it finds any, it create an ephemeral rescan node so that each
                        split log worker is notified to re-scan unassigned tasks via the
                          <code class="code">nodeChildrenChanged</code> ZooKeeper event.</p></li><li class="listitem"><p>Checks for tasks which are assigned but expired. If any are found, they
                        are moved back to <code class="code">TASK_UNASSIGNED</code> state again so that they can
                        be retried. It is possible that these tasks are assigned to slow workers, or
                        they may already be finished. This is not a problem, because log splitting
                        tasks have the property of idempotence. In other words, the same log
                        splitting task can be processed many times without causing any
                        problem.</p></li><li class="listitem"><p>The split log manager watches the HBase split log znodes constantly. If
                        any split log task node data is changed, the split log manager retrieves the
                        node data. The
                        node data contains the current state of the task. You can use the
                        <span class="command"><strong>zkcli</strong></span> <span class="command"><strong>get</strong></span> command to retrieve the
                        current state of a task. In the example output below, the first line of the
                        output shows that the task is currently unassigned.</p><pre class="screen">
<strong class="userinput"><code>get /hbase/splitlog/hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost6.sample.com%2C57020%2C1340474893287-splitting%2Fhost6.sample.com%253A57020.1340474893945
</code></strong> 
<code class="computeroutput">unassigned host2.sample.com:57000
cZxid = 0&times;7115
ctime = Sat Jun 23 11:13:40 PDT 2012
...</code>  
                      </pre><p>Based on the state of the task whose data is changed, the split log
                        manager does one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Resubmit the task if it is unassigned</p></li><li class="listitem"><p>Heartbeat the task if it is assigned</p></li><li class="listitem"><p>Resubmit or fail the task if it is resigned (see <a class="xref" href="#distributed.log.replay.failure.reasons" title="Reasons a Task Will Fail">Reasons a Task Will Fail</a>)</p></li><li class="listitem"><p>Resubmit or fail the task if it is completed with errors (see <a class="xref" href="#distributed.log.replay.failure.reasons" title="Reasons a Task Will Fail">Reasons a Task Will Fail</a>)</p></li><li class="listitem"><p>Resubmit or fail the task if it could not complete due to
                            errors (see <a class="xref" href="#distributed.log.replay.failure.reasons" title="Reasons a Task Will Fail">Reasons a Task Will Fail</a>)</p></li><li class="listitem"><p>Delete the task if it is successfully completed or failed</p></li></ul></div><div class="itemizedlist" title="Reasons a Task Will Fail"><a name="distributed.log.replay.failure.reasons"></a><p class="title"><b>Reasons a Task Will Fail</b></p><ul class="itemizedlist" type="circle"><li class="listitem"><p>The task has been deleted.</p></li><li class="listitem"><p>The node no longer exists.</p></li><li class="listitem"><p>The log status manager failed to move the state of the task
                          to TASK_UNASSIGNED.</p></li><li class="listitem"><p>The number of resubmits is over the resubmit
                          threshold.</p></li></ul></div></li></ul></div></li><li class="step" title="Each RegionServer's split log worker performs the log-splitting tasks."><p class="title"><b>Each RegionServer's split log worker performs the log-splitting tasks.</b></p><p>Each RegionServer runs a daemon thread called the <em class="firstterm">split log
                      worker</em>, which does the work to split the logs. The daemon thread
                    starts when the RegionServer starts, and registers itself to watch HBase znodes.
                    If any splitlog znode children change, it notifies a sleeping worker thread to
                    wake up and grab more tasks. If if a worker's current task&#8217;s node data is
                    changed, the worker checks to see if the task has been taken by another worker.
                    If so, the worker thread stops work on the current task.</p><p>The worker monitors
                    the splitlog znode constantly. When a new task appears, the split log worker
                    retrieves  the task paths and checks each one until it finds an unclaimed task,
                    which it attempts to claim. If the claim was successful, it attempts to perform
                    the task and updates the task's <span class="property">state</span> property based on the
                    splitting outcome. At this point, the split log worker scans for another
                    unclaimed task.</p><div class="itemizedlist" title="How the Split Log Worker Approaches a Task"><p class="title"><b>How the Split Log Worker Approaches a Task</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>It queries the task state and only takes action if the task is in
                          <code class="literal">TASK_UNASSIGNED </code>state.</p></li><li class="listitem"><p>If the task is is in <code class="literal">TASK_UNASSIGNED</code> state, the
                        worker attempts to set the state to <code class="literal">TASK_OWNED</code> by itself.
                        If it fails to set the state, another worker will try to grab it. The split
                        log manager will also ask all workers to rescan later if the task remains
                        unassigned.</p></li><li class="listitem"><p>If the worker succeeds in taking ownership of the task, it tries to get
                        the task state again to make sure it really gets it asynchronously. In the
                        meantime, it starts a split task executor to do the actual work: </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Get the HBase root folder, create a temp folder under the root, and
                            split the log file to the temp folder.</p></li><li class="listitem"><p>If the split was successful, the task executor sets the task to
                            state <code class="literal">TASK_DONE</code>.</p></li><li class="listitem"><p>If the worker catches an unexpected IOException, the task is set to
                            state <code class="literal">TASK_ERR</code>.</p></li><li class="listitem"><p>If the worker is shutting down, set the the task to state
                              <code class="literal">TASK_RESIGNED</code>.</p></li><li class="listitem"><p>If the task is taken by another worker, just log it.</p></li></ul></div></li></ul></div></li><li class="step" title="The split log manager monitors for uncompleted tasks."><p class="title"><b>The split log manager monitors for uncompleted tasks.</b></p><p>The split log manager returns when all tasks are completed successfully. If
                    all tasks are completed with some failures, the split log manager throws an
                    exception so that the log splitting can be retried. Due to an asynchronous
                    implementation, in very rare cases, the split log manager loses track of some
                    completed tasks. For that reason, it periodically checks for remaining
                    uncompleted task in its task map or ZooKeeper. If none are found, it throws an
                    exception so that the log splitting can be retried right away instead of hanging
                    there waiting for something that won&#8217;t happen.</p></li></ol></div></div><div class="section" title="9.6.5.3.2.2.&nbsp;Distributed Log Replay"><div class="titlepage"><div><div><h6 class="title"><a name="distributed.log.replay"></a>9.6.5.3.2.2.&nbsp;Distributed Log Replay</h6></div></div></div><p>After a RegionServer fails, its failed region is assigned to another
                RegionServer, which is marked as "recovering" in ZooKeeper. A split log worker directly
                replays edits from the WAL of the failed region server to the region at its new
                location. When a region is in "recovering" state, it can accept writes but no reads
                (including Append and Increment), region splits or merges. </p><p>Distributed Log Replay extends the <a class="xref" href="#distributed.log.splitting" title="9.6.5.3.2.1.&nbsp;Distributed Log Splitting">Section&nbsp;9.6.5.3.2.1, &#8220;Distributed Log Splitting&#8221;</a> framework. It works by
                directly replaying WAL edits to another RegionServer instead of creating
                  <code class="filename">recovered.edits</code> files. It provides the following advantages
                over distributed log splitting alone:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>It eliminates the overhead of writing and reading a large number of
                  <code class="filename">recovered.edits</code> files. It is not unusual for thousands of
                  <code class="filename">recovered.edits</code> files to be created and written concurrently
                  during a RegionServer recovery. Many small random writes can degrade overall
                  system performance.</p></li><li class="listitem"><p>It allows writes even when a region is in recovering state. It only takes seconds for a recovering region to accept writes again. 
</p></li></ul></div><p title="Enabling Distributed Log Replay"><b>Enabling Distributed Log Replay.&nbsp;</b>To enable distributed log replay, set <code class="varname">hbase.master.distributed.log.replay</code> to
                  true. This will be the default for HBase 0.99 (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-10888" target="_top">HBASE-10888</a>).</p><p>You must also enable HFile version 3 (which is the default HFile format starting
                in HBase 0.99. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10855" target="_top">HBASE-10855</a>).
                Distributed log replay is unsafe for rolling upgrades.</p></div></div></div><div class="section" title="9.6.5.4.&nbsp;Disabling the WAL"><div class="titlepage"><div><div><h4 class="title"><a name="wal.disable"></a>9.6.5.4.&nbsp;Disabling the WAL</h4></div></div></div><p>It is possible to disable the WAL, to improve performace in certain specific
            situations. However, disabling the WAL puts your data at risk. The only situation where
            this is recommended is during a bulk load. This is because, in the event of a problem,
            the bulk load can be re-run with no risk of data loss.</p><p>The WAL is disabled by calling the HBase client field
              <code class="code">Mutation.writeToWAL(false)</code>. Use the
              <code class="code">Mutation.setDurability(Durability.SKIP_WAL)</code> and Mutation.getDurability()
            methods to set and get the field's value. There is no way to disable the WAL for only a
            specific table.</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>If you disable the WAL for anything other than bulk loads, your data is at
              risk.</p></div></div></div></div><div class="section" title="9.7.&nbsp;Regions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="regions.arch"></a>9.7.&nbsp;Regions</h2></div></div></div><p>Regions are the basic element of availability and
     distribution for tables, and are comprised of a Store per Column Family. The heirarchy of objects
     is as follows:
</p><pre class="programlisting">
<code class="filename">Table</code>       (HBase table)
    <code class="filename">Region</code>       (Regions for the table)
         <code class="filename">Store</code>          (Store per ColumnFamily for each Region for the table)
              <code class="filename">MemStore</code>           (MemStore for each Store for each Region for the table)
              <code class="filename">StoreFile</code>          (StoreFiles for each Store for each Region for the table)
                    <code class="filename">Block</code>             (Blocks within a StoreFile within a Store for each Region for the table)
 </pre><p>
     For a description of what HBase files look like when written to HDFS, see <a class="xref" href="#trouble.namenode.hbase.objects" title="15.7.2.&nbsp;Browsing HDFS for HBase Objects">Section&nbsp;15.7.2, &#8220;Browsing HDFS for HBase Objects&#8221;</a>.
            </p><div class="section" title="9.7.1.&nbsp;Considerations for Number of Regions"><div class="titlepage"><div><div><h3 class="title"><a name="arch.regions.size"></a>9.7.1.&nbsp;Considerations for Number of Regions</h3></div></div></div><p> In general, HBase is designed to run with a small (20-200) number of relatively large (5-20Gb) regions per server. The considerations for this are as follows:</p><div class="section" title="9.7.1.1.&nbsp;Why cannot I have too many regions?"><div class="titlepage"><div><div><h4 class="title"><a name="too_many_regions"></a>9.7.1.1.&nbsp;Why cannot I have too many regions?</h4></div></div></div><p>
              Typically you want to keep your region count low on HBase for numerous reasons.
              Usually right around 100 regions per RegionServer has yielded the best results.
              Here are some of the reasons below for keeping region count low:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                          MSLAB requires 2mb per memstore (that's 2mb per family per region).
                          1000 regions that have 2 families each is 3.9GB of heap used, and it's not even storing data yet. NB: the 2MB value is configurable.
                  </p></li><li class="listitem"><p>If you fill all the regions at somewhat the same rate, the global memory usage makes it that it forces tiny
                          flushes when you have too many regions which in turn generates compactions.
                          Rewriting the same data tens of times is the last thing you want.
                          An example is filling 1000 regions (with one family) equally and let's consider a lower bound for global memstore
                          usage of 5GB (the region server would have a big heap).
                          Once it reaches 5GB it will force flush the biggest region,
                          at that point they should almost all have about 5MB of data so
                          it would flush that amount. 5MB inserted later, it would flush another
                          region that will now have a bit over 5MB of data, and so on.
                          This is currently the main limiting factor for the number of regions; see <a class="xref" href="#ops.capacity.regions.count" title="17.9.2.2.&nbsp;Number of regions per RS - upper bound">Section&nbsp;17.9.2.2, &#8220;Number of regions per RS - upper bound&#8221;</a>
                          for detailed formula.
                  </p></li><li class="listitem"><p>The master as is is allergic to tons of regions, and will
                          take a lot of time assigning them and moving them around in batches.
                          The reason is that it's heavy on ZK usage, and it's not very async
                          at the moment (could really be improved -- and has been imporoved a bunch
                          in 0.96 hbase).
                  </p></li><li class="listitem"><p>
                          In older versions of HBase (pre-v2 hfile, 0.90 and previous), tons of regions
                          on a few RS can cause the store file index to rise, increasing heap usage and potentially
                          creating memory pressure or OOME on the RSs
                  </p></li></ol></div><p>Another issue is the effect of the number of regions on mapreduce jobs; it is typical to have one mapper per HBase region.
              Thus, hosting only 5 regions per RS may not be enough to get sufficient number of tasks for a mapreduce job, while 1000 regions will generate far too many tasks.
            </p><p>See <a class="xref" href="#ops.capacity.regions" title="17.9.2.&nbsp;Determining region count and size">Section&nbsp;17.9.2, &#8220;Determining region count and size&#8221;</a> for configuration guidelines.</p></div></div><div class="section" title="9.7.2.&nbsp;Region-RegionServer Assignment"><div class="titlepage"><div><div><h3 class="title"><a name="regions.arch.assignment"></a>9.7.2.&nbsp;Region-RegionServer Assignment</h3></div></div></div><p>This section describes how Regions are assigned to RegionServers.
         </p><div class="section" title="9.7.2.1.&nbsp;Startup"><div class="titlepage"><div><div><h4 class="title"><a name="regions.arch.assignment.startup"></a>9.7.2.1.&nbsp;Startup</h4></div></div></div><p>When HBase starts regions are assigned as follows (short version):
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The Master invokes the <code class="code">AssignmentManager</code> upon startup.</p></li><li class="listitem"><p>The <code class="code">AssignmentManager</code> looks at the existing region assignments in META.</p></li><li class="listitem"><p>If the region assignment is still valid (i.e., if the RegionServer is still online)
                then the assignment is kept.</p></li><li class="listitem"><p>If the assignment is invalid, then the <code class="code">LoadBalancerFactory</code> is invoked to assign the
                region.  The <code class="code">DefaultLoadBalancer</code> will randomly assign the region to a RegionServer.</p></li><li class="listitem"><p>META is updated with the RegionServer assignment (if needed) and the RegionServer start codes
              (start time of the RegionServer process) upon region opening by the RegionServer.</p></li></ol></div><p>
          </p></div><div class="section" title="9.7.2.2.&nbsp;Failover"><div class="titlepage"><div><div><h4 class="title"><a name="regions.arch.assignment.failover"></a>9.7.2.2.&nbsp;Failover</h4></div></div></div><p>When a RegionServer fails: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The regions immediately become unavailable because the RegionServer is
                  down.</p></li><li class="listitem"><p>The Master will detect that the RegionServer has failed.</p></li><li class="listitem"><p>The region assignments will be considered invalid and will be re-assigned just
                  like the startup sequence.</p></li><li class="listitem"><p>In-flight queries are re-tried, and not lost.</p></li><li class="listitem"><p>Operations are switched to a new RegionServer within the following amount of
                  time:</p><pre class="programlisting">ZooKeeper session timeout + split time + assignment/replay time</pre></li></ol></div><p>
          </p></div><div class="section" title="9.7.2.3.&nbsp;Region Load Balancing"><div class="titlepage"><div><div><h4 class="title"><a name="regions.arch.balancer"></a>9.7.2.3.&nbsp;Region Load Balancing</h4></div></div></div><p>
          Regions can be periodically moved by the <a class="xref" href="#master.processes.loadbalancer" title="9.5.4.1.&nbsp;LoadBalancer">Section&nbsp;9.5.4.1, &#8220;LoadBalancer&#8221;</a>.
          </p></div><div class="section" title="9.7.2.4.&nbsp;Region State Transition"><div class="titlepage"><div><div><h4 class="title"><a name="regions.arch.states"></a>9.7.2.4.&nbsp;Region State Transition</h4></div></div></div><p> HBase maintains a state for each region and persists the state in META. The state
            of the META region itself is persisted in ZooKeeper. You can see the states of regions
            in transition in the Master web UI. Following is the list of possible region
            states.</p><div class="itemizedlist" title="Possible Region States"><p class="title"><b>Possible Region States</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>OFFLINE: the region is offline and not opening</p></li><li class="listitem"><p>OPENING: the region is in the process of being opened</p></li><li class="listitem"><p>OPEN: the region is open and the region server has notified the master</p></li><li class="listitem"><p>FAILED_OPEN: the region server failed to open the region</p></li><li class="listitem"><p>CLOSING: the region is in the process of being closed</p></li><li class="listitem"><p>CLOSED: the region server has closed the region and notified the master</p></li><li class="listitem"><p>FAILED_CLOSE: the region server failed to close the region</p></li><li class="listitem"><p>SPLITTING: the region server notified the master that the region is
                splitting</p></li><li class="listitem"><p>SPLIT: the region server notified the master that the region has finished
                splitting</p></li><li class="listitem"><p>SPLITTING_NEW: this region is being created by a split which is in
                progress</p></li><li class="listitem"><p>MERGING: the region server notified the master that this region is being merged
                with another region</p></li><li class="listitem"><p>MERGED: the region server notified the master that this region has been
                merged</p></li><li class="listitem"><p>MERGING_NEW: this region is being created by a merge of two regions</p></li></ul></div><div class="figure"><a name="d2875e10868"></a><p class="title"><b>Figure&nbsp;9.1.&nbsp;Region State Transitions</b></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td align="center" valign="middle"><img src="images/region_states.png" align="middle" alt="Region State Transitions"></td></tr></table><div class="caption"><p>This graph shows all allowed transitions a region can undergo. In the graph,
                  each node is a state. A node has a color based on the state type, for readability.
                  A directed line in the graph is a possible state transition.</p></div></div></div></div><br class="figure-break"><div class="itemizedlist" title="Graph Legend"><p class="title"><b>Graph Legend</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Brown: Offline state, a special state that can be transient (after closed before
                opening), terminal (regions of disabled tables), or initial (regions of newly
                created tables)</p></li><li class="listitem"><p>Palegreen: Online state that regions can serve requests</p></li><li class="listitem"><p>Lightblue: Transient states</p></li><li class="listitem"><p>Red: Failure states that need OPS attention</p></li><li class="listitem"><p>Gold: Terminal states of regions split/merged</p></li><li class="listitem"><p>Grey: Initial states of regions created through split/merge</p></li></ul></div><div class="orderedlist" title="Region State Transitions Explained"><p class="title"><b>Region State Transitions Explained</b></p><ol class="orderedlist" type="1"><li class="listitem"><p>The master moves a region from <code class="literal">OFFLINE</code> to
                  <code class="literal">OPENING</code> state and tries to assign the region to a region
                server. The region server may or may not have received the open region request. The
                master retries sending the open region request to the region server until the RPC
                goes through or the master runs out of retries. After the region server receives the
                open region request, the region server begins opening the region.</p></li><li class="listitem"><p>If the master is running out of retries, the master prevents the region server
                from opening the region by moving the region to <code class="literal">CLOSING</code> state and
                trying to close it, even if the region server is starting to open the region.</p></li><li class="listitem"><p>After the region server opens the region, it continues to try to notify the
                master until the master moves the region to <code class="literal">OPEN</code> state and
                notifies the region server. The region is now open.</p></li><li class="listitem"><p>If the region server cannot open the region, it notifies the master. The master
                moves the region to <code class="literal">CLOSED</code> state and tries to open the region on
                a different region server.</p></li><li class="listitem"><p>If the master cannot open the region on any of a certain number of regions, it
                moves the region to <code class="literal">FAILED_OPEN</code> state, and takes no further
                action until an operator intervenes from the HBase shell, or the server is
                dead.</p></li><li class="listitem"><p>The master moves a region from <code class="literal">OPEN</code> to
                  <code class="literal">CLOSING</code> state. The region server holding the region may or may
                not have received the close region request. The master retries sending the close
                request to the server until the RPC goes through or the master runs out of
                retries.</p></li><li class="listitem"><p>If the region server is not online, or throws
                  <code class="code">NotServingRegionException</code>, the master moves the region to
                  <code class="literal">OFFLINE</code> state and re-assigns it to a different region
                server.</p></li><li class="listitem"><p>If the region server is online, but not reachable after the master runs out of
                retries, the master moves the region to <code class="literal">FAILED_CLOSE</code> state and
                takes no further action until an operator intervenes from the HBase shell, or the
                server is dead.</p></li><li class="listitem"><p>If the region server gets the close region request, it closes the region and
                notifies the master. The master moves the region to <code class="literal">CLOSED</code> state
                and re-assigns it to a different region server.</p></li><li class="listitem"><p>Before assigning a region, the master moves the region to
                  <code class="literal">OFFLINE</code> state automatically if it is in
                  <code class="literal">CLOSED</code> state.</p></li><li class="listitem"><p>When a region server is about to split a region, it notifies the master. The
                master moves the region to be split from <code class="literal">OPEN</code> to
                  <code class="literal">SPLITTING</code> state and add the two new regions to be created to
                the region server. These two regions are in <code class="literal">SPLITING_NEW</code> state
                initially.</p></li><li class="listitem"><p>After notifying the master, the region server starts to split the region. Once
                past the point of no return, the region server notifies the master again so the
                master can update the META. However, the master does not update the region states
                until it is notified by the server that the split is done. If the split is
                successful, the splitting region is moved from <code class="literal">SPLITTING</code> to
                  <code class="literal">SPLIT</code> state and the two new regions are moved from
                  <code class="literal">SPLITTING_NEW</code> to <code class="literal">OPEN</code> state.</p></li><li class="listitem"><p>If the split fails, the splitting region is moved from
                  <code class="literal">SPLITTING</code> back to <code class="literal">OPEN</code> state, and the two
                new regions which were created are moved from <code class="literal">SPLITTING_NEW</code> to
                  <code class="literal">OFFLINE</code> state.</p></li><li class="listitem"><p>When a region server is about to merge two regions, it notifies the master
                first. The master moves the two regions to be merged from <code class="literal">OPEN</code> to
                  <code class="literal">MERGING</code>state, and adds the new region which will hold the
                contents of the merged regions region to the region server. The new region is in
                  <code class="literal">MERGING_NEW</code> state initially.</p></li><li class="listitem"><p>After notifying the master, the region server starts to merge the two regions.
                Once past the point of no return, the region server notifies the master again so the
                master can update the META. However, the master does not update the region states
                until it is notified by the region server that the merge has completed. If the merge
                is successful, the two merging regions are moved from <code class="literal">MERGING</code> to
                  <code class="literal">MERGED</code> state and the new region is moved from
                  <code class="literal">MERGING_NEW</code> to <code class="literal">OPEN</code> state.</p></li><li class="listitem"><p>If the merge fails, the two merging regions are moved from
                  <code class="literal">MERGING</code> back to <code class="literal">OPEN</code> state, and the new
                region which was created to hold the contents of the merged regions is moved from
                  <code class="literal">MERGING_NEW</code> to <code class="literal">OFFLINE</code> state.</p></li><li class="listitem"><p>For regions in <code class="literal">FAILED_OPEN</code> or <code class="literal">FAILED_CLOSE</code>
                states , the master tries to close them again when they are reassigned by an
                operator via HBase Shell. </p></li></ol></div></div></div><div class="section" title="9.7.3.&nbsp;Region-RegionServer Locality"><div class="titlepage"><div><div><h3 class="title"><a name="regions.arch.locality"></a>9.7.3.&nbsp;Region-RegionServer Locality</h3></div></div></div><p>Over time, Region-RegionServer locality is achieved via HDFS block replication.
          The HDFS client does the following by default when choosing locations to write replicas:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>First replica is written to local node</p></li><li class="listitem"><p>Second replica is written to a random node on another rack</p></li><li class="listitem"><p>Third replica is written on the same rack as the second, but on a different node chosen randomly</p></li><li class="listitem"><p>Subsequent replicas are written on random nodes on the cluster. See <span class="emphasis"><em>Replica Placement: The First Baby Steps</em></span> on this page: <a class="link" href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_top">HDFS Architecture</a></p></li></ol></div><p>
          Thus, HBase eventually achieves locality for a region after a flush or a compaction.
          In a RegionServer failover situation a RegionServer may be assigned regions with non-local
          StoreFiles (because none of the replicas are local), however as new data is written
          in the region, or the table is compacted and StoreFiles are re-written, they will become "local"
          to the RegionServer.
        </p><p>For more information, see <span class="emphasis"><em>Replica Placement: The First Baby Steps</em></span> on this page: <a class="link" href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_top">HDFS Architecture</a>
        and also Lars George's blog on <a class="link" href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html" target="_top">HBase and HDFS locality</a>.
        </p></div><div class="section" title="9.7.4.&nbsp;Region Splits"><div class="titlepage"><div><div><h3 class="title"><a name="arch.region.splits"></a>9.7.4.&nbsp;Region Splits</h3></div></div></div><p>Regions split when they reach a configured threshold.
        Below we treat the topic in short.  For a longer exposition,
        see <a class="link" href="http://hortonworks.com/blog/apache-hbase-region-splitting-and-merging/" target="_top">Apache HBase Region Splitting and Merging</a>
        by our Enis Soztutar.
        </p><p>Splits run unaided on the RegionServer; i.e. the Master does not
        participate. The RegionServer splits a region, offlines the split
        region and then adds the daughter regions to META, opens daughters on
        the parent's hosting RegionServer and then reports the split to the
        Master. See <a class="xref" href="#disable.splitting" title="2.6.2.7.&nbsp;Managed Splitting">Section&nbsp;2.6.2.7, &#8220;Managed Splitting&#8221;</a> for how to manually manage
        splits (and for why you might do this)</p><div class="section" title="9.7.4.1.&nbsp;Custom Split Policies"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e11115"></a>9.7.4.1.&nbsp;Custom Split Policies</h4></div></div></div><p>The default split policy can be overwritten using a custom <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/RegionSplitPolicy.html" target="_top">RegionSplitPolicy</a> (HBase 0.94+).
          Typically a custom split policy should extend HBase's default split policy: <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/ConstantSizeRegionSplitPolicy.html" target="_top">ConstantSizeRegionSplitPolicy</a>.
          </p><p>The policy can set globally through the HBaseConfiguration used or on a per table basis:
</p><pre class="programlisting">
HTableDescriptor myHtd = ...;
myHtd.setValue(HTableDescriptor.SPLIT_POLICY, MyCustomSplitPolicy.class.getName());
</pre><p>
          </p></div></div><div class="section" title="9.7.5.&nbsp;Manual Region Splitting"><div class="titlepage"><div><div><h3 class="title"><a name="manual_region_splitting_decisions"></a>9.7.5.&nbsp;Manual Region Splitting</h3></div></div></div><p>It is possible to manually split your table, either at table creation (pre-splitting),
          or at a later time as an administrative action. You might choose to split your region for
          one or more of the following reasons. There may be other valid reasons, but the need to
          manually split your table might also point to problems with your schema design.</p><div class="itemizedlist" title="Reasons to Manually Split Your Table"><p class="title"><b>Reasons to Manually Split Your Table</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Your data is sorted by timeseries or another similar algorithm that sorts new data
              at the end of the table. This means that the Region Server holding the last region is
              always under load, and the other Region Servers are idle, or mostly idle. See also
                <a class="xref" href="#timeseries" title="6.3.2.&nbsp; Monotonically Increasing Row Keys/Timeseries Data">Section&nbsp;6.3.2, &#8220; Monotonically Increasing Row Keys/Timeseries Data &#8221;</a>.</p></li><li class="listitem"><p>You have developed an unexpected hotspot in one region of your table. For
              instance, an application which tracks web searches might be inundated by a lot of
              searches for a celebrity in the event of news about that celebrity. See <a class="xref" href="#perf.one.region" title="14.8.8.&nbsp;Anti-Pattern: One Hot Region">Section&nbsp;14.8.8, &#8220;Anti-Pattern: One Hot Region&#8221;</a> for more discussion about this particular
              scenario.</p></li><li class="listitem"><p>After a big increase to the number of Region Servers in your cluster, to get the
              load spread out quickly.</p></li><li class="listitem"><p>Before a bulk-load which is likely to cause unusual and uneven load across
              regions.</p></li></ul></div><p>See <a class="xref" href="#disable.splitting" title="2.6.2.7.&nbsp;Managed Splitting">Section&nbsp;2.6.2.7, &#8220;Managed Splitting&#8221;</a> for a discussion about the dangers and
          possible benefits of managing splitting completely manually.</p><div class="section" title="9.7.5.1.&nbsp;Determining Split Points"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e11159"></a>9.7.5.1.&nbsp;Determining Split Points</h4></div></div></div><p>The goal of splitting your table manually is to improve the chances of balancing the
            load across the cluster in situations where good rowkey design alone won't get you
            there. Keeping that in mind, the way you split your regions is very dependent upon the
            characteristics of your data. It may be that you already know the best way to split your
            table. If not, the way you split your table depends on what your keys are like.</p><div class="variablelist"><dl><dt><span class="term">Alphanumeric Rowkeys</span></dt><dd><p>If your rowkeys start with a letter or number, you can split your table at
                  letter or number boundaries. For instance, the following command creates a table
                  with regions that split at each vowel, so the first region has A-D, the second
                  region has E-H, the third region has I-N, the fourth region has O-V, and the fifth
                  region has U-Z.</p><pre class="screen">hbase&gt; create 'test_table', 'f1', SPLITS=&gt; ['a', 'e', 'i', 'o', 'u']</pre><p>The following command splits an existing table at split point '2'.</p><pre class="screen">hbase&gt; split 'test_table', '2'</pre><p>You can also split a specific region by referring to its ID. You can find the
                  region ID by looking at either the table or region in the Web UI. It will be a
                  long number such as
                    <code class="literal">t2,1,1410227759524.829850c6eaba1acc689480acd8f081bd.</code>. The
                  format is <em class="replaceable"><code>table_name,start_key,region_id</code></em>To split that
                  region into two, as close to equally as possible (at the nearest row boundary),
                  issue the following command.</p><pre class="screen">hbase&gt; split 't2,1,1410227759524.829850c6eaba1acc689480acd8f081bd.'</pre><p>The split key is optional. If it is omitted, the table or region is split in
                  half.</p><p>The following example shows how to use the RegionSplitter to create 10
                  regions, split at hexadecimal values.</p><pre class="screen">hbase org.apache.hadoop.hbase.util.RegionSplitter test_table HexStringSplit -c 10 -f f1</pre></dd><dt><span class="term">Using a Custom Algorithm</span></dt><dd><p>The RegionSplitter tool is provided with HBase, and uses a <em class="firstterm"><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.SplitAlgorithm.html" target="_top">SplitAlgorithm</a></em> to determine split points for you. As
                  parameters, you give it the algorithm, desired number of regions, and column
                  families. It includes two split algorithms. The first is the <code class="code"><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.HexStringSplit.html" target="_top">HexStringSplit</a></code> algorithm, which assumes the row keys are
                  hexadecimal strings. The second, <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.UniformSplit.html" target="_top">UniformSplit</a>, assumes the row keys are random byte arrays. You will
                  probably need to develop your own SplitAlgorithm, using the provided ones as
                  models. </p></dd></dl></div></div></div><div class="section" title="9.7.6.&nbsp;Online Region Merges"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e11210"></a>9.7.6.&nbsp;Online Region Merges</h3></div></div></div><p>Both Master and Regionserver participate in the event of online region merges.
        Client sends merge RPC to master, then master moves the regions together to the
        same regionserver where the more heavily loaded region resided, finally master
        send merge request to this regionserver and regionserver run the region merges.
        Similar with process of region splits, region merges run as a local transaction
        on the regionserver, offlines the regions and then merges two regions on the file
        system, atomically delete merging regions from META and add merged region to the META,
        opens merged region on the regionserver and reports the merge to Master at last.
        </p><p>An example of region merges in the hbase shell
          </p><pre class="programlisting">$ hbase&gt; merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME'
          hbase&gt; merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME', true
          </pre><p>
          It's an asynchronous operation and call returns immediately without waiting merge completed.
          Passing 'true' as the optional third parameter will force a merge ('force' merges regardless
          else merge will fail unless passed adjacent regions. 'force' is for expert use only)
        </p></div><div class="section" title="9.7.7.&nbsp;Store"><div class="titlepage"><div><div><h3 class="title"><a name="store"></a>9.7.7.&nbsp;Store</h3></div></div></div><p>A Store hosts a MemStore and 0 or more StoreFiles (HFiles). A Store corresponds to a column family for a table for a given region.
          </p><div class="section" title="9.7.7.1.&nbsp;MemStore"><div class="titlepage"><div><div><h4 class="title"><a name="store.memstore"></a>9.7.7.1.&nbsp;MemStore</h4></div></div></div><p>The MemStore holds in-memory modifications to the Store. Modifications are
            Cells/KeyValues. When a flush is requested, the current memstore is moved to a snapshot and is
            cleared. HBase continues to serve edits from the new memstore and backing snapshot until
            the flusher reports that the flush succeeded. At this point, the snapshot is discarded.
            Note that when the flush happens, Memstores that belong to the same region will all be
            flushed.</p></div><div class="section" title="9.7.7.2.&nbsp;MemStoreFlush"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e11230"></a>9.7.7.2.&nbsp;MemStoreFlush</h4></div></div></div><p> A MemStore flush can be triggered under any of the conditions listed below. The
            minimum flush unit is per region, not at individual MemStore level.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>When a MemStore reaches the value specified by
                  <code class="varname">hbase.hregion.memstore.flush.size</code>, all MemStores that belong to
                its region will be flushed out to disk.</p></li><li class="listitem"><p>When overall memstore usage reaches the value specified by
                  <code class="varname">hbase.regionserver.global.memstore.upperLimit</code>, MemStores from
                various regions will be flushed out to disk to reduce overall MemStore usage in a
                Region Server. The flush order is based on the descending order of a region's
                MemStore usage. Regions will have their MemStores flushed until the overall MemStore
                usage drops to or slightly below
                  <code class="varname">hbase.regionserver.global.memstore.lowerLimit</code>. </p></li><li class="listitem"><p>When the number of HLog per region server reaches the value specified in
                  <code class="varname">hbase.regionserver.max.logs</code>, MemStores from various regions
                will be flushed out to disk to reduce HLog count. The flush order is based on time.
                Regions with the oldest MemStores are flushed first until HLog count drops below
                  <code class="varname">hbase.regionserver.max.logs</code>. </p></li></ol></div></div><div class="section" title="9.7.7.3.&nbsp;Scans"><div class="titlepage"><div><div><h4 class="title"><a name="hregion.scans"></a>9.7.7.3.&nbsp;Scans</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p> When a client issues a scan against a table, HBase generates
                  <code class="code">RegionScanner</code> objects, one per region, to serve the scan request.
              </p></li><li class="listitem"><p>The <code class="code">RegionScanner</code> object contains a list of
                  <code class="code">StoreScanner</code> objects, one per column family. </p></li><li class="listitem"><p>Each <code class="code">StoreScanner</code> object further contains a list of
                  <code class="code">StoreFileScanner</code> objects, corresponding to each StoreFile and
                HFile of the corresponding column family, and a list of
                  <code class="code">KeyValueScanner</code> objects for the MemStore. </p></li><li class="listitem"><p>The two lists are merge into one, which is sorted in ascending order with the
                scan object for the MemStore at the end of the list.</p></li><li class="listitem"><p>When a <code class="code">StoreFileScanner</code> object is constructed, it is associated
                with a <code class="code">MultiVersionConsistencyControl</code> read point, which is the
                current <code class="code">memstoreTS</code>, filtering out any new updates beyond the read
                point. </p></li></ul></div></div><div class="section" title="9.7.7.4.&nbsp;StoreFile (HFile)"><div class="titlepage"><div><div><h4 class="title"><a name="hfile"></a>9.7.7.4.&nbsp;StoreFile (HFile)</h4></div></div></div><p>StoreFiles are where your data lives.
      </p><div class="section" title="9.7.7.4.1.&nbsp;HFile Format"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e11311"></a>9.7.7.4.1.&nbsp;HFile Format</h5></div></div></div><p>The <span class="emphasis"><em>hfile</em></span> file format is based on
              the SSTable file described in the <a class="link" href="http://research.google.com/archive/bigtable.html" target="_top">BigTable [2006]</a> paper and on
              Hadoop's <a class="link" href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/io/file/tfile/TFile.html" target="_top">tfile</a>
              (The unit test suite and the compression harness were taken directly from tfile).
              Schubert Zhang's blog post on <a class="link" href="http://cloudepr.blogspot.com/2009/09/hfile-block-indexed-file-format-to.html" target="_top">HFile: A Block-Indexed File Format to Store Sorted Key-Value Pairs</a> makes for a thorough introduction to HBase's hfile.  Matteo Bertozzi has also put up a
              helpful description, <a class="link" href="http://th30z.blogspot.com/2011/02/hbase-io-hfile.html?spref=tw" target="_top">HBase I/O: HFile</a>.
          </p><p>For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFile.html" target="_top">HFile source code</a>.
          Also see <a class="xref" href="#hfilev2" title="H.2.&nbsp; HBase file format with inline blocks (version 2)">Section&nbsp;H.2, &#8220;
      HBase file format with inline blocks (version 2)
      &#8221;</a> for information about the HFile v2 format that was included in 0.92.
          </p></div><div class="section" title="9.7.7.4.2.&nbsp;HFile Tool"><div class="titlepage"><div><div><h5 class="title"><a name="hfile_tool"></a>9.7.7.4.2.&nbsp;HFile Tool</h5></div></div></div><p>To view a textualized version of hfile content, you can do use
        the <code class="classname">org.apache.hadoop.hbase.io.hfile.HFile
        </code>tool. Type the following to see usage:</p><pre class="programlisting"><code class="code">$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile </code> </pre><p>For
        example, to view the content of the file
        <code class="filename">hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475</code>,
        type the following:</p><pre class="programlisting"> <code class="code">$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile -v -f hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475 </code> </pre><p>If
        you leave off the option -v to see just a summary on the hfile. See
        usage for other things to do with the <code class="classname">HFile</code>
        tool.</p></div><div class="section" title="9.7.7.4.3.&nbsp;StoreFile Directory Structure on HDFS"><div class="titlepage"><div><div><h5 class="title"><a name="store.file.dir"></a>9.7.7.4.3.&nbsp;StoreFile Directory Structure on HDFS</h5></div></div></div><p>For more information of what StoreFiles look like on HDFS with respect to the directory structure, see <a class="xref" href="#trouble.namenode.hbase.objects" title="15.7.2.&nbsp;Browsing HDFS for HBase Objects">Section&nbsp;15.7.2, &#8220;Browsing HDFS for HBase Objects&#8221;</a>.
        </p></div></div><div class="section" title="9.7.7.5.&nbsp;Blocks"><div class="titlepage"><div><div><h4 class="title"><a name="hfile.blocks"></a>9.7.7.5.&nbsp;Blocks</h4></div></div></div><p>StoreFiles are composed of blocks.  The blocksize is configured on a per-ColumnFamily basis.
        </p><p>Compression happens at the block level within StoreFiles.  For more information on compression, see <a class="xref" href="#compression" title="Appendix&nbsp;E.&nbsp;Compression and Data Block Encoding In HBase">Appendix&nbsp;E, <i>Compression and Data Block Encoding In
          HBase</i></a>.
        </p><p>For more information on blocks, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFileBlock.html" target="_top">HFileBlock source code</a>.
        </p></div><div class="section" title="9.7.7.6.&nbsp;KeyValue"><div class="titlepage"><div><div><h4 class="title"><a name="keyvalue"></a>9.7.7.6.&nbsp;KeyValue</h4></div></div></div><p>The KeyValue class is the heart of data storage in HBase.  KeyValue wraps a byte array and takes offsets and lengths into passed array
         at where to start interpreting the content as KeyValue.
        </p><p>The KeyValue format inside a byte array is:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>keylength</p></li><li class="listitem"><p>valuelength</p></li><li class="listitem"><p>key</p></li><li class="listitem"><p>value</p></li></ul></div><p>
        </p><p>The Key is further decomposed as:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>rowlength</p></li><li class="listitem"><p>row (i.e., the rowkey)</p></li><li class="listitem"><p>columnfamilylength</p></li><li class="listitem"><p>columnfamily</p></li><li class="listitem"><p>columnqualifier</p></li><li class="listitem"><p>timestamp</p></li><li class="listitem"><p>keytype (e.g., Put, Delete, DeleteColumn, DeleteFamily)</p></li></ul></div><p>
        </p><p>KeyValue instances are <span class="emphasis"><em>not</em></span> split across blocks.
         For example, if there is an 8 MB KeyValue, even if the block-size is 64kb this KeyValue will be read
         in as a coherent block.  For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/KeyValue.html" target="_top">KeyValue source code</a>.
        </p><div class="section" title="9.7.7.6.1.&nbsp;Example"><div class="titlepage"><div><div><h5 class="title"><a name="keyvalue.example"></a>9.7.7.6.1.&nbsp;Example</h5></div></div></div><p>To emphasize the points above, examine what happens with two Puts for two different columns for the same row:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Put #1:  <code class="code">rowkey=row1, cf:attr1=value1</code></p></li><li class="listitem"><p>Put #2:  <code class="code">rowkey=row1, cf:attr2=value2</code></p></li></ul></div><p>Even though these are for the same row, a KeyValue is created for each column:</p><p>Key portion for Put #1:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>rowlength <code class="code">------------&gt; 4</code></p></li><li class="listitem"><p>row <code class="code">-----------------&gt; row1</code></p></li><li class="listitem"><p>columnfamilylength <code class="code">---&gt; 2</code></p></li><li class="listitem"><p>columnfamily <code class="code">--------&gt; cf</code></p></li><li class="listitem"><p>columnqualifier <code class="code">------&gt; attr1</code></p></li><li class="listitem"><p>timestamp <code class="code">-----------&gt; server time of Put</code></p></li><li class="listitem"><p>keytype <code class="code">-------------&gt; Put</code></p></li></ul></div><p>
          </p><p>Key portion for Put #2:
           </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>rowlength <code class="code">------------&gt; 4</code></p></li><li class="listitem"><p>row <code class="code">-----------------&gt; row1</code></p></li><li class="listitem"><p>columnfamilylength <code class="code">---&gt; 2</code></p></li><li class="listitem"><p>columnfamily <code class="code">--------&gt; cf</code></p></li><li class="listitem"><p>columnqualifier <code class="code">------&gt; attr2</code></p></li><li class="listitem"><p>timestamp <code class="code">-----------&gt; server time of Put</code></p></li><li class="listitem"><p>keytype <code class="code">-------------&gt; Put</code></p></li></ul></div><p>
           
          </p><p>It is critical to understand that the rowkey, ColumnFamily, and column (aka columnqualifier) are embedded within
            the KeyValue instance.  The longer these identifiers are, the bigger the KeyValue is.</p></div></div><div class="section" title="9.7.7.7.&nbsp;Compaction"><div class="titlepage"><div><div><h4 class="title"><a name="compaction"></a>9.7.7.7.&nbsp;Compaction</h4></div></div></div><div class="itemizedlist" title="Ambiguous Terminology"><p class="title"><b>Ambiguous Terminology</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>A <em class="firstterm">StoreFile</em> is a facade of HFile. In terms of compaction, use of
              StoreFile seems to have prevailed in the past.</p></li><li class="listitem"><p>A <em class="firstterm">Store</em> is the same thing as a ColumnFamily.
              StoreFiles are related to a Store, or ColumnFamily.</p></li><li class="listitem"><p>If you want to read more about StoreFiles versus HFiles and Stores versus
                ColumnFamilies, see <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11316" target="_top">HBASE-11316</a>.</p></li></ul></div><p>When the MemStore reaches a given size
              (<code class="code">hbase.hregion.memstore.flush.size)</code>, it flushes its contents to a
            StoreFile. The number of StoreFiles in a Store increases over time.
              <em class="firstterm">Compaction</em> is an operation which reduces the number of
            StoreFiles in a Store, by merging them together, in order to increase performance on
            read operations. Compactions can be resource-intensive to perform, and can either help
            or hinder performance depending on many factors. </p><p>Compactions fall into two categories: minor and major. Minor and major compactions
            differ in the following ways.</p><p><em class="firstterm">Minor compactions</em> usually select a small number of small,
            adjacent StoreFiles and rewrite them as a single StoreFile. Minor compactions do not
            drop (filter out) deletes or expired versions, because of potential side effects. See <a class="xref" href="#compaction.and.deletes" title="Compaction and Deletions">Compaction and Deletions</a> and <a class="xref" href="#compaction.and.versions" title="Compaction and Versions">Compaction and Versions</a> for information on how deletes and versions are
            handled in relation to compactions. The end result of a minor compaction is fewer,
            larger StoreFiles for a given Store.</p><p>The end result of a <em class="firstterm">major compaction</em> is a single StoreFile
            per Store. Major compactions also process delete markers and max versions. See <a class="xref" href="#compaction.and.deletes" title="Compaction and Deletions">Compaction and Deletions</a> and <a class="xref" href="#compaction.and.versions" title="Compaction and Versions">Compaction and Versions</a> for information on how deletes and versions are
            handled in relation to compactions.</p><p title="Compaction and Deletions"><a name="compaction.and.deletes"></a><b>Compaction and Deletions.&nbsp;</b> When an explicit deletion occurs in HBase, the data is not actually deleted.
              Instead, a <em class="firstterm">tombstone</em> marker is written. The tombstone marker
              prevents the data from being returned with queries. During a major compaction, the
              data is actually deleted, and the tombstone marker is removed from the StoreFile. If
              the deletion happens because of an expired TTL, no tombstone is created. Instead, the
              expired data is filtered out and is not written back to the compacted
              StoreFile.</p><p title="Compaction and Versions"><a name="compaction.and.versions"></a><b>Compaction and Versions.&nbsp;</b> When you create a Column Family, you can specify the maximum number of versions
              to keep, by specifying <code class="varname">HColumnDescriptor.setMaxVersions(int
                versions)</code>. The default value is <code class="literal">3</code>. If more versions
              than the specified maximum exist, the excess versions are filtered out and not written
              back to the compacted StoreFile.</p><div class="note" title="Major Compactions Can Impact Query Results" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Major Compactions Can Impact Query Results</h3><p> In some situations, older versions can be inadvertently resurrected if a newer
              version is explicitly deleted. See <a class="xref" href="#major.compactions.change.query.results" title="5.9.3.2.&nbsp;Major compactions change query results">Section&nbsp;5.9.3.2, &#8220;Major compactions change query results&#8221;</a> for a more in-depth explanation.
              This situation is only possible before the compaction finishes. </p></div><p>In theory, major compactions improve performance. However, on a highly loaded
            system, major compactions can require an inappropriate number of resources and adversely
            affect performance. In a default configuration, major compactions are scheduled
            automatically to run once in a 7-day period. This is sometimes inappropriate for systems
            in production. You can manage major compactions manually. See <a class="xref" href="#managed.compactions" title="2.6.2.8.&nbsp;Managed Compactions">Section&nbsp;2.6.2.8, &#8220;Managed Compactions&#8221;</a>. </p><p>Compactions do not perform region merges. See <a class="xref" href="#ops.regionmgt.merge" title="17.2.2.&nbsp;Merge">Section&nbsp;17.2.2, &#8220;Merge&#8221;</a> for more information on region merging. </p><div class="section" title="9.7.7.7.1.&nbsp;Compaction Policy - HBase 0.96.x and newer"><div class="titlepage"><div><div><h5 class="title"><a name="compaction.file.selection"></a>9.7.7.7.1.&nbsp;Compaction Policy - HBase 0.96.x and newer</h5></div></div></div><p>Compacting large StoreFiles, or too many StoreFiles at once, can cause more IO
              load than your cluster is able to handle without causing performance problems. The
              method by which HBase selects which StoreFiles to include in a compaction (and whether
              the compaction is a minor or major compaction) is called the <em class="firstterm">compaction
                policy</em>.</p><p>Prior to HBase 0.96.x, there was only one compaction policy. That original
              compaction policy is still available as
                <code class="systemitem">RatioBasedCompactionPolicy</code> The new compaction default
              policy, called <code class="systemitem">ExploringCompactionPolicy</code>, was subsequently
              backported to HBase 0.94 and HBase 0.95, and is the default in HBase 0.96 and newer.
              It was implemented in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-7842" target="_top">HBASE-7842</a>. In
              short, <code class="systemitem">ExploringCompactionPolicy</code> attempts to select the best
              possible set of StoreFiles to compact with the least amount of work, while the
                <code class="systemitem">RatioBasedCompactionPolicy</code> selects the first set that meets
              the criteria.</p><p>Regardless of the compaction policy used, file selection is controlled by several
              configurable parameters and happens in a multi-step approach. These parameters will be
              explained in context, and then will be given in a table which shows their
              descriptions, defaults, and implications of changing them.</p><div class="section" title="9.7.7.7.1.1.&nbsp;Being Stuck"><div class="titlepage"><div><div><h6 class="title"><a name="compaction.being.stuck"></a>9.7.7.7.1.1.&nbsp;Being Stuck</h6></div></div></div><p>When the MemStore gets too large, it needs to flush its contents to a StoreFile.
                However, a Store can only have <code class="varname">hbase.hstore.blockingStoreFiles</code>
                files, so the MemStore needs to wait for the number of StoreFiles to be reduced by
                one or more compactions. However, if the MemStore grows larger than
                  <code class="varname">hbase.hregion.memstore.flush.size</code>, it is not able to flush its
                contents to a StoreFile. If the MemStore is too large and the number of StpreFo;es
                is also too high, the algorithm is said to be "stuck". The compaction algorithm
                checks for this "stuck" situation and provides mechanisms to alleviate it.</p></div><div class="section" title="9.7.7.7.1.2.&nbsp;The ExploringCompactionPolicy Algorithm"><div class="titlepage"><div><div><h6 class="title"><a name="exploringcompaction.policy"></a>9.7.7.7.1.2.&nbsp;The ExploringCompactionPolicy Algorithm</h6></div></div></div><p>The ExploringCompactionPolicy algorithm considers each possible set of
                adjacent StoreFiles before choosing the set where compaction will have the most
                benefit. </p><p>One situation where the ExploringCompactionPolicy works especially well is when
                you are bulk-loading data and the bulk loads create larger StoreFiles than the
                StoreFiles which are holding data older than the bulk-loaded data. This can "trick"
                HBase into choosing to perform a major compaction each time a compaction is needed,
                and cause a lot of extra overhead. With the ExploringCompactionPolicy, major
                compactions happen much less frequently because minor compactions are more
                efficient.</p><p>In general, ExploringCompactionPolicy is the right choice for most situations,
                and thus is the default compaction policy. You can also use
                ExploringCompactionPolicy along with <a class="xref" href="#ops.stripe" title="9.7.7.7.3.&nbsp;Experimental: Stripe Compactions">Section&nbsp;9.7.7.7.3, &#8220;Experimental: Stripe Compactions&#8221;</a>.</p><p>The logic of this policy can be examined in
                  <code class="filename">hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/ExploringCompactionPolicy.java</code>.
                The following is a walk-through of the logic of the
                ExploringCompactionPolicy.</p><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Make a list of all existing StoreFiles in the Store. The rest of the
                    algorithm filters this list to come up with the subset of HFiles which will be
                    chosen for compaction.</p></li><li class="step" title="Step 2"><p>If this was a user-requested compaction, attempt to perform the requested
                    compaction type, regardless of what would normally be chosen. Note that even if
                    the user requests a major compaction, it may not be possible to perform a major
                    compaction. This may be because not all StoreFiles in the Column Family are
                    available to compact or because there are too many Stores in the Column
                    Family.</p></li><li class="step" title="Step 3"><p>Some StoreFiles are automatically excluded from consideration. These
                    include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>StoreFiles that are larger than
                          <code class="varname">hbase.hstore.compaction.max.size</code></p></li><li class="listitem"><p>StoreFiles that were created by a bulk-load operation which explicitly
                        excluded compaction. You may decide to exclude StoreFiles resulting from
                        bulk loads, from compaction. To do this, specify the
                          <code class="varname">hbase.mapreduce.hfileoutputformat.compaction.exclude</code>
                        parameter during the bulk load operation.</p></li></ul></div></li><li class="step" title="Step 4"><p>Iterate through the list from step 1, and make a list of all potential sets
                    of StoreFiles to compact together. A potential set is a grouping of
                      <code class="varname">hbase.hstore.compaction.min</code> contiguous StoreFiles in the
                    list. For each set, perform some sanity-checking and figure out whether this is
                    the best compaction that could be done:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If the number of StoreFiles in this set (not the size of the StoreFiles)
                        is fewer than <code class="varname">hbase.hstore.compaction.min</code> or more than
                          <code class="varname">hbase.hstore.compaction.max</code>, take it out of
                        consideration.</p></li><li class="listitem"><p>Compare the size of this set of StoreFiles with the size of the smallest
                        possible compaction that has been found in the list so far. If the size of
                        this set of StoreFiles represents the smallest compaction that could be
                        done, store it to be used as a fall-back if the algorithm is "stuck" and no
                        StoreFiles would otherwise be chosen. See <a class="xref" href="#compaction.being.stuck" title="9.7.7.7.1.1.&nbsp;Being Stuck">Section&nbsp;9.7.7.7.1.1, &#8220;Being Stuck&#8221;</a>.</p></li><li class="listitem"><p>Do size-based sanity checks against each StoreFile in this set of
                        StoreFiles.</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>If the size of this StoreFile is larger than
                              <code class="varname">hbase.hstore.compaction.max.size</code>, take it out of
                            consideration.</p></li><li class="listitem"><p>If the size is greater than or equal to
                              <code class="varname">hbase.hstore.compaction.min.size</code>, sanity-check it
                            against the file-based ratio to see whether it is too large to be
                            considered. The sanity-checking is successful if:</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>There is only one StoreFile in this set, or</p></li><li class="listitem"><p>For each StoreFile, its size multiplied by
                                  <code class="varname">hbase.hstore.compaction.ratio</code> (or
                                  <code class="varname">hbase.hstore.compaction.ratio.offpeak</code> if
                                off-peak hours are configured and it is during off-peak hours) is
                                less than the sum of the sizes of the other HFiles in the
                                set.</p></li></ul></div></li></ul></div></li></ul></div></li><li class="step" title="Step 5"><p>If this set of StoreFiles is still in consideration, compare it to the
                    previously-selected best compaction. If it is better, replace the
                    previously-selected best compaction with this one.</p></li><li class="step" title="Step 6"><p>When the entire list of potential compactions has been processed, perform
                    the best compaction that was found. If no StoreFiles were selected for
                    compaction, but there are multiple StoreFiles, assume the algorithm is stuck
                    (see <a class="xref" href="#compaction.being.stuck" title="9.7.7.7.1.1.&nbsp;Being Stuck">Section&nbsp;9.7.7.7.1.1, &#8220;Being Stuck&#8221;</a>) and if so, perform the smallest
                    compaction that was found in step 3.</p></li></ol></div></div><div class="section" title="9.7.7.7.1.3.&nbsp;RatioBasedCompactionPolicy Algorithm"><div class="titlepage"><div><div><h6 class="title"><a name="compaction.ratiobasedcompactionpolicy.algorithm"></a>9.7.7.7.1.3.&nbsp;RatioBasedCompactionPolicy Algorithm</h6></div></div></div><p>The RatioBasedCompactionPolicy was the only compaction policy prior to HBase
                0.96, though ExploringCompactionPolicy has now been backported to HBase 0.94 and
                0.95. To use the RatioBasedCompactionPolicy rather than the
                ExploringCompactionPolicy, set
                  <code class="varname">hbase.hstore.defaultengine.compactionpolicy.class</code> to
                  <code class="literal">RatioBasedCompactionPolicy</code> in the
                  <code class="filename">hbase-site.xml</code> file. To switch back to the
                ExploringCompactionPolicy, remove the setting from the
                  <code class="filename">hbase-site.xml</code>.</p><p>The following section walks you through the algorithm used to select StoreFiles
                for compaction in the RatioBasedCompactionPolicy.</p><div class="procedure"><ol class="procedure" type="1"><li class="step" title="Step 1"><p>The first phase is to create a list of all candidates for compaction. A list
                    is created of all StoreFiles not already in the compaction queue, and all
                    StoreFiles newer than the newest file that is currently being compacted. This
                    list of StoreFiles is ordered by the sequence ID. The sequence ID is generated
                    when a Put is appended to the write-ahead log (WAL), and is stored in the
                    metadata of the HFile.</p></li><li class="step" title="Step 2"><p>Check to see if the algorithm is stuck (see <a class="xref" href="#compaction.being.stuck" title="9.7.7.7.1.1.&nbsp;Being Stuck">Section&nbsp;9.7.7.7.1.1, &#8220;Being Stuck&#8221;</a>, and if so, a major compaction is forced.
                    This is a key area where <a class="xref" href="#exploringcompaction.policy" title="9.7.7.7.1.2.&nbsp;The ExploringCompactionPolicy Algorithm">Section&nbsp;9.7.7.7.1.2, &#8220;The ExploringCompactionPolicy Algorithm&#8221;</a> is often a better choice than the
                    RatioBasedCompactionPolicy.</p></li><li class="step" title="Step 3"><p>If the compaction was user-requested, try to perform the type of compaction
                    that was requested. Note that a major compaction may not be possible if all
                    HFiles are not available for compaction or if too may StoreFiles exist (more
                    than <code class="varname">hbase.hstore.compaction.max</code>).</p></li><li class="step" title="Step 4"><p>Some StoreFiles are automatically excluded from consideration. These
                    include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>StoreFiles that are larger than
                          <code class="varname">hbase.hstore.compaction.max.size</code></p></li><li class="listitem"><p>StoreFiles that were created by a bulk-load operation which explicitly
                        excluded compaction. You may decide to exclude StoreFiles resulting from
                        bulk loads, from compaction. To do this, specify the
                          <code class="varname">hbase.mapreduce.hfileoutputformat.compaction.exclude</code>
                        parameter during the bulk load operation.</p></li></ul></div></li><li class="step" title="Step 5"><p>The maximum number of StoreFiles allowed in a major compaction is controlled
                    by the <code class="varname">hbase.hstore.compaction.max</code> parameter. If the list
                    contains more than this number of StoreFiles, a minor compaction is performed
                    even if a major compaction would otherwise have been done. However, a
                    user-requested major compaction still occurs even if there are more than
                      <code class="varname">hbase.hstore.compaction.max</code> StoreFiles to compact.</p></li><li class="step" title="Step 6"><p>If the list contains fewer than
                      <code class="varname">hbase.hstore.compaction.min</code> StoreFiles to compact, a minor
                    compaction is aborted. Note that a major compaction can be performed on a single
                    HFile. Its function is to remove deletes and expired versions, and reset
                    locality on the StoreFile.</p></li><li class="step" title="Step 7"><p>The value of the <code class="varname">hbase.hstore.compaction.ratio</code> parameter
                    is multiplied by the sum of StoreFiles smaller than a given file, to determine
                    whether that StoreFile is selected for compaction during a minor compaction. For
                    instance, if hbase.hstore.compaction.ratio is 1.2, FileX is 5 mb, FileY is 2 mb,
                    and FileZ is 3 mb:</p><pre class="screen">5 &lt;= 1.2 x (2 + 3)            or           5 &lt;= 6</pre><p>In this scenario, FileX is eligible for minor compaction. If FileX were 7
                    mb, it would not be eligible for minor compaction. This ratio favors smaller
                    StoreFile. You can configure a different ratio for use in off-peak hours, using
                    the parameter <code class="varname">hbase.hstore.compaction.ratio.offpeak</code>, if you
                    also configure <code class="varname">hbase.offpeak.start.hour</code> and
                      <code class="varname">hbase.offpeak.end.hour</code>.</p></li><li class="step" title="Step 8"><p>If the last major compaction was too long ago and there is more than one
                    StoreFile to be compacted, a major compaction is run, even if it would otherwise
                    have been minor. By default, the maximum time between major compactions is 7
                    days, plus or minus a 4.8 hour period, and determined randomly within those
                    parameters. Prior to HBase 0.96, the major compaction period was 24 hours. See
                      <code class="varname">hbase.hregion.majorcompaction</code> in the table below to tune or
                    disable time-based major compactions.</p></li></ol></div></div><div class="section" title="9.7.7.7.1.4.&nbsp;Parameters Used by Compaction Algorithm"><div class="titlepage"><div><div><h6 class="title"><a name="compaction.parameters"></a>9.7.7.7.1.4.&nbsp;Parameters Used by Compaction Algorithm</h6></div></div></div><p>This table contains the main configuration parameters for compaction. This list
                is not exhaustive. To tune these parameters from the defaults, edit the
                  <code class="filename">hbase-default.xml</code> file. For a full list of all configuration
                parameters available, see <a class="xref" href="#config.files" title="2.4.&nbsp;Configuration Files">Section&nbsp;2.4, &#8220;Configuration Files&#8221;</a></p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Parameter</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td>hbase.hstore.compaction.min</td><td><p>The minimum number of StoreFiles which must be eligible for
                          compaction before compaction can run.</p>
                        <p>The goal of tuning <code class="varname">hbase.hstore.compaction.min</code>
                          is to avoid ending up with too many tiny StoreFiles to compact. Setting
                          this value to <code class="literal">2</code> would cause a minor compaction each
                          time you have two StoreFiles in a Store, and this is probably not
                          appropriate. If you set this value too high, all the other values will
                          need to be adjusted accordingly. For most cases, the default value is
                          appropriate.</p>
                        <p>In previous versions of HBase, the parameter
                            <code class="code">hbase.hstore.compaction.min</code> was called
                            <code class="code">hbase.hstore.compactionThreshold</code>.</p>
                      </td><td>3</td></tr><tr><td>hbase.hstore.compaction.max</td><td><p>The maximum number of StoreFiles which will be selected for a
                          single minor compaction, regardless of the number of eligible
                          StoreFiles.</p>
                        <p>Effectively, the value of
                            <code class="varname">hbase.hstore.compaction.max</code> controls the length of
                          time it takes a single compaction to complete. Setting it larger means
                          that more StoreFiles are included in a compaction. For most cases, the
                          default value is appropriate.</p>
                      </td><td>10</td></tr><tr><td>hbase.hstore.compaction.min.size</td><td><p>A StoreFile smaller than this size will always be eligible for
                          minor compaction. StoreFiles this size or larger are evaluated by
                            <code class="varname">hbase.hstore.compaction.ratio</code> to determine if they are
                          eligible.</p>
                        <p>Because this limit represents the "automatic include" limit for
                          all StoreFiles smaller than this value, this value may need to be reduced
                          in write-heavy environments where many files in the 1-2 MB range are being
                          flushed, because every StoreFile will be targeted for compaction and the
                          resulting StoreFiles may still be under the minimum size and require
                          further compaction.</p>
                        <p>If this parameter is lowered, the ratio check is triggered more
                          quickly. This addressed some issues seen in earlier versions of HBase but
                          changing this parameter is no longer necessary in most situations.</p>
                      </td><td>128 MB</td></tr><tr><td>hbase.hstore.compaction.max.size</td><td><p>An StoreFile larger than this size will be excluded from
                          compaction. The effect of raising
                            <code class="varname">hbase.hstore.compaction.max.size</code> is fewer, larger
                          StoreFiles that do not get compacted often. If you feel that compaction is
                          happening too often without much benefit, you can try raising this
                          value.</p></td><td>Long.MAX_VALUE</td></tr><tr><td>hbase.hstore.compaction.ratio</td><td><p>For minor compaction, this ratio is used to determine whether a
                          given StoreFile which is larger than
                            <code class="varname">hbase.hstore.compaction.min.size</code> is eligible for
                          compaction. Its effect is to limit compaction of large StoreFile. The
                          value of <code class="varname">hbase.hstore.compaction.ratio</code> is expressed as
                          a floating-point decimal.</p>
                        <p>A large ratio, such as <code class="literal">10</code>, will produce a
                          single giant StoreFile. Conversely, a value of <code class="literal">.25</code>,
                          will produce behavior similar to the BigTable compaction algorithm,
                          producing four StoreFiles.</p>
                        <p>A moderate value of between 1.0 and 1.4 is recommended. When
                          tuning this value, you are balancing write costs with read costs. Raising
                          the value (to something like 1.4) will have more write costs, because you
                          will compact larger StoreFiles. However, during reads, HBase will need to seek
                          through fewer StpreFo;es to accomplish the read. Consider this approach if you
                          cannot take advantage of <a class="xref" href="#schema.bloom" title="14.6.4.&nbsp;Bloom Filters">Section&nbsp;14.6.4, &#8220;Bloom Filters&#8221;</a>.</p>
                        <p>Alternatively, you can lower this value to something like 1.0 to
                          reduce the background cost of writes, and use <a class="xref" href="#schema.bloom" title="14.6.4.&nbsp;Bloom Filters">Section&nbsp;14.6.4, &#8220;Bloom Filters&#8221;</a> to limit the number of StoreFiles touched
                          during reads.</p>
                        <p>For most cases, the default value is appropriate.</p>
                      </td><td>1.2F</td></tr><tr><td>hbase.hstore.compaction.ratio.offpeak</td><td>The compaction ratio used during off-peak compactions, if off-peak
                        hours are also configured (see below). Expressed as a floating-point
                        decimal. This allows for more aggressive (or less aggressive, if you set it
                        lower than <code class="varname">hbase.hstore.compaction.ratio</code>) compaction
                        during a set time period. Ignored if off-peak is disabled (default). This
                        works the same as <code class="varname">hbase.hstore.compaction.ratio</code>.</td><td>5.0F</td></tr><tr><td>hbase.offpeak.start.hour</td><td>The start of off-peak hours, expressed as an integer between 0 and 23,
                        inclusive. Set to <code class="literal">-1</code> to disable off-peak.</td><td>-1 (disabled)</td></tr><tr><td>hbase.offpeak.end.hour</td><td>The end of off-peak hours, expressed as an integer between 0 and 23,
                        inclusive. Set to <code class="literal">-1</code> to disable off-peak.</td><td>-1 (disabled)</td></tr><tr><td>hbase.regionserver.thread.compaction.throttle</td><td><p>There are two different thread pools for compactions, one for
                          large compactions and the other for small compactions. This helps to keep
                          compaction of lean tables (such as <code class="systemitem">hbase:meta</code>)
                          fast. If a compaction is larger than this threshold, it goes into the
                          large compaction pool. In most cases, the default value is
                          appropriate.</p></td><td>2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size
                        (which defaults to 128)</td></tr><tr><td>hbase.hregion.majorcompaction</td><td><p>Time between major compactions, expressed in milliseconds. Set to
                          0 to disable time-based automatic major compactions. User-requested and
                          size-based major compactions will still run. This value is multiplied by
                            <code class="varname">hbase.hregion.majorcompaction.jitter</code> to cause
                          compaction to start at a somewhat-random time during a given window of
                          time.</p></td><td>7 days (604800000 milliseconds)</td></tr><tr><td>hbase.hregion.majorcompaction.jitter</td><td><p>A multiplier applied to
                            <code class="varname">hbase.hregion.majorcompaction</code> to cause compaction to
                          occur a given amount of time either side of
                            <code class="varname">hbase.hregion.majorcompaction</code>. The smaller the
                          number, the closer the compactions will happen to the
                            <code class="varname">hbase.hregion.majorcompaction</code> interval. Expressed as
                          a floating-point decimal.</p></td><td>.50F</td></tr></tbody></table></div></div></div><div class="section" title="9.7.7.7.2.&nbsp;Compaction File Selection"><div class="titlepage"><div><div><h5 class="title"><a name="compaction.file.selection.old"></a>9.7.7.7.2.&nbsp;Compaction File Selection</h5></div></div></div><div class="note" title="Legacy Information" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Legacy Information</h3><p>This section has been preserved for historical reasons and refers to the way
                compaction worked prior to HBase 0.96.x. You can still use this behavior if you
                enable <a class="xref" href="#compaction.ratiobasedcompactionpolicy.algorithm" title="9.7.7.7.1.3.&nbsp;RatioBasedCompactionPolicy Algorithm">Section&nbsp;9.7.7.7.1.3, &#8220;RatioBasedCompactionPolicy Algorithm&#8221;</a> For information on
                the way that compactions work in HBase 0.96.x and later, see <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a>.</p></div><p>To understand the core algorithm for StoreFile selection, there is some ASCII-art
              in the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/regionserver/Store.html#836" target="_top">Store
                source code</a> that will serve as useful reference. It has been copied below:
              </p><pre class="programlisting">
/* normal skew:
 *
 *         older ----&gt; newer
 *     _
 *    | |   _
 *    | |  | |   _
 *  --|-|- |-|- |-|---_-------_-------  minCompactSize
 *    | |  | |  | |  | |  _  | |
 *    | |  | |  | |  | | | | | |
 *    | |  | |  | |  | | | | | |
 */
</pre><p>
              Important knobs: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">hbase.hstore.compaction.ratio</code> Ratio used in compaction file
                    selection algorithm (default 1.2f).</p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min</code> (.90
                    hbase.hstore.compactionThreshold) (files) Minimum number of StoreFiles per Store
                    to be selected for a compaction to occur (default 2).</p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max</code> (files) Maximum number of
                    StoreFiles to compact per minor compaction (default 10).</p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min.size</code> (bytes) Any StoreFile smaller
                    than this setting with automatically be a candidate for compaction. Defaults to
                      <code class="code">hbase.hregion.memstore.flush.size</code> (128 mb). </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max.size</code> (.92) (bytes) Any StoreFile
                    larger than this setting with automatically be excluded from compaction (default
                    Long.MAX_VALUE). </p></li></ul></div><p>
            </p><p>The minor compaction StoreFile selection logic is size based, and selects a file
              for compaction when the file &lt;= sum(smaller_files) *
                <code class="code">hbase.hstore.compaction.ratio</code>. </p><div class="section" title="9.7.7.7.2.1.&nbsp;Minor Compaction File Selection - Example #1 (Basic Example)"><div class="titlepage"><div><div><h6 class="title"><a name="compaction.file.selection.example1"></a>9.7.7.7.2.1.&nbsp;Minor Compaction File Selection - Example #1 (Basic Example)</h6></div></div></div><p>This example mirrors an example from the unit test
                <code class="code">TestCompactSelection</code>.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">hbase.hstore.compaction.ratio</code> = 1.0f </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min</code> = 3 (files) </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max</code> = 5 (files) </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min.size</code> = 10 (bytes) </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max.size</code> = 1000 (bytes) </p></li></ul></div><p> The following StoreFiles exist: 100, 50, 23, 12, and 12 bytes apiece (oldest to
              newest). With the above parameters, the files that would be selected for minor
              compaction are 23, 12, and 12. </p><p>Why? </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>100 --&gt; No, because sum(50, 23, 12, 12) * 1.0 = 97. </p></li><li class="listitem"><p>50 --&gt; No, because sum(23, 12, 12) * 1.0 = 47. </p></li><li class="listitem"><p>23 --&gt; Yes, because sum(12, 12) * 1.0 = 24. </p></li><li class="listitem"><p>12 --&gt; Yes, because the previous file has been included, and because this
                    does not exceed the the max-file limit of 5 </p></li><li class="listitem"><p>12 --&gt; Yes, because the previous file had been included, and because this
                    does not exceed the the max-file limit of 5.</p></li></ul></div><p>
            </p></div><div class="section" title="9.7.7.7.2.2.&nbsp;Minor Compaction File Selection - Example #2 (Not Enough Files To Compact)"><div class="titlepage"><div><div><h6 class="title"><a name="compaction.file.selection.example2"></a>9.7.7.7.2.2.&nbsp;Minor Compaction File Selection - Example #2 (Not Enough Files To
              Compact)</h6></div></div></div><p>This example mirrors an example from the unit test
                <code class="code">TestCompactSelection</code>. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">hbase.hstore.compaction.ratio</code> = 1.0f </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min</code> = 3 (files) </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max</code> = 5 (files)</p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min.size</code> = 10 (bytes) </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max.size</code> = 1000 (bytes) </p></li></ul></div><p>
            </p><p>The following StoreFiles exist: 100, 25, 12, and 12 bytes apiece (oldest to
              newest). With the above parameters, no compaction will be started. </p><p>Why? </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>100 --&gt; No, because sum(25, 12, 12) * 1.0 = 47</p></li><li class="listitem"><p>25 --&gt; No, because sum(12, 12) * 1.0 = 24</p></li><li class="listitem"><p>12 --&gt; No. Candidate because sum(12) * 1.0 = 12, there are only 2 files
                    to compact and that is less than the threshold of 3</p></li><li class="listitem"><p>12 --&gt; No. Candidate because the previous StoreFile was, but there are
                    not enough files to compact</p></li></ul></div><p>
            </p></div><div class="section" title="9.7.7.7.2.3.&nbsp;Minor Compaction File Selection - Example #3 (Limiting Files To Compact)"><div class="titlepage"><div><div><h6 class="title"><a name="compaction.file.selection.example3"></a>9.7.7.7.2.3.&nbsp;Minor Compaction File Selection - Example #3 (Limiting Files To Compact)</h6></div></div></div><p>This example mirrors an example from the unit test
                <code class="code">TestCompactSelection</code>. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">hbase.hstore.compaction.ratio</code> = 1.0f </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min</code> = 3 (files) </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max</code> = 5 (files)</p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.min.size</code> = 10 (bytes) </p></li><li class="listitem"><p><code class="code">hbase.hstore.compaction.max.size</code> = 1000 (bytes) </p></li></ul></div><p> The following StoreFiles exist: 7, 6, 5, 4, 3, 2, and 1 bytes apiece
              (oldest to newest). With the above parameters, the files that would be selected for
              minor compaction are 7, 6, 5, 4, 3. </p><p>Why? </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>7 --&gt; Yes, because sum(6, 5, 4, 3, 2, 1) * 1.0 = 21. Also, 7 is less than
                    the min-size</p></li><li class="listitem"><p>6 --&gt; Yes, because sum(5, 4, 3, 2, 1) * 1.0 = 15. Also, 6 is less than
                    the min-size. </p></li><li class="listitem"><p>5 --&gt; Yes, because sum(4, 3, 2, 1) * 1.0 = 10. Also, 5 is less than the
                    min-size. </p></li><li class="listitem"><p>4 --&gt; Yes, because sum(3, 2, 1) * 1.0 = 6. Also, 4 is less than the
                    min-size. </p></li><li class="listitem"><p>3 --&gt; Yes, because sum(2, 1) * 1.0 = 3. Also, 3 is less than the
                    min-size. </p></li><li class="listitem"><p>2 --&gt; No. Candidate because previous file was selected and 2 is less than
                    the min-size, but the max-number of files to compact has been reached. </p></li><li class="listitem"><p>1 --&gt; No. Candidate because previous file was selected and 1 is less than
                    the min-size, but max-number of files to compact has been reached. </p></li></ul></div><p>
            </p><div class="section" title="9.7.7.7.2.3.1.&nbsp;Impact of Key Configuration Options"><div class="titlepage"><div><div><h6 class="title"><a name="compaction.config.impact"></a>9.7.7.7.2.3.1.&nbsp;Impact of Key Configuration Options</h6></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This information is now included in the configuration parameter table in <a class="xref" href="#">???</a>.</p></div></div></div></div><div class="section" title="9.7.7.7.3.&nbsp;Experimental: Stripe Compactions"><div class="titlepage"><div><div><h5 class="title"><a name="ops.stripe"></a>9.7.7.7.3.&nbsp;Experimental: Stripe Compactions</h5></div></div></div><p> Stripe compactions is an experimental feature added in HBase 0.98 which aims to
              improve compactions for large regions or non-uniformly distributed row keys. In order
              to achieve smaller and/or more granular compactions, the StoreFiles within a region
              are maintained separately for several row-key sub-ranges, or "stripes", of the region.
              The stripes are transparent to the rest of HBase, so other operations on the HFiles or
              data work without modification.</p><p>Stripe compactions change the HFile layout, creating sub-regions within regions.
              These sub-regions are easier to compact, and should result in fewer major compactions.
              This approach alleviates some of the challenges of larger regions.</p><p>Stripe compaction is fully compatible with <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a> and works in conjunction with either the
              ExploringCompactionPolicy or RatioBasedCompactionPolicy. It can be enabled for
              existing tables, and the table will continue to operate normally if it is disabled
              later. </p></div><div class="section" title="9.7.7.7.4.&nbsp;When To Use Stripe Compactions"><div class="titlepage"><div><div><h5 class="title"><a name="ops.stripe.when"></a>9.7.7.7.4.&nbsp;When To Use Stripe Compactions</h5></div></div></div><p>Consider using stripe compaction if you have either of the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Large regions. You can get the positive effects of smaller regions without
                  additional overhead for MemStore and region management overhead.</p></li><li class="listitem"><p>Non-uniform keys, such as time dimension in a key. Only the stripes receiving
                  the new keys will need to compact. Old data will not compact as often, if at
                  all</p></li></ul></div><p title="Performance Improvements"><b>Performance Improvements.&nbsp;</b>Performance testing has shown that the performance of reads improves somewhat,
                and variability of performance of reads and writes is greatly reduced. An overall
                long-term performance improvement is seen on large non-uniform-row key regions, such
                as a hash-prefixed timestamp key. These performance gains are the most dramatic on a
                table which is already large. It is possible that the performance improvement might
                extend to region splits.</p><div class="section" title="9.7.7.7.4.1.&nbsp;Enabling Stripe Compaction"><div class="titlepage"><div><div><h6 class="title"><a name="ops.stripe.enable"></a>9.7.7.7.4.1.&nbsp;Enabling Stripe Compaction</h6></div></div></div><p>You can enable stripe compaction for a table or a column family, by setting its
                  <code class="varname">hbase.hstore.engine.class</code> to
                  <code class="varname">org.apache.hadoop.hbase.regionserver.StripeStoreEngine</code>. You
                also need to set the <code class="varname">hbase.hstore.blockingStoreFiles</code> to a high
                number, such as 100 (rather than the default value of 10).</p><div class="procedure" title="Procedure&nbsp;9.4.&nbsp;Enable Stripe Compaction"><a name="d2875e12322"></a><p class="title"><b>Procedure&nbsp;9.4.&nbsp;Enable Stripe Compaction</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>If the table already exists, disable the table.</p></li><li class="step" title="Step 2"><p>Run one of following commands in the HBase shell. Replace the table name
                      <code class="literal">orders_table</code> with the name of your table.</p><pre class="screen">
<strong class="userinput"><code>alter 'orders_table', CONFIGURATION =&gt; {'hbase.hstore.engine.class' =&gt; 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' =&gt; '100'}</code></strong>
<strong class="userinput"><code>alter 'orders_table', {NAME =&gt; 'blobs_cf', CONFIGURATION =&gt; {'hbase.hstore.engine.class' =&gt; 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' =&gt; '100'}}</code></strong>
<strong class="userinput"><code>create 'orders_table', 'blobs_cf', CONFIGURATION =&gt; {'hbase.hstore.engine.class' =&gt; 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' =&gt; '100'}</code></strong>                  
                </pre></li><li class="step" title="Step 3"><p>Configure other options if needed. See <a class="xref" href="#ops.stripe.config" title="9.7.7.7.4.2.&nbsp;Configuring Stripe Compaction">Section&nbsp;9.7.7.7.4.2, &#8220;Configuring Stripe Compaction&#8221;</a> for more information.</p></li><li class="step" title="Step 4"><p>Enable the table.</p></li></ol></div><div class="procedure" title="Procedure&nbsp;9.5.&nbsp;Disable Stripe Compaction"><a name="d2875e12353"></a><p class="title"><b>Procedure&nbsp;9.5.&nbsp;Disable Stripe Compaction</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Disable the table.</p></li><li class="step" title="Step 2"><p>Set the <code class="varname">hbase.hstore.engine.class</code> option to either nil or
                      <code class="literal">org.apache.hadoop.hbase.regionserver.DefaultStoreEngine</code>.
                    Either option has the same effect.</p><pre class="screen">
<strong class="userinput"><code>alter 'orders_table', CONFIGURATION =&gt; {'hbase.hstore.engine.class' =&gt; ''}</code></strong>
                </pre></li><li class="step" title="Step 3"><p>Enable the table.</p></li></ol></div><p> When you enable a large table after changing the store engine either way, a
                major compaction will likely be performed on most regions. This is not necessary on
                new tables.</p></div><div class="section" title="9.7.7.7.4.2.&nbsp;Configuring Stripe Compaction"><div class="titlepage"><div><div><h6 class="title"><a name="ops.stripe.config"></a>9.7.7.7.4.2.&nbsp;Configuring Stripe Compaction</h6></div></div></div><p>Each of the settings for stripe compaction should be configured at the table or
                column family, after disabling the table. If you use HBase shell, the general
                command pattern is as follows:</p><pre class="programlisting">
alter 'orders_table', CONFIGURATION =&gt; {'key' =&gt; 'value', ..., 'key' =&gt; 'value'}}
              </pre><div class="section" title="9.7.7.7.4.2.1.&nbsp;Region and stripe sizing"><div class="titlepage"><div><div><h6 class="title"><a name="ops.stripe.config.sizing"></a>9.7.7.7.4.2.1.&nbsp;Region and stripe sizing</h6></div></div></div><p>You can configure your stripe sizing bsaed upon your region sizing. By
                  default, your new regions will start with one stripe. On the next compaction after
                  the stripe has grown too large (16 x MemStore flushes size), it is split into two
                  stripes. Stripe splitting continues as the region grows, until the region is large
                  enough to split.</p><p>You can improve this pattern for your own data. A good rule is to aim for a
                  stripe size of at least 1 GB, and about 8-12 stripes for uniform row keys. For
                  example, if your regions are 30 GB, 12 x 2.5 GB stripes might be a good starting
                  point.</p><div class="table"><a name="d2875e12392"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;Stripe Sizing Settings</b></p><div class="table-contents"><table summary="Stripe Sizing Settings" border="1"><colgroup><col align="left" class="c1"><col align="left" class="c2"></colgroup><thead><tr><th align="left">Setting</th><th align="left">Notes</th></tr></thead><tbody><tr><td align="left">
                          <code class="varname">hbase.store.stripe.initialStripeCount</code>
                        </td><td align="left">
                          <p>The number of stripes to create when stripe compaction is enabled.
                            You can use it as follows: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>For relatively uniform row keys, if you know the approximate
                                target number of stripes from the above, you can avoid some
                                splitting overhead by starting with several stripes (2, 5, 10...).
                                If the early data is not representative of overall row key
                                distribution, this will not be as efficient.</p></li><li class="listitem"><p>For existing tables with a large amount of data, this setting
                                will effectively pre-split your stripes.</p></li><li class="listitem"><p>For keys such as hash-prefixed sequential keys, with more than
                                one hash prefix per region, pre-splitting may make sense. </p></li></ul></div>
                        </td></tr><tr><td align="left">
                          <code class="varname">hbase.store.stripe.sizeToSplit</code>
                        </td><td align="left">The maximum size a stripe grows before splitting. Use this in
                          conjunction with <code class="varname">hbase.store.stripe.splitPartCount</code> to
                          control the target stripe size (sizeToSplit = splitPartsCount * target
                          stripe size), according to the above sizing considerations. </td></tr><tr><td align="left">
                          <code class="varname">hbase.store.stripe.splitPartCount</code>
                        </td><td align="left">The number of new stripes to create when splitting a stripe. The
                          default is 2, which is appropriate for most cases. For non-uniform row
                          keys, you can experiment with increasing the number to 3 or 4, to isolate
                          the arriving updates into narrower slice of the region without additional
                          splits being required.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="9.7.7.7.4.2.2.&nbsp;MemStore Size Settings"><div class="titlepage"><div><div><h6 class="title"><a name="ops.stripe.config.memstore"></a>9.7.7.7.4.2.2.&nbsp;MemStore Size Settings</h6></div></div></div><p> By default, the flush creates several files from one MemStore, according to
                  existing stripe boundaries and row keys to flush. This approach minimizes write
                  amplification, but can be undesirable if the MemStore is small and there are many
                  stripes, because the files will be too small. </p><p>In this type of situation, you can set
                    <code class="varname">hbase.store.stripe.compaction.flushToL0</code> to
                    <code class="literal">true</code>. This will cause a MemStore flush to create a single
                  file instead. When at least
                    <code class="varname">hbase.store.stripe.compaction.minFilesL0</code> such files (by
                  default, 4) accumulate, they will be compacted into striped files.</p></div><div class="section" title="9.7.7.7.4.2.3.&nbsp;Normal Compaction Configuration and Stripe Compaction"><div class="titlepage"><div><div><h6 class="title"><a name="ops.stripe.config.compact"></a>9.7.7.7.4.2.3.&nbsp;Normal Compaction Configuration and Stripe Compaction</h6></div></div></div><p> All the settings that apply to normal compactions (see <a class="xref" href="#">???</a>) apply to stripe compactions.
                  The exceptions are the minimum and maximum number of files, which are set to
                  higher values by default because the files in stripes are smaller. To control
                  these for stripe compactions, use
                    <code class="varname">hbase.store.stripe.compaction.minFiles</code> and
                    <code class="varname">hbase.store.stripe.compaction.maxFiles</code>, rather than
                    <code class="varname">hbase.hstore.compaction.min</code> and
                    <code class="varname">hbase.hstore.compaction.max</code>. </p></div></div></div></div></div></div><div class="section" title="9.8.&nbsp;Bulk Loading"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch.bulk.load"></a>9.8.&nbsp;Bulk Loading</h2></div></div></div><div class="section" title="9.8.1.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="arch.bulk.load.overview"></a>9.8.1.&nbsp;Overview</h3></div></div></div><p>
        HBase includes several methods of loading data into tables.
        The most straightforward method is to either use the <code class="code">TableOutputFormat</code>
        class from a MapReduce job, or use the normal client APIs; however,
        these are not always the most efficient methods.
      </p><p>
        The bulk load feature uses a MapReduce job to output table data in HBase's internal
        data format, and then directly loads the generated StoreFiles into a running
        cluster. Using bulk load will use less CPU and network resources than
        simply using the HBase API.
      </p></div><div class="section" title="9.8.2.&nbsp;Bulk Load Limitations"><div class="titlepage"><div><div><h3 class="title"><a name="arch.bulk.load.limitations"></a>9.8.2.&nbsp;Bulk Load Limitations</h3></div></div></div><p>As bulk loading bypasses the write path, the WAL doesn&#8217;t get written to as part of the process.
            Replication works by reading the WAL files so it won&#8217;t see the bulk loaded data &#8211; and the same goes for the edits that use Put.setWriteToWAL(true).
            One way to handle that is to ship the raw files or the HFiles to the other cluster and do the other processing there.</p></div><div class="section" title="9.8.3.&nbsp;Bulk Load Architecture"><div class="titlepage"><div><div><h3 class="title"><a name="arch.bulk.load.arch"></a>9.8.3.&nbsp;Bulk Load Architecture</h3></div></div></div><p>
        The HBase bulk load process consists of two main steps.
      </p><div class="section" title="9.8.3.1.&nbsp;Preparing data via a MapReduce job"><div class="titlepage"><div><div><h4 class="title"><a name="arch.bulk.load.prep"></a>9.8.3.1.&nbsp;Preparing data via a MapReduce job</h4></div></div></div><p>
          The first step of a bulk load is to generate HBase data files (StoreFiles) from
          a MapReduce job using <code class="code">HFileOutputFormat</code>. This output format writes
          out data in HBase's internal storage format so that they can be
          later loaded very efficiently into the cluster.
        </p><p>
          In order to function efficiently, <code class="code">HFileOutputFormat</code> must be
          configured such that each output HFile fits within a single region.
          In order to do this, jobs whose output will be bulk loaded into HBase
          use Hadoop's <code class="code">TotalOrderPartitioner</code> class to partition the map output
          into disjoint ranges of the key space, corresponding to the key
          ranges of the regions in the table.
        </p><p>
          <code class="code">HFileOutputFormat</code> includes a convenience function,
          <code class="code">configureIncrementalLoad()</code>, which automatically sets up
          a <code class="code">TotalOrderPartitioner</code> based on the current region boundaries of a
          table.
        </p></div><div class="section" title="9.8.3.2.&nbsp;Completing the data load"><div class="titlepage"><div><div><h4 class="title"><a name="arch.bulk.load.complete"></a>9.8.3.2.&nbsp;Completing the data load</h4></div></div></div><p>
          After the data has been prepared using
          <code class="code">HFileOutputFormat</code>, it is loaded into the cluster using
          <code class="code">completebulkload</code>. This command line tool iterates
          through the prepared data files, and for each one determines the
          region the file belongs to. It then contacts the appropriate Region
          Server which adopts the HFile, moving it into its storage directory
          and making the data available to clients.
        </p><p>
          If the region boundaries have changed during the course of bulk load
          preparation, or between the preparation and completion steps, the
          <code class="code">completebulkloads</code> utility will automatically split the
          data files into pieces corresponding to the new boundaries. This
          process is not optimally efficient, so users should take care to
          minimize the delay between preparing a bulk load and importing it
          into the cluster, especially if other clients are simultaneously
          loading data through other means.
        </p></div></div><div class="section" title="9.8.4.&nbsp;Importing the prepared data using the completebulkload tool"><div class="titlepage"><div><div><h3 class="title"><a name="arch.bulk.load.import"></a>9.8.4.&nbsp;Importing the prepared data using the completebulkload tool</h3></div></div></div><p>
        After a data import has been prepared, either by using the
        <code class="code">importtsv</code> tool with the
        "<code class="code">importtsv.bulk.output</code>" option or by some other MapReduce
        job using the <code class="code">HFileOutputFormat</code>, the
        <code class="code">completebulkload</code> tool is used to import the data into the
        running cluster.
      </p><p>
        The <code class="code">completebulkload</code> tool simply takes the output path
        where <code class="code">importtsv</code> or your MapReduce job put its results, and
        the table name to import into. For example:
      </p><pre class="screen">$ hadoop jar hbase-server-VERSION.jar completebulkload [-c /path/to/hbase/config/hbase-site.xml] /user/todd/myoutput mytable</pre><p>
        The <code class="code">-c config-file</code> option can be used to specify a file
        containing the appropriate hbase parameters (e.g., hbase-site.xml) if
        not supplied already on the CLASSPATH (In addition, the CLASSPATH must
        contain the directory that has the zookeeper configuration file if
        zookeeper is NOT managed by HBase).
      </p><p>
        Note: If the target table does not already exist in HBase, this
        tool will create the table automatically.</p><p>
        This tool will run quickly, after which point the new data will be visible in
        the cluster.
      </p></div><div class="section" title="9.8.5.&nbsp;See Also"><div class="titlepage"><div><div><h3 class="title"><a name="arch.bulk.load.also"></a>9.8.5.&nbsp;See Also</h3></div></div></div><p>For more information about the referenced utilities, see <a class="xref" href="#importtsv" title="17.1.11.&nbsp;ImportTsv">Section&nbsp;17.1.11, &#8220;ImportTsv&#8221;</a> and  <a class="xref" href="#completebulkload" title="17.1.12.&nbsp;CompleteBulkLoad">Section&nbsp;17.1.12, &#8220;CompleteBulkLoad&#8221;</a>.
      </p><p>
          See <a class="link" href="http://blog.cloudera.com/blog/2013/09/how-to-use-hbase-bulk-loading-and-why/" target="_top">How-to: Use HBase Bulk Loading, and Why</a>
          for a recent blog on current state of bulk loading.
      </p></div><div class="section" title="9.8.6.&nbsp;Advanced Usage"><div class="titlepage"><div><div><h3 class="title"><a name="arch.bulk.load.adv"></a>9.8.6.&nbsp;Advanced Usage</h3></div></div></div><p>
        Although the <code class="code">importtsv</code> tool is useful in many cases, advanced users may
        want to generate data programatically, or import data from other formats. To get
        started doing so, dig into <code class="code">ImportTsv.java</code> and check the JavaDoc for
        HFileOutputFormat.
      </p><p>
        The import step of the bulk load can also be done programatically. See the
        <code class="code">LoadIncrementalHFiles</code> class for more information.
      </p></div></div><div class="section" title="9.9.&nbsp;HDFS"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch.hdfs"></a>9.9.&nbsp;HDFS</h2></div></div></div><p>As HBase runs on HDFS (and each StoreFile is written as a file on HDFS),
        it is important to have an understanding of the HDFS Architecture
         especially in terms of how it stores files, handles failovers, and replicates blocks.
       </p><p>See the Hadoop documentation on <a class="link" href="http://hadoop.apache.org/common/docs/current/hdfs_design.html" target="_top">HDFS Architecture</a>
       for more information.
       </p><div class="section" title="9.9.1.&nbsp;NameNode"><div class="titlepage"><div><div><h3 class="title"><a name="arch.hdfs.nn"></a>9.9.1.&nbsp;NameNode</h3></div></div></div><p>The NameNode is responsible for maintaining the filesystem metadata.  See the above HDFS Architecture link
         for more information.
         </p></div><div class="section" title="9.9.2.&nbsp;DataNode"><div class="titlepage"><div><div><h3 class="title"><a name="arch.hdfs.dn"></a>9.9.2.&nbsp;DataNode</h3></div></div></div><p>The DataNodes are responsible for storing HDFS blocks.  See the above HDFS Architecture link
         for more information.
         </p></div></div><div class="section" title="9.10.&nbsp;Timeline-consistent High Available Reads"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="arch.timelineconsistent.reads"></a>9.10.&nbsp;Timeline-consistent High Available Reads</h2></div></div></div><div class="section" title="9.10.1.&nbsp;Introduction"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.timelineconsistent.intro"></a>9.10.1.&nbsp;Introduction</h3></div></div></div><p> 
			HBase, architecturally, always had the strong consistency guarantee from the start. All reads and writes are routed through a single region server, which guarantees that all writes happen in an order, and all reads are seeing the most recent committed data. 
	          </p><p>
			However, because of this single homing of the reads to a single location, if the server becomes unavailable, the regions of the table that were hosted in the region server become unavailable for some time. There are three phases in the region recovery process - detection, assignment, and recovery. Of these, the detection is usually the longest and is presently in the order of 20-30 seconds depending on the zookeeper session timeout. During this time and before the recovery is complete, the clients will not be able to read the region data.
	          </p><p>
			However, for some use cases, either the data may be read-only, or doing reads againsts some stale data is acceptable. With timeline-consistent high available reads, HBase can be used for these kind of latency-sensitive use cases where the application can expect to have a time bound on the read completion. 
	          </p><p>
			For achieving high availability for reads, HBase provides a feature called &#8220;region replication&#8221;. In this model, for each region of a table, there will be multiple replicas that are opened in different region servers. By default, the region replication is set to 1, so only a single region replica is deployed and there will not be any changes from the original model. If region replication is set to 2 or more, than the master will assign replicas of the regions of the table. The Load Balancer ensures that the region replicas are not co-hosted in the same region servers and also in the same rack (if possible). 
	          </p><p>
			All of the replicas for a single region will have a unique replica_id, starting from 0. The region replica having replica_id==0 is called the primary region, and the others &#8220;secondary regions&#8221; or secondaries. Only the primary can accept writes from the client, and the primary will always contain the latest changes. Since all writes still have to go through the primary region, the writes are not highly-available (meaning they might block for some time if the region becomes unavailable). 
	          </p><p>
			The writes are asynchronously sent to the secondary region replicas using an &#8220;Async WAL replication&#8221; feature. This works similarly to HBase&#8217;s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. This ensures that the secondaries won&#8217;t diverge from the primary regions data, but since the log replication is asnyc, the data might be stale in secondary regions. In some sense, this design can be thought of as &#8220;in-cluster replication&#8221;, where instead of replicating to a different datacenter, the data goes to a secondary region to keep secondary region&#8217;s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. 
	         </p><p>
	Async WAL replication feature is being implemented in Phase 2 of issue HBASE-10070. Before this, region replicas will only be updated with flushed data files from the primary (see hbase.regionserver.storefile.refresh.period below). It is also possible to use this without setting storefile.refresh.period for read only tables. 
		     </p></div><div class="section" title="9.10.2.&nbsp;Timeline Consistency"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12656"></a>9.10.2.&nbsp;Timeline Consistency </h3></div></div></div><p>
			With this feature, HBase introduces a Consistency definition, which can be provided per read operation (get or scan).
	</p><pre class="programlisting">
public enum Consistency {
    STRONG,
    TIMELINE
}
	</pre><p>
			<code class="code">Consistency.STRONG</code> is the default consistency model provided by HBase. In case the table has region replication = 1, or in a table with region replicas but the reads are done with this consistency, the read is always performed by the primary regions, so that there will not be any change from the previous behaviour, and the client always observes the latest data. 
	          </p><p>
			In case a read is performed with <code class="code">Consistency.TIMELINE</code>, then the read RPC will be sent to the primary region server first. After a short interval (<code class="code">hbase.client.primaryCallTimeout.get</code>, 10ms by default), parallel RPC for secondary region replicas will also be sent if the primary does not respond back. After this, the result is returned from whichever RPC is finished first. If the response came back from the primary region replica, we can always know that the data is latest. For this Result.isStale() API has been added to inspect the staleness. If the result is from a secondary region, then Result.isStale() will be set to true. The user can then inspect this field to possibly reason about the data. 
	          </p><p>
			In terms of semantics, TIMELINE consistency as implemented by HBase differs from pure eventual
			consistency in these respects: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p> Single homed and ordered updates: Region replication or not, on the write side,
                there is still only 1 defined replica (primary) which can accept writes. This
                replica is responsible for ordering the edits and preventing conflicts. This
                guarantees that two different writes are not committed at the same time by different
                replicas and the data diverges. With this, there is no need to do read-repair or
                last-timestamp-wins kind of conflict resolution. </p></li><li class="listitem"><p> The secondaries also apply the edits in the order that the primary committed
                them. This way the secondaries will contain a snapshot of the primaries data at any
                point in time. This is similar to RDBMS replications and even HBase&#8217;s own
                multi-datacenter replication, however in a single cluster. </p></li><li class="listitem"><p> On the read side, the client can detect whether the read is coming from
                up-to-date data or is stale data. Also, the client can issue reads with different
                consistency requirements on a per-operation basis to ensure its own semantic
                guarantees. </p></li><li class="listitem"><p> The client can still observe edits out-of-order, and can go back in time, if it
                observes reads from one secondary replica first, then another secondary replica.
                There is no stickiness to region replicas or a transaction-id based guarantee. If
                required, this can be implemented later though. </p></li></ul></div><div class="figure"><a name="d2875e12690"></a><p class="title"><b>Figure&nbsp;9.2.&nbsp;HFile Version 1</b></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td align="center" valign="middle"><img src="images/timeline_consistency.png" align="middle" alt="HFile Version 1"></td></tr></table></div></div></div><br class="figure-break"><p>
			To better understand the TIMELINE semantics, lets look at the above diagram. Lets say that there are two clients, and the first one writes x=1 at first, then x=2 and x=3 later. As above, all writes are handled by the primary region replica. The writes are saved in the write ahead log (WAL), and replicated to the other replicas asynchronously. In the above diagram, notice that replica_id=1 received 2 updates, and it&#8217;s data shows that x=2, while the replica_id=2 only received a single update, and its data shows that x=1. 
		</p><p>
			If client1 reads with STRONG consistency, it will only talk with the replica_id=0, and thus is guaranteed to observe the latest value of x=3. In case of a client issuing TIMELINE consistency reads, the RPC will go to all replicas (after primary timeout) and the result from the first response will be returned back. Thus the client can see either 1, 2 or 3 as the value of x. Let&#8217;s say that the primary region has failed and log replication cannot continue for some time. If the client does multiple reads with TIMELINE consistency, she can observe x=2 first, then x=1, and so on. 

		</p></div><div class="section" title="9.10.3.&nbsp;Tradeoffs"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12703"></a>9.10.3.&nbsp;Tradeoffs</h3></div></div></div><p> Having secondary regions hosted for read availability comes with some tradeoffs which
          should be carefully evaluated per use case. Following are advantages and
          disadvantages.</p><div class="itemizedlist" title="Advantages"><p class="title"><b>Advantages</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>High availability for read-only tables.</p></li><li class="listitem"><p>High availability for stale reads</p></li><li class="listitem"><p>Ability to do very low latency reads with very high percentile (99.9%+) latencies
              for stale reads</p></li></ul></div><div class="itemizedlist" title="Disadvantages"><p class="title"><b>Disadvantages</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Double / Triple memstore usage (depending on region replication count) for tables
              with region replication &gt; 1</p></li><li class="listitem"><p>Increased block cache usage</p></li><li class="listitem"><p>Extra network traffic for log replication </p></li><li class="listitem"><p>Extra backup RPCs for replicas</p></li></ul></div><p>To serve the region data from multiple replicas, HBase opens the regions in secondary
          mode in the region servers. The regions opened in secondary mode will share the same data
          files with the primary region replica, however each secondary region replica will have its
          own memstore to keep the unflushed data (only primary region can do flushes). Also to
          serve reads from secondary regions, the blocks of data files may be also cached in the
          block caches for the secondary regions. </p></div><div class="section" title="9.10.4.&nbsp;Configuration properties"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12737"></a>9.10.4.&nbsp;Configuration properties</h3></div></div></div><p>
	To use highly available reads, you should set the following properties in hbase-site.xml file. There is no specific configuration to enable or disable region replicas. Instead you can change the number of region replicas per table to increase or decrease at the table creation or with alter table. 
		</p><div class="section" title="9.10.4.1.&nbsp;Server side properties"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e12742"></a>9.10.4.1.&nbsp;Server side properties</h4></div></div></div><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.regionserver.storefile.refresh.period&lt;/name&gt;
    &lt;value&gt;0&lt;/value&gt;
    &lt;description&gt;
      The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region. But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.
    &lt;/description&gt;
&lt;/property&gt;
</pre><p> One thing to keep in mind also is that, region replica placement policy is only
            enforced by the <code class="code">StochasticLoadBalancer</code> which is the default balancer. If
            you are using a custom load balancer property in hbase-site.xml
              (<code class="code">hbase.master.loadbalancer.class</code>) replicas of regions might end up being
            hosted in the same server.</p></div><div class="section" title="9.10.4.2.&nbsp;Client side properties"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e12755"></a>9.10.4.2.&nbsp;Client side properties</h4></div></div></div><p> Ensure to set the following for all clients (and servers) that will use region
            replicas. </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.ipc.client.allowsInterrupt&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;
      Whether to enable interruption of RPC threads at the client side. This is required for region replicas with fallback RPC&#8217;s to secondary regions.
    &lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.client.primaryCallTimeout.get&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;
      The timeout (in microseconds), before secondary fallback RPC&#8217;s are submitted for get requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC&#8217;s, but will lower the p99 latencies. 
    &lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.client.primaryCallTimeout.multiget&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;
      The timeout (in microseconds), before secondary fallback RPC&#8217;s are submitted for multi-get requests (HTable.get(List&lt;Get&gt;)) with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC&#8217;s, but will lower the p99 latencies. 
    &lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.client.replicaCallTimeout.scan&lt;/name&gt;
    &lt;value&gt;1000000&lt;/value&gt;
    &lt;description&gt;
      The timeout (in microseconds), before secondary fallback RPC&#8217;s are submitted for scan requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 1 sec. Setting this lower will increase the number of RPC&#8217;s, but will lower the p99 latencies. 
    &lt;/description&gt;
&lt;/property&gt;
</pre></div></div><div class="section" title="9.10.5.&nbsp;Creating a table with region replication"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12762"></a>9.10.5.&nbsp;Creating a table with region replication</h3></div></div></div><p>
		Region replication is a per-table property. All tables have REGION_REPLICATION = 1 by default, which means that there is only one replica per region. You can set and change the number of replicas per region of a table by supplying the REGION_REPLICATION property in the table descriptor. 
	    </p><div class="section" title="9.10.5.1.&nbsp;Shell"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e12767"></a>9.10.5.1.&nbsp;Shell</h4></div></div></div><pre class="programlisting">
create 't1', 'f1', {REGION_REPLICATION =&gt; 2}

describe 't1'
for i in 1..100
put 't1', "r#{i}", 'f1:c1', i
end
flush 't1'
</pre></div><div class="section" title="9.10.5.2.&nbsp;Java"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e12772"></a>9.10.5.2.&nbsp;Java</h4></div></div></div><pre class="programlisting">
HTableDescriptor htd = new HTableDesctiptor(TableName.valueOf(&#8220;test_table&#8221;)); 
htd.setRegionReplication(2);
...
admin.createTable(htd); 
</pre><p>You can also use <code class="code">setRegionReplication()</code> and alter table to increase, decrease the
            region replication for a table.</p></div></div><div class="section" title="9.10.6.&nbsp;Region splits and merges"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12782"></a>9.10.6.&nbsp;Region splits and merges</h3></div></div></div><p>Region splits and merges are not compatible with regions with replicas yet. So you
          have to pre-split the table, and disable the region splits. Also you should not execute
          region merges on tables with region replicas. To disable region splits you can use
          DisabledRegionSplitPolicy as the split policy.</p></div><div class="section" title="9.10.7.&nbsp;User Interface"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12787"></a>9.10.7.&nbsp;User Interface</h3></div></div></div><p> In the masters user interface, the region replicas of a table are also shown together
          with the primary regions. You can notice that the replicas of a region will share the same
          start and end keys and the same region name prefix. The only difference would be the
          appended replica_id (which is encoded as hex), and the region encoded name will be
          different. You can also see the replica ids shown explicitly in the UI. </p></div><div class="section" title="9.10.8.&nbsp;API and Usage"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12792"></a>9.10.8.&nbsp;API and Usage</h3></div></div></div><div class="section" title="9.10.8.1.&nbsp;Shell"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e12795"></a>9.10.8.1.&nbsp;Shell</h4></div></div></div><p> You can do reads in shell using a the Consistency.TIMELINE semantics as follows
          </p><pre class="programlisting">
hbase(main):001:0&gt; get 't1','r6', {CONSISTENCY =&gt; "TIMELINE"}
</pre><p> You can simulate a region server pausing or becoming unavailable and do a read from
            the secondary replica: </p><pre class="programlisting">
$ kill -STOP &lt;pid or primary region server&gt;

hbase(main):001:0&gt; get 't1','r6', {CONSISTENCY =&gt; "TIMELINE"}
</pre><p> Using scans is also similar </p><pre class="programlisting">
hbase&gt; scan 't1', {CONSISTENCY =&gt; 'TIMELINE'}
</pre></div><div class="section" title="9.10.8.2.&nbsp;Java"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e12810"></a>9.10.8.2.&nbsp;Java</h4></div></div></div><p>You can set set the consistency for Gets and Scans and do requests as
            follows.</p><pre class="programlisting">
Get get = new Get(row);
get.setConsistency(Consistency.TIMELINE);
...
Result result = table.get(get); 
</pre><p>You can also pass multiple gets: </p><pre class="programlisting">
Get get1 = new Get(row);
get1.setConsistency(Consistency.TIMELINE);
...
ArrayList&lt;Get&gt; gets = new ArrayList&lt;Get&gt;();
gets.add(get1);
...
Result[] results = table.get(gets); 
</pre><p>And Scans: </p><pre class="programlisting">
Scan scan = new Scan();
scan.setConsistency(Consistency.TIMELINE);
...
ResultScanner scanner = table.getScanner(scan);
</pre><p>You can inspect whether the results are coming from primary region or not by calling
            the Result.isStale() method: </p><pre class="programlisting">
Result result = table.get(get); 
if (result.isStale()) {
  ...
}
</pre></div></div><div class="section" title="9.10.9.&nbsp;Resources"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e12829"></a>9.10.9.&nbsp;Resources</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>More information about the design and implementation can be found at the jira
              issue: <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10070" target="_top">HBASE-10070</a></p></li><li class="listitem"><p>HBaseCon 2014 <a class="link" href="http://hbasecon.com/sessions/#session15" target="_top">talk</a> also contains some
              details and <a class="link" href="http://www.slideshare.net/enissoz/hbase-high-availability-for-reads-with-time" target="_top">slides</a>.</p></li></ol></div></div></div></div><div class="chapter" title="Chapter&nbsp;10.&nbsp;Apache HBase APIs"><div class="titlepage"><div><div><h2 class="title"><a name="hbase_apis"></a>Chapter&nbsp;10.&nbsp;Apache HBase APIs</h2></div></div></div><p>This chapter provides information about performing operations using HBase native APIs. This
    information is not exhaustive, and provides a quick reference in addition to the <a class="link" href="http://hbase.apache.org/apidocs/index.html" target="_top">User API
    Reference</a>. The examples here are not comprehensive or complete, and should be used for
    purposes of illustration only.</p><p>Apache HBase also works with multiple external APIs. See <a class="xref" href="#external_apis" title="Chapter&nbsp;11.&nbsp;Apache HBase External APIs">Chapter&nbsp;11, <i>Apache HBase External APIs</i></a>
    for more information.</p><div class="example"><a name="d2875e12861"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;Create a Table Using Java</b></p><div class="example-contents"><p>This example has been tested on HBase 0.96.1.1.</p><pre class="programlisting">
package com.example.hbase.admin;

import java.io.IOException;

import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.HColumnDescriptor;
import org.apache.hadoop.hbase.HTableDescriptor;
import org.apache.hadoop.hbase.TableName;
import org.apache.hadoop.hbase.client.HBaseAdmin;
import org.apache.hadoop.hbase.io.compress.Compression.Algorithm;
import org.apache.hadoop.conf.Configuration;

import static com.example.hbase.Constants.*;

public class CreateSchema {

 public static void createOrOverwrite(HBaseAdmin admin, HTableDescriptor table) throws IOException {
    if (admin.tableExists(table.getName())) {
      admin.disableTable(table.getName());
      admin.deleteTable(table.getName());
    }
    admin.createTable(table);
  }

  public static void createSchemaTables (Configuration config) {
    try {
      final HBaseAdmin admin = new HBaseAdmin(config);
      HTableDescriptor table = new HTableDescriptor(TableName.valueOf(TABLE_NAME));
      table.addFamily(new HColumnDescriptor(CF_DEFAULT).setCompressionType(Algorithm.SNAPPY));

      System.out.print("Creating table. ");
      createOrOverwrite(admin, table);
      System.out.println(" Done.");

      admin.close();
    } catch (Exception e) {
      e.printStackTrace();
      System.exit(-1);
    }
  }


}      
      
    </pre></div></div><br class="example-break"><div class="example"><a name="d2875e12868"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;Add, Modify, and Delete a Table</b></p><div class="example-contents"><p>This example has been tested on HBase 0.96.1.1.</p><pre class="programlisting">
public static void upgradeFrom0 (Configuration config) {

    try {
      final HBaseAdmin admin = new HBaseAdmin(config);
      TableName tableName = TableName.valueOf(TABLE_ASSETMETA);
      HTableDescriptor table_assetmeta = new HTableDescriptor(tableName);
      table_assetmeta.addFamily(new HColumnDescriptor(CF_DEFAULT).setCompressionType(Algorithm.SNAPPY));

      // Create a new table.

      System.out.print("Creating table_assetmeta. ");
      admin.createTable(table_assetmeta);
      System.out.println(" Done.");

      // Update existing table
      HColumnDescriptor newColumn = new HColumnDescriptor("NEWCF");
      newColumn.setCompactionCompressionType(Algorithm.GZ);
      newColumn.setMaxVersions(HConstants.ALL_VERSIONS);
      admin.addColumn(tableName, newColumn);

      // Disable an existing table
      admin.disableTable(tableName);

      // Delete an existing column family
      admin.deleteColumn(tableName, CF_DEFAULT);

      // Delete a table (Need to be disabled first)
      admin.deleteTable(tableName);


      admin.close();
    } catch (Exception e) {
      e.printStackTrace();
      System.exit(-1);
    }
  }      
    </pre></div></div><br class="example-break"></div><div class="chapter" title="Chapter&nbsp;11.&nbsp;Apache HBase External APIs"><div class="titlepage"><div><div><h2 class="title"><a name="external_apis"></a>Chapter&nbsp;11.&nbsp;Apache HBase External APIs</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#nonjava.jvm">11.1. Non-Java Languages Talking to the JVM</a></span></dt><dt><span class="section"><a href="#rest">11.2. REST</a></span></dt><dt><span class="section"><a href="#d2875e12924">11.3. Thrift</a></span></dt><dt><span class="section"><a href="#c">11.4. C/C++ Apache HBase Client</a></span></dt></dl></div><p> This chapter will cover access to Apache HBase either through non-Java languages, or
    through custom protocols. For information on using the native HBase APIs, refer to <a class="link" href="http://hbase.apache.org/apidocs/index.html" target="_top">User API Reference</a> and the new <a class="xref" href="#hbase_apis" title="Chapter&nbsp;10.&nbsp;Apache HBase APIs">Chapter&nbsp;10, <i>Apache HBase APIs</i></a> chapter. </p><div class="section" title="11.1.&nbsp;Non-Java Languages Talking to the JVM"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="nonjava.jvm"></a>11.1.&nbsp;Non-Java Languages Talking to the JVM</h2></div></div></div><p>Currently the documentation on this topic in the
      <a class="link" href="http://wiki.apache.org/hadoop/Hbase" target="_top">Apache HBase Wiki</a>.
      See also the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/thrift/package-summary.html#package_description" target="_top">Thrift API Javadoc</a>.
    </p></div><div class="section" title="11.2.&nbsp;REST"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest"></a>11.2.&nbsp;REST</h2></div></div></div><p>Currently most of the documentation on REST exists in the
        <a class="link" href="http://wiki.apache.org/hadoop/Hbase/Stargate" target="_top">Apache HBase Wiki on REST</a> (The REST gateway used to be
        called 'Stargate').  There are also a nice set of blogs on <a class="link" href="http://blog.cloudera.com/blog/2013/03/how-to-use-the-apache-hbase-rest-interface-part-1/" target="_top">How-to: Use the Apache HBase REST Interface</a>
        by Jesse Anderson.
    </p><p>
    To run your REST server under SSL, set hbase.rest.ssl.enabled to true and also set the
    following configs when you launch the REST server:(See example commands in
    <a class="xref" href="#JMX_config" title="2.6.3.5.&nbsp;JMX">Section&nbsp;2.6.3.5, &#8220;JMX&#8221;</a>)
</p><pre class="programlisting">
hbase.rest.ssl.keystore.store
hbase.rest.ssl.keystore.password
hbase.rest.ssl.keystore.keypassword</pre><p>
    </p><p>
    HBase ships a simple REST client, see <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/rest/client/package-summary.html" target="_top">REST client</a> package for details.
    To enable SSL support for it, please also import your certificate into local java
    cacerts keystore:
    </p><pre class="screen">keytool -import -trustcacerts -file /home/user/restserver.cert -keystore $JAVA_HOME/jre/lib/security/cacerts</pre><p>
    </p></div><div class="section" title="11.3.&nbsp;Thrift"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e12924"></a>11.3.&nbsp;Thrift</h2></div></div></div><p>Documentation about Thrift has moved to <a class="xref" href="#thrift" title="Chapter&nbsp;12.&nbsp;Thrift API and Filter Language">Chapter&nbsp;12, <i>Thrift API and Filter Language</i></a>.</p></div><div class="section" title="11.4.&nbsp;C/C++ Apache HBase Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="c"></a>11.4.&nbsp;C/C++ Apache HBase Client</h2></div></div></div><p>FB's Chip Turner wrote a pure C/C++ client.  <a class="link" href="https://github.com/facebook/native-cpp-hbase-client" target="_top">Check it out</a>.
    </p></div></div><div class="chapter" title="Chapter&nbsp;12.&nbsp;Thrift API and Filter Language"><div class="titlepage"><div><div><h2 class="title"><a name="thrift"></a>Chapter&nbsp;12.&nbsp;Thrift API and Filter Language</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#thrift.filter-language">12.1. Filter Language</a></span></dt><dd><dl><dt><span class="section"><a href="#general-syntax">12.1.1. General Filter String Syntax</a></span></dt><dt><span class="section"><a href="#compound-filters-and-operators">12.1.2. Compound Filters and Operators</a></span></dt><dt><span class="section"><a href="#order-of-evaluation">12.1.3. Order of Evaluation</a></span></dt><dt><span class="section"><a href="#compare-operator">12.1.4. Compare Operator</a></span></dt><dt><span class="section"><a href="#comparator">12.1.5. Comparator</a></span></dt><dt><span class="section"><a href="#examplePHPClientProgram">12.1.6. Example PHP Client Program that uses the Filter Language</a></span></dt><dt><span class="section"><a href="#example-filter-strings">12.1.7. Example Filter Strings</a></span></dt><dt><span class="section"><a href="#IndividualFilterSyntax">12.1.8. Individual Filter Syntax</a></span></dt></dl></dd></dl></div><p>Apache <a class="link" href="http://thrift.apache.org/" target="_top">Thrift</a> is a cross-platform,
        cross-language development framework. HBase includes a Thrift API and filter language. The
        Thrift API relies on client and server processes. Documentation about the HBase Thrift API
        is located at <a class="link" href="http://wiki.apache.org/hadoop/Hbase/ThriftApi" target="_top">http://wiki.apache.org/hadoop/Hbase/ThriftApi</a>. </p><p>You can configure Thrift for secure authentication at the server and client side, by
        following the procedures in <a class="xref" href="#security.client.thrift" title="8.1.4.&nbsp;Client-side Configuration for Secure Operation - Thrift Gateway">Section&nbsp;8.1.4, &#8220;Client-side Configuration for Secure Operation - Thrift Gateway&#8221;</a> and <a class="xref" href="#security.gateway.thrift" title="8.1.5.&nbsp;Configure the Thrift Gateway to Authenticate on Behalf of the Client">Section&nbsp;8.1.5, &#8220;Configure the Thrift Gateway to Authenticate on Behalf of the Client&#8221;</a>. </p><p>The rest of this chapter discusses the filter language provided by the Thrift API.</p><div class="section" title="12.1.&nbsp;Filter Language"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="thrift.filter-language"></a>12.1.&nbsp;Filter Language</h2></div></div></div><p><a name="use-case"></a>Thrift Filter Language was introduced in APache HBase 0.92. It allows
            you to perform server-side filtering when accessing HBase over Thrift or in the HBase
            shell. You can find out more about shell integration by using the <code class="code">scan help</code>
            command in the shell.</p><p>You specify a filter as a string, which is parsed on the server to construct the
            filter.</p><div class="section" title="12.1.1.&nbsp;General Filter String Syntax"><div class="titlepage"><div><div><h3 class="title"><a name="general-syntax"></a>12.1.1.&nbsp;General Filter String Syntax</h3></div></div></div><p>A simple filter expression is expressed as a string:</p><pre class="screen">&#8220;FilterName (argument, argument,... , argument)&#8221;</pre><p>Keep the following syntax guidelines in mind.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Specify the name of the filter followed by the comma-separated argument
                        list in parentheses.</p></li><li class="listitem"><p>If the argument represents a string, it should be enclosed in single
                        quotes (<code class="literal">'</code>).</p></li><li class="listitem"><p>Arguments which represent a boolean, an integer, or a comparison operator
                        (such as &lt;, &gt;, or !=), should not be enclosed in quotes</p></li><li class="listitem"><p>The filter name must be a single word. All ASCII characters are allowed
                        except for whitespace, single quotes and parentheses.</p></li><li class="listitem"><p>The filter&#8217;s arguments can contain any ASCII character. If single quotes
                        are present in the argument, they must be escaped by an additional preceding
                        single quote.</p></li></ul></div></div><div class="section" title="12.1.2.&nbsp;Compound Filters and Operators"><div class="titlepage"><div><div><h3 class="title"><a name="compound-filters-and-operators"></a>12.1.2.&nbsp;Compound Filters and Operators</h3></div></div></div><div class="variablelist" title="Binary Operators"><p class="title"><b>Binary Operators</b></p><dl><dt><span class="term"><code class="code">AND</code></span></dt><dd><p>If the <code class="code">AND</code> operator is used, the key-vallue
                        must satisfy both the filters.</p></dd><dt><span class="term"><code class="code">OR</code></span></dt><dd><p>If the <code class="code">OR</code> operator is used, the key-value
                        must satisfy at least one of the filters.</p></dd></dl></div><div class="variablelist" title="Unary Operators"><p class="title"><b>Unary Operators</b></p><dl><dt><span class="term"><code class="code">SKIP</code></span></dt><dd><p>For a particular row, if any of the key-values fail the
                        filter condition, the entire row is skipped.</p></dd><dt><span class="term"><code class="code">WHILE</code></span></dt><dd><p>For a particular row, key-values will be emitted until a
                        key-value is reached t hat fails the filter condition.</p></dd></dl></div><div class="example"><a name="d2875e13040"></a><p class="title"><b>Example&nbsp;12.1.&nbsp;Compound Operators</b></p><div class="example-contents"><p>You can combine multiple operators to create a hierarchy of filters, such as
                    the following example:</p><pre class="programlisting">(Filter1 AND Filter2) OR (Filter3 AND Filter4)</pre></div></div><br class="example-break"></div><div class="section" title="12.1.3.&nbsp;Order of Evaluation"><div class="titlepage"><div><div><h3 class="title"><a name="order-of-evaluation"></a>12.1.3.&nbsp;Order of Evaluation</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Parentheses have the highest precedence.</p></li><li class="listitem"><p>The unary operators <code class="code">SKIP</code> and <code class="code">WHILE</code> are next, and have the same
                precedence.</p></li><li class="listitem"><p>The binary operators follow. <code class="code">AND</code> has highest
                    precedence, followed by <code class="code">OR</code>.</p></li></ol></div><div class="example"><a name="d2875e13072"></a><p class="title"><b>Example&nbsp;12.2.&nbsp;Precedence Example</b></p><div class="example-contents"><pre class="programlisting"><strong class="userinput"><code>Filter1 AND Filter2 OR Filter</code></strong>
is evaluated as
<strong class="userinput"><code>(Filter1 AND Filter2) OR Filter3</code></strong></pre><pre class="programlisting"><strong class="userinput"><code>Filter1 AND SKIP Filter2 OR Filter3</code></strong>
is evaluated as
<strong class="userinput"><code>(Filter1 AND (SKIP Filter2)) OR Filter3</code></strong></pre></div></div><br class="example-break"><p>You can use parentheses to explicitly control the order of evaluation.</p></div><div class="section" title="12.1.4.&nbsp;Compare Operator"><div class="titlepage"><div><div><h3 class="title"><a name="compare-operator"></a>12.1.4.&nbsp;Compare Operator</h3></div></div></div><p>The following compare operators are provided:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>LESS (&lt;)</p></li><li class="listitem"><p>LESS_OR_EQUAL (&lt;=)</p></li><li class="listitem"><p>EQUAL (=)</p></li><li class="listitem"><p>NOT_EQUAL (!=)</p></li><li class="listitem"><p>GREATER_OR_EQUAL (&gt;=)</p></li><li class="listitem"><p>GREATER (&gt;)</p></li><li class="listitem"><p>NO_OP (no operation)</p></li></ol></div><p>The client should use the symbols (&lt;, &lt;=, =, !=, &gt;, &gt;=) to express compare
                operators.</p></div><div class="section" title="12.1.5.&nbsp;Comparator"><div class="titlepage"><div><div><h3 class="title"><a name="comparator"></a>12.1.5.&nbsp;Comparator</h3></div></div></div><p>A comparator can be any of the following:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong>BinaryComparator</strong></span> - This lexicographically
                        compares against the specified byte array using Bytes.compareTo(byte[],
                        byte[])</p></li><li class="listitem"><p><span class="bold"><strong>BinaryPrefixComparator</strong></span> - This lexicographically
                        compares against a specified byte array. It only compares up to the length
                        of this byte array.</p></li><li class="listitem"><p><span class="bold"><strong>RegexStringComparator</strong></span> - This compares against the
                        specified byte array using the given regular expression. Only EQUAL and
                        NOT_EQUAL comparisons are valid with this comparator</p></li><li class="listitem"><p><span class="bold"><strong>SubStringComparator</strong></span> - This tests if the given
                        substring appears in a specified byte array. The comparison is case
                        insensitive. Only EQUAL and NOT_EQUAL comparisons are valid with this
                        comparator</p></li></ol></div><p>The general syntax of a comparator is:<code class="code">
                ComparatorType:ComparatorValue</code></p><p>The ComparatorType for the various comparators is as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong>BinaryComparator</strong></span> - binary</p></li><li class="listitem"><p><span class="bold"><strong>BinaryPrefixComparator</strong></span> - binaryprefix</p></li><li class="listitem"><p><span class="bold"><strong>RegexStringComparator</strong></span> - regexstring</p></li><li class="listitem"><p><span class="bold"><strong>SubStringComparator</strong></span> - substring</p></li></ol></div><p>The ComparatorValue can be any value.</p><div class="example"><a name="d2875e13173"></a><p class="title"><b>Example&nbsp;12.3.&nbsp;Example 1</b></p><div class="example-contents"><p><code class="code"> &gt;, 'binary:abc' </code>will match everything that is
                lexicographically greater than "abc" </p></div></div><br class="example-break"><div class="example"><a name="d2875e13180"></a><p class="title"><b>Example&nbsp;12.4.&nbsp;Example 2</b></p><div class="example-contents"><p><code class="code"> =, 'binaryprefix:abc' </code>will match everything whose first 3
                characters are lexicographically equal to "abc"</p></div></div><br class="example-break"><div class="example"><a name="d2875e13187"></a><p class="title"><b>Example&nbsp;12.5.&nbsp;Example 3</b></p><div class="example-contents"><p><code class="code"> !=, 'regexstring:ab*yz' </code>will match everything that doesn't
                begin with "ab" and ends with "yz"</p></div></div><br class="example-break"><div class="example"><a name="d2875e13194"></a><p class="title"><b>Example&nbsp;12.6.&nbsp;Example 4</b></p><div class="example-contents"><p><code class="code"> =, 'substring:abc123' </code>will match everything that begins
                with the substring "abc123"</p></div></div><br class="example-break"></div><div class="section" title="12.1.6.&nbsp;Example PHP Client Program that uses the Filter Language"><div class="titlepage"><div><div><h3 class="title"><a name="examplePHPClientProgram"></a>12.1.6.&nbsp;Example PHP Client Program that uses the Filter Language</h3></div></div></div><pre class="programlisting">
&lt;? $_SERVER['PHP_ROOT'] = realpath(dirname(__FILE__).'/..');
   require_once $_SERVER['PHP_ROOT'].'/flib/__flib.php';
   flib_init(FLIB_CONTEXT_SCRIPT);
   require_module('storage/hbase');
   $hbase = new HBase('&lt;server_name_running_thrift_server&gt;', &lt;port on which thrift server is running&gt;);
   $hbase-&gt;open();
   $client = $hbase-&gt;getClient();
   $result = $client-&gt;scannerOpenWithFilterString('table_name', "(PrefixFilter ('row2') AND (QualifierFilter (&gt;=, 'binary:xyz'))) AND (TimestampsFilter ( 123, 456))");
   $to_print = $client-&gt;scannerGetList($result,1);
   while ($to_print) {
      print_r($to_print);
      $to_print = $client-&gt;scannerGetList($result,1);
    }
   $client-&gt;scannerClose($result);
?&gt;
        </pre></div><div class="section" title="12.1.7.&nbsp;Example Filter Strings"><div class="titlepage"><div><div><h3 class="title"><a name="example-filter-strings"></a>12.1.7.&nbsp;Example Filter Strings</h3></div></div></div><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">&#8220;PrefixFilter (&#8216;Row&#8217;) AND PageFilter (1) AND FirstKeyOnlyFilter
                                ()&#8221;</code> will return all key-value pairs that match the following
                            conditions:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The row containing the key-value should have prefix &#8220;Row&#8221;
                                </p></li><li class="listitem"><p>The key-value must be located in the first row of the table
                                </p></li><li class="listitem"><p>The key-value pair must be the first key-value in the row
                                </p></li></ol></div></li></ul></div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">&#8220;(RowFilter (=, &#8216;binary:Row 1&#8217;) AND TimeStampsFilter (74689,
                                    89734)) OR ColumnRangeFilter (&#8216;abc&#8217;, true, &#8216;xyz&#8217;,
                                    false))&#8221;</code> will return all key-value pairs that match both
                                the following conditions:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>The key-value is in a row having row key &#8220;Row 1&#8221; </p></li><li class="listitem"><p>The key-value must have a timestamp of either 74689 or
                                        89734.</p></li><li class="listitem"><p>Or it must match the following condition:</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>The key-value pair must be in a column that is
                                                lexicographically &gt;= abc and &lt; xyz&nbsp;</p></li></ul></div></li></ul></div></li></ul></div></li></ol></div><p>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">&#8220;SKIP ValueFilter (0)&#8221;</code> will skip the entire row if any of
                            the values in the row is not 0</p></li></ul></div><p>
            </p></div><div class="section" title="12.1.8.&nbsp;Individual Filter Syntax"><div class="titlepage"><div><div><h3 class="title"><a name="IndividualFilterSyntax"></a>12.1.8.&nbsp;Individual Filter Syntax</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">KeyOnlyFilter</span></dt><dd><p>This filter doesn&#8217;t take any arguments. It returns only the key
                            component of each key-value.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">KeyOnlyFilter ()</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">KeyOnlyFilter ()"</pre></li></ul></div></dd><dt><span class="term">FirstKeyOnlyFilter</span></dt><dd><p>This filter doesn&#8217;t take any arguments. It returns only the first
                            key-value from each row.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">FirstKeyOnlyFilter ()</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">FirstKeyOnlyFilter ()</pre></li></ul></div></dd><dt><span class="term">PrefixFilter</span></dt><dd><p>This filter takes one argument &#8211; a prefix of a row key. It returns
                            only those key-values present in a row that starts with the specified
                            row prefix</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">PrefixFilter (&#8216;&lt;row_prefix&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">PrefixFilter (&#8216;Row&#8217;)</pre></li></ul></div></dd><dt><span class="term">ColumnPrefixFilter</span></dt><dd><p>This filter takes one argument &#8211; a column prefix. It returns only
                            those key-values present in a column that starts with the specified
                            column prefix. The column prefix must be of the form:
                                <code class="code">&#8220;qualifier&#8221;</code>.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnPrefixFilter(&#8216;&lt;column_prefix&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnPrefixFilter(&#8216;Col&#8217;)</pre></li></ul></div></dd><dt><span class="term">MultipleColumnPrefixFilter</span></dt><dd><p>This filter takes a list of column prefixes. It returns key-values
                            that are present in a column that starts with any of the specified
                            column prefixes. Each of the column prefixes must be of the form:
                                <code class="code">&#8220;qualifier&#8221;</code>.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">MultipleColumnPrefixFilter(&#8216;&lt;column_prefix&gt;&#8217;, &#8216;&lt;column_prefix&gt;&#8217;, &#8230;, &#8216;&lt;column_prefix&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">MultipleColumnPrefixFilter(&#8216;Col1&#8217;, &#8216;Col2&#8217;)</pre></li></ul></div></dd><dt><span class="term">ColumnCountGetFilter</span></dt><dd><p>This filter takes one argument &#8211; a limit. It returns the first limit
                            number of columns in the table.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnCountGetFilter
                        (&#8216;&lt;limit&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnCountGetFilter (4)</pre></li></ul></div></dd><dt><span class="term">PageFilter</span></dt><dd><p>This filter takes one argument &#8211; a page size. It returns page size
                            number of rows from the table.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">PageFilter (&#8216;&lt;page_size&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">PageFilter (2)</pre></li></ul></div></dd><dt><span class="term">ColumnPaginationFilter</span></dt><dd><p>This filter takes two arguments &#8211; a limit and offset. It returns limit
                            number of columns after offset number of columns. It does this for all
                            the rows.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnPaginationFilter(&#8216;&lt;limit&gt;&#8217;, &#8216;&lt;offset&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnPaginationFilter (3, 5)</pre></li></ul></div></dd><dt><span class="term">InclusiveStopFilter</span></dt><dd><p>This filter takes one argument &#8211; a row key on which to stop scanning.
                            It returns all key-values present in rows up to and including the
                            specified row.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">InclusiveStopFilter(&#8216;&lt;stop_row_key&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">InclusiveStopFilter ('Row2')</pre></li></ul></div></dd><dt><span class="term">TimeStampsFilter</span></dt><dd><p>This filter takes a list of timestamps. It returns those key-values
                            whose timestamps matches any of the specified timestamps.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">TimeStampsFilter (&lt;timestamp&gt;, &lt;timestamp&gt;, ... ,&lt;timestamp&gt;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">TimeStampsFilter (5985489, 48895495, 58489845945)</pre></li></ul></div></dd><dt><span class="term">RowFilter</span></dt><dd><p>This filter takes a compare operator and a comparator. It compares
                            each row key with the comparator using the compare operator and if the
                            comparison returns true, it returns all the key-values in that
                            row.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">RowFilter (&lt;compareOp&gt;, &#8216;&lt;row_comparator&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">RowFilter (&lt;=, &#8216;xyz)</pre></li></ul></div></dd><dt><span class="term">Family Filter</span></dt><dd><p>This filter takes a compare operator and a comparator. It compares
                            each qualifier name with the comparator using the compare operator and
                            if the comparison returns true, it returns all the key-values in that
                            column.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">QualifierFilter (&lt;compareOp&gt;, &#8216;&lt;qualifier_comparator&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">QualifierFilter (=, &#8216;Column1&#8217;)</pre></li></ul></div></dd><dt><span class="term">QualifierFilter</span></dt><dd><p>This filter takes a compare operator and a comparator. It compares
                            each qualifier name with the comparator using the compare operator and
                            if the comparison returns true, it returns all the key-values in that
                            column.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">QualifierFilter (&lt;compareOp&gt;,&#8216;&lt;qualifier_comparator&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">QualifierFilter (=,&#8216;Column1&#8217;)</pre></li></ul></div></dd><dt><span class="term">ValueFilter</span></dt><dd><p>This filter takes a compare operator and a comparator. It compares
                            each value with the comparator using the compare operator and if the
                            comparison returns true, it returns that key-value.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ValueFilter (&lt;compareOp&gt;,&#8216;&lt;value_comparator&gt;&#8217;) </pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ValueFilter (!=, &#8216;Value&#8217;)</pre></li></ul></div></dd><dt><span class="term">DependentColumnFilter</span></dt><dd><p>This filter takes two arguments &#8211; a family and a qualifier. It tries
                            to locate this column in each row and returns all key-values in that row
                            that have the same timestamp. If the row doesn&#8217;t contain the specified
                            column &#8211; none of the key-values in that row will be returned.</p><p>The filter can also take an optional boolean argument &#8211;
                            dropDependentColumn. If set to true, the column we were depending on
                            doesn&#8217;t get returned.</p><p>The filter can also take two more additional optional arguments &#8211; a
                            compare operator and a value comparator, which are further checks in
                            addition to the family and qualifier. If the dependent column is found,
                            its value should also pass the value check and then only is its
                            timestamp taken into consideration.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">DependentColumnFilter (&#8216;&lt;family&gt;&#8217;,&#8216;&lt;qualifier&gt;&#8217;, &lt;boolean&gt;, &lt;compare operator&gt;, &#8216;&lt;value
                        comparator&#8217;)</pre></li><li class="listitem"><pre class="programlisting">DependentColumnFilter (&#8216;&lt;family&gt;&#8217;,&#8216;&lt;qualifier&gt;&#8217;, &lt;boolean&gt;)</pre></li><li class="listitem"><pre class="programlisting">DependentColumnFilter (&#8216;&lt;family&gt;&#8217;,&#8216;&lt;qualifier&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">DependentColumnFilter (&#8216;conf&#8217;, &#8216;blacklist&#8217;, false, &gt;=, &#8216;zebra&#8217;)</pre></li><li class="listitem"><pre class="programlisting">DependentColumnFilter (&#8216;conf&#8217;, 'blacklist', true)</pre></li><li class="listitem"><pre class="programlisting">DependentColumnFilter (&#8216;conf&#8217;, 'blacklist')</pre></li></ul></div></dd><dt><span class="term">SingleColumnValueFilter</span></dt><dd><p>This filter takes a column family, a qualifier, a compare operator and
                            a comparator. If the specified column is not found &#8211; all the columns of
                            that row will be emitted. If the column is found and the comparison with
                            the comparator returns true, all the columns of the row will be emitted.
                            If the condition fails, the row will not be emitted. </p><p>This filter also takes two additional optional boolean arguments &#8211;
                            filterIfColumnMissing and setLatestVersionOnly</p><p>If the filterIfColumnMissing flag is set to true the columns of the
                            row will not be emitted if the specified column to check is not found in
                            the row. The default value is false.</p><p>If the setLatestVersionOnly flag is set to false, it will test
                            previous versions (timestamps) too. The default value is true.</p><p>These flags are optional and if you must set neither or both.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">SingleColumnValueFilter(&#8216;&lt;family&gt;&#8217;,&#8216;&lt;qualifier&gt;&#8217;, &lt;compare operator&gt;, &#8216;&lt;comparator&gt;&#8217;, &lt;filterIfColumnMissing_boolean&gt;, &lt;latest_version_boolean&gt;)</pre></li><li class="listitem"><pre class="programlisting">SingleColumnValueFilter(&#8216;&lt;family&gt;&#8217;, &#8216;&lt;qualifier&gt;, &lt;compare operator&gt;, &#8216;&lt;comparator&gt;&#8217;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">SingleColumnValueFilter (&#8216;FamilyA&#8217;, &#8216;Column1&#8217;, &lt;=, &#8216;abc&#8217;, true, false)</pre></li><li class="listitem"><pre class="programlisting">SingleColumnValueFilter (&#8216;FamilyA&#8217;, &#8216;Column1&#8217;, &lt;=, &#8216;abc&#8217;)</pre></li></ul></div></dd><dt><span class="term">SingleColumnValueExcludeFilter</span></dt><dd><p>This filter takes the same arguments and behaves same as
                            SingleColumnValueFilter &#8211; however, if the column is found and the
                            condition passes, all the columns of the row will be emitted except for
                            the tested column value.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">SingleColumnValueExcludeFilter('&lt;family&gt;', '&lt;qualifier&gt;', &lt;compare operator&gt;, '&lt;comparator&gt;', &lt;latest_version_boolean&gt;, &lt;filterIfColumnMissing_boolean&gt;)</pre></li><li class="listitem"><pre class="programlisting">SingleColumnValueExcludeFilter('&lt;family&gt;', '&lt;qualifier&gt;', &lt;compare operator&gt;, '&lt;comparator&gt;')</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">SingleColumnValueExcludeFilter (&#8216;FamilyA&#8217;, &#8216;Column1&#8217;, &#8216;&lt;=&#8217;, &#8216;abc&#8217;, &#8216;false&#8217;, &#8216;true&#8217;)</pre></li><li class="listitem"><pre class="programlisting">SingleColumnValueExcludeFilter (&#8216;FamilyA&#8217;, &#8216;Column1&#8217;, &#8216;&lt;=&#8217;, &#8216;abc&#8217;)</pre></li></ul></div></dd><dt><span class="term">ColumnRangeFilter</span></dt><dd><p>This filter is used for selecting only those keys with columns that
                            are between minColumn and maxColumn. It also takes two boolean variables
                            to indicate whether to include the minColumn and maxColumn or
                            not.</p><p>If you don&#8217;t want to set the minColumn or the maxColumn &#8211; you can pass
                            in an empty argument.</p><div class="itemizedlist" title="Syntax"><p class="title"><b>Syntax</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnRangeFilter (&#8216;&lt;minColumn&gt;&#8217;, &lt;minColumnInclusive_bool&gt;, &#8216;&lt;maxColumn&gt;&#8217;, &lt;maxColumnInclusive_bool&gt;)</pre></li></ul></div><div class="itemizedlist" title="Example"><p class="title"><b>Example</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="programlisting">ColumnRangeFilter (&#8216;abc&#8217;, true, &#8216;xyz&#8217;, false)</pre></li></ul></div></dd></dl></div></div></div></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Apache HBase Coprocessors"><div class="titlepage"><div><div><h2 class="title"><a name="cp"></a>Chapter&nbsp;13.&nbsp;Apache HBase Coprocessors</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e13646">13.1. Coprocessor Framework</a></span></dt><dt><span class="section"><a href="#d2875e13822">13.2. Examples</a></span></dt><dt><span class="section"><a href="#d2875e13830">13.3. Building A Coprocessor</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e13835">13.3.1. Load from Configuration</a></span></dt><dt><span class="section"><a href="#d2875e13875">13.3.2. Load from the HBase Shell</a></span></dt></dl></dd><dt><span class="section"><a href="#d2875e13944">13.4. Check the Status of a Coprocessor</a></span></dt><dt><span class="section"><a href="#d2875e13960">13.5. Monitor Time Spent in Coprocessors</a></span></dt><dt><span class="section"><a href="#d2875e13981">13.6. Status of Coprocessors in HBase</a></span></dt></dl></div><p> HBase coprocessors are modeled after the coprocessors which are part of Google's BigTable
      (<a class="link" href="http://www.scribd.com/doc/21631448/Dean-Keynote-Ladis2009" target="_top">http://www.scribd.com/doc/21631448/Dean-Keynote-Ladis2009</a>, pages
    66-67.). Coprocessors function in a similar way to Linux kernel modules. They provide a way to
    run server-level code against locally-stored data. The functionality they provide is very
    powerful, but also carries great risk and can have adverse effects on the system, at the level
    of the operating system. The information in this chapter is primarily sourced and heavily reused
    from Mingjie Lai's blog post at <a class="link" href="https://blogs.apache.org/hbase/entry/coprocessor_introduction" target="_top">https://blogs.apache.org/hbase/entry/coprocessor_introduction</a>. </p><p> Coprocessors are not designed to be used by end users of HBase, but by HBase developers who
    need to add specialized functionality to HBase. One example of the use of coprocessors is
    pluggable compaction and scan policies, which are provided as coprocessors in <a class="link" href="HBASE-6427" target="_top">HBASE-6427</a>. </p><div class="section" title="13.1.&nbsp;Coprocessor Framework"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e13646"></a>13.1.&nbsp;Coprocessor Framework</h2></div></div></div><p>The implementation of HBase coprocessors diverges from the BigTable implementation. The
      HBase framework provides a library and runtime environment for executing user code within the
      HBase region server and master processes. </p><p> The framework API is provided in the <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/coprocessor/package-summary.html" target="_top">coprocessor</a>
      package.</p><p>Two different types of coprocessors are provided by the framework, based on their
      scope.</p><div class="variablelist" title="Types of Coprocessors"><p class="title"><b>Types of Coprocessors</b></p><dl><dt><span class="term">System Coprocessors</span></dt><dd><p>System coprocessors are loaded globally on all tables and regions hosted by a region
            server.</p></dd><dt><span class="term">Table Coprocessors</span></dt><dd><p>You can specify which coprocessors should be loaded on all regions for a table on a
            per-table basis.</p></dd></dl></div><p>The framework provides two different aspects of extensions as well:
        <em class="firstterm">observers</em> and <em class="firstterm">endpoints</em>.</p><div class="variablelist"><dl><dt><span class="term">Observers</span></dt><dd><p>Observers are analogous to triggers in conventional databases. They allow you to
            insert user code by overriding upcall methods provided by the coprocessor framework.
            Callback functions are executed from core HBase code when events occur. Callbacks are
            handled by the framework, and the coprocessor itself only needs to insert the extended
            or alternate functionality.</p><div class="variablelist" title="Provided Observer Interfaces"><p class="title"><b>Provided Observer Interfaces</b></p><dl><dt><span class="term"><a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/coprocessor/RegionObserver.html" target="_top">RegionObserver</a></span></dt><dd><p>A RegionObserver provides hooks for data manipulation events, such as Get,
                  Put, Delete, Scan. An instance of a RegionObserver coprocessor exists for each
                  table region. The scope of the observations a RegionObserver can make is
                  constrained to that region. </p></dd><dt><span class="term"><a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/coprocessor/RegionServerObserver.html" target="_top">RegionServerObserver</a></span></dt><dd><p>A RegionServerObserver provides for operations related to the RegionServer,
                  such as stopping the RegionServer and performing operations before or after
                  merges, commits, or rollbacks.</p></dd><dt><span class="term"><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/coprocessor/WALObserver.html" target="_top">WALObserver</a></span></dt><dd><p>A WALObserver provides hooks for operations related to the write-ahead log
                  (WAL). You can observe or intercept WAL writing and reconstruction events. A
                  WALObserver runs in the context of WAL processing. A single WALObserver exists on
                  a single region server.</p></dd><dt><span class="term"><a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/coprocessor/MasterObserver.html" target="_top">MasterObserver</a></span></dt><dd><p>A MasterObserver provides hooks for DDL-type operation, such as create,
                  delete, modify table. The MasterObserver runs within the context of the HBase
                  master. </p></dd></dl></div><p>More than one observer of a given type can be loaded at once. Multiple observers are
            chained to execute sequentially by order of assigned priority. Nothing prevents a
            coprocessor implementor from communicating internally among its installed
            observers.</p><p>An observer of a higher priority can preempt lower-priority observers by throwing an
            IOException or a subclass of IOException.</p></dd><dt><span class="term">Endpoints (HBase 0.96.x and later)</span></dt><dd><p>The implementation for endpoints changed significantly in HBase 0.96.x due to the
            introduction of protocol buffers (protobufs) (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-5448" target="_top">HBASE-5488</a>). If
            you created endpoints before 0.96.x, you will need to rewrite them. Endpoints are now
            defined and callable as protobuf services, rather than endpoint invocations passed
            through as Writable blobs</p><p>Dynamic RPC endpoints resemble stored procedures. An endpoint can be invoked at any
            time from the client. When it is invoked, it is executed remotely at the target region
            or regions, and results of the executions are returned to the client.</p><p>The endpoint implementation is installed on the server and is invoked using HBase
            RPC. The client library provides convenience methods for invoking these dynamic
            interfaces. </p><p>An endpoint, like an observer, can communicate with any installed observers. This
            allows you to plug new features into HBase without modifying or recompiling HBase
            itself.</p><div class="itemizedlist" title="Steps to Implement an Endpoint"><p class="title"><b>Steps to Implement an Endpoint</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Define the coprocessor service and related messages in a <code class="filename">.proto</code> file</p></li><li class="listitem"><p>Run the <span class="command"><strong>protoc</strong></span> command to generate the code.</p></li><li class="listitem"><p>Write code to implement the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>the generated protobuf Service interface</p></li><li class="listitem"><p>the new <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#coprocessorService(byte[])" target="_top">org.apache.hadoop.hbase.coprocessor.CoprocessorService</a>
                    interface (required for the <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/RegionCoprocessorHost.html" target="_top">RegionCoprocessorHost</a>
                    to register the exposed service)</p></li></ul></div></li><li class="listitem"><p>The client calls the new HTable.coprocessorService() methods to perform the endpoint RPCs.</p></li></ul></div><p>For more information and examples, refer to the API documentation for the <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/coprocessor/package-summary.html" target="_top">coprocessor</a>
          package, as well as the included RowCount example in the
            <code class="filename">/hbase-examples/src/test/java/org/apache/hadoop/hbase/coprocessor/example/</code>
            of the HBase source.</p></dd><dt><span class="term">Endpoints (HBase 0.94.x and earlier)</span></dt><dd><p>Dynamic RPC endpoints resemble stored procedures. An endpoint can be invoked at any
            time from the client. When it is invoked, it is executed remotely at the target region
            or regions, and results of the executions are returned to the client.</p><p>The endpoint implementation is installed on the server and is invoked using HBase
            RPC. The client library provides convenience methods for invoking these dynamic
            interfaces. </p><p>An endpoint, like an observer, can communicate with any installed observers. This
            allows you to plug new features into HBase without modifying or recompiling HBase
            itself.</p><div class="itemizedlist" title="Steps to Implement an Endpoint"><p class="title"><b>Steps to Implement an Endpoint</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><h3><a name="d2875e13794"></a>Server-Side</h3><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Create new protocol interface which extends CoprocessorProtocol.</p></li><li class="listitem"><p>Implement the Endpoint interface. The implementation will be loaded into and
                    executed from the region context.</p></li><li class="listitem"><p>Extend the abstract class BaseEndpointCoprocessor. This convenience class
                    hides some internal details that the implementer does not need to be concerned
                    about, &#710; such as coprocessor framework class loading.</p></li></ul></div></li><li class="listitem"><h3><a name="d2875e13807"></a>Client-Side</h3><p>Endpoint can be invoked by two new HBase client APIs:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p><code class="code">HTableInterface.coprocessorProxy(Class&lt;T&gt; protocol, byte[]
                      row)</code> for executing against a single region</p></li><li class="listitem"><p><code class="code">HTableInterface.coprocessorExec(Class&lt;T&gt; protocol, byte[]
                      startKey, byte[] endKey, Batch.Call&lt;T,R&gt; callable)</code> for executing
                    over a range of regions</p></li></ul></div></li></ul></div></dd></dl></div></div><div class="section" title="13.2.&nbsp;Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e13822"></a>13.2.&nbsp;Examples</h2></div></div></div><p>An example of an observer is included in
      <code class="filename">hbase-examples/src/test/java/org/apache/hadoop/hbase/coprocessor/example/TestZooKeeperScanPolicyObserver.java</code>.
    Several endpoint examples are included in the same directory.</p></div><div class="section" title="13.3.&nbsp;Building A Coprocessor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e13830"></a>13.3.&nbsp;Building A Coprocessor</h2></div></div></div><p>Before you can build a processor, it must be developed, compiled, and packaged in a JAR
      file. The next step is to configure the coprocessor framework to use your coprocessor. You can
      load the coprocessor from your HBase configuration, so that the coprocessor starts with HBase,
      or you can configure the coprocessor from the HBase shell, as a table attribute, so that it is
      loaded dynamically when the table is opened or reopened.</p><div class="section" title="13.3.1.&nbsp;Load from Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e13835"></a>13.3.1.&nbsp;Load from Configuration</h3></div></div></div><p> To configure a coprocessor to be loaded when HBase starts, modify the RegionServer's
          <code class="filename">hbase-site.xml</code> and configure one of the following properties, based
        on the type of observer you are configuring: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">hbase.coprocessor.region.classes</code>for RegionObservers and
            Endpoints</p></li><li class="listitem"><p><code class="code">hbase.coprocessor.wal.classes</code>for WALObservers</p></li><li class="listitem"><p><code class="code">hbase.coprocessor.master.classes</code>for MasterObservers</p></li></ul></div><div class="example"><a name="d2875e13859"></a><p class="title"><b>Example&nbsp;13.1.&nbsp;Example RegionObserver Configuration</b></p><div class="example-contents"><p>In this example, one RegionObserver is configured for all the HBase tables.</p><pre class="screen">
&lt;property&gt;
    &lt;name&gt;hbase.coprocessor.region.classes&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.coprocessor.AggregateImplementation&lt;/value&gt;
 &lt;/property&gt;          
        </pre></div></div><br class="example-break"><p> If multiple classes are specified for loading, the class names must be comma-separated.
        The framework attempts to load all the configured classes using the default class loader.
        Therefore, the jar file must reside on the server-side HBase classpath.</p><p>Coprocessors which are loaded in this way will be active on all regions of
        all tables. These are the system coprocessor introduced earlier. The first listed
        coprocessors will be assigned the priority <code class="literal">Coprocessor.Priority.SYSTEM</code>.
        Each subsequent coprocessor in the list will have its priority value incremented by one
        (which reduces its priority, because priorities have the natural sort order of Integers). </p><p>When calling out to registered observers, the framework executes their callbacks methods
        in the sorted order of their priority. Ties are broken arbitrarily.</p></div><div class="section" title="13.3.2.&nbsp;Load from the HBase Shell"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e13875"></a>13.3.2.&nbsp;Load from the HBase Shell</h3></div></div></div><p> You can load a coprocessor on a specific table via a table attribute. The following
        example will load the <code class="systemitem">FooRegionObserver</code> observer when table
          <code class="systemitem">t1</code> is read or re-read. </p><div class="example"><a name="d2875e13886"></a><p class="title"><b>Example&nbsp;13.2.&nbsp;Load a Coprocessor On a Table Using HBase Shell</b></p><div class="example-contents"><pre class="screen">
hbase(main):005:0&gt;  <strong class="userinput"><code>alter 't1', METHOD =&gt; 'table_att', 
  'coprocessor'=&gt;'hdfs:///foo.jar|com.foo.FooRegionObserver|1001|arg1=1,arg2=2'</code></strong>
<code class="computeroutput">Updating all regions with the new schema...
1/1 regions updated.
Done.
0 row(s) in 1.0730 seconds</code>

hbase(main):006:0&gt; <strong class="userinput"><code>describe 't1'</code></strong>
<code class="computeroutput">DESCRIPTION                                                        ENABLED                             
 {NAME =&gt; 't1', coprocessor$1 =&gt; 'hdfs:///foo.jar|com.foo.FooRegio false                               
 nObserver|1001|arg1=1,arg2=2', FAMILIES =&gt; [{NAME =&gt; 'c1', DATA_B                                     
 LOCK_ENCODING =&gt; 'NONE', BLOOMFILTER =&gt; 'NONE', REPLICATION_SCOPE                                     
  =&gt; '0', VERSIONS =&gt; '3', COMPRESSION =&gt; 'NONE', MIN_VERSIONS =&gt;                                      
 '0', TTL =&gt; '2147483647', KEEP_DELETED_CELLS =&gt; 'false', BLOCKSIZ                                     
 E =&gt; '65536', IN_MEMORY =&gt; 'false', ENCODE_ON_DISK =&gt; 'true', BLO                                     
 CKCACHE =&gt; 'true'}, {NAME =&gt; 'f1', DATA_BLOCK_ENCODING =&gt; 'NONE',                                     
  BLOOMFILTER =&gt; 'NONE', REPLICATION_SCOPE =&gt; '0', VERSIONS =&gt; '3'                                     
 , COMPRESSION =&gt; 'NONE', MIN_VERSIONS =&gt; '0', TTL =&gt; '2147483647'                                     
 , KEEP_DELETED_CELLS =&gt; 'false', BLOCKSIZE =&gt; '65536', IN_MEMORY                                      
 =&gt; 'false', ENCODE_ON_DISK =&gt; 'true', BLOCKCACHE =&gt; 'true'}]}                                         
1 row(s) in 0.0190 seconds</code>
        </pre></div></div><br class="example-break"><p>The coprocessor framework will try to read the class information from the coprocessor
        table attribute value. The value contains four pieces of information which are separated by
        the <code class="literal">|</code> character.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>File path: The jar file containing the coprocessor implementation must be in a
            location where all region servers can read it. You could copy the file onto the local
            disk on each region server, but it is recommended to store it in HDFS.</p></li><li class="listitem"><p>Class name: The full class name of the coprocessor.</p></li><li class="listitem"><p>Priority: An integer. The framework will determine the execution sequence of all
            configured observers registered at the same hook using priorities. This field can be
            left blank. In that case the framework will assign a default priority value.</p></li><li class="listitem"><p>Arguments: This field is passed to the coprocessor implementation.</p></li></ul></div><div class="example"><a name="d2875e13921"></a><p class="title"><b>Example&nbsp;13.3.&nbsp;Unload a Coprocessor From a Table Using HBase Shell</b></p><div class="example-contents"><pre class="screen">
hbase(main):007:0&gt; <strong class="userinput"><code>alter 't1', METHOD =&gt; 'table_att_unset',</code></strong> 
hbase(main):008:0*   <strong class="userinput"><code>NAME =&gt; 'coprocessor$1'</code></strong>
<code class="computeroutput">Updating all regions with the new schema...
1/1 regions updated.
Done.
0 row(s) in 1.1130 seconds</code>

hbase(main):009:0&gt; <strong class="userinput"><code>describe 't1'</code></strong>
<code class="computeroutput">DESCRIPTION                                                        ENABLED                             
 {NAME =&gt; 't1', FAMILIES =&gt; [{NAME =&gt; 'c1', DATA_BLOCK_ENCODING =&gt; false                               
  'NONE', BLOOMFILTER =&gt; 'NONE', REPLICATION_SCOPE =&gt; '0', VERSION                                     
 S =&gt; '3', COMPRESSION =&gt; 'NONE', MIN_VERSIONS =&gt; '0', TTL =&gt; '214                                     
 7483647', KEEP_DELETED_CELLS =&gt; 'false', BLOCKSIZE =&gt; '65536', IN                                     
 _MEMORY =&gt; 'false', ENCODE_ON_DISK =&gt; 'true', BLOCKCACHE =&gt; 'true                                     
 '}, {NAME =&gt; 'f1', DATA_BLOCK_ENCODING =&gt; 'NONE', BLOOMFILTER =&gt;                                      
 'NONE', REPLICATION_SCOPE =&gt; '0', VERSIONS =&gt; '3', COMPRESSION =&gt;                                     
  'NONE', MIN_VERSIONS =&gt; '0', TTL =&gt; '2147483647', KEEP_DELETED_C                                     
 ELLS =&gt; 'false', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'false', ENCO                                     
 DE_ON_DISK =&gt; 'true', BLOCKCACHE =&gt; 'true'}]}                                                         
1 row(s) in 0.0180 seconds          </code>
        </pre></div></div><br class="example-break"><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>There is no guarantee that the framework will load a given coprocessor successfully.
          For example, the shell command neither guarantees a jar file exists at a particular
          location nor verifies whether the given class is actually contained in the jar file.
        </p></div></div></div><div class="section" title="13.4.&nbsp;Check the Status of a Coprocessor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e13944"></a>13.4.&nbsp;Check the Status of a Coprocessor</h2></div></div></div><p>To check the status of a coprocessor after it has been configured, use the
        <span class="command"><strong>status</strong></span> HBase Shell command.</p><pre class="screen">
hbase(main):020:0&gt; <strong class="userinput"><code>status 'detailed'</code></strong>
<code class="computeroutput">version 0.92-tm-6
0 regionsInTransition
master coprocessors: []
1 live servers
    localhost:52761 1328082515520
        requestsPerSecond=3, numberOfOnlineRegions=3, usedHeapMB=32, maxHeapMB=995
        -ROOT-,,0
            numberOfStores=1, numberOfStorefiles=1, storefileUncompressedSizeMB=0, storefileSizeMB=0, memstoreSizeMB=0, 
storefileIndexSizeMB=0, readRequestsCount=54, writeRequestsCount=1, rootIndexSizeKB=0, totalStaticIndexSizeKB=0, 
totalStaticBloomSizeKB=0, totalCompactingKVs=0, currentCompactedKVs=0, compactionProgressPct=NaN, coprocessors=[]
        .META.,,1
            numberOfStores=1, numberOfStorefiles=0, storefileUncompressedSizeMB=0, storefileSizeMB=0, memstoreSizeMB=0, 
storefileIndexSizeMB=0, readRequestsCount=97, writeRequestsCount=4, rootIndexSizeKB=0, totalStaticIndexSizeKB=0, 
totalStaticBloomSizeKB=0, totalCompactingKVs=0, currentCompactedKVs=0, compactionProgressPct=NaN, coprocessors=[]
        t1,,1328082575190.c0491168a27620ffe653ec6c04c9b4d1.
            numberOfStores=2, numberOfStorefiles=1, storefileUncompressedSizeMB=0, storefileSizeMB=0, memstoreSizeMB=0, 
storefileIndexSizeMB=0, readRequestsCount=0, writeRequestsCount=0, rootIndexSizeKB=0, totalStaticIndexSizeKB=0, 
totalStaticBloomSizeKB=0, totalCompactingKVs=0, currentCompactedKVs=0, compactionProgressPct=NaN, 
coprocessors=[AggregateImplementation]
0 dead servers      </code>
    </pre></div><div class="section" title="13.5.&nbsp;Monitor Time Spent in Coprocessors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e13960"></a>13.5.&nbsp;Monitor Time Spent in Coprocessors</h2></div></div></div><p>HBase 0.98.5 introduced the ability to monitor some statistics relating to the amount of
      time spent executing a given coprocessor. You can see these statistics via the HBase Metrics
      framework (see <a class="xref" href="#hbase_metrics" title="17.4.&nbsp;HBase Metrics">Section&nbsp;17.4, &#8220;HBase Metrics&#8221;</a> or the Web UI for a given Region Server, via
      the <span class="guilabel">Coprocessor Metrics</span> tab. These statistics are valuable for debugging
      and benchmarking the performance impact of a given coprocessor on your cluster. Tracked
      statistics include min, max, average, and 90th, 95th, and 99th percentile. All times are shown
      in milliseconds. The statistics are calculated over coprocessor
      execution samples recorded during the reporting interval, which is 10 seconds by default. The
      metrics sampling rate as described in <a class="xref" href="#hbase_metrics" title="17.4.&nbsp;HBase Metrics">Section&nbsp;17.4, &#8220;HBase Metrics&#8221;</a>.</p><div class="figure"><a name="d2875e13972"></a><p class="title"><b>Figure&nbsp;13.1.&nbsp;Coprocessor Metrics UI</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/coprocessor_stats.png" width="100%" alt="Coprocessor Metrics UI"></td></tr></table><div class="caption"><p>The Coprocessor Metrics UI shows statistics about time spent executing a given
            coprocessor, including min, max, average, and 90th, 95th, and 99th percentile.</p></div></div></div></div><br class="figure-break"></div><div class="section" title="13.6.&nbsp;Status of Coprocessors in HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e13981"></a>13.6.&nbsp;Status of Coprocessors in HBase</h2></div></div></div><p> Coprocessors and the coprocessor framework are evolving rapidly and work is ongoing on
      several different JIRAs. </p></div></div><div class="chapter" title="Chapter&nbsp;14.&nbsp;Apache HBase Performance Tuning"><div class="titlepage"><div><div><h2 class="title"><a name="performance"></a>Chapter&nbsp;14.&nbsp;Apache HBase Performance Tuning</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#perf.os">14.1. Operating System</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.os.ram">14.1.1. Memory</a></span></dt><dt><span class="section"><a href="#perf.os.64">14.1.2. 64-bit</a></span></dt><dt><span class="section"><a href="#perf.os.swap">14.1.3. Swapping</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.network">14.2. Network</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.network.1switch">14.2.1. Single Switch</a></span></dt><dt><span class="section"><a href="#perf.network.2switch">14.2.2. Multiple Switches</a></span></dt><dt><span class="section"><a href="#perf.network.multirack">14.2.3. Multiple Racks</a></span></dt><dt><span class="section"><a href="#perf.network.ints">14.2.4. Network Interfaces</a></span></dt></dl></dd><dt><span class="section"><a href="#jvm">14.3. Java</a></span></dt><dd><dl><dt><span class="section"><a href="#gc">14.3.1. The Garbage Collector and Apache HBase</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.configurations">14.4. HBase Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.compactions.and.splits">14.4.1. Managing Compactions</a></span></dt><dt><span class="section"><a href="#perf.handlers">14.4.2. <code class="varname">hbase.regionserver.handler.count</code></a></span></dt><dt><span class="section"><a href="#perf.hfile.block.cache.size">14.4.3. <code class="varname">hfile.block.cache.size</code></a></span></dt><dt><span class="section"><a href="#blockcache.prefetch">14.4.4. Prefetch Option for Blockcache</a></span></dt><dt><span class="section"><a href="#perf.rs.memstore.size">14.4.5. <code class="varname">hbase.regionserver.global.memstore.size</code></a></span></dt><dt><span class="section"><a href="#perf.rs.memstore.size.lower.limit">14.4.6. <code class="varname">hbase.regionserver.global.memstore.size.lower.limit</code></a></span></dt><dt><span class="section"><a href="#perf.hstore.blockingstorefiles">14.4.7. <code class="varname">hbase.hstore.blockingStoreFiles</code></a></span></dt><dt><span class="section"><a href="#perf.hregion.memstore.block.multiplier">14.4.8. <code class="varname">hbase.hregion.memstore.block.multiplier</code></a></span></dt><dt><span class="section"><a href="#hbase.regionserver.checksum.verify">14.4.9. <code class="varname">hbase.regionserver.checksum.verify</code></a></span></dt><dt><span class="section"><a href="#d2875e14227">14.4.10. Tuning <code class="code">callQueue</code> Options</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.zookeeper">14.5. ZooKeeper</a></span></dt><dt><span class="section"><a href="#perf.schema">14.6. Schema Design</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.number.of.cfs">14.6.1. Number of Column Families</a></span></dt><dt><span class="section"><a href="#perf.schema.keys">14.6.2. Key and Attribute Lengths</a></span></dt><dt><span class="section"><a href="#schema.regionsize">14.6.3. Table RegionSize</a></span></dt><dt><span class="section"><a href="#schema.bloom">14.6.4. Bloom Filters</a></span></dt><dt><span class="section"><a href="#schema.cf.blocksize">14.6.5. ColumnFamily BlockSize</a></span></dt><dt><span class="section"><a href="#cf.in.memory">14.6.6. In-Memory ColumnFamilies</a></span></dt><dt><span class="section"><a href="#perf.compression">14.6.7. Compression</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.general">14.7. HBase General Patterns</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.general.constants">14.7.1. Constants</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.writing">14.8. Writing to HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.batch.loading">14.8.1. Batch Loading</a></span></dt><dt><span class="section"><a href="#precreate.regions">14.8.2.  Table Creation: Pre-Creating Regions </a></span></dt><dt><span class="section"><a href="#def.log.flush">14.8.3.  Table Creation: Deferred Log Flush </a></span></dt><dt><span class="section"><a href="#perf.hbase.client.autoflush">14.8.4. HBase Client: AutoFlush</a></span></dt><dt><span class="section"><a href="#perf.hbase.client.putwal">14.8.5. HBase Client: Turn off WAL on Puts</a></span></dt><dt><span class="section"><a href="#perf.hbase.client.regiongroup">14.8.6. HBase Client: Group Puts by RegionServer</a></span></dt><dt><span class="section"><a href="#perf.hbase.write.mr.reducer">14.8.7. MapReduce: Skip The Reducer</a></span></dt><dt><span class="section"><a href="#perf.one.region">14.8.8. Anti-Pattern: One Hot Region</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.reading">14.9. Reading from HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.hbase.client.caching">14.9.1. Scan Caching</a></span></dt><dt><span class="section"><a href="#perf.hbase.client.selection">14.9.2. Scan Attribute Selection</a></span></dt><dt><span class="section"><a href="#perf.hbase.client.seek">14.9.3. Avoid scan seeks</a></span></dt><dt><span class="section"><a href="#perf.hbase.mr.input">14.9.4. MapReduce - Input Splits</a></span></dt><dt><span class="section"><a href="#perf.hbase.client.scannerclose">14.9.5. Close ResultScanners</a></span></dt><dt><span class="section"><a href="#perf.hbase.client.blockcache">14.9.6. Block Cache</a></span></dt><dt><span class="section"><a href="#perf.hbase.client.rowkeyonly">14.9.7. Optimal Loading of Row Keys</a></span></dt><dt><span class="section"><a href="#perf.hbase.read.dist">14.9.8. Concurrency: Monitor Data Spread</a></span></dt><dt><span class="section"><a href="#blooms">14.9.9. Bloom Filters</a></span></dt><dt><span class="section"><a href="#d2875e15120">14.9.10. Hedged Reads</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.deleting">14.10. Deleting from HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.deleting.queue">14.10.1. Using HBase Tables as Queues</a></span></dt><dt><span class="section"><a href="#perf.deleting.rpc">14.10.2. Delete RPC Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.hdfs">14.11. HDFS</a></span></dt><dd><dl><dt><span class="section"><a href="#perf.hdfs.curr">14.11.1. Current Issues With Low-Latency Reads</a></span></dt><dt><span class="section"><a href="#perf.hdfs.configs.localread">14.11.2. Leveraging local data</a></span></dt><dt><span class="section"><a href="#perf.hdfs.comp">14.11.3. Performance Comparisons of HBase vs. HDFS</a></span></dt></dl></dd><dt><span class="section"><a href="#perf.ec2">14.12. Amazon EC2</a></span></dt><dt><span class="section"><a href="#perf.hbase.mr.cluster">14.13. Collocating HBase and MapReduce</a></span></dt><dt><span class="section"><a href="#perf.casestudy">14.14. Case Studies</a></span></dt></dl></div><div class="section" title="14.1.&nbsp;Operating System"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.os"></a>14.1.&nbsp;Operating System</h2></div></div></div><div class="section" title="14.1.1.&nbsp;Memory"><div class="titlepage"><div><div><h3 class="title"><a name="perf.os.ram"></a>14.1.1.&nbsp;Memory</h3></div></div></div><p>RAM, RAM, RAM. Don't starve HBase.</p></div><div class="section" title="14.1.2.&nbsp;64-bit"><div class="titlepage"><div><div><h3 class="title"><a name="perf.os.64"></a>14.1.2.&nbsp;64-bit</h3></div></div></div><p>Use a 64-bit platform (and 64-bit JVM).</p></div><div class="section" title="14.1.3.&nbsp;Swapping"><div class="titlepage"><div><div><h3 class="title"><a name="perf.os.swap"></a>14.1.3.&nbsp;Swapping</h3></div></div></div><p>Watch out for swapping. Set swappiness to 0.</p></div></div><div class="section" title="14.2.&nbsp;Network"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.network"></a>14.2.&nbsp;Network</h2></div></div></div><p> Perhaps the most important factor in avoiding network issues degrading Hadoop and HBase
      performance is the switching hardware that is used, decisions made early in the scope of the
      project can cause major problems when you double or triple the size of your cluster (or more). </p><p> Important items to consider: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Switching capacity of the device</p></li><li class="listitem"><p>Number of systems connected</p></li><li class="listitem"><p>Uplink capacity</p></li></ul></div><p>
    </p><div class="section" title="14.2.1.&nbsp;Single Switch"><div class="titlepage"><div><div><h3 class="title"><a name="perf.network.1switch"></a>14.2.1.&nbsp;Single Switch</h3></div></div></div><p>The single most important factor in this configuration is that the switching capacity of
        the hardware is capable of handling the traffic which can be generated by all systems
        connected to the switch. Some lower priced commodity hardware can have a slower switching
        capacity than could be utilized by a full switch. </p></div><div class="section" title="14.2.2.&nbsp;Multiple Switches"><div class="titlepage"><div><div><h3 class="title"><a name="perf.network.2switch"></a>14.2.2.&nbsp;Multiple Switches</h3></div></div></div><p>Multiple switches are a potential pitfall in the architecture. The most common
        configuration of lower priced hardware is a simple 1Gbps uplink from one switch to another.
        This often overlooked pinch point can easily become a bottleneck for cluster communication.
        Especially with MapReduce jobs that are both reading and writing a lot of data the
        communication across this uplink could be saturated. </p><p>Mitigation of this issue is fairly simple and can be accomplished in multiple ways: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use appropriate hardware for the scale of the cluster which you're attempting to
            build.</p></li><li class="listitem"><p>Use larger single switch configurations i.e. single 48 port as opposed to 2x 24
            port</p></li><li class="listitem"><p>Configure port trunking for uplinks to utilize multiple interfaces to increase cross
            switch bandwidth.</p></li></ul></div></div><div class="section" title="14.2.3.&nbsp;Multiple Racks"><div class="titlepage"><div><div><h3 class="title"><a name="perf.network.multirack"></a>14.2.3.&nbsp;Multiple Racks</h3></div></div></div><p>Multiple rack configurations carry the same potential issues as multiple switches, and
        can suffer performance degradation from two main areas: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Poor switch capacity performance</p></li><li class="listitem"><p>Insufficient uplink to another rack</p></li></ul></div><p>If the the switches in your rack have appropriate switching capacity to handle all the
        hosts at full speed, the next most likely issue will be caused by homing more of your
        cluster across racks. The easiest way to avoid issues when spanning multiple racks is to use
        port trunking to create a bonded uplink to other racks. The downside of this method however,
        is in the overhead of ports that could potentially be used. An example of this is, creating
        an 8Gbps port channel from rack A to rack B, using 8 of your 24 ports to communicate between
        racks gives you a poor ROI, using too few however can mean you're not getting the most out
        of your cluster. </p><p>Using 10Gbe links between racks will greatly increase performance, and assuming your
        switches support a 10Gbe uplink or allow for an expansion card will allow you to save your
        ports for machines as opposed to uplinks. </p></div><div class="section" title="14.2.4.&nbsp;Network Interfaces"><div class="titlepage"><div><div><h3 class="title"><a name="perf.network.ints"></a>14.2.4.&nbsp;Network Interfaces</h3></div></div></div><p>Are all the network interfaces functioning correctly? Are you sure? See the
        Troubleshooting Case Study in <a class="xref" href="#casestudies.slownode" title="16.3.1.&nbsp;Case Study #1 (Performance Issue On A Single Node)">Section&nbsp;16.3.1, &#8220;Case Study #1 (Performance Issue On A Single Node)&#8221;</a>. </p></div></div><div class="section" title="14.3.&nbsp;Java"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jvm"></a>14.3.&nbsp;Java</h2></div></div></div><div class="section" title="14.3.1.&nbsp;The Garbage Collector and Apache HBase"><div class="titlepage"><div><div><h3 class="title"><a name="gc"></a>14.3.1.&nbsp;The Garbage Collector and Apache HBase</h3></div></div></div><div class="section" title="14.3.1.1.&nbsp;Long GC pauses"><div class="titlepage"><div><div><h4 class="title"><a name="gcpause"></a>14.3.1.1.&nbsp;Long GC pauses</h4></div></div></div><p><a name="mslab"></a>In his presentation, <a class="link" href="http://www.slideshare.net/cloudera/hbase-hug-presentation" target="_top">Avoiding Full GCs
            with MemStore-Local Allocation Buffers</a>, Todd Lipcon describes two cases of
          stop-the-world garbage collections common in HBase, especially during loading; CMS failure
          modes and old generation heap fragmentation brought. To address the first, start the CMS
          earlier than default by adding <code class="code">-XX:CMSInitiatingOccupancyFraction</code> and setting
          it down from defaults. Start at 60 or 70 percent (The lower you bring down the threshold,
          the more GCing is done, the more CPU used). To address the second fragmentation issue,
          Todd added an experimental facility, <a class="indexterm" name="d2875e14089"></a>, that
          must be explicitly enabled in Apache HBase 0.90.x (Its defaulted to be on in Apache 0.92.x
          HBase). See <code class="code">hbase.hregion.memstore.mslab.enabled</code> to true in your
            <code class="classname">Configuration</code>. See the cited slides for background and detail.
          The latest jvms do better regards fragmentation so make sure you are running a recent
          release. Read down in the message, <a class="link" href="http://osdir.com/ml/hotspot-gc-use/2011-11/msg00002.html" target="_top">Identifying
            concurrent mode failures caused by fragmentation</a>. Be aware that when enabled,
          each MemStore instance will occupy at least an MSLAB instance of memory. If you have
          thousands of regions or lots of regions each with many column families, this allocation of
          MSLAB may be responsible for a good portion of your heap allocation and in an extreme case
          cause you to OOME. Disable MSLAB in this case, or lower the amount of memory it uses or
          float less regions per server. </p><p>If you have a write-heavy workload, check out <a class="link" href="https://issues.apache.org/jira/browse/HBASE-8163" target="_top">HBASE-8163
            MemStoreChunkPool: An improvement for JAVA GC when using MSLAB</a>. It describes
          configurations to lower the amount of young GC during write-heavy loadings. If you do not
          have HBASE-8163 installed, and you are trying to improve your young GC times, one trick to
          consider -- courtesy of our Liang Xie -- is to set the GC config
            <code class="varname">-XX:PretenureSizeThreshold</code> in <code class="filename">hbase-env.sh</code> to be
          just smaller than the size of <code class="varname">hbase.hregion.memstore.mslab.chunksize</code> so
          MSLAB allocations happen in the tenured space directly rather than first in the young gen.
          You'd do this because these MSLAB allocations are going to likely make it to the old gen
          anyways and rather than pay the price of a copies between s0 and s1 in eden space followed
          by the copy up from young to old gen after the MSLABs have achieved sufficient tenure,
          save a bit of YGC churn and allocate in the old gen directly. </p><p>For more information about GC logs, see <a class="xref" href="#trouble.log.gc" title="15.2.3.&nbsp;JVM Garbage Collection Logs">Section&nbsp;15.2.3, &#8220;JVM Garbage Collection Logs&#8221;</a>. </p><p>Consider also enabling the offheap Block Cache.  This has been shown to mitigate
        GC pause times.  See <a class="xref" href="#block.cache" title="9.6.4.&nbsp;Block Cache">Section&nbsp;9.6.4, &#8220;Block Cache&#8221;</a></p></div></div></div><div class="section" title="14.4.&nbsp;HBase Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.configurations"></a>14.4.&nbsp;HBase Configurations</h2></div></div></div><p>See <a class="xref" href="#recommended_configurations" title="2.6.2.&nbsp;Recommended Configurations">Section&nbsp;2.6.2, &#8220;Recommended Configurations&#8221;</a>.</p><div class="section" title="14.4.1.&nbsp;Managing Compactions"><div class="titlepage"><div><div><h3 class="title"><a name="perf.compactions.and.splits"></a>14.4.1.&nbsp;Managing Compactions</h3></div></div></div><p>For larger systems, managing <a class="link" href="#disable.splitting" title="2.6.2.7.&nbsp;Managed Splitting">compactions and splits</a> may be
      something you want to consider.</p></div><div class="section" title="14.4.2.&nbsp;hbase.regionserver.handler.count"><div class="titlepage"><div><div><h3 class="title"><a name="perf.handlers"></a>14.4.2.&nbsp;<code class="varname">hbase.regionserver.handler.count</code></h3></div></div></div><p>See <a class="xref" href="#hbase.regionserver.handler.count" title="hbase.regionserver.handler.count"><code class="varname">hbase.regionserver.handler.count</code></a>.
	    </p></div><div class="section" title="14.4.3.&nbsp;hfile.block.cache.size"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hfile.block.cache.size"></a>14.4.3.&nbsp;<code class="varname">hfile.block.cache.size</code></h3></div></div></div><p>See <a class="xref" href="#hfile.block.cache.size" title="hfile.block.cache.size"><code class="varname">hfile.block.cache.size</code></a>.
        A memory setting for the RegionServer process.
        </p></div><div class="section" title="14.4.4.&nbsp;Prefetch Option for Blockcache"><div class="titlepage"><div><div><h3 class="title"><a name="blockcache.prefetch"></a>14.4.4.&nbsp;Prefetch Option for Blockcache</h3></div></div></div><p><a class="link" href="https://issues.apache.org/jira/browse/HBASE-9857" target="_top">HBASE-9857</a>
        adds a new option to prefetch HFile contents when opening the blockcache, if a columnfamily
        or regionserver property is set. This option is available for HBase 0.98.3 and later. The
        purpose is to warm the blockcache as rapidly as possible after the cache is opened, using
        in-memory table data, and not counting the prefetching as cache misses. This is great for
        fast reads, but is not a good idea if the data to be preloaded will not fit into the
        blockcache. It is useful for tuning the IO impact of prefetching versus the time before all
        data blocks are in cache. </p><p>To enable prefetching on a given column family, you can use HBase Shell or use the
        API.</p><div class="example"><a name="d2875e14163"></a><p class="title"><b>Example&nbsp;14.1.&nbsp;Enable Prefetch Using HBase Shell</b></p><div class="example-contents"><pre class="screen">hbase&gt; create 'MyTable', { NAME =&gt; 'myCF', PREFETCH_BLOCKS_ON_OPEN =&gt; 'true' }</pre></div></div><br class="example-break"><div class="example"><a name="d2875e14168"></a><p class="title"><b>Example&nbsp;14.2.&nbsp;Enable Prefetch Using the API</b></p><div class="example-contents"><pre class="programlisting">
// ...
HTableDescriptor tableDesc = new HTableDescriptor("myTable");
HColumnDescriptor cfDesc = new HColumnDescriptor("myCF");
cfDesc.setPrefetchBlocksOnOpen(true);
tableDesc.addFamily(cfDesc);
// ...        
        </pre></div></div><br class="example-break"><p>See the API documentation for <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html" target="_top">CacheConfig</a>.</p></div><div class="section" title="14.4.5.&nbsp;hbase.regionserver.global.memstore.size"><div class="titlepage"><div><div><h3 class="title"><a name="perf.rs.memstore.size"></a>14.4.5.&nbsp;<code class="varname">hbase.regionserver.global.memstore.size</code></h3></div></div></div><p>See <a class="xref" href="#">???</a>.
        This memory setting is often adjusted for the RegionServer process depending on needs.
        </p></div><div class="section" title="14.4.6.&nbsp;hbase.regionserver.global.memstore.size.lower.limit"><div class="titlepage"><div><div><h3 class="title"><a name="perf.rs.memstore.size.lower.limit"></a>14.4.6.&nbsp;<code class="varname">hbase.regionserver.global.memstore.size.lower.limit</code></h3></div></div></div><p>See <a class="xref" href="#">???</a>.
        This memory setting is often adjusted for the RegionServer process depending on needs.
        </p></div><div class="section" title="14.4.7.&nbsp;hbase.hstore.blockingStoreFiles"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hstore.blockingstorefiles"></a>14.4.7.&nbsp;<code class="varname">hbase.hstore.blockingStoreFiles</code></h3></div></div></div><p>See <a class="xref" href="#hbase.hstore.blockingStoreFiles" title="hbase.hstore.blockingStoreFiles"><code class="varname">hbase.hstore.blockingStoreFiles</code></a>.
        If there is blocking in the RegionServer logs, increasing this can help.
        </p></div><div class="section" title="14.4.8.&nbsp;hbase.hregion.memstore.block.multiplier"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hregion.memstore.block.multiplier"></a>14.4.8.&nbsp;<code class="varname">hbase.hregion.memstore.block.multiplier</code></h3></div></div></div><p>See <a class="xref" href="#hbase.hregion.memstore.block.multiplier" title="hbase.hregion.memstore.block.multiplier"><code class="varname">hbase.hregion.memstore.block.multiplier</code></a>.
        If there is enough RAM, increasing this can help.
        </p></div><div class="section" title="14.4.9.&nbsp;hbase.regionserver.checksum.verify"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.regionserver.checksum.verify"></a>14.4.9.&nbsp;<code class="varname">hbase.regionserver.checksum.verify</code></h3></div></div></div><p>Have HBase write the checksum into the datablock and save
        having to do the checksum seek whenever you read.</p><p>See <a class="xref" href="#hbase.regionserver.checksum.verify" title="hbase.regionserver.checksum.verify"><code class="varname">hbase.regionserver.checksum.verify</code></a>,
        <a class="xref" href="#hbase.hstore.bytes.per.checksum" title="hbase.hstore.bytes.per.checksum"><code class="varname">hbase.hstore.bytes.per.checksum</code></a> and <a class="xref" href="#hbase.hstore.checksum.algorithm" title="hbase.hstore.checksum.algorithm"><code class="varname">hbase.hstore.checksum.algorithm</code></a>
        For more information see the
        release note on <a class="link" href="https://issues.apache.org/jira/browse/HBASE-5074" target="_top">HBASE-5074 support checksums in HBase block cache</a>.
        </p></div><div class="section" title="14.4.10.&nbsp;Tuning callQueue Options"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e14227"></a>14.4.10.&nbsp;Tuning <code class="code">callQueue</code> Options</h3></div></div></div><p><a class="link" href="https://issues.apache.org/jira/browse/HBASE-11355" target="_top">HBASE-11355</a>
        introduces several callQueue tuning mechanisms which can increase performance. See the JIRA
        for some benchmarking information.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>To increase the number of callqueues, set
              <code class="option">hbase.ipc.server.num.callqueue</code> to a value greater than
              <code class="literal">1</code>.</p></li><li class="listitem"><p>To split the callqueue into separate read and write queues, set
              <code class="code">hbase.ipc.server.callqueue.read.ratio</code> to a value between
              <code class="literal">0</code> and <code class="literal">1</code>. This factor weights the queues toward
            writes (if below .5) or reads (if above .5). Another way to say this is that the factor
            determines what percentage of the split queues are used for reads. The following
            examples illustrate some of the possibilities. Note that you always have at least one
            write queue, no matter what setting you use.</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>The default value of <code class="literal">0</code> does not split the queue.</p></li><li class="listitem"><p>A value of <code class="literal">.3</code> uses 30% of the queues for reading and 60% for
                writing. Given a value of <code class="literal">10</code> for
                  <code class="option">hbase.ipc.server.num.callqueue</code>, 3 queues would be used for reads
                and 7 for writes.</p></li><li class="listitem"><p>A value of <code class="literal">.5</code> uses the same number of read queues and write
                queues. Given a value of <code class="literal">10</code> for
                <code class="option">hbase.ipc.server.num.callqueue</code>, 5 queues would be used for reads
                and 5 for writes.</p></li><li class="listitem"><p>A value of <code class="literal">.6</code> uses 60% of the queues for reading and 30% for
                reading. Given a value of <code class="literal">10</code> for
                <code class="option">hbase.ipc.server.num.callqueue</code>, 7 queues would be used for reads
                and 3 for writes.</p></li><li class="listitem"><p>A value of <code class="literal">1.0</code> uses one queue to process write requests, and
                all other queues process read requests. A value higher than <code class="literal">1.0</code>
                has the same effect as a value of <code class="literal">1.0</code>. Given a value of
                  <code class="literal">10</code> for <code class="option">hbase.ipc.server.num.callqueue</code>, 9
                queues would be used for reads and 1 for writes.</p></li></ul></div></li><li class="listitem"><p>You can also split the read queues so that separate queues are used for short reads
            (from Get operations) and long reads (from Scan operations), by setting the
              <code class="option">hbase.ipc.server.callqueue.scan.ratio</code> option. This option is a factor
            between 0 and 1, which determine the ratio of read queues used for Gets and Scans. More
            queues are used for Gets if the value is below <code class="literal">.5</code> and more are used
            for scans if the value is above <code class="literal">.5</code>. No matter what setting you use,
            at least one read queue is used for Get operations.</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>A value of <code class="literal">0</code> does not split the read queue.</p></li><li class="listitem"><p>A value of <code class="literal">.3</code> uses 60% of the read queues for Gets and 30%
                for Scans. Given a value of <code class="literal">20</code> for
                  <code class="option">hbase.ipc.server.num.callqueue</code> and a value of <code class="literal">.5
                </code> for <code class="option">hbase.ipc.server.callqueue.read.ratio</code>, 10 queues
                would be used for reads, out of those 10, 7 would be used for Gets and 3 for
                Scans.</p></li><li class="listitem"><p>A value of <code class="literal">.5</code> uses half the read queues for Gets and half for
                Scans. Given a value of <code class="literal">20</code> for
                  <code class="option">hbase.ipc.server.num.callqueue</code> and a value of <code class="literal">.5
                </code> for <code class="option">hbase.ipc.server.callqueue.read.ratio</code>, 10 queues
                would be used for reads, out of those 10, 5 would be used for Gets and 5 for
                Scans.</p></li><li class="listitem"><p>A value of <code class="literal">.6</code> uses 30% of the read queues for Gets and 60%
                for Scans. Given a value of <code class="literal">20</code> for
                  <code class="option">hbase.ipc.server.num.callqueue</code> and a value of <code class="literal">.5
                </code> for <code class="option">hbase.ipc.server.callqueue.read.ratio</code>, 10 queues
                would be used for reads, out of those 10, 3 would be used for Gets and 7 for
                Scans.</p></li><li class="listitem"><p>A value of <code class="literal">1.0</code> uses all but one of the read queues for Scans.
                Given a value of <code class="literal">20</code> for
                  <code class="option">hbase.ipc.server.num.callqueue</code> and a value of <code class="literal">.5
                </code> for <code class="option">hbase.ipc.server.callqueue.read.ratio</code>, 10 queues
                would be used for reads, out of those 10, 1 would be used for Gets and 9 for
                Scans.</p></li></ul></div></li><li class="listitem"><p>You can use the new option
              <code class="option">hbase.ipc.server.callqueue.handler.factor</code> to programmatically tune
            the number of queues:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>A value of <code class="literal">0</code> uses a single shared queue between all the
                handlers.</p></li><li class="listitem"><p>A value of <code class="literal">1</code> uses a separate queue for each handler.</p></li><li class="listitem"><p>A value between <code class="literal">0</code> and <code class="literal">1</code> tunes the number
                of queues against the number of handlers. For instance, a value of
                  <code class="literal">.5</code> shares one queue between each two handlers.</p></li></ul></div><p>Having more queues, such as in a situation where you have one queue per handler,
            reduces contention when adding a task to a queue or selecting it from a queue. The
            trade-off is that if you have some queues with long-running tasks, a handler may end up
            waiting to execute from that queue rather than processing another queue which has
            waiting tasks.</p></li></ul></div><p>For these values to take effect on a given Region Server, the Region Server must be
        restarted. These parameters are intended for testing purposes and should be used
        carefully.</p></div></div><div class="section" title="14.5.&nbsp;ZooKeeper"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.zookeeper"></a>14.5.&nbsp;ZooKeeper</h2></div></div></div><p>See <a class="xref" href="#zookeeper" title="Chapter&nbsp;20.&nbsp;ZooKeeper">Chapter&nbsp;20, <i>ZooKeeper</i></a> for information on configuring ZooKeeper, and see the part about
      having a dedicated disk. </p></div><div class="section" title="14.6.&nbsp;Schema Design"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.schema"></a>14.6.&nbsp;Schema Design</h2></div></div></div><div class="section" title="14.6.1.&nbsp;Number of Column Families"><div class="titlepage"><div><div><h3 class="title"><a name="perf.number.of.cfs"></a>14.6.1.&nbsp;Number of Column Families</h3></div></div></div><p>See <a class="xref" href="#number.of.cfs" title="6.2.&nbsp; On the number of column families">Section&nbsp;6.2, &#8220; On the number of column families &#8221;</a>.</p></div><div class="section" title="14.6.2.&nbsp;Key and Attribute Lengths"><div class="titlepage"><div><div><h3 class="title"><a name="perf.schema.keys"></a>14.6.2.&nbsp;Key and Attribute Lengths</h3></div></div></div><p>See <a class="xref" href="#keysize" title="6.3.3.&nbsp;Try to minimize row and column sizes">Section&nbsp;6.3.3, &#8220;Try to minimize row and column sizes&#8221;</a>. See also <a class="xref" href="#perf.compression.however" title="14.6.7.1.&nbsp;However...">Section&nbsp;14.6.7.1, &#8220;However...&#8221;</a> for compression caveats.</p></div><div class="section" title="14.6.3.&nbsp;Table RegionSize"><div class="titlepage"><div><div><h3 class="title"><a name="schema.regionsize"></a>14.6.3.&nbsp;Table RegionSize</h3></div></div></div><p>The regionsize can be set on a per-table basis via <code class="code">setFileSize</code> on <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HTableDescriptor.html" target="_top">HTableDescriptor</a>
        in the event where certain tables require different regionsizes than the configured default
        regionsize. </p><p>See <a class="xref" href="#ops.capacity.regions" title="17.9.2.&nbsp;Determining region count and size">Section&nbsp;17.9.2, &#8220;Determining region count and size&#8221;</a> for more information. </p></div><div class="section" title="14.6.4.&nbsp;Bloom Filters"><div class="titlepage"><div><div><h3 class="title"><a name="schema.bloom"></a>14.6.4.&nbsp;Bloom Filters</h3></div></div></div><p>A Bloom filter, named for its creator, Burton Howard Bloom, is a data structure which is
        designed to predict whether a given element is a member of a set of data. A positive result
        from a Bloom filter is not always accurate, but a negative result is guaranteed to be
        accurate. Bloom filters are designed to be "accurate enough" for sets of data which are so
        large that conventional hashing mechanisms would be impractical. For more information about
        Bloom filters in general, refer to <a class="link" href="http://en.wikipedia.org/wiki/Bloom_filter" target="_top">http://en.wikipedia.org/wiki/Bloom_filter</a>.</p><p>In terms of HBase, Bloom filters provide a lightweight in-memory structure to reduce the
        number of disk reads for a given Get operation (Bloom filters do not work with Scans) to only the StoreFiles likely to
        contain the desired Row. The potential performance gain increases with the number of
        parallel reads. </p><p>The Bloom filters themselves are stored in the metadata of each HFile and never need to
        be updated. When an HFile is opened because a region is deployed to a RegionServer, the
        Bloom filter is loaded into memory. </p><p>HBase includes some tuning mechanisms for folding the Bloom filter to reduce the size
        and keep the false positive rate within a desired range.</p><p>Bloom filters were introduced in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1200" target="_top">HBASE-1200</a>. Since
        HBase 0.96, row-based Bloom filters are enabled by default. (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-8450" target="_top">HBASE-</a>)</p><p>For more information on Bloom filters in relation to HBase, see <a class="xref" href="#blooms" title="14.9.9.&nbsp;Bloom Filters">Section&nbsp;14.9.9, &#8220;Bloom Filters&#8221;</a> for more information, or the following Quora discussion: <a class="link" href="http://www.quora.com/How-are-bloom-filters-used-in-HBase" target="_top">How are bloom
          filters used in HBase?</a>. </p><div class="section" title="14.6.4.1.&nbsp;When To Use Bloom Filters"><div class="titlepage"><div><div><h4 class="title"><a name="bloom.filters.when"></a>14.6.4.1.&nbsp;When To Use Bloom Filters</h4></div></div></div><p>Since HBase 0.96, row-based Bloom filters are enabled by default. You may choose to
          disable them or to change some tables to use row+column Bloom filters, depending on the
          characteristics of your data and how it is loaded into HBase.</p><p>To determine whether Bloom filters could have a positive impact, check the value of
          <code class="code">blockCacheHitRatio</code> in the RegionServer metrics. If Bloom filters are enabled, the value of
          <code class="code">blockCacheHitRatio</code> should increase, because the Bloom filter is filtering out blocks that
          are definitely not needed. </p><p>You can choose to enable Bloom filters for a row or for a row+column combination. If
          you generally scan entire rows, the row+column combination will not provide any benefit. A
          row-based Bloom filter can operate on a row+column Get, but not the other way around.
          However, if you have a large number of column-level Puts, such that a row may be present
          in every StoreFile, a row-based filter will always return a positive result and provide no
          benefit. Unless you have one column per row, row+column Bloom filters require more space,
          in order to store more keys. Bloom filters work best when the size of each data entry is
          at least a few kilobytes in size. </p><p>Overhead will be reduced when your data is stored in a few larger StoreFiles, to avoid
          extra disk IO during low-level scans to find a specific row. </p><p>Bloom filters need to be rebuilt upon deletion, so may not be appropriate in
          environments with a large number of deletions.</p></div><div class="section" title="14.6.4.2.&nbsp;Enabling Bloom Filters"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e14534"></a>14.6.4.2.&nbsp;Enabling Bloom Filters</h4></div></div></div><p>Bloom filters are enabled on a Column Family. You can do this by using the
          setBloomFilterType method of HColumnDescriptor or using the HBase API. Valid values are
            <code class="literal">NONE</code> (the default), <code class="literal">ROW</code>, or
            <code class="literal">ROWCOL</code>. See <a class="xref" href="#bloom.filters.when" title="14.6.4.1.&nbsp;When To Use Bloom Filters">Section&nbsp;14.6.4.1, &#8220;When To Use Bloom Filters&#8221;</a> for more information on <code class="literal">ROW</code> versus
            <code class="literal">ROWCOL</code>. See also the API documentation for <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>.</p><p>The following example creates a table and enables a ROWCOL Bloom filter on the
            <code class="literal">colfam1</code> column family.</p><pre class="screen">
hbase&gt; <strong class="userinput"><code>create 'mytable',{NAME =&gt; 'colfam1', BLOOMFILTER =&gt; 'ROWCOL'}</code></strong>          
        </pre></div><div class="section" title="14.6.4.3.&nbsp;Configuring Server-Wide Behavior of Bloom Filters"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e14569"></a>14.6.4.3.&nbsp;Configuring Server-Wide Behavior of Bloom Filters</h4></div></div></div><p>You can configure the following settings in the <code class="filename">hbase-site.xml</code>.
        </p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><p><code class="code">io.hfile.bloom.enabled</code></p></td><td><p><code class="literal">yes</code></p></td><td><p>Set to <code class="literal">no</code> to kill bloom filters server-wide if
                    something goes wrong</p></td></tr><tr><td><p><code class="code">io.hfile.bloom.error.rate</code></p></td><td><p><code class="literal">.01</code></p></td><td><p>The average false positive rate for bloom filters. Folding is used to
                  maintain the false positive rate. Expressed as a decimal representation of a
                  percentage.</p></td></tr><tr><td><p><code class="code">io.hfile.bloom.max.fold</code></p></td><td><p><code class="literal">7</code></p></td><td><p>The guaranteed maximum fold rate. Changing this setting should not be
                  necessary and is not recommended.</p></td></tr><tr><td><p><code class="code">io.storefile.bloom.max.keys</code></p></td><td><p><code class="literal">128000000</code></p></td><td><p>For default (single-block) Bloom filters, this specifies the maximum
                    number of keys.</p></td></tr><tr><td><p><code class="code">io.storefile.delete.family.bloom.enabled</code></p></td><td><p><code class="literal">true</code></p></td><td><p>Master switch to enable Delete Family Bloom filters and store them in
                  the StoreFile.</p></td></tr><tr><td><p><code class="code">io.storefile.bloom.block.size</code></p></td><td><p><code class="literal">65536</code></p></td><td><p>Target Bloom block size. Bloom filter blocks of approximately this size
                    are interleaved with data blocks.</p></td></tr><tr><td><p><code class="code">hfile.block.bloom.cacheonwrite</code></p></td><td><p><code class="literal">false</code></p></td><td><p>Enables cache-on-write for inline blocks of a compound Bloom filter.</p></td></tr></tbody></table></div></div></div><div class="section" title="14.6.5.&nbsp;ColumnFamily BlockSize"><div class="titlepage"><div><div><h3 class="title"><a name="schema.cf.blocksize"></a>14.6.5.&nbsp;ColumnFamily BlockSize</h3></div></div></div><p>The blocksize can be configured for each ColumnFamily in a table, and this defaults to
        64k. Larger cell values require larger blocksizes. There is an inverse relationship between
        blocksize and the resulting StoreFile indexes (i.e., if the blocksize is doubled then the
        resulting indexes should be roughly halved). </p><p>See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>
        and <a class="xref" href="#store" title="9.7.7.&nbsp;Store">Section&nbsp;9.7.7, &#8220;Store&#8221;</a>for more information. </p></div><div class="section" title="14.6.6.&nbsp;In-Memory ColumnFamilies"><div class="titlepage"><div><div><h3 class="title"><a name="cf.in.memory"></a>14.6.6.&nbsp;In-Memory ColumnFamilies</h3></div></div></div><p>ColumnFamilies can optionally be defined as in-memory. Data is still persisted to disk,
        just like any other ColumnFamily. In-memory blocks have the highest priority in the <a class="xref" href="#block.cache" title="9.6.4.&nbsp;Block Cache">Section&nbsp;9.6.4, &#8220;Block Cache&#8221;</a>, but it is not a guarantee that the entire table will be in
        memory. </p><p>See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html" target="_top">HColumnDescriptor</a>
        for more information. </p></div><div class="section" title="14.6.7.&nbsp;Compression"><div class="titlepage"><div><div><h3 class="title"><a name="perf.compression"></a>14.6.7.&nbsp;Compression</h3></div></div></div><p>Production systems should use compression with their ColumnFamily definitions. See <a class="xref" href="#compression" title="Appendix&nbsp;E.&nbsp;Compression and Data Block Encoding In HBase">Appendix&nbsp;E, <i>Compression and Data Block Encoding In
          HBase</i></a> for more information. </p><div class="section" title="14.6.7.1.&nbsp;However..."><div class="titlepage"><div><div><h4 class="title"><a name="perf.compression.however"></a>14.6.7.1.&nbsp;However...</h4></div></div></div><p>Compression deflates data <span class="emphasis"><em>on disk</em></span>. When it's in-memory (e.g., in
          the MemStore) or on the wire (e.g., transferring between RegionServer and Client) it's
          inflated. So while using ColumnFamily compression is a best practice, but it's not going
          to completely eliminate the impact of over-sized Keys, over-sized ColumnFamily names, or
          over-sized Column names. </p><p>See <a class="xref" href="#keysize" title="6.3.3.&nbsp;Try to minimize row and column sizes">Section&nbsp;6.3.3, &#8220;Try to minimize row and column sizes&#8221;</a> on for schema design tips, and <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a> for more information on HBase stores data internally. </p></div></div></div><div class="section" title="14.7.&nbsp;HBase General Patterns"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.general"></a>14.7.&nbsp;HBase General Patterns</h2></div></div></div><div class="section" title="14.7.1.&nbsp;Constants"><div class="titlepage"><div><div><h3 class="title"><a name="perf.general.constants"></a>14.7.1.&nbsp;Constants</h3></div></div></div><p>When people get started with HBase they have a tendency to write code that looks like
        this:</p><pre class="programlisting">
Get get = new Get(rowkey);
Result r = htable.get(get);
byte[] b = r.getValue(Bytes.toBytes("cf"), Bytes.toBytes("attr"));  // returns current version of value
      </pre><p>But especially when inside loops (and MapReduce jobs), converting the columnFamily and
        column-names to byte-arrays repeatedly is surprisingly expensive. It's better to use
        constants for the byte-arrays, like this:</p><pre class="programlisting">
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Get get = new Get(rowkey);
Result r = htable.get(get);
byte[] b = r.getValue(CF, ATTR);  // returns current version of value
      </pre></div></div><div class="section" title="14.8.&nbsp;Writing to HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.writing"></a>14.8.&nbsp;Writing to HBase</h2></div></div></div><div class="section" title="14.8.1.&nbsp;Batch Loading"><div class="titlepage"><div><div><h3 class="title"><a name="perf.batch.loading"></a>14.8.1.&nbsp;Batch Loading</h3></div></div></div><p>Use the bulk load tool if you can. See <a class="xref" href="#arch.bulk.load" title="9.8.&nbsp;Bulk Loading">Section&nbsp;9.8, &#8220;Bulk Loading&#8221;</a>. Otherwise, pay attention to the below. </p></div><div class="section" title="14.8.2.&nbsp; Table Creation: Pre-Creating Regions"><div class="titlepage"><div><div><h3 class="title"><a name="precreate.regions"></a>14.8.2.&nbsp; Table Creation: Pre-Creating Regions </h3></div></div></div><p> Tables in HBase are initially created with one region by default. For bulk imports,
        this means that all clients will write to the same region until it is large enough to split
        and become distributed across the cluster. A useful pattern to speed up the bulk import
        process is to pre-create empty regions. Be somewhat conservative in this, because too-many
        regions can actually degrade performance. </p><p>There are two different approaches to pre-creating splits. The first approach is to rely
        on the default <code class="code">HBaseAdmin</code> strategy (which is implemented in
          <code class="code">Bytes.split</code>)... </p><pre class="programlisting">
byte[] startKey = ...;   	// your lowest key
byte[] endKey = ...;   		// your highest key
int numberOfRegions = ...;	// # of regions to create
admin.createTable(table, startKey, endKey, numberOfRegions);
      </pre><p>And the other approach is to define the splits yourself... </p><pre class="programlisting">
byte[][] splits = ...;   // create your own splits
admin.createTable(table, splits);
</pre><p> See <a class="xref" href="#rowkey.regionsplits" title="6.3.7.&nbsp;Relationship Between RowKeys and Region Splits">Section&nbsp;6.3.7, &#8220;Relationship Between RowKeys and Region Splits&#8221;</a> for issues related to understanding your
        keyspace and pre-creating regions. See <a class="xref" href="#manual_region_splitting_decisions" title="9.7.5.&nbsp;Manual Region Splitting">Section&nbsp;9.7.5, &#8220;Manual Region Splitting&#8221;</a>
        for discussion on manually pre-splitting regions.</p></div><div class="section" title="14.8.3.&nbsp; Table Creation: Deferred Log Flush"><div class="titlepage"><div><div><h3 class="title"><a name="def.log.flush"></a>14.8.3.&nbsp; Table Creation: Deferred Log Flush </h3></div></div></div><p> The default behavior for Puts using the Write Ahead Log (WAL) is that
          <code class="classname">HLog</code> edits will be written immediately. If deferred log flush is
        used, WAL edits are kept in memory until the flush period. The benefit is aggregated and
        asynchronous <code class="classname">HLog</code>- writes, but the potential downside is that if the
        RegionServer goes down the yet-to-be-flushed edits are lost. This is safer, however, than
        not using WAL at all with Puts. </p><p> Deferred log flush can be configured on tables via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HTableDescriptor.html" target="_top">HTableDescriptor</a>.
        The default value of <code class="varname">hbase.regionserver.optionallogflushinterval</code> is
        1000ms. </p></div><div class="section" title="14.8.4.&nbsp;HBase Client: AutoFlush"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.autoflush"></a>14.8.4.&nbsp;HBase Client: AutoFlush</h3></div></div></div><p>When performing a lot of Puts, make sure that setAutoFlush is set to false on your <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>
        instance. Otherwise, the Puts will be sent one at a time to the RegionServer. Puts added via
          <code class="code"> htable.add(Put)</code> and <code class="code"> htable.add( &lt;List&gt; Put)</code> wind up in
        the same write buffer. If <code class="code">autoFlush = false</code>, these messages are not sent until
        the write-buffer is filled. To explicitly flush the messages, call
          <code class="methodname">flushCommits</code>. Calling <code class="methodname">close</code> on the
          <code class="classname">HTable</code> instance will invoke
        <code class="methodname">flushCommits</code>.</p></div><div class="section" title="14.8.5.&nbsp;HBase Client: Turn off WAL on Puts"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.putwal"></a>14.8.5.&nbsp;HBase Client: Turn off WAL on Puts</h3></div></div></div><p>A frequent request is to disable the WAL to increase performance of Puts. This is only
        appropriate for bulk loads, as it puts your data at risk by removing the protection of the
        WAL in the event of a region server crash. Bulk loads can be re-run in the event of a crash,
        with little risk of data loss.</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>If you disable the WAL for anything other than bulk loads, your data is at
          risk.</p></div><p>In general, it is best to use WAL for Puts, and where loading throughput is a concern to
        use <a class="link" href="#perf.batch.loading" title="14.8.1.&nbsp;Batch Loading">bulk loading</a> techniques instead. For normal
        Puts, you are not likely to see a performance improvement which would outweigh the risk. To
        disable the WAL, see <a class="xref" href="#wal.disable" title="9.6.5.4.&nbsp;Disabling the WAL">Section&nbsp;9.6.5.4, &#8220;Disabling the WAL&#8221;</a>.</p></div><div class="section" title="14.8.6.&nbsp;HBase Client: Group Puts by RegionServer"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.regiongroup"></a>14.8.6.&nbsp;HBase Client: Group Puts by RegionServer</h3></div></div></div><p>In addition to using the writeBuffer, grouping <code class="classname">Put</code>s by
        RegionServer can reduce the number of client RPC calls per writeBuffer flush. There is a
        utility <code class="classname">HTableUtil</code> currently on TRUNK that does this, but you can
        either copy that or implement your own version for those still on 0.90.x or earlier. </p></div><div class="section" title="14.8.7.&nbsp;MapReduce: Skip The Reducer"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.write.mr.reducer"></a>14.8.7.&nbsp;MapReduce: Skip The Reducer</h3></div></div></div><p>When writing a lot of data to an HBase table from a MR job (e.g., with <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html" target="_top">TableOutputFormat</a>),
        and specifically where Puts are being emitted from the Mapper, skip the Reducer step. When a
        Reducer step is used, all of the output (Puts) from the Mapper will get spooled to disk,
        then sorted/shuffled to other Reducers that will most likely be off-node. It's far more
        efficient to just write directly to HBase. </p><p>For summary jobs where HBase is used as a source and a sink, then writes will be coming
        from the Reducer step (e.g., summarize values then write out result). This is a different
        processing problem than from the the above case. </p></div><div class="section" title="14.8.8.&nbsp;Anti-Pattern: One Hot Region"><div class="titlepage"><div><div><h3 class="title"><a name="perf.one.region"></a>14.8.8.&nbsp;Anti-Pattern: One Hot Region</h3></div></div></div><p>If all your data is being written to one region at a time, then re-read the section on
        processing <a class="link" href="#timeseries" title="6.3.2.&nbsp; Monotonically Increasing Row Keys/Timeseries Data">timeseries</a> data.</p><p>Also, if you are pre-splitting regions and all your data is <span class="emphasis"><em>still</em></span>
        winding up in a single region even though your keys aren't monotonically increasing, confirm
        that your keyspace actually works with the split strategy. There are a variety of reasons
        that regions may appear "well split" but won't work with your data. As the HBase client
        communicates directly with the RegionServers, this can be obtained via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#getRegionLocation%28byte[]%29" target="_top">HTable.getRegionLocation</a>. </p><p>See <a class="xref" href="#precreate.regions" title="14.8.2.&nbsp; Table Creation: Pre-Creating Regions">Section&nbsp;14.8.2, &#8220; Table Creation: Pre-Creating Regions &#8221;</a>, as well as <a class="xref" href="#perf.configurations" title="14.4.&nbsp;HBase Configurations">Section&nbsp;14.4, &#8220;HBase Configurations&#8221;</a>
      </p></div></div><div class="section" title="14.9.&nbsp;Reading from HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.reading"></a>14.9.&nbsp;Reading from HBase</h2></div></div></div><p>The mailing list can help if you are having performance issues. For example, here is a
      good general thread on what to look at addressing read-time issues: <a class="link" href="http://search-hadoop.com/m/qOo2yyHtCC1" target="_top">HBase Random Read latency &gt;
      100ms</a></p><div class="section" title="14.9.1.&nbsp;Scan Caching"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.caching"></a>14.9.1.&nbsp;Scan Caching</h3></div></div></div><p>If HBase is used as an input source for a MapReduce job, for example, make sure that the
        input <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a>
        instance to the MapReduce job has <code class="methodname">setCaching</code> set to something
        greater than the default (which is 1). Using the default value means that the map-task will
        make call back to the region-server for every record processed. Setting this value to 500,
        for example, will transfer 500 rows at a time to the client to be processed. There is a
        cost/benefit to have the cache value be large because it costs more in memory for both
        client and RegionServer, so bigger isn't always better.</p><div class="section" title="14.9.1.1.&nbsp;Scan Caching in MapReduce Jobs"><div class="titlepage"><div><div><h4 class="title"><a name="perf.hbase.client.caching.mr"></a>14.9.1.1.&nbsp;Scan Caching in MapReduce Jobs</h4></div></div></div><p>Scan settings in MapReduce jobs deserve special attention. Timeouts can result (e.g.,
          UnknownScannerException) in Map tasks if it takes longer to process a batch of records
          before the client goes back to the RegionServer for the next set of data. This problem can
          occur because there is non-trivial processing occuring per row. If you process rows
          quickly, set caching higher. If you process rows more slowly (e.g., lots of
          transformations per row, writes), then set caching lower. </p><p>Timeouts can also happen in a non-MapReduce use case (i.e., single threaded HBase
          client doing a Scan), but the processing that is often performed in MapReduce jobs tends
          to exacerbate this issue. </p></div></div><div class="section" title="14.9.2.&nbsp;Scan Attribute Selection"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.selection"></a>14.9.2.&nbsp;Scan Attribute Selection</h3></div></div></div><p>Whenever a Scan is used to process large numbers of rows (and especially when used as a
        MapReduce source), be aware of which attributes are selected. If <code class="code">scan.addFamily</code>
        is called then <span class="emphasis"><em>all</em></span> of the attributes in the specified ColumnFamily will
        be returned to the client. If only a small number of the available attributes are to be
        processed, then only those attributes should be specified in the input scan because
        attribute over-selection is a non-trivial performance penalty over large datasets. </p></div><div class="section" title="14.9.3.&nbsp;Avoid scan seeks"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.seek"></a>14.9.3.&nbsp;Avoid scan seeks</h3></div></div></div><p>When columns are selected explicitly with <code class="code">scan.addColumn</code>, HBase will
        schedule seek operations to seek between the selected columns. When rows have few columns
        and each column has only a few versions this can be inefficient. A seek operation is
        generally slower if does not seek at least past 5-10 columns/versions or 512-1024
        bytes.</p><p>In order to opportunistically look ahead a few columns/versions to see if the next
        column/version can be found that way before a seek operation is scheduled, a new attribute
          <code class="code">Scan.HINT_LOOKAHEAD</code> can be set the on Scan object. The following code
        instructs the RegionServer to attempt two iterations of next before a seek is
        scheduled:</p><pre class="programlisting">
Scan scan = new Scan();
scan.addColumn(...);
scan.setAttribute(Scan.HINT_LOOKAHEAD, Bytes.toBytes(2));
table.getScanner(scan);
      </pre></div><div class="section" title="14.9.4.&nbsp;MapReduce - Input Splits"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.mr.input"></a>14.9.4.&nbsp;MapReduce - Input Splits</h3></div></div></div><p>For MapReduce jobs that use HBase tables as a source, if there a pattern where the
        "slow" map tasks seem to have the same Input Split (i.e., the RegionServer serving the
        data), see the Troubleshooting Case Study in <a class="xref" href="#casestudies.slownode" title="16.3.1.&nbsp;Case Study #1 (Performance Issue On A Single Node)">Section&nbsp;16.3.1, &#8220;Case Study #1 (Performance Issue On A Single Node)&#8221;</a>. </p></div><div class="section" title="14.9.5.&nbsp;Close ResultScanners"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.scannerclose"></a>14.9.5.&nbsp;Close ResultScanners</h3></div></div></div><p>This isn't so much about improving performance but rather <span class="emphasis"><em>avoiding</em></span>
        performance problems. If you forget to close <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/ResultScanner.html" target="_top">ResultScanners</a>
        you can cause problems on the RegionServers. Always have ResultScanner processing enclosed
        in try/catch blocks...</p><pre class="programlisting">
Scan scan = new Scan();
// set attrs...
ResultScanner rs = htable.getScanner(scan);
try {
  for (Result r = rs.next(); r != null; r = rs.next()) {
  // process result...
} finally {
  rs.close();  // always close the ResultScanner!
}
htable.close();
      </pre></div><div class="section" title="14.9.6.&nbsp;Block Cache"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.blockcache"></a>14.9.6.&nbsp;Block Cache</h3></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">Scan</a>
        instances can be set to use the block cache in the RegionServer via the
          <code class="methodname">setCacheBlocks</code> method. For input Scans to MapReduce jobs, this
        should be <code class="varname">false</code>. For frequently accessed rows, it is advisable to use the
        block cache.</p><p>Cache more data by moving your Block Cache offheap.  See <a class="xref" href="#offheap.blockcache" title="9.6.4.5.&nbsp;Offheap Block Cache">Section&nbsp;9.6.4.5, &#8220;Offheap Block Cache&#8221;</a></p></div><div class="section" title="14.9.7.&nbsp;Optimal Loading of Row Keys"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.client.rowkeyonly"></a>14.9.7.&nbsp;Optimal Loading of Row Keys</h3></div></div></div><p>When performing a table <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html" target="_top">scan</a>
        where only the row keys are needed (no families, qualifiers, values or timestamps), add a
        FilterList with a <code class="varname">MUST_PASS_ALL</code> operator to the scanner using
          <code class="methodname">setFilter</code>. The filter list should include both a <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html" target="_top">FirstKeyOnlyFilter</a>
        and a <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/KeyOnlyFilter.html" target="_top">KeyOnlyFilter</a>.
        Using this filter combination will result in a worst case scenario of a RegionServer reading
        a single value from disk and minimal network traffic to the client for a single row. </p></div><div class="section" title="14.9.8.&nbsp;Concurrency: Monitor Data Spread"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hbase.read.dist"></a>14.9.8.&nbsp;Concurrency: Monitor Data Spread</h3></div></div></div><p>When performing a high number of concurrent reads, monitor the data spread of the target
        tables. If the target table(s) have too few regions then the reads could likely be served
        from too few nodes. </p><p>See <a class="xref" href="#precreate.regions" title="14.8.2.&nbsp; Table Creation: Pre-Creating Regions">Section&nbsp;14.8.2, &#8220; Table Creation: Pre-Creating Regions &#8221;</a>, as well as <a class="xref" href="#perf.configurations" title="14.4.&nbsp;HBase Configurations">Section&nbsp;14.4, &#8220;HBase Configurations&#8221;</a>
      </p></div><div class="section" title="14.9.9.&nbsp;Bloom Filters"><div class="titlepage"><div><div><h3 class="title"><a name="blooms"></a>14.9.9.&nbsp;Bloom Filters</h3></div></div></div><p>Enabling Bloom Filters can save your having to go to disk and can help improve read
        latencies.</p><p><a class="link" href="http://en.wikipedia.org/wiki/Bloom_filter" target="_top">Bloom filters</a> were developed
        over in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1200" target="_top">HBase-1200 Add
          bloomfilters</a>. For description of the development process -- why static blooms rather than dynamic
            -- and for an overview of the unique properties that pertain to blooms in HBase, as well
            as possible future directions, see the <span class="emphasis"><em>Development Process</em></span> section
            of the document <a class="link" href="https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf" target="_top">BloomFilters
              in HBase</a> attached to <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1200" target="_top">HBase-1200</a>.  The bloom filters described here are actually version two of blooms in HBase. In
            versions up to 0.19.x, HBase had a dynamic bloom option based on work done by the <a class="link" href="http://www.one-lab.org" target="_top">European Commission One-Lab Project 034819</a>.
            The core of the HBase bloom work was later pulled up into Hadoop to implement
            org.apache.hadoop.io.BloomMapFile. Version 1 of HBase blooms never worked that well.
            Version 2 is a rewrite from scratch though again it starts with the one-lab work.</p><p>See also <a class="xref" href="#schema.bloom" title="14.6.4.&nbsp;Bloom Filters">Section&nbsp;14.6.4, &#8220;Bloom Filters&#8221;</a>. </p><div class="section" title="14.9.9.1.&nbsp;Bloom StoreFile footprint"><div class="titlepage"><div><div><h4 class="title"><a name="bloom_footprint"></a>14.9.9.1.&nbsp;Bloom StoreFile footprint</h4></div></div></div><p>Bloom filters add an entry to the <code class="classname">StoreFile</code> general
            <code class="classname">FileInfo</code> data structure and then two extra entries to the
            <code class="classname">StoreFile</code> metadata section.</p><div class="section" title="14.9.9.1.1.&nbsp;BloomFilter in the StoreFile FileInfo data structure"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e15038"></a>14.9.9.1.1.&nbsp;BloomFilter in the <code class="classname">StoreFile</code>
            <code class="classname">FileInfo</code> data structure</h5></div></div></div><p><code class="classname">FileInfo</code> has a <code class="varname">BLOOM_FILTER_TYPE</code> entry
            which is set to <code class="varname">NONE</code>, <code class="varname">ROW</code> or
              <code class="varname">ROWCOL.</code></p></div><div class="section" title="14.9.9.1.2.&nbsp;BloomFilter entries in StoreFile metadata"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e15062"></a>14.9.9.1.2.&nbsp;BloomFilter entries in <code class="classname">StoreFile</code> metadata</h5></div></div></div><p><code class="varname">BLOOM_FILTER_META</code> holds Bloom Size, Hash Function used, etc. Its
            small in size and is cached on <code class="classname">StoreFile.Reader</code> load</p><p><code class="varname">BLOOM_FILTER_DATA</code> is the actual bloomfilter data. Obtained
            on-demand. Stored in the LRU cache, if it is enabled (Its enabled by default).</p></div></div><div class="section" title="14.9.9.2.&nbsp;Bloom Filter Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="config.bloom"></a>14.9.9.2.&nbsp;Bloom Filter Configuration</h4></div></div></div><div class="section" title="14.9.9.2.1.&nbsp;io.hfile.bloom.enabled global kill switch"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e15082"></a>14.9.9.2.1.&nbsp;<code class="varname">io.hfile.bloom.enabled</code> global kill switch</h5></div></div></div><p><code class="code">io.hfile.bloom.enabled</code> in <code class="classname">Configuration</code> serves
            as the kill switch in case something goes wrong. Default =
            <code class="varname">true</code>.</p></div><div class="section" title="14.9.9.2.2.&nbsp;io.hfile.bloom.error.rate"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e15097"></a>14.9.9.2.2.&nbsp;<code class="varname">io.hfile.bloom.error.rate</code></h5></div></div></div><p><code class="varname">io.hfile.bloom.error.rate</code> = average false positive rate. Default
            = 1%. Decrease rate by &frac12; (e.g. to .5%) == +1 bit per bloom entry.</p></div><div class="section" title="14.9.9.2.3.&nbsp;io.hfile.bloom.max.fold"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e15105"></a>14.9.9.2.3.&nbsp;<code class="varname">io.hfile.bloom.max.fold</code></h5></div></div></div><p><code class="varname">io.hfile.bloom.max.fold</code> = guaranteed minimum fold rate. Most
            people should leave this alone. Default = 7, or can collapse to at least 1/128th of
            original size. See the <span class="emphasis"><em>Development Process</em></span> section of the document <a class="link" href="https://issues.apache.org/jira/secure/attachment/12444007/Bloom_Filters_in_HBase.pdf" target="_top">BloomFilters
              in HBase</a> for more on what this option means.</p></div></div></div><div class="section" title="14.9.10.&nbsp;Hedged Reads"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e15120"></a>14.9.10.&nbsp;Hedged Reads</h3></div></div></div><p>Hedged reads are a feature of HDFS, introduced in <a class="link" href="https://issues.apache.org/jira/browse/HDFS-5776" target="_top">HDFS-5776</a>. Normally, a
        single thread is spawned for each read request. However, if hedged reads are enabled, the
        client waits some configurable amount of time, and if the read does not return, the client
        spawns a second read request, against a different block replica of the same data. Whichever
        read returns first is used, and the other read request is discarded. Hedged reads can be
        helpful for times where a rare slow read is caused by a transient error such as a failing
        disk or flaky network connection.</p><p> Because a HBase RegionServer is a HDFS client, you can enable hedged reads in HBase, by
        adding the following properties to the RegionServer's hbase-site.xml and tuning the values
        to suit your environment.</p><div class="itemizedlist" title="Configuration for Hedged Reads"><p class="title"><b>Configuration for Hedged Reads</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">dfs.client.hedged.read.threadpool.size</code> - the number of threads
            dedicated to servicing hedged reads. If this is set to 0 (the default), hedged reads are
            disabled.</p></li><li class="listitem"><p><code class="code">dfs.client.hedged.read.threshold.millis</code> - the number of milliseconds to
            wait before spawning a second read thread.</p></li></ul></div><div class="example"><a name="d2875e15143"></a><p class="title"><b>Example&nbsp;14.3.&nbsp;Hedged Reads Configuration Example</b></p><div class="example-contents"><pre class="screen">&lt;property&gt;
  &lt;name&gt;dfs.client.hedged.read.threadpool.size&lt;/name&gt;
  &lt;value&gt;20&lt;/value&gt;  &lt;!-- 20 threads --&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;dfs.client.hedged.read.threshold.millis&lt;/name&gt;
  &lt;value&gt;10&lt;/value&gt;  &lt;!-- 10 milliseconds --&gt;
&lt;/property&gt;</pre></div></div><br class="example-break"><p>Use the following metrics to tune the settings for hedged reads on
        your cluster. See <a class="xref" href="#hbase_metrics" title="17.4.&nbsp;HBase Metrics">Section&nbsp;17.4, &#8220;HBase Metrics&#8221;</a>  for more information.</p><div class="itemizedlist" title="Metrics for Hedged Reads"><p class="title"><b>Metrics for Hedged Reads</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>hedgedReadOps - the number of times hedged read threads have been triggered. This
            could indicate that read requests are often slow, or that hedged reads are triggered too
            quickly.</p></li><li class="listitem"><p>hedgeReadOpsWin - the number of times the hedged read thread was faster than the
            original thread. This could indicate that a given RegionServer is having trouble
            servicing requests.</p></li></ul></div></div></div><div class="section" title="14.10.&nbsp;Deleting from HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.deleting"></a>14.10.&nbsp;Deleting from HBase</h2></div></div></div><div class="section" title="14.10.1.&nbsp;Using HBase Tables as Queues"><div class="titlepage"><div><div><h3 class="title"><a name="perf.deleting.queue"></a>14.10.1.&nbsp;Using HBase Tables as Queues</h3></div></div></div><p>HBase tables are sometimes used as queues. In this case, special care must be taken to
        regularly perform major compactions on tables used in this manner. As is documented in <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a>, marking rows as deleted creates additional StoreFiles which then
        need to be processed on reads. Tombstones only get cleaned up with major compactions. </p><p>See also <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a> and <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact%28java.lang.String%29" target="_top">HBaseAdmin.majorCompact</a>.
      </p></div><div class="section" title="14.10.2.&nbsp;Delete RPC Behavior"><div class="titlepage"><div><div><h3 class="title"><a name="perf.deleting.rpc"></a>14.10.2.&nbsp;Delete RPC Behavior</h3></div></div></div><p>Be aware that <code class="code">htable.delete(Delete)</code> doesn't use the writeBuffer. It will
        execute an RegionServer RPC with each invocation. For a large number of deletes, consider
          <code class="code">htable.delete(List)</code>. </p><p>See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29" target="_top">http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29</a>
      </p></div></div><div class="section" title="14.11.&nbsp;HDFS"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.hdfs"></a>14.11.&nbsp;HDFS</h2></div></div></div><p>Because HBase runs on <a class="xref" href="#arch.hdfs" title="9.9.&nbsp;HDFS">Section&nbsp;9.9, &#8220;HDFS&#8221;</a> it is important to understand how it works and how it affects HBase. </p><div class="section" title="14.11.1.&nbsp;Current Issues With Low-Latency Reads"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hdfs.curr"></a>14.11.1.&nbsp;Current Issues With Low-Latency Reads</h3></div></div></div><p>The original use-case for HDFS was batch processing. As such, there low-latency reads
        were historically not a priority. With the increased adoption of Apache HBase this is
        changing, and several improvements are already in development. See the <a class="link" href="https://issues.apache.org/jira/browse/HDFS-1599" target="_top">Umbrella Jira Ticket for HDFS
          Improvements for HBase</a>. </p></div><div class="section" title="14.11.2.&nbsp;Leveraging local data"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hdfs.configs.localread"></a>14.11.2.&nbsp;Leveraging local data</h3></div></div></div><p>Since Hadoop 1.0.0 (also 0.22.1, 0.23.1, CDH3u3 and HDP 1.0) via <a class="link" href="https://issues.apache.org/jira/browse/HDFS-2246" target="_top">HDFS-2246</a>, it is
        possible for the DFSClient to take a "short circuit" and read directly from the disk instead
        of going through the DataNode when the data is local. What this means for HBase is that the
        RegionServers can read directly off their machine's disks instead of having to open a socket
        to talk to the DataNode, the former being generally much faster. See JD's <a class="link" href="http://files.meetup.com/1350427/hug_ebay_jdcryans.pdf" target="_top">Performance
              Talk</a>. Also see <a class="link" href="http://search-hadoop.com/m/zV6dKrLCVh1" target="_top">HBase, mail # dev - read short
          circuit</a> thread for more discussion around short circuit reads. </p><p>To enable "short circuit" reads, it will depend on your version of Hadoop. The original
        shortcircuit read patch was much improved upon in Hadoop 2 in <a class="link" href="https://issues.apache.org/jira/browse/HDFS-347" target="_top">HDFS-347</a>. See <a class="link" href="http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/" target="_top">http://blog.cloudera.com/blog/2013/08/how-improved-short-circuit-local-reads-bring-better-performance-and-security-to-hadoop/</a>
        for details on the difference between the old and new implementations. See <a class="link" href="http://archive.cloudera.com/cdh4/cdh/4/hadoop/hadoop-project-dist/hadoop-hdfs/ShortCircuitLocalReads.html" target="_top">Hadoop
          shortcircuit reads configuration page</a> for how to enable the latter, better version
        of shortcircuit. For example, here is a minimal config. enabling short-circuit reads added
        to <code class="filename">hbase-site.xml</code>: </p><pre class="programlisting">&lt;property&gt;
  &lt;name&gt;dfs.client.read.shortcircuit&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
  &lt;description&gt;
    This configuration parameter turns on short-circuit local reads.
  &lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;dfs.domain.socket.path&lt;/name&gt;
  &lt;value&gt;/home/stack/sockets/short_circuit_read_socket_PORT&lt;/value&gt;
  &lt;description&gt;
    Optional.  This is a path to a UNIX domain socket that will be used for
    communication between the DataNode and local HDFS clients.
    If the string "_PORT" is present in this path, it will be replaced by the
    TCP port of the DataNode.
  &lt;/description&gt;
&lt;/property&gt;</pre><p>Be careful about permissions for the directory that hosts the shared domain socket;
        dfsclient will complain if open to other than the hbase user. </p><p>If you are running on an old Hadoop, one that is without <a class="link" href="https://issues.apache.org/jira/browse/HDFS-347" target="_top">HDFS-347</a> but that has
          <a class="link" href="https://issues.apache.org/jira/browse/HDFS-2246" target="_top">HDFS-2246</a>, you
        must set two configurations. First, the hdfs-site.xml needs to be amended. Set the property
          <code class="varname">dfs.block.local-path-access.user</code> to be the <span class="emphasis"><em>only</em></span>
        user that can use the shortcut. This has to be the user that started HBase. Then in
        hbase-site.xml, set <code class="varname">dfs.client.read.shortcircuit</code> to be
          <code class="varname">true</code>
      </p><p> Services -- at least the HBase RegionServers -- will need to be restarted in order to
        pick up the new configurations. </p><div class="note" title="dfs.client.read.shortcircuit.buffer.size" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="dfs.client.read.shortcircuit.buffer.size"></a>dfs.client.read.shortcircuit.buffer.size</h3><p>The default for this value is too high when running on a highly trafficed HBase. In
          HBase, if this value has not been set, we set it down from the default of 1M to 128k
          (Since HBase 0.98.0 and 0.96.1). See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-8143" target="_top">HBASE-8143 HBase on Hadoop
            2 with local short circuit reads (ssr) causes OOM</a>). The Hadoop DFSClient in HBase
          will allocate a direct byte buffer of this size for <span class="emphasis"><em>each</em></span> block it has
          open; given HBase keeps its HDFS files open all the time, this can add up quickly.</p></div></div><div class="section" title="14.11.3.&nbsp;Performance Comparisons of HBase vs. HDFS"><div class="titlepage"><div><div><h3 class="title"><a name="perf.hdfs.comp"></a>14.11.3.&nbsp;Performance Comparisons of HBase vs. HDFS</h3></div></div></div><p>A fairly common question on the dist-list is why HBase isn't as performant as HDFS files
        in a batch context (e.g., as a MapReduce source or sink). The short answer is that HBase is
        doing a lot more than HDFS (e.g., reading the KeyValues, returning the most current row or
        specified timestamps, etc.), and as such HBase is 4-5 times slower than HDFS in this
        processing context. There is room for improvement and this gap will, over time, be reduced,
        but HDFS will always be faster in this use-case. </p></div></div><div class="section" title="14.12.&nbsp;Amazon EC2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.ec2"></a>14.12.&nbsp;Amazon EC2</h2></div></div></div><p>Performance questions are common on Amazon EC2 environments because it is a shared
      environment. You will not see the same throughput as a dedicated server. In terms of running
      tests on EC2, run them several times for the same reason (i.e., it's a shared environment and
      you don't know what else is happening on the server). </p><p>If you are running on EC2 and post performance questions on the dist-list, please state
      this fact up-front that because EC2 issues are practically a separate class of performance
      issues. </p></div><div class="section" title="14.13.&nbsp;Collocating HBase and MapReduce"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.hbase.mr.cluster"></a>14.13.&nbsp;Collocating HBase and MapReduce</h2></div></div></div><p>It is often recommended to have different clusters for HBase and MapReduce. A better
      qualification of this is: don't collocate a HBase that serves live requests with a heavy MR
      workload. OLTP and OLAP-optimized systems have conflicting requirements and one will lose to
      the other, usually the former. For example, short latency-sensitive disk reads will have to
      wait in line behind longer reads that are trying to squeeze out as much throughput as
      possible. MR jobs that write to HBase will also generate flushes and compactions, which will
      in turn invalidate blocks in the <a class="xref" href="#block.cache" title="9.6.4.&nbsp;Block Cache">Section&nbsp;9.6.4, &#8220;Block Cache&#8221;</a>. </p><p>If you need to process the data from your live HBase cluster in MR, you can ship the
      deltas with <a class="xref" href="#">???</a> or use replication to get the new data in real time on the OLAP
      cluster. In the worst case, if you really need to collocate both, set MR to use less Map and
      Reduce slots than you'd normally configure, possibly just one. </p><p>When HBase is used for OLAP operations, it's preferable to set it up in a hardened way
      like configuring the ZooKeeper session timeout higher and giving more memory to the MemStores
      (the argument being that the Block Cache won't be used much since the workloads are usually
      long scans). </p></div><div class="section" title="14.14.&nbsp;Case Studies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="perf.casestudy"></a>14.14.&nbsp;Case Studies</h2></div></div></div><p>For Performance and Troubleshooting Case Studies, see <a class="xref" href="#casestudies" title="Chapter&nbsp;16.&nbsp;Apache HBase Case Studies">Chapter&nbsp;16, <i>Apache HBase Case Studies</i></a>. </p></div></div><div class="chapter" title="Chapter&nbsp;15.&nbsp;Troubleshooting and Debugging Apache HBase"><div class="titlepage"><div><div><h2 class="title"><a name="trouble"></a>Chapter&nbsp;15.&nbsp;Troubleshooting and Debugging Apache HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#trouble.general">15.1. General Guidelines</a></span></dt><dt><span class="section"><a href="#trouble.log">15.2. Logs</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.log.locations">15.2.1. Log Locations</a></span></dt><dt><span class="section"><a href="#trouble.log.levels">15.2.2. Log Levels</a></span></dt><dt><span class="section"><a href="#trouble.log.gc">15.2.3. JVM Garbage Collection Logs</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.resources">15.3. Resources</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.resources.searchhadoop">15.3.1. search-hadoop.com</a></span></dt><dt><span class="section"><a href="#trouble.resources.lists">15.3.2. Mailing Lists</a></span></dt><dt><span class="section"><a href="#trouble.resources.irc">15.3.3. IRC</a></span></dt><dt><span class="section"><a href="#trouble.resources.jira">15.3.4. JIRA</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.tools">15.4. Tools</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.tools.builtin">15.4.1. Builtin Tools</a></span></dt><dt><span class="section"><a href="#trouble.tools.external">15.4.2. External Tools</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.client">15.5. Client</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.client.scantimeout">15.5.1. ScannerTimeoutException or UnknownScannerException</a></span></dt><dt><span class="section"><a href="#d2875e15701">15.5.2. Performance Differences in Thrift and Java APIs</a></span></dt><dt><span class="section"><a href="#trouble.client.lease.exception">15.5.3. <code class="classname">LeaseException</code> when calling
        <code class="classname">Scanner.next</code></a></span></dt><dt><span class="section"><a href="#trouble.client.scarylogs">15.5.4. Shell or client application throws lots of scary exceptions during normal
        operation</a></span></dt><dt><span class="section"><a href="#trouble.client.longpauseswithcompression">15.5.5. Long Client Pauses With Compression</a></span></dt><dt><span class="section"><a href="#trouble.client.security.rpc.krb">15.5.6. Secure Client Connect ([Caused by GSSException: No valid credentials provided...])</a></span></dt><dt><span class="section"><a href="#trouble.client.zookeeper">15.5.7. ZooKeeper Client Connection Errors</a></span></dt><dt><span class="section"><a href="#trouble.client.oome.directmemory.leak">15.5.8. Client running out of memory though heap size seems to be stable (but the
        off-heap/direct heap keeps growing)</a></span></dt><dt><span class="section"><a href="#trouble.client.slowdown.admin">15.5.9. Client Slowdown When Calling Admin Methods (flush, compact, etc.)</a></span></dt><dt><span class="section"><a href="#trouble.client.security.rpc">15.5.10. Secure Client Cannot Connect ([Caused by GSSException: No valid credentials provided
        (Mechanism level: Failed to find any Kerberos tgt)])</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.mapreduce">15.6. MapReduce</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.mapreduce.local">15.6.1. You Think You're On The Cluster, But You're Actually Local</a></span></dt><dt><span class="section"><a href="#trouble.hbasezerocopybytestring">15.6.2. Launching a job, you get java.lang.IllegalAccessError: com/google/protobuf/HBaseZeroCopyByteString or class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.namenode">15.7. NameNode</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.namenode.disk">15.7.1. HDFS Utilization of Tables and Regions</a></span></dt><dt><span class="section"><a href="#trouble.namenode.hbase.objects">15.7.2. Browsing HDFS for HBase Objects</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.network">15.8. Network</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.network.spikes">15.8.1. Network Spikes</a></span></dt><dt><span class="section"><a href="#trouble.network.loopback">15.8.2. Loopback IP</a></span></dt><dt><span class="section"><a href="#trouble.network.ints">15.8.3. Network Interfaces</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.rs">15.9. RegionServer</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.rs.startup">15.9.1. Startup Errors</a></span></dt><dt><span class="section"><a href="#trouble.rs.runtime">15.9.2. Runtime Errors</a></span></dt><dt><span class="section"><a href="#d2875e16247">15.9.3. Snapshot Errors Due to Reverse DNS</a></span></dt><dt><span class="section"><a href="#trouble.rs.shutdown">15.9.4. Shutdown Errors</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.master">15.10. Master</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.master.startup">15.10.1. Startup Errors</a></span></dt><dt><span class="section"><a href="#trouble.master.shutdown">15.10.2. Shutdown Errors</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.zookeeper">15.11. ZooKeeper</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.zookeeper.startup">15.11.1. Startup Errors</a></span></dt><dt><span class="section"><a href="#trouble.zookeeper.general">15.11.2. ZooKeeper, The Cluster Canary</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.ec2">15.12. Amazon EC2</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.ec2.zookeeper">15.12.1. ZooKeeper does not seem to work on Amazon EC2</a></span></dt><dt><span class="section"><a href="#trouble.ec2.instability">15.12.2. Instability on Amazon EC2</a></span></dt><dt><span class="section"><a href="#trouble.ec2.connection">15.12.3. Remote Java Connection into EC2 Cluster Not Working</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.versions">15.13. HBase and Hadoop version issues</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.versions.205">15.13.1. <code class="code">NoClassDefFoundError</code> when trying to run 0.90.x on hadoop-0.20.205.x (or hadoop-1.0.x)</a></span></dt><dt><span class="section"><a href="#trouble.wrong.version">15.13.2. ...cannot communicate with client version...</a></span></dt></dl></dd><dt><span class="section"><a href="#d2875e16399">15.14. IPC Configuration Conflicts with Hadoop</a></span></dt><dt><span class="section"><a href="#d2875e16556">15.15. HBase and HDFS</a></span></dt><dt><span class="section"><a href="#trouble.tests">15.16. Running unit or integration tests</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.HDFS-2556">15.16.1. Runtime exceptions from MiniDFSCluster when running tests</a></span></dt></dl></dd><dt><span class="section"><a href="#trouble.casestudy">15.17. Case Studies</a></span></dt><dt><span class="section"><a href="#trouble.crypto">15.18. Cryptographic Features</a></span></dt><dd><dl><dt><span class="section"><a href="#trouble.crypto.HBASE-10132">15.18.1. sun.security.pkcs11.wrapper.PKCS11Exception: CKR_ARGUMENTS_BAD</a></span></dt></dl></dd><dt><span class="section"><a href="#d2875e16806">15.19. Operating System Specific Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e16809">15.19.1. Page Allocation Failure</a></span></dt></dl></dd><dt><span class="section"><a href="#d2875e16848">15.20. JDK Issues</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e16851">15.20.1. NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet</a></span></dt></dl></dd></dl></div><div class="section" title="15.1.&nbsp;General Guidelines"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.general"></a>15.1.&nbsp;General Guidelines</h2></div></div></div><p> Always start with the master log (TODO: Which lines?). Normally it&#8217;s just printing the
      same lines over and over again. If not, then there&#8217;s an issue. Google or <a class="link" href="http://search-hadoop.com" target="_top">search-hadoop.com</a> should return some hits for
      those exceptions you&#8217;re seeing. </p><p> An error rarely comes alone in Apache HBase, usually when something gets screwed up what
      will follow may be hundreds of exceptions and stack traces coming from all over the place. The
      best way to approach this type of problem is to walk the log up to where it all began, for
      example one trick with RegionServers is that they will print some metrics when aborting so
      grepping for <span class="emphasis"><em>Dump</em></span> should get you around the start of the problem. </p><p> RegionServer suicides are &#8220;normal&#8221;, as this is what they do when something goes wrong.
      For example, if ulimit and max transfer threads (the two most important initial settings, see
      <a class="xref" href="#ulimit">Limits on Number of Files and Processes (<span class="command"><strong>ulimit</strong></span>)
          </a><a class="indexterm" name="d2875e1308"></a><a class="xref" href="#ulimit"></a><a class="indexterm" name="d2875e1311"></a><a class="xref" href="#ulimit">
        </a> and <a class="xref" href="#dfs.datanode.max.transfer.threads" title="2.1.1.6.&nbsp;dfs.datanode.max.transfer.threads">Section&nbsp;2.1.1.6, &#8220;<code class="varname">dfs.datanode.max.transfer.threads</code>&#8221;</a>) aren&#8217;t
      changed, it will make it impossible at some point for DataNodes
      to create new threads that from the HBase point of view is seen as if HDFS was gone. Think
      about what would happen if your MySQL database was suddenly unable to access files on your
      local file system, well it&#8217;s the same with HBase and HDFS. Another very common reason to see
      RegionServers committing seppuku is when they enter prolonged garbage collection pauses that
      last longer than the default ZooKeeper session timeout. For more information on GC pauses, see
      the <a class="link" href="http://www.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/" target="_top">3
        part blog post</a> by Todd Lipcon and <a class="xref" href="#gcpause" title="14.3.1.1.&nbsp;Long GC pauses">Section&nbsp;14.3.1.1, &#8220;Long GC pauses&#8221;</a> above. </p></div><div class="section" title="15.2.&nbsp;Logs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.log"></a>15.2.&nbsp;Logs</h2></div></div></div><p> The key process logs are as follows... (replace &lt;user&gt; with the user that started
      the service, and &lt;hostname&gt; for the machine name) </p><p> NameNode:
        <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-namenode-&lt;hostname&gt;.log</code>
    </p><p> DataNode:
        <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-datanode-&lt;hostname&gt;.log</code>
    </p><p> JobTracker:
        <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-jobtracker-&lt;hostname&gt;.log</code>
    </p><p> TaskTracker:
        <code class="filename">$HADOOP_HOME/logs/hadoop-&lt;user&gt;-tasktracker-&lt;hostname&gt;.log</code>
    </p><p> HMaster:
        <code class="filename">$HBASE_HOME/logs/hbase-&lt;user&gt;-master-&lt;hostname&gt;.log</code>
    </p><p> RegionServer:
        <code class="filename">$HBASE_HOME/logs/hbase-&lt;user&gt;-regionserver-&lt;hostname&gt;.log</code>
    </p><p> ZooKeeper: <code class="filename">TODO</code>
    </p><div class="section" title="15.2.1.&nbsp;Log Locations"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.log.locations"></a>15.2.1.&nbsp;Log Locations</h3></div></div></div><p>For stand-alone deployments the logs are obviously going to be on a single machine,
        however this is a development configuration only. Production deployments need to run on a
        cluster.</p><div class="section" title="15.2.1.1.&nbsp;NameNode"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.log.locations.namenode"></a>15.2.1.1.&nbsp;NameNode</h4></div></div></div><p>The NameNode log is on the NameNode server. The HBase Master is typically run on the
          NameNode server, and well as ZooKeeper.</p><p>For smaller clusters the JobTracker is typically run on the NameNode server as
          well.</p></div><div class="section" title="15.2.1.2.&nbsp;DataNode"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.log.locations.datanode"></a>15.2.1.2.&nbsp;DataNode</h4></div></div></div><p>Each DataNode server will have a DataNode log for HDFS, as well as a RegionServer log
          for HBase.</p><p>Additionally, each DataNode server will also have a TaskTracker log for MapReduce task
          execution.</p></div></div><div class="section" title="15.2.2.&nbsp;Log Levels"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.log.levels"></a>15.2.2.&nbsp;Log Levels</h3></div></div></div><div class="section" title="15.2.2.1.&nbsp;Enabling RPC-level logging"><div class="titlepage"><div><div><h4 class="title"><a name="rpc.logging"></a>15.2.2.1.&nbsp;Enabling RPC-level logging</h4></div></div></div><p>Enabling the RPC-level logging on a RegionServer can often given insight on timings at
          the server. Once enabled, the amount of log spewed is voluminous. It is not recommended
          that you leave this logging on for more than short bursts of time. To enable RPC-level
          logging, browse to the RegionServer UI and click on <span class="emphasis"><em>Log Level</em></span>. Set
          the log level to <code class="varname">DEBUG</code> for the package
            <code class="classname">org.apache.hadoop.ipc</code> (Thats right, for
            <code class="classname">hadoop.ipc</code>, NOT, <code class="classname">hbase.ipc</code>). Then tail the
          RegionServers log. Analyze.</p><p>To disable, set the logging level back to <code class="varname">INFO</code> level. </p></div></div><div class="section" title="15.2.3.&nbsp;JVM Garbage Collection Logs"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.log.gc"></a>15.2.3.&nbsp;JVM Garbage Collection Logs</h3></div></div></div><p>HBase is memory intensive, and using the default GC you can see long pauses in all
        threads including the <span class="emphasis"><em>Juliet Pause</em></span> aka "GC of Death". To help debug
        this or confirm this is happening GC logging can be turned on in the Java virtual machine. </p><p> To enable, in <code class="filename">hbase-env.sh</code>, uncomment one of the below lines
        :</p><pre class="programlisting">
# This enables basic gc logging to the .out file.
# export SERVER_GC_OPTS="-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps"

# This enables basic gc logging to its own file.
# export SERVER_GC_OPTS="-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:&lt;FILE-PATH&gt;"

# This enables basic GC logging to its own file with automatic log rolling. Only applies to jdk 1.6.0_34+ and 1.7.0_2+.
# export SERVER_GC_OPTS="-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:&lt;FILE-PATH&gt; -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=1 -XX:GCLogFileSize=512M"

# If &lt;FILE-PATH&gt; is not replaced, the log file(.gc) would be generated in the HBASE_LOG_DIR.
          </pre><p> At this point you should see logs like so:</p><pre class="programlisting">
64898.952: [GC [1 CMS-initial-mark: 2811538K(3055704K)] 2812179K(3061272K), 0.0007360 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
64898.953: [CMS-concurrent-mark-start]
64898.971: [GC 64898.971: [ParNew: 5567K-&gt;576K(5568K), 0.0101110 secs] 2817105K-&gt;2812715K(3061272K), 0.0102200 secs] [Times: user=0.07 sys=0.00, real=0.01 secs]
          </pre><p> In this section, the first line indicates a 0.0007360 second pause for the CMS to
        initially mark. This pauses the entire VM, all threads for that period of time. </p><p> The third line indicates a "minor GC", which pauses the VM for 0.0101110 seconds - aka
        10 milliseconds. It has reduced the "ParNew" from about 5.5m to 576k. Later on in this cycle
        we see:</p><pre class="programlisting">
64901.445: [CMS-concurrent-mark: 1.542/2.492 secs] [Times: user=10.49 sys=0.33, real=2.49 secs]
64901.445: [CMS-concurrent-preclean-start]
64901.453: [GC 64901.453: [ParNew: 5505K-&gt;573K(5568K), 0.0062440 secs] 2868746K-&gt;2864292K(3061272K), 0.0063360 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
64901.476: [GC 64901.476: [ParNew: 5563K-&gt;575K(5568K), 0.0072510 secs] 2869283K-&gt;2864837K(3061272K), 0.0073320 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]
64901.500: [GC 64901.500: [ParNew: 5517K-&gt;573K(5568K), 0.0120390 secs] 2869780K-&gt;2865267K(3061272K), 0.0121150 secs] [Times: user=0.09 sys=0.00, real=0.01 secs]
64901.529: [GC 64901.529: [ParNew: 5507K-&gt;569K(5568K), 0.0086240 secs] 2870200K-&gt;2865742K(3061272K), 0.0087180 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
64901.554: [GC 64901.555: [ParNew: 5516K-&gt;575K(5568K), 0.0107130 secs] 2870689K-&gt;2866291K(3061272K), 0.0107820 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]
64901.578: [CMS-concurrent-preclean: 0.070/0.133 secs] [Times: user=0.48 sys=0.01, real=0.14 secs]
64901.578: [CMS-concurrent-abortable-preclean-start]
64901.584: [GC 64901.584: [ParNew: 5504K-&gt;571K(5568K), 0.0087270 secs] 2871220K-&gt;2866830K(3061272K), 0.0088220 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
64901.609: [GC 64901.609: [ParNew: 5512K-&gt;569K(5568K), 0.0063370 secs] 2871771K-&gt;2867322K(3061272K), 0.0064230 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]
64901.615: [CMS-concurrent-abortable-preclean: 0.007/0.037 secs] [Times: user=0.13 sys=0.00, real=0.03 secs]
64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]
64901.621: [CMS-concurrent-sweep-start]
            </pre><p> The first line indicates that the CMS concurrent mark (finding garbage) has taken 2.4
        seconds. But this is a _concurrent_ 2.4 seconds, Java has not been paused at any point in
        time. </p><p> There are a few more minor GCs, then there is a pause at the 2nd last line:
        </p><pre class="programlisting">
64901.616: [GC[YG occupancy: 645 K (5568 K)]64901.616: [Rescan (parallel) , 0.0020210 secs]64901.618: [weak refs processing, 0.0027950 secs] [1 CMS-remark: 2866753K(3055704K)] 2867399K(3061272K), 0.0049380 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]
            </pre><p>
      </p><p> The pause here is 0.0049380 seconds (aka 4.9 milliseconds) to 'remark' the heap. </p><p> At this point the sweep starts, and you can watch the heap size go down:</p><pre class="programlisting">
64901.637: [GC 64901.637: [ParNew: 5501K-&gt;569K(5568K), 0.0097350 secs] 2871958K-&gt;2867441K(3061272K), 0.0098370 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
...  lines removed ...
64904.936: [GC 64904.936: [ParNew: 5532K-&gt;568K(5568K), 0.0070720 secs] 1365024K-&gt;1360689K(3061272K), 0.0071930 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
64904.953: [CMS-concurrent-sweep: 2.030/3.332 secs] [Times: user=9.57 sys=0.26, real=3.33 secs]
            </pre><p>At this point, the CMS sweep took 3.332 seconds, and heap went from about ~ 2.8 GB to
        1.3 GB (approximate). </p><p> The key points here is to keep all these pauses low. CMS pauses are always low, but if
        your ParNew starts growing, you can see minor GC pauses approach 100ms, exceed 100ms and hit
        as high at 400ms. </p><p> This can be due to the size of the ParNew, which should be relatively small. If your
        ParNew is very large after running HBase for a while, in one example a ParNew was about
        150MB, then you might have to constrain the size of ParNew (The larger it is, the longer the
        collections take but if its too small, objects are promoted to old gen too quickly). In the
        below we constrain new gen size to 64m. </p><p> Add the below line in <code class="filename">hbase-env.sh</code>:
        </p><pre class="programlisting">
export SERVER_GC_OPTS="$SERVER_GC_OPTS -XX:NewSize=64m -XX:MaxNewSize=64m"
            </pre><p>
      </p><p> Similarly, to enable GC logging for client processes, uncomment one of the below lines
        in <code class="filename">hbase-env.sh</code>:</p><pre class="programlisting">
# This enables basic gc logging to the .out file.
# export CLIENT_GC_OPTS="-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps"

# This enables basic gc logging to its own file.
# export CLIENT_GC_OPTS="-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:&lt;FILE-PATH&gt;"

# This enables basic GC logging to its own file with automatic log rolling. Only applies to jdk 1.6.0_34+ and 1.7.0_2+.
# export CLIENT_GC_OPTS="-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:&lt;FILE-PATH&gt; -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=1 -XX:GCLogFileSize=512M"

# If &lt;FILE-PATH&gt; is not replaced, the log file(.gc) would be generated in the HBASE_LOG_DIR .
            </pre><p> For more information on GC pauses, see the <a class="link" href="http://www.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/" target="_top">3
          part blog post</a> by Todd Lipcon and <a class="xref" href="#gcpause" title="14.3.1.1.&nbsp;Long GC pauses">Section&nbsp;14.3.1.1, &#8220;Long GC pauses&#8221;</a> above. </p></div></div><div class="section" title="15.3.&nbsp;Resources"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.resources"></a>15.3.&nbsp;Resources</h2></div></div></div><div class="section" title="15.3.1.&nbsp;search-hadoop.com"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.resources.searchhadoop"></a>15.3.1.&nbsp;search-hadoop.com</h3></div></div></div><p>
        <a class="link" href="http://search-hadoop.com" target="_top">search-hadoop.com</a> indexes all the mailing
        lists and is great for historical searches. Search here first when you have an issue as its
        more than likely someone has already had your problem. </p></div><div class="section" title="15.3.2.&nbsp;Mailing Lists"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.resources.lists"></a>15.3.2.&nbsp;Mailing Lists</h3></div></div></div><p>Ask a question on the <a class="link" href="http://hbase.apache.org/mail-lists.html" target="_top">Apache
          HBase mailing lists</a>. The 'dev' mailing list is aimed at the community of developers
        actually building Apache HBase and for features currently under development, and 'user' is
        generally used for questions on released versions of Apache HBase. Before going to the
        mailing list, make sure your question has not already been answered by searching the mailing
        list archives first. Use <a class="xref" href="#trouble.resources.searchhadoop" title="15.3.1.&nbsp;search-hadoop.com">Section&nbsp;15.3.1, &#8220;search-hadoop.com&#8221;</a>. Take some time
        crafting your question. See <a class="link" href="http://www.mikeash.com/getting_answers.html" target="_top">Getting Answers</a> for ideas on crafting good questions. A quality question that
        includes all context and exhibits evidence the author has tried to find answers in the
        manual and out on lists is more likely to get a prompt response. </p></div><div class="section" title="15.3.3.&nbsp;IRC"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.resources.irc"></a>15.3.3.&nbsp;IRC</h3></div></div></div><p>#hbase on irc.freenode.net</p></div><div class="section" title="15.3.4.&nbsp;JIRA"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.resources.jira"></a>15.3.4.&nbsp;JIRA</h3></div></div></div><p>
        <a class="link" href="https://issues.apache.org/jira/browse/HBASE" target="_top">JIRA</a> is also really
        helpful when looking for Hadoop/HBase-specific issues. </p></div></div><div class="section" title="15.4.&nbsp;Tools"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.tools"></a>15.4.&nbsp;Tools</h2></div></div></div><div class="section" title="15.4.1.&nbsp;Builtin Tools"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.tools.builtin"></a>15.4.1.&nbsp;Builtin Tools</h3></div></div></div><div class="section" title="15.4.1.1.&nbsp;Master Web Interface"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.builtin.webmaster"></a>15.4.1.1.&nbsp;Master Web Interface</h4></div></div></div><p>The Master starts a web-interface on port 16010 by default. (Up to and including 0.98
          this was port 60010) </p><p>The Master web UI lists created tables and their definition (e.g., ColumnFamilies,
          blocksize, etc.). Additionally, the available RegionServers in the cluster are listed
          along with selected high-level metrics (requests, number of regions, usedHeap, maxHeap).
          The Master web UI allows navigation to each RegionServer's web UI. </p></div><div class="section" title="15.4.1.2.&nbsp;RegionServer Web Interface"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.builtin.webregion"></a>15.4.1.2.&nbsp;RegionServer Web Interface</h4></div></div></div><p>RegionServers starts a web-interface on port 16030 by default. (Up to an including
          0.98 this was port 60030) </p><p>The RegionServer web UI lists online regions and their start/end keys, as well as
          point-in-time RegionServer metrics (requests, regions, storeFileIndexSize,
          compactionQueueSize, etc.). </p><p>See <a class="xref" href="#hbase_metrics" title="17.4.&nbsp;HBase Metrics">Section&nbsp;17.4, &#8220;HBase Metrics&#8221;</a> for more information in metric definitions. </p></div><div class="section" title="15.4.1.3.&nbsp;zkcli"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.builtin.zkcli"></a>15.4.1.3.&nbsp;zkcli</h4></div></div></div><p><code class="code">zkcli</code> is a very useful tool for investigating ZooKeeper-related issues.
          To invoke:
          </p><pre class="programlisting">
./hbase zkcli -server host:port &lt;cmd&gt; &lt;args&gt;
</pre><p>
          The commands (and arguments) are:</p><pre class="programlisting">
	connect host:port
	get path [watch]
	ls path [watch]
	set path data [version]
	delquota [-n|-b] path
	quit
	printwatches on|off
	create [-s] [-e] path data acl
	stat path [watch]
	close
	ls2 path [watch]
	history
	listquota path
	setAcl path acl
	getAcl path
	sync path
	redo cmdno
	addauth scheme auth
	delete path [version]
	setquota -n|-b val path
</pre></div></div><div class="section" title="15.4.2.&nbsp;External Tools"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.tools.external"></a>15.4.2.&nbsp;External Tools</h3></div></div></div><div class="section" title="15.4.2.1.&nbsp;tail"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.tail"></a>15.4.2.1.&nbsp;tail</h4></div></div></div><p>
          <code class="code">tail</code> is the command line tool that lets you look at the end of a file. Add
          the &#8220;-f&#8221; option and it will refresh when new data is available. It&#8217;s useful when you are
          wondering what&#8217;s happening, for example, when a cluster is taking a long time to shutdown
          or startup as you can just fire a new terminal and tail the master log (and maybe a few
          RegionServers). </p></div><div class="section" title="15.4.2.2.&nbsp;top"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.top"></a>15.4.2.2.&nbsp;top</h4></div></div></div><p>
          <code class="code">top</code> is probably one of the most important tool when first trying to see
          what&#8217;s running on a machine and how the resources are consumed. Here&#8217;s an example from
          production system:</p><pre class="programlisting">
top - 14:46:59 up 39 days, 11:55,  1 user,  load average: 3.75, 3.57, 3.84
Tasks: 309 total,   1 running, 308 sleeping,   0 stopped,   0 zombie
Cpu(s):  4.5%us,  1.6%sy,  0.0%ni, 91.7%id,  1.4%wa,  0.1%hi,  0.6%si,  0.0%st
Mem:  24414432k total, 24296956k used,   117476k free,     7196k buffers
Swap: 16008732k total,	14348k used, 15994384k free, 11106908k cached

  PID USER  	PR  NI  VIRT  RES  SHR S %CPU %MEM	TIME+  COMMAND
15558 hadoop	18  -2 3292m 2.4g 3556 S   79 10.4   6523:52 java
13268 hadoop	18  -2 8967m 8.2g 4104 S   21 35.1   5170:30 java
 8895 hadoop	18  -2 1581m 497m 3420 S   11  2.1   4002:32 java
&#8230;
        </pre><p> Here we can see that the system load average during the last five minutes is 3.75,
          which very roughly means that on average 3.75 threads were waiting for CPU time during
          these 5 minutes. In general, the &#8220;perfect&#8221; utilization equals to the number of cores,
          under that number the machine is under utilized and over that the machine is over
          utilized. This is an important concept, see this article to understand it more: <a class="link" href="http://www.linuxjournal.com/article/9001" target="_top">http://www.linuxjournal.com/article/9001</a>. </p><p> Apart from load, we can see that the system is using almost all its available RAM but
          most of it is used for the OS cache (which is good). The swap only has a few KBs in it and
          this is wanted, high numbers would indicate swapping activity which is the nemesis of
          performance of Java systems. Another way to detect swapping is when the load average goes
          through the roof (although this could also be caused by things like a dying disk, among
          others). </p><p> The list of processes isn&#8217;t super useful by default, all we know is that 3 java
          processes are using about 111% of the CPUs. To know which is which, simply type &#8220;c&#8221; and
          each line will be expanded. Typing &#8220;1&#8221; will give you the detail of how each CPU is used
          instead of the average for all of them like shown here. </p></div><div class="section" title="15.4.2.3.&nbsp;jps"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.jps"></a>15.4.2.3.&nbsp;jps</h4></div></div></div><p>
          <code class="code">jps</code> is shipped with every JDK and gives the java process ids for the current
          user (if root, then it gives the ids for all users). Example:</p><pre class="programlisting">
hadoop@sv4borg12:~$ jps
1322 TaskTracker
17789 HRegionServer
27862 Child
1158 DataNode
25115 HQuorumPeer
2950 Jps
19750 ThriftServer
18776 jmx
        </pre><p>In order, we see a: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Hadoop TaskTracker, manages the local Childs</p></li><li class="listitem"><p>HBase RegionServer, serves regions</p></li><li class="listitem"><p>Child, its MapReduce task, cannot tell which type exactly</p></li><li class="listitem"><p>Hadoop TaskTracker, manages the local Childs</p></li><li class="listitem"><p>Hadoop DataNode, serves blocks</p></li><li class="listitem"><p>HQuorumPeer, a ZooKeeper ensemble member</p></li><li class="listitem"><p>Jps, well&#8230; it&#8217;s the current process</p></li><li class="listitem"><p>ThriftServer, it&#8217;s a special one will be running only if thrift was started</p></li><li class="listitem"><p>jmx, this is a local process that&#8217;s part of our monitoring platform ( poorly named
              maybe). You probably don&#8217;t have that.</p></li></ul></div><p> You can then do stuff like checking out the full command line that started the
          process:</p><pre class="programlisting">
hadoop@sv4borg12:~$ ps aux | grep HRegionServer
hadoop   17789  155 35.2 9067824 8604364 ?     S&lt;l  Mar04 9855:48 /usr/java/jdk1.6.0_14/bin/java -Xmx8000m -XX:+DoEscapeAnalysis -XX:+AggressiveOpts -XX:+UseConcMarkSweepGC -XX:NewSize=64m -XX:MaxNewSize=64m -XX:CMSInitiatingOccupancyFraction=88 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/export1/hadoop/logs/gc-hbase.log -Dcom.sun.management.jmxremote.port=10102 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=/home/hadoop/hbase/conf/jmxremote.password -Dcom.sun.management.jmxremote -Dhbase.log.dir=/export1/hadoop/logs -Dhbase.log.file=hbase-hadoop-regionserver-sv4borg12.log -Dhbase.home.dir=/home/hadoop/hbase -Dhbase.id.str=hadoop -Dhbase.root.logger=INFO,DRFA -Djava.library.path=/home/hadoop/hbase/lib/native/Linux-amd64-64 -classpath /home/hadoop/hbase/bin/../conf:[many jars]:/home/hadoop/hadoop/conf org.apache.hadoop.hbase.regionserver.HRegionServer start
        </pre></div><div class="section" title="15.4.2.4.&nbsp;jstack"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.jstack"></a>15.4.2.4.&nbsp;jstack</h4></div></div></div><p>
          <code class="code">jstack</code> is one of the most important tools when trying to figure out what a
          java process is doing apart from looking at the logs. It has to be used in conjunction
          with jps in order to give it a process id. It shows a list of threads, each one has a
          name, and they appear in the order that they were created (so the top ones are the most
          recent threads). Here&#8217;s a few example: </p><p> The main thread of a RegionServer that&#8217;s waiting for something to do from the
          master:</p><pre class="programlisting">
"regionserver60020" prio=10 tid=0x0000000040ab4000 nid=0x45cf waiting on condition [0x00007f16b6a96000..0x00007f16b6a96a70]
java.lang.Thread.State: TIMED_WAITING (parking)
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  &lt;0x00007f16cd5c2f30&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1963)
    at java.util.concurrent.LinkedBlockingQueue.poll(LinkedBlockingQueue.java:395)
    at org.apache.hadoop.hbase.regionserver.HRegionServer.run(HRegionServer.java:647)
    at java.lang.Thread.run(Thread.java:619)

    The MemStore flusher thread that is currently flushing to a file:
"regionserver60020.cacheFlusher" daemon prio=10 tid=0x0000000040f4e000 nid=0x45eb in Object.wait() [0x00007f16b5b86000..0x00007f16b5b87af0]
java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:485)
    at org.apache.hadoop.ipc.Client.call(Client.java:803)
    - locked &lt;0x00007f16cb14b3a8&gt; (a org.apache.hadoop.ipc.Client$Call)
    at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:221)
    at $Proxy1.complete(Unknown Source)
    at sun.reflect.GeneratedMethodAccessor38.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:82)
    at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:59)
    at $Proxy1.complete(Unknown Source)
    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.closeInternal(DFSClient.java:3390)
    - locked &lt;0x00007f16cb14b470&gt; (a org.apache.hadoop.hdfs.DFSClient$DFSOutputStream)
    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.close(DFSClient.java:3304)
    at org.apache.hadoop.fs.FSDataOutputStream$PositionCache.close(FSDataOutputStream.java:61)
    at org.apache.hadoop.fs.FSDataOutputStream.close(FSDataOutputStream.java:86)
    at org.apache.hadoop.hbase.io.hfile.HFile$Writer.close(HFile.java:650)
    at org.apache.hadoop.hbase.regionserver.StoreFile$Writer.close(StoreFile.java:853)
    at org.apache.hadoop.hbase.regionserver.Store.internalFlushCache(Store.java:467)
    - locked &lt;0x00007f16d00e6f08&gt; (a java.lang.Object)
    at org.apache.hadoop.hbase.regionserver.Store.flushCache(Store.java:427)
    at org.apache.hadoop.hbase.regionserver.Store.access$100(Store.java:80)
    at org.apache.hadoop.hbase.regionserver.Store$StoreFlusherImpl.flushCache(Store.java:1359)
    at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:907)
    at org.apache.hadoop.hbase.regionserver.HRegion.internalFlushcache(HRegion.java:834)
    at org.apache.hadoop.hbase.regionserver.HRegion.flushcache(HRegion.java:786)
    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:250)
    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.flushRegion(MemStoreFlusher.java:224)
    at org.apache.hadoop.hbase.regionserver.MemStoreFlusher.run(MemStoreFlusher.java:146)
        </pre><p> A handler thread that&#8217;s waiting for stuff to do (like put, delete, scan, etc):</p><pre class="programlisting">
"IPC Server handler 16 on 60020" daemon prio=10 tid=0x00007f16b011d800 nid=0x4a5e waiting on condition [0x00007f16afefd000..0x00007f16afefd9f0]
   java.lang.Thread.State: WAITING (parking)
        	at sun.misc.Unsafe.park(Native Method)
        	- parking to wait for  &lt;0x00007f16cd3f8dd8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)
        	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1925)
        	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:358)
        	at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1013)
        </pre><p> And one that&#8217;s busy doing an increment of a counter (it&#8217;s in the phase where it&#8217;s
          trying to create a scanner in order to read the last value):</p><pre class="programlisting">
"IPC Server handler 66 on 60020" daemon prio=10 tid=0x00007f16b006e800 nid=0x4a90 runnable [0x00007f16acb77000..0x00007f16acb77cf0]
   java.lang.Thread.State: RUNNABLE
        	at org.apache.hadoop.hbase.regionserver.KeyValueHeap.&lt;init&gt;(KeyValueHeap.java:56)
        	at org.apache.hadoop.hbase.regionserver.StoreScanner.&lt;init&gt;(StoreScanner.java:79)
        	at org.apache.hadoop.hbase.regionserver.Store.getScanner(Store.java:1202)
        	at org.apache.hadoop.hbase.regionserver.HRegion$RegionScanner.&lt;init&gt;(HRegion.java:2209)
        	at org.apache.hadoop.hbase.regionserver.HRegion.instantiateInternalScanner(HRegion.java:1063)
        	at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1055)
        	at org.apache.hadoop.hbase.regionserver.HRegion.getScanner(HRegion.java:1039)
        	at org.apache.hadoop.hbase.regionserver.HRegion.getLastIncrement(HRegion.java:2875)
        	at org.apache.hadoop.hbase.regionserver.HRegion.incrementColumnValue(HRegion.java:2978)
        	at org.apache.hadoop.hbase.regionserver.HRegionServer.incrementColumnValue(HRegionServer.java:2433)
        	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
        	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        	at java.lang.reflect.Method.invoke(Method.java:597)
        	at org.apache.hadoop.hbase.ipc.HBaseRPC$Server.call(HBaseRPC.java:560)
        	at org.apache.hadoop.hbase.ipc.HBaseServer$Handler.run(HBaseServer.java:1027)
        </pre><p> A thread that receives data from HDFS:</p><pre class="programlisting">
"IPC Client (47) connection to sv4borg9/10.4.24.40:9000 from hadoop" daemon prio=10 tid=0x00007f16a02d0000 nid=0x4fa3 runnable [0x00007f16b517d000..0x00007f16b517dbf0]
   java.lang.Thread.State: RUNNABLE
        	at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
        	at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:215)
        	at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:65)
        	at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:69)
        	- locked &lt;0x00007f17d5b68c00&gt; (a sun.nio.ch.Util$1)
        	- locked &lt;0x00007f17d5b68be8&gt; (a java.util.Collections$UnmodifiableSet)
        	- locked &lt;0x00007f1877959b50&gt; (a sun.nio.ch.EPollSelectorImpl)
        	at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:80)
        	at org.apache.hadoop.net.SocketIOWithTimeout$SelectorPool.select(SocketIOWithTimeout.java:332)
        	at org.apache.hadoop.net.SocketIOWithTimeout.doIO(SocketIOWithTimeout.java:157)
        	at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:155)
        	at org.apache.hadoop.net.SocketInputStream.read(SocketInputStream.java:128)
        	at java.io.FilterInputStream.read(FilterInputStream.java:116)
        	at org.apache.hadoop.ipc.Client$Connection$PingInputStream.read(Client.java:304)
        	at java.io.BufferedInputStream.fill(BufferedInputStream.java:218)
        	at java.io.BufferedInputStream.read(BufferedInputStream.java:237)
        	- locked &lt;0x00007f1808539178&gt; (a java.io.BufferedInputStream)
        	at java.io.DataInputStream.readInt(DataInputStream.java:370)
        	at org.apache.hadoop.ipc.Client$Connection.receiveResponse(Client.java:569)
        	at org.apache.hadoop.ipc.Client$Connection.run(Client.java:477)
          </pre><p> And here is a master trying to recover a lease after a RegionServer died:</p><pre class="programlisting">
"LeaseChecker" daemon prio=10 tid=0x00000000407ef800 nid=0x76cd waiting on condition [0x00007f6d0eae2000..0x00007f6d0eae2a70]
--
   java.lang.Thread.State: WAITING (on object monitor)
        	at java.lang.Object.wait(Native Method)
        	at java.lang.Object.wait(Object.java:485)
        	at org.apache.hadoop.ipc.Client.call(Client.java:726)
        	- locked &lt;0x00007f6d1cd28f80&gt; (a org.apache.hadoop.ipc.Client$Call)
        	at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:220)
        	at $Proxy1.recoverBlock(Unknown Source)
        	at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.processDatanodeError(DFSClient.java:2636)
        	at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.&lt;init&gt;(DFSClient.java:2832)
        	at org.apache.hadoop.hdfs.DFSClient.append(DFSClient.java:529)
        	at org.apache.hadoop.hdfs.DistributedFileSystem.append(DistributedFileSystem.java:186)
        	at org.apache.hadoop.fs.FileSystem.append(FileSystem.java:530)
        	at org.apache.hadoop.hbase.util.FSUtils.recoverFileLease(FSUtils.java:619)
        	at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1322)
        	at org.apache.hadoop.hbase.regionserver.wal.HLog.splitLog(HLog.java:1210)
        	at org.apache.hadoop.hbase.master.HMaster.splitLogAfterStartup(HMaster.java:648)
        	at org.apache.hadoop.hbase.master.HMaster.joinCluster(HMaster.java:572)
        	at org.apache.hadoop.hbase.master.HMaster.run(HMaster.java:503)
          </pre></div><div class="section" title="15.4.2.5.&nbsp;OpenTSDB"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.opentsdb"></a>15.4.2.5.&nbsp;OpenTSDB</h4></div></div></div><p>
          <a class="link" href="http://opentsdb.net" target="_top">OpenTSDB</a> is an excellent alternative to Ganglia
          as it uses Apache HBase to store all the time series and doesn&#8217;t have to downsample.
          Monitoring your own HBase cluster that hosts OpenTSDB is a good exercise. </p><p> Here&#8217;s an example of a cluster that&#8217;s suffering from hundreds of compactions launched
          almost all around the same time, which severely affects the IO performance: (TODO: insert
          graph plotting compactionQueueSize) </p><p> It&#8217;s a good practice to build dashboards with all the important graphs per machine
          and per cluster so that debugging issues can be done with a single quick look. For
          example, at StumbleUpon there&#8217;s one dashboard per cluster with the most important metrics
          from both the OS and Apache HBase. You can then go down at the machine level and get even
          more detailed metrics. </p></div><div class="section" title="15.4.2.6.&nbsp;clusterssh+top"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.tools.clustersshtop"></a>15.4.2.6.&nbsp;clusterssh+top</h4></div></div></div><p> clusterssh+top, it&#8217;s like a poor man&#8217;s monitoring system and it can be quite useful
          when you have only a few machines as it&#8217;s very easy to setup. Starting clusterssh will
          give you one terminal per machine and another terminal in which whatever you type will be
          retyped in every window. This means that you can type &#8220;top&#8221; once and it will start it for
          all of your machines at the same time giving you full view of the current state of your
          cluster. You can also tail all the logs at the same time, edit files, etc. </p></div></div></div><div class="section" title="15.5.&nbsp;Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.client"></a>15.5.&nbsp;Client</h2></div></div></div><p>For more information on the HBase client, see <a class="xref" href="#client" title="9.3.&nbsp;Client">Section&nbsp;9.3, &#8220;Client&#8221;</a>. </p><div class="section" title="15.5.1.&nbsp;ScannerTimeoutException or UnknownScannerException"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.scantimeout"></a>15.5.1.&nbsp;ScannerTimeoutException or UnknownScannerException</h3></div></div></div><p>This is thrown if the time between RPC calls from the client to RegionServer exceeds the
        scan timeout. For example, if <code class="code">Scan.setCaching</code> is set to 500, then there will be
        an RPC call to fetch the next batch of rows every 500 <code class="code">.next()</code> calls on the
        ResultScanner because data is being transferred in blocks of 500 rows to the client.
        Reducing the setCaching value may be an option, but setting this value too low makes for
        inefficient processing on numbers of rows. </p><p>See <a class="xref" href="#perf.hbase.client.caching" title="14.9.1.&nbsp;Scan Caching">Section&nbsp;14.9.1, &#8220;Scan Caching&#8221;</a>. </p></div><div class="section" title="15.5.2.&nbsp;Performance Differences in Thrift and Java APIs"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e15701"></a>15.5.2.&nbsp;Performance Differences in Thrift and Java APIs</h3></div></div></div><p>Poor performance, or even <code class="code">ScannerTimeoutExceptions</code>, can occur if
          <code class="code">Scan.setCaching</code> is too high, as discussed in <a class="xref" href="#trouble.client.scantimeout" title="15.5.1.&nbsp;ScannerTimeoutException or UnknownScannerException">Section&nbsp;15.5.1, &#8220;ScannerTimeoutException or UnknownScannerException&#8221;</a>. If the Thrift client uses the wrong caching
        settings for a given workload, performance can suffer compared to the Java API. To set
        caching for a given scan in the Thrift client, use the <code class="code">scannerGetList(scannerId,
          numRows)</code> method, where <code class="code">numRows</code> is an integer representing the number
        of rows to cache. In one case, it was found that reducing the cache for Thrift scans from
        1000 to 100 increased performance to near parity with the Java API given the same
        queries.</p><p>See also Jesse Andersen's <a class="link" href="http://blog.cloudera.com/blog/2014/04/how-to-use-the-hbase-thrift-interface-part-3-using-scans/" target="_top">blog post</a> 
        about using Scans with Thrift.</p></div><div class="section" title="15.5.3.&nbsp;LeaseException when calling Scanner.next"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.lease.exception"></a>15.5.3.&nbsp;<code class="classname">LeaseException</code> when calling
        <code class="classname">Scanner.next</code></h3></div></div></div><p> In some situations clients that fetch data from a RegionServer get a LeaseException
        instead of the usual <a class="xref" href="#trouble.client.scantimeout" title="15.5.1.&nbsp;ScannerTimeoutException or UnknownScannerException">Section&nbsp;15.5.1, &#8220;ScannerTimeoutException or UnknownScannerException&#8221;</a>. Usually the source of the exception is
          <code class="classname">org.apache.hadoop.hbase.regionserver.Leases.removeLease(Leases.java:230)</code>
        (line number may vary). It tends to happen in the context of a slow/freezing
        RegionServer#next call. It can be prevented by having <code class="varname">hbase.rpc.timeout</code> &gt;
          <code class="varname">hbase.regionserver.lease.period</code>. Harsh J investigated the issue as part
        of the mailing list thread <a class="link" href="http://mail-archives.apache.org/mod_mbox/hbase-user/201209.mbox/%3CCAOcnVr3R-LqtKhFsk8Bhrm-YW2i9O6J6Fhjz2h7q6_sxvwd2yw%40mail.gmail.com%3E" target="_top">HBase,
          mail # user - Lease does not exist exceptions</a>
      </p></div><div class="section" title="15.5.4.&nbsp;Shell or client application throws lots of scary exceptions during normal operation"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.scarylogs"></a>15.5.4.&nbsp;Shell or client application throws lots of scary exceptions during normal
        operation</h3></div></div></div><p>Since 0.20.0 the default log level for <code class="code">org.apache.hadoop.hbase.*</code>is DEBUG. </p><p> On your clients, edit <code class="filename">$HBASE_HOME/conf/log4j.properties</code> and change
        this: <code class="code">log4j.logger.org.apache.hadoop.hbase=DEBUG</code> to this:
          <code class="code">log4j.logger.org.apache.hadoop.hbase=INFO</code>, or even
          <code class="code">log4j.logger.org.apache.hadoop.hbase=WARN</code>. </p></div><div class="section" title="15.5.5.&nbsp;Long Client Pauses With Compression"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.longpauseswithcompression"></a>15.5.5.&nbsp;Long Client Pauses With Compression</h3></div></div></div><p>This is a fairly frequent question on the Apache HBase dist-list. The scenario is that a
        client is typically inserting a lot of data into a relatively un-optimized HBase cluster.
        Compression can exacerbate the pauses, although it is not the source of the problem.</p><p>See <a class="xref" href="#precreate.regions" title="14.8.2.&nbsp; Table Creation: Pre-Creating Regions">Section&nbsp;14.8.2, &#8220; Table Creation: Pre-Creating Regions &#8221;</a> on the pattern for pre-creating regions and confirm that
        the table isn't starting with a single region.</p><p>See <a class="xref" href="#perf.configurations" title="14.4.&nbsp;HBase Configurations">Section&nbsp;14.4, &#8220;HBase Configurations&#8221;</a> for cluster configuration, particularly
          <code class="code">hbase.hstore.blockingStoreFiles</code>,
          <code class="code">hbase.hregion.memstore.block.multiplier</code>, <code class="code">MAX_FILESIZE</code> (region
        size), and <code class="code">MEMSTORE_FLUSHSIZE.</code>
      </p><p>A slightly longer explanation of why pauses can happen is as follows: Puts are sometimes
        blocked on the MemStores which are blocked by the flusher thread which is blocked because
        there are too many files to compact because the compactor is given too many small files to
        compact and has to compact the same data repeatedly. This situation can occur even with
        minor compactions. Compounding this situation, Apache HBase doesn't compress data in memory.
        Thus, the 64MB that lives in the MemStore could become a 6MB file after compression - which
        results in a smaller StoreFile. The upside is that more data is packed into the same region,
        but performance is achieved by being able to write larger files - which is why HBase waits
        until the flushize before writing a new StoreFile. And smaller StoreFiles become targets for
        compaction. Without compression the files are much bigger and don't need as much compaction,
        however this is at the expense of I/O. </p><p> For additional information, see this thread on <a class="link" href="http://search-hadoop.com/m/WUnLM6ojHm1/Long+client+pauses+with+compression&amp;subj=Long+client+pauses+with+compression" target="_top">Long
          client pauses with compression</a>. </p></div><div class="section" title="15.5.6.&nbsp;Secure Client Connect ([Caused by GSSException: No valid credentials provided...])"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.security.rpc.krb"></a>15.5.6.&nbsp;Secure Client Connect ([Caused by GSSException: No valid credentials provided...])</h3></div></div></div><p>You may encounter the following error:</p><pre class="screen">Secure Client Connect ([Caused by GSSException: No valid credentials provided
        (Mechanism level: Request is a replay (34) V PROCESS_TGS)])</pre><p> This issue is caused by bugs in the MIT Kerberos replay_cache component, <a class="link" href="http://krbdev.mit.edu/rt/Ticket/Display.html?id=1201" target="_top">#1201</a> and <a class="link" href="http://krbdev.mit.edu/rt/Ticket/Display.html?id=5924" target="_top">#5924</a>. These bugs
        caused the old version of krb5-server to erroneously block subsequent requests sent from a
        Principal. This caused krb5-server to block the connections sent from one Client (one HTable
        instance with multi-threading connection instances for each regionserver); Messages, such as
          <code class="literal">Request is a replay (34)</code>, are logged in the client log You can ignore
        the messages, because HTable will retry 5 * 10 (50) times for each failed connection by
        default. HTable will throw IOException if any connection to the regionserver fails after the
        retries, so that the user client code for HTable instance can handle it further. </p><p> Alternatively, update krb5-server to a version which solves these issues, such as
        krb5-server-1.10.3. See JIRA <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10379" target="_top">HBASE-10379</a> for more
        details. </p></div><div class="section" title="15.5.7.&nbsp;ZooKeeper Client Connection Errors"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.zookeeper"></a>15.5.7.&nbsp;ZooKeeper Client Connection Errors</h3></div></div></div><p>Errors like this...</p><pre class="programlisting">
11/07/05 11:26:41 WARN zookeeper.ClientCnxn: Session 0x0 for server null,
 unexpected error, closing socket connection and attempting reconnect
 java.net.ConnectException: Connection refused: no further information
        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)
        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)
 11/07/05 11:26:43 INFO zookeeper.ClientCnxn: Opening socket connection to
 server localhost/127.0.0.1:2181
 11/07/05 11:26:44 WARN zookeeper.ClientCnxn: Session 0x0 for server null,
 unexpected error, closing socket connection and attempting reconnect
 java.net.ConnectException: Connection refused: no further information
        at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method)
        at sun.nio.ch.SocketChannelImpl.finishConnect(Unknown Source)
        at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:1078)
 11/07/05 11:26:45 INFO zookeeper.ClientCnxn: Opening socket connection to
 server localhost/127.0.0.1:2181
</pre><p>... are either due to ZooKeeper being down, or unreachable due to network issues. </p><p>The utility <a class="xref" href="#trouble.tools.builtin.zkcli" title="15.4.1.3.&nbsp;zkcli">Section&nbsp;15.4.1.3, &#8220;zkcli&#8221;</a> may help investigate ZooKeeper issues. </p></div><div class="section" title="15.5.8.&nbsp;Client running out of memory though heap size seems to be stable (but the off-heap/direct heap keeps growing)"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.oome.directmemory.leak"></a>15.5.8.&nbsp;Client running out of memory though heap size seems to be stable (but the
        off-heap/direct heap keeps growing)</h3></div></div></div><p> You are likely running into the issue that is described and worked through in the mail
        thread <a class="link" href="http://search-hadoop.com/m/ubhrX8KvcH/Suspected+memory+leak&amp;subj=Re+Suspected+memory+leak" target="_top">HBase,
          mail # user - Suspected memory leak</a> and continued over in <a class="link" href="http://search-hadoop.com/m/p2Agc1Zy7Va/MaxDirectMemorySize+Was%253A+Suspected+memory+leak&amp;subj=Re+FeedbackRe+Suspected+memory+leak" target="_top">HBase,
          mail # dev - FeedbackRe: Suspected memory leak</a>. A workaround is passing your
        client-side JVM a reasonable value for <code class="code">-XX:MaxDirectMemorySize</code>. By default, the
          <code class="varname">MaxDirectMemorySize</code> is equal to your <code class="code">-Xmx</code> max heapsize
        setting (if <code class="code">-Xmx</code> is set). Try seting it to something smaller (for example, one
        user had success setting it to <code class="code">1g</code> when they had a client-side heap of
          <code class="code">12g</code>). If you set it too small, it will bring on <code class="code">FullGCs</code> so keep
        it a bit hefty. You want to make this setting client-side only especially if you are running
        the new experiemental server-side off-heap cache since this feature depends on being able to
        use big direct buffers (You may have to keep separate client-side and server-side config
        dirs). </p></div><div class="section" title="15.5.9.&nbsp;Client Slowdown When Calling Admin Methods (flush, compact, etc.)"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.slowdown.admin"></a>15.5.9.&nbsp;Client Slowdown When Calling Admin Methods (flush, compact, etc.)</h3></div></div></div><p> This is a client issue fixed by <a class="link" href="https://issues.apache.org/jira/browse/HBASE-5073" target="_top">HBASE-5073</a> in 0.90.6.
        There was a ZooKeeper leak in the client and the client was getting pummeled by ZooKeeper
        events with each additional invocation of the admin API. </p></div><div class="section" title="15.5.10.&nbsp;Secure Client Cannot Connect ([Caused by GSSException: No valid credentials provided (Mechanism level: Failed to find any Kerberos tgt)])"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.client.security.rpc"></a>15.5.10.&nbsp;Secure Client Cannot Connect ([Caused by GSSException: No valid credentials provided
        (Mechanism level: Failed to find any Kerberos tgt)])</h3></div></div></div><p> There can be several causes that produce this symptom. </p><p> First, check that you have a valid Kerberos ticket. One is required in order to set up
        communication with a secure Apache HBase cluster. Examine the ticket currently in the
        credential cache, if any, by running the klist command line utility. If no ticket is listed,
        you must obtain a ticket by running the kinit command with either a keytab specified, or by
        interactively entering a password for the desired principal. </p><p> Then, consult the <a class="link" href="http://docs.oracle.com/javase/1.5.0/docs/guide/security/jgss/tutorials/Troubleshooting.html" target="_top">Java
          Security Guide troubleshooting section</a>. The most common problem addressed there is
        resolved by setting javax.security.auth.useSubjectCredsOnly system property value to false. </p><p> Because of a change in the format in which MIT Kerberos writes its credentials cache,
        there is a bug in the Oracle JDK 6 Update 26 and earlier that causes Java to be unable to
        read the Kerberos credentials cache created by versions of MIT Kerberos 1.8.1 or higher. If
        you have this problematic combination of components in your environment, to work around this
        problem, first log in with kinit and then immediately refresh the credential cache with
        kinit -R. The refresh will rewrite the credential cache without the problematic formatting. </p><p> Finally, depending on your Kerberos configuration, you may need to install the <a class="link" href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html" target="_top">Java
          Cryptography Extension</a>, or JCE. Insure the JCE jars are on the classpath on both
        server and client systems. </p><p> You may also need to download the <a class="link" href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_top">unlimited
          strength JCE policy files</a>. Uncompress and extract the downloaded file, and install
        the policy jars into &lt;java-home&gt;/lib/security. </p></div></div><div class="section" title="15.6.&nbsp;MapReduce"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.mapreduce"></a>15.6.&nbsp;MapReduce</h2></div></div></div><div class="section" title="15.6.1.&nbsp;You Think You're On The Cluster, But You're Actually Local"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.mapreduce.local"></a>15.6.1.&nbsp;You Think You're On The Cluster, But You're Actually Local</h3></div></div></div><p>This following stacktrace happened using <code class="code">ImportTsv</code>, but things like this
        can happen on any job with a mis-configuration.</p><pre class="programlisting">
    WARN mapred.LocalJobRunner: job_local_0001
java.lang.IllegalArgumentException: Can't read partitions file
       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.setConf(TotalOrderPartitioner.java:111)
       at org.apache.hadoop.util.ReflectionUtils.setConf(ReflectionUtils.java:62)
       at org.apache.hadoop.util.ReflectionUtils.newInstance(ReflectionUtils.java:117)
       at org.apache.hadoop.mapred.MapTask$NewOutputCollector.&lt;init&gt;(MapTask.java:560)
       at org.apache.hadoop.mapred.MapTask.runNewMapper(MapTask.java:639)
       at org.apache.hadoop.mapred.MapTask.run(MapTask.java:323)
       at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)
Caused by: java.io.FileNotFoundException: File _partition.lst does not exist.
       at org.apache.hadoop.fs.RawLocalFileSystem.getFileStatus(RawLocalFileSystem.java:383)
       at org.apache.hadoop.fs.FilterFileSystem.getFileStatus(FilterFileSystem.java:251)
       at org.apache.hadoop.fs.FileSystem.getLength(FileSystem.java:776)
       at org.apache.hadoop.io.SequenceFile$Reader.&lt;init&gt;(SequenceFile.java:1424)
       at org.apache.hadoop.io.SequenceFile$Reader.&lt;init&gt;(SequenceFile.java:1419)
       at org.apache.hadoop.hbase.mapreduce.hadoopbackport.TotalOrderPartitioner.readPartitions(TotalOrderPartitioner.java:296)
</pre><p>.. see the critical portion of the stack? It's...</p><pre class="programlisting">
at org.apache.hadoop.mapred.LocalJobRunner$Job.run(LocalJobRunner.java:210)
</pre><p>LocalJobRunner means the job is running locally, not on the cluster. </p><p>To solve this problem, you should run your MR job with your
          <code class="code">HADOOP_CLASSPATH</code> set to include the HBase dependencies. The "hbase classpath"
        utility can be used to do this easily. For example (substitute VERSION with your HBase
        version):</p><pre class="programlisting">
          HADOOP_CLASSPATH=`hbase classpath` hadoop jar $HBASE_HOME/hbase-server-VERSION.jar rowcounter usertable
      </pre><p>See <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/package-summary.html#classpath" target="_top">
          http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/package-summary.html#classpath</a>
        for more information on HBase MapReduce jobs and classpaths. </p></div><div class="section" title="15.6.2.&nbsp;Launching a job, you get java.lang.IllegalAccessError: com/google/protobuf/HBaseZeroCopyByteString or class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.hbasezerocopybytestring"></a>15.6.2.&nbsp;Launching a job, you get java.lang.IllegalAccessError: com/google/protobuf/HBaseZeroCopyByteString or class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString</h3></div></div></div><p>See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10304" target="_top">HBASE-10304 Running an hbase job jar: IllegalAccessError: class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString</a> and <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11118" target="_top">HBASE-11118 non environment variable solution for "IllegalAccessError: class com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass com.google.protobuf.LiteralByteString"</a>.  The issue can also show up
          when trying to run spark jobs.  See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10877" target="_top">HBASE-10877 HBase non-retriable exception list should be expanded</a>.
      </p></div></div><div class="section" title="15.7.&nbsp;NameNode"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.namenode"></a>15.7.&nbsp;NameNode</h2></div></div></div><p>For more information on the NameNode, see <a class="xref" href="#arch.hdfs" title="9.9.&nbsp;HDFS">Section&nbsp;9.9, &#8220;HDFS&#8221;</a>. </p><div class="section" title="15.7.1.&nbsp;HDFS Utilization of Tables and Regions"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.namenode.disk"></a>15.7.1.&nbsp;HDFS Utilization of Tables and Regions</h3></div></div></div><p>To determine how much space HBase is using on HDFS use the <code class="code">hadoop</code> shell
        commands from the NameNode. For example... </p><pre class="programlisting">hadoop fs -dus /hbase/</pre><p> ...returns the summarized disk
        utilization for all HBase objects. </p><pre class="programlisting">hadoop fs -dus /hbase/myTable</pre><p> ...returns the summarized
        disk utilization for the HBase table 'myTable'. </p><pre class="programlisting">hadoop fs -du /hbase/myTable</pre><p> ...returns a list of the
        regions under the HBase table 'myTable' and their disk utilization. </p><p>For more information on HDFS shell commands, see the <a class="link" href="http://hadoop.apache.org/common/docs/current/file_system_shell.html" target="_top">HDFS
          FileSystem Shell documentation</a>. </p></div><div class="section" title="15.7.2.&nbsp;Browsing HDFS for HBase Objects"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.namenode.hbase.objects"></a>15.7.2.&nbsp;Browsing HDFS for HBase Objects</h3></div></div></div><p>Sometimes it will be necessary to explore the HBase objects that exist on HDFS. These
        objects could include the WALs (Write Ahead Logs), tables, regions, StoreFiles, etc. The
        easiest way to do this is with the NameNode web application that runs on port 50070. The
        NameNode web application will provide links to the all the DataNodes in the cluster so that
        they can be browsed seamlessly. </p><p>The HDFS directory structure of HBase tables in the cluster is...
        </p><pre class="programlisting">
<code class="filename">/hbase</code>
     <code class="filename">/&lt;Table&gt;</code>             (Tables in the cluster)
          <code class="filename">/&lt;Region&gt;</code>           (Regions for the table)
               <code class="filename">/&lt;ColumnFamily&gt;</code>      (ColumnFamilies for the Region for the table)
                    <code class="filename">/&lt;StoreFile&gt;</code>        (StoreFiles for the ColumnFamily for the Regions for the table)
            </pre><p>
      </p><p>The HDFS directory structure of HBase WAL is..
        </p><pre class="programlisting">
<code class="filename">/hbase</code>
     <code class="filename">/.logs</code>
          <code class="filename">/&lt;RegionServer&gt;</code>    (RegionServers)
               <code class="filename">/&lt;HLog&gt;</code>           (WAL HLog files for the RegionServer)
            </pre><p>
      </p><p>See the <a class="link" href="http://hadoop.apache.org/common/docs/current/hdfs_user_guide.html" target="_top">HDFS User
          Guide</a> for other non-shell diagnostic utilities like <code class="code">fsck</code>. </p><div class="section" title="15.7.2.1.&nbsp;Zero size HLogs with data in them"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.namenode.0size.hlogs"></a>15.7.2.1.&nbsp;Zero size HLogs with data in them</h4></div></div></div><p>Problem: when getting a listing of all the files in a region server's .logs directory,
          one file has a size of 0 but it contains data.</p><p>Answer: It's an HDFS quirk. A file that's currently being to will appear to have a
          size of 0 but once it's closed it will show its true size</p></div><div class="section" title="15.7.2.2.&nbsp;Use Cases"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.namenode.uncompaction"></a>15.7.2.2.&nbsp;Use Cases</h4></div></div></div><p>Two common use-cases for querying HDFS for HBase objects is research the degree of
          uncompaction of a table. If there are a large number of StoreFiles for each ColumnFamily
          it could indicate the need for a major compaction. Additionally, after a major compaction
          if the resulting StoreFile is "small" it could indicate the need for a reduction of
          ColumnFamilies for the table. </p></div></div></div><div class="section" title="15.8.&nbsp;Network"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.network"></a>15.8.&nbsp;Network</h2></div></div></div><div class="section" title="15.8.1.&nbsp;Network Spikes"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.network.spikes"></a>15.8.1.&nbsp;Network Spikes</h3></div></div></div><p>If you are seeing periodic network spikes you might want to check the
          <code class="code">compactionQueues</code> to see if major compactions are happening. </p><p>See <a class="xref" href="#managed.compactions" title="2.6.2.8.&nbsp;Managed Compactions">Section&nbsp;2.6.2.8, &#8220;Managed Compactions&#8221;</a> for more information on managing compactions. </p></div><div class="section" title="15.8.2.&nbsp;Loopback IP"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.network.loopback"></a>15.8.2.&nbsp;Loopback IP</h3></div></div></div><p>HBase expects the loopback IP Address to be 127.0.0.1. See the Getting Started section
        on <a class="xref" href="#loopback.ip">Loopback IP</a>. </p></div><div class="section" title="15.8.3.&nbsp;Network Interfaces"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.network.ints"></a>15.8.3.&nbsp;Network Interfaces</h3></div></div></div><p>Are all the network interfaces functioning correctly? Are you sure? See the
        Troubleshooting Case Study in <a class="xref" href="#trouble.casestudy" title="15.17.&nbsp;Case Studies">Section&nbsp;15.17, &#8220;Case Studies&#8221;</a>. </p></div></div><div class="section" title="15.9.&nbsp;RegionServer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.rs"></a>15.9.&nbsp;RegionServer</h2></div></div></div><p>For more information on the RegionServers, see <a class="xref" href="#regionserver.arch" title="9.6.&nbsp;RegionServer">Section&nbsp;9.6, &#8220;RegionServer&#8221;</a>. </p><div class="section" title="15.9.1.&nbsp;Startup Errors"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.rs.startup"></a>15.9.1.&nbsp;Startup Errors</h3></div></div></div><div class="section" title="15.9.1.1.&nbsp;Master Starts, But RegionServers Do Not"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.startup.master-no-region"></a>15.9.1.1.&nbsp;Master Starts, But RegionServers Do Not</h4></div></div></div><p>The Master believes the RegionServers have the IP of 127.0.0.1 - which is localhost
          and resolves to the master's own localhost. </p><p>The RegionServers are erroneously informing the Master that their IP addresses are
          127.0.0.1. </p><p>Modify <code class="filename">/etc/hosts</code> on the region servers, from...</p><pre class="programlisting">
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               fully.qualified.regionservername regionservername  localhost.localdomain localhost
::1             localhost6.localdomain6 localhost6
            </pre><p>... to (removing the master node's name from localhost)...</p><pre class="programlisting">
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1               localhost.localdomain localhost
::1             localhost6.localdomain6 localhost6
            </pre></div><div class="section" title="15.9.1.2.&nbsp;Compression Link Errors"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.startup.compression"></a>15.9.1.2.&nbsp;Compression Link Errors</h4></div></div></div><p> Since compression algorithms such as LZO need to be installed and configured on each
          cluster this is a frequent source of startup error. If you see messages like
          this...</p><pre class="programlisting">
11/02/20 01:32:15 ERROR lzo.GPLNativeCodeLoader: Could not load native gpl library
java.lang.UnsatisfiedLinkError: no gplcompression in java.library.path
        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1734)
        at java.lang.Runtime.loadLibrary0(Runtime.java:823)
        at java.lang.System.loadLibrary(System.java:1028)
            </pre><p>.. then there is a path issue with the compression libraries. See the Configuration
          section on <a class="link" href="#lzo.compression" title="E.3.1.3.&nbsp;Install LZO Support">LZO compression configuration</a>. </p></div></div><div class="section" title="15.9.2.&nbsp;Runtime Errors"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.rs.runtime"></a>15.9.2.&nbsp;Runtime Errors</h3></div></div></div><div class="section" title="15.9.2.1.&nbsp;RegionServer Hanging"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.hang"></a>15.9.2.1.&nbsp;RegionServer Hanging</h4></div></div></div><p> Are you running an old JVM (&lt; 1.6.0_u21?)? When you look at a thread dump, does it
          look like threads are BLOCKED but no one holds the lock all are blocked on? See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3622" target="_top">HBASE 3622 Deadlock in
            HBaseServer (JVM bug?)</a>. Adding <code class="code">-XX:+UseMembar</code> to the HBase
            <code class="varname">HBASE_OPTS</code> in <code class="filename">conf/hbase-env.sh</code> may fix it.
        </p></div><div class="section" title="15.9.2.2.&nbsp;java.io.IOException...(Too many open files)"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.filehandles"></a>15.9.2.2.&nbsp;java.io.IOException...(Too many open files)</h4></div></div></div><p> If you see log messages like this...</p><pre class="programlisting">
2010-09-13 01:24:17,336 WARN org.apache.hadoop.hdfs.server.datanode.DataNode:
Disk-related IOException in BlockReceiver constructor. Cause is java.io.IOException: Too many open files
        at java.io.UnixFileSystem.createFileExclusively(Native Method)
        at java.io.File.createNewFile(File.java:883)
</pre><p>... see the Getting Started section on <a class="link" href="#ulimit">ulimit and nproc configuration</a>. </p></div><div class="section" title="15.9.2.3.&nbsp;xceiverCount 258 exceeds the limit of concurrent xcievers 256"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.xceivers"></a>15.9.2.3.&nbsp;xceiverCount 258 exceeds the limit of concurrent xcievers 256</h4></div></div></div><p> This typically shows up in the DataNode logs. </p><p> See the Getting Started section on <a class="link" href="#dfs.datanode.max.transfer.threads" title="2.1.1.6.&nbsp;dfs.datanode.max.transfer.threads">xceivers configuration</a>. </p></div><div class="section" title="15.9.2.4.&nbsp;System instability, and the presence of &#34;java.lang.OutOfMemoryError: unable to create new native thread in exceptions&#34; HDFS DataNode logs or that of any system daemon"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.oom-nt"></a>15.9.2.4.&nbsp;System instability, and the presence of "java.lang.OutOfMemoryError: unable to create
          new native thread in exceptions" HDFS DataNode logs or that of any system daemon</h4></div></div></div><p> See the Getting Started section on <a class="link" href="#ulimit">ulimit and nproc configuration</a>. The default on recent Linux
          distributions is 1024 - which is far too low for HBase. </p></div><div class="section" title="15.9.2.5.&nbsp;DFS instability and/or RegionServer lease timeouts"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.gc"></a>15.9.2.5.&nbsp;DFS instability and/or RegionServer lease timeouts</h4></div></div></div><p> If you see warning messages like this...</p><pre class="programlisting">
2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 10000
2009-02-24 10:01:33,516 WARN org.apache.hadoop.hbase.util.Sleeper: We slept xxx ms, ten times longer than scheduled: 15000
2009-02-24 10:01:36,472 WARN org.apache.hadoop.hbase.regionserver.HRegionServer: unable to report to master for xxx milliseconds - retrying
           </pre><p>... or see full GC compactions then you may be experiencing full GC's. </p></div><div class="section" title="15.9.2.6.&nbsp;&#34;No live nodes contain current block&#34; and/or YouAreDeadException"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.nolivenodes"></a>15.9.2.6.&nbsp;"No live nodes contain current block" and/or YouAreDeadException</h4></div></div></div><p> These errors can happen either when running out of OS file handles or in periods of
          severe network problems where the nodes are unreachable. </p><p> See the Getting Started section on <a class="link" href="#ulimit">ulimit and nproc configuration</a> and check your network. </p></div><div class="section" title="15.9.2.7.&nbsp;ZooKeeper SessionExpired events"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.zkexpired"></a>15.9.2.7.&nbsp;ZooKeeper SessionExpired events</h4></div></div></div><p>Master or RegionServers shutting down with messages like those in the logs: </p><pre class="programlisting">
WARN org.apache.zookeeper.ClientCnxn: Exception
closing session 0x278bd16a96000f to sun.nio.ch.SelectionKeyImpl@355811ec
java.io.IOException: TIMED OUT
       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:906)
WARN org.apache.hadoop.hbase.util.Sleeper: We slept 79410ms, ten times longer than scheduled: 5000
INFO org.apache.zookeeper.ClientCnxn: Attempting connection to server hostname/IP:PORT
INFO org.apache.zookeeper.ClientCnxn: Priming connection to java.nio.channels.SocketChannel[connected local=/IP:PORT remote=hostname/IP:PORT]
INFO org.apache.zookeeper.ClientCnxn: Server connection successful
WARN org.apache.zookeeper.ClientCnxn: Exception closing session 0x278bd16a96000d to sun.nio.ch.SelectionKeyImpl@3544d65e
java.io.IOException: Session Expired
       at org.apache.zookeeper.ClientCnxn$SendThread.readConnectResult(ClientCnxn.java:589)
       at org.apache.zookeeper.ClientCnxn$SendThread.doIO(ClientCnxn.java:709)
       at org.apache.zookeeper.ClientCnxn$SendThread.run(ClientCnxn.java:945)
ERROR org.apache.hadoop.hbase.regionserver.HRegionServer: ZooKeeper session expired
           </pre><p> The JVM is doing a long running garbage collecting which is pausing every threads
          (aka "stop the world"). Since the RegionServer's local ZooKeeper client cannot send
          heartbeats, the session times out. By design, we shut down any node that isn't able to
          contact the ZooKeeper ensemble after getting a timeout so that it stops serving data that
          may already be assigned elsewhere. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Make sure you give plenty of RAM (in <code class="filename">hbase-env.sh</code>), the
              default of 1GB won't be able to sustain long running imports.</p></li><li class="listitem"><p>Make sure you don't swap, the JVM never behaves well under swapping.</p></li><li class="listitem"><p>Make sure you are not CPU starving the RegionServer thread. For example, if you
              are running a MapReduce job using 6 CPU-intensive tasks on a machine with 4 cores, you
              are probably starving the RegionServer enough to create longer garbage collection
              pauses.</p></li><li class="listitem"><p>Increase the ZooKeeper session timeout</p></li></ul></div><p>If you wish to increase the session timeout, add the following to your
            <code class="filename">hbase-site.xml</code> to increase the timeout from the default of 60
          seconds to 120 seconds. </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;zookeeper.session.timeout&lt;/name&gt;
    &lt;value&gt;1200000&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.tickTime&lt;/name&gt;
    &lt;value&gt;6000&lt;/value&gt;
&lt;/property&gt;
            </pre><p>
           Be aware that setting a higher timeout means that the regions served by a failed RegionServer will take at least
           that amount of time to be transfered to another RegionServer. For a production system serving live requests, we would instead
           recommend setting it lower than 1 minute and over-provision your cluster in order the lower the memory load on each machines (hence having
           less garbage to collect per machine).
           </p><p>
           If this is happening during an upload which only happens once (like initially loading all your data into HBase), consider bulk loading.
           </p><p>See <a class="xref" href="#trouble.zookeeper.general" title="15.11.2.&nbsp;ZooKeeper, The Cluster Canary">Section&nbsp;15.11.2, &#8220;ZooKeeper, The Cluster Canary&#8221;</a> for other general information about ZooKeeper troubleshooting.
</p></div><div class="section" title="15.9.2.8.&nbsp;NotServingRegionException"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.notservingregion"></a>15.9.2.8.&nbsp;NotServingRegionException</h4></div></div></div><p>This exception is "normal" when found in the RegionServer logs at DEBUG level.  This exception is returned back to the client
           and then the client goes back to hbase:meta to find the new location of the moved region.</p><p>However, if the NotServingRegionException is logged ERROR, then the client ran out of retries and something probably wrong.</p></div><div class="section" title="15.9.2.9.&nbsp;Regions listed by domain name, then IP"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.double_listed_regions"></a>15.9.2.9.&nbsp;Regions listed by domain name, then IP</h4></div></div></div><p>
           Fix your DNS.  In versions of Apache HBase before 0.92.x, reverse DNS needs to give same answer
           as forward lookup. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-3431" target="_top">HBASE 3431
           RegionServer is not using the name given it by the master; double entry in master listing of servers</a> for gorey details.
          </p></div><div class="section" title="15.9.2.10.&nbsp;Logs flooded with '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Got brand-new compressor' messages"><div class="titlepage"><div><div><h4 class="title"><a name="brand.new.compressor"></a>15.9.2.10.&nbsp;Logs flooded with '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Got
            brand-new compressor' messages</h4></div></div></div><p>We are not using the native versions of compression
                    libraries.  See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1900" target="_top">HBASE-1900 Put back native support when hadoop 0.21 is released</a>.
                    Copy the native libs from hadoop under hbase lib dir or
                    symlink them into place and the message should go away.
                </p></div><div class="section" title="15.9.2.11.&nbsp;Server handler X on 60020 caught: java.nio.channels.ClosedChannelException"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.rs.runtime.client_went_away"></a>15.9.2.11.&nbsp;Server handler X on 60020 caught: java.nio.channels.ClosedChannelException</h4></div></div></div><p>
           If you see this type of message it means that the region server was trying to read/send data from/to a client but
           it already went away. Typical causes for this are if the client was killed (you see a storm of messages like this when a MapReduce
           job is killed or fails) or if the client receives a SocketTimeoutException. It's harmless, but you should consider digging in
           a bit more if you aren't doing something to trigger them.
           </p></div></div><div class="section" title="15.9.3.&nbsp;Snapshot Errors Due to Reverse DNS"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e16247"></a>15.9.3.&nbsp;Snapshot Errors Due to Reverse DNS</h3></div></div></div><p>Several operations within HBase, including snapshots, rely on properly configured
        reverse DNS. Some environments, such as Amazon EC2, have trouble with reverse DNS. If you
        see errors like the following on your RegionServers, check your reverse DNS configuration:</p><pre class="screen">
2013-05-01 00:04:56,356 DEBUG org.apache.hadoop.hbase.procedure.Subprocedure: Subprocedure 'backup1' 
coordinator notified of 'acquire', waiting on 'reached' or 'abort' from coordinator.        
      </pre><p>In general, the hostname reported by the RegionServer needs to be the same as the
        hostname the Master is trying to reach. You can see a hostname mismatch by looking for the
        following type of message in the RegionServer's logs at start-up.</p><pre class="screen">
2013-05-01 00:03:00,614 INFO org.apache.hadoop.hbase.regionserver.HRegionServer: Master passed us hostname 
to use. Was=myhost-1234, Now=ip-10-55-88-99.ec2.internal        
      </pre></div><div class="section" title="15.9.4.&nbsp;Shutdown Errors"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.rs.shutdown"></a>15.9.4.&nbsp;Shutdown Errors</h3></div></div></div><p></p></div></div><div class="section" title="15.10.&nbsp;Master"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.master"></a>15.10.&nbsp;Master</h2></div></div></div><p>For more information on the Master, see <a class="xref" href="#master" title="9.5.&nbsp;Master">Section&nbsp;9.5, &#8220;Master&#8221;</a>.
       </p><div class="section" title="15.10.1.&nbsp;Startup Errors"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.master.startup"></a>15.10.1.&nbsp;Startup Errors</h3></div></div></div><div class="section" title="15.10.1.1.&nbsp;Master says that you need to run the hbase migrations script"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.master.startup.migration"></a>15.10.1.1.&nbsp;Master says that you need to run the hbase migrations script</h4></div></div></div><p>Upon running that, the hbase migrations script says no files in root directory.</p><p>HBase expects the root directory to either not exist, or to have already been initialized by hbase running a previous time. If you create a new directory for HBase using Hadoop DFS, this error will occur.
             Make sure the HBase root directory does not currently exist or has been initialized by a previous run of HBase. Sure fire solution is to just use Hadoop dfs to delete the HBase root and let HBase create and initialize the directory itself.
             </p></div><div class="section" title="15.10.1.2.&nbsp;Packet len6080218 is out of range!"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.master.startup.zk.buffer"></a>15.10.1.2.&nbsp;Packet len6080218 is out of range!</h4></div></div></div><p>If you have many regions on your cluster and you see an error
                  like that reported above in this sections title in your logs, see
                  <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4246" target="_top">HBASE-4246 Cluster with too many regions cannot withstand some master failover scenarios</a>.</p></div></div><div class="section" title="15.10.2.&nbsp;Shutdown Errors"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.master.shutdown"></a>15.10.2.&nbsp;Shutdown Errors</h3></div></div></div><p></p></div></div><div class="section" title="15.11.&nbsp;ZooKeeper"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.zookeeper"></a>15.11.&nbsp;ZooKeeper</h2></div></div></div><div class="section" title="15.11.1.&nbsp;Startup Errors"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.zookeeper.startup"></a>15.11.1.&nbsp;Startup Errors</h3></div></div></div><div class="section" title="15.11.1.1.&nbsp;Could not find my address: xyz in list of ZooKeeper quorum servers"><div class="titlepage"><div><div><h4 class="title"><a name="trouble.zookeeper.startup.address"></a>15.11.1.1.&nbsp;Could not find my address: xyz in list of ZooKeeper quorum servers</h4></div></div></div><p>A ZooKeeper server wasn't able to start, throws that error. xyz is the name of your server.</p><p>This is a name lookup problem. HBase tries to start a ZooKeeper server on some machine but that machine isn't able to find itself in the <code class="varname">hbase.zookeeper.quorum</code> configuration.
             </p><p>Use the hostname presented in the error message instead of the value you used. If you have a DNS server, you can set <code class="varname">hbase.zookeeper.dns.interface</code> and <code class="varname">hbase.zookeeper.dns.nameserver</code> in <code class="filename">hbase-site.xml</code> to make sure it resolves to the correct FQDN.
             </p></div></div><div class="section" title="15.11.2.&nbsp;ZooKeeper, The Cluster Canary"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.zookeeper.general"></a>15.11.2.&nbsp;ZooKeeper, The Cluster Canary</h3></div></div></div><p>ZooKeeper is the cluster's "canary in the mineshaft". It'll be the first to notice issues if any so making sure its happy is the short-cut to a humming cluster.
          </p><p>
          See the <a class="link" href="http://wiki.apache.org/hadoop/ZooKeeper/Troubleshooting" target="_top">ZooKeeper Operating Environment Troubleshooting</a> page. It has suggestions and tools for checking disk and networking performance; i.e. the operating environment your ZooKeeper and HBase are running in.
          </p><p>Additionally, the utility <a class="xref" href="#trouble.tools.builtin.zkcli" title="15.4.1.3.&nbsp;zkcli">Section&nbsp;15.4.1.3, &#8220;zkcli&#8221;</a> may help investigate ZooKeeper issues.
         </p></div></div><div class="section" title="15.12.&nbsp;Amazon EC2"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.ec2"></a>15.12.&nbsp;Amazon EC2</h2></div></div></div><div class="section" title="15.12.1.&nbsp;ZooKeeper does not seem to work on Amazon EC2"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.ec2.zookeeper"></a>15.12.1.&nbsp;ZooKeeper does not seem to work on Amazon EC2</h3></div></div></div><p>HBase does not start when deployed as Amazon EC2 instances.  Exceptions like the below appear in the Master and/or RegionServer logs: </p><pre class="programlisting">
  2009-10-19 11:52:27,030 INFO org.apache.zookeeper.ClientCnxn: Attempting
  connection to server ec2-174-129-15-236.compute-1.amazonaws.com/10.244.9.171:2181
  2009-10-19 11:52:27,032 WARN org.apache.zookeeper.ClientCnxn: Exception
  closing session 0x0 to sun.nio.ch.SelectionKeyImpl@656dc861
  java.net.ConnectException: Connection refused
             </pre><p>
             Security group policy is blocking the ZooKeeper port on a public address.
             Use the internal EC2 host names when configuring the ZooKeeper quorum peer list.
             </p></div><div class="section" title="15.12.2.&nbsp;Instability on Amazon EC2"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.ec2.instability"></a>15.12.2.&nbsp;Instability on Amazon EC2</h3></div></div></div><p>Questions on HBase and Amazon EC2 come up frequently on the HBase dist-list. Search for old threads using <a class="link" href="http://search-hadoop.com/" target="_top">Search Hadoop</a>
             </p></div><div class="section" title="15.12.3.&nbsp;Remote Java Connection into EC2 Cluster Not Working"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.ec2.connection"></a>15.12.3.&nbsp;Remote Java Connection into EC2 Cluster Not Working</h3></div></div></div><p>
             See Andrew's answer here, up on the user list: <a class="link" href="http://search-hadoop.com/m/sPdqNFAwyg2" target="_top">Remote Java client connection into EC2 instance</a>.
             </p></div></div><div class="section" title="15.13.&nbsp;HBase and Hadoop version issues"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.versions"></a>15.13.&nbsp;HBase and Hadoop version issues</h2></div></div></div><div class="section" title="15.13.1.&nbsp;NoClassDefFoundError when trying to run 0.90.x on hadoop-0.20.205.x (or hadoop-1.0.x)"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.versions.205"></a>15.13.1.&nbsp;<code class="code">NoClassDefFoundError</code> when trying to run 0.90.x on hadoop-0.20.205.x (or hadoop-1.0.x)</h3></div></div></div><p>Apache HBase 0.90.x does not ship with hadoop-0.20.205.x, etc.  To make it run, you need to replace the hadoop
             jars that Apache HBase shipped with in its <code class="filename">lib</code> directory with those of the Hadoop you want to
             run HBase on.  If even after replacing Hadoop jars you get the below exception:</p><pre class="programlisting">
sv4r6s38: Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/commons/configuration/Configuration
sv4r6s38:       at org.apache.hadoop.metrics2.lib.DefaultMetricsSystem.&lt;init&gt;(DefaultMetricsSystem.java:37)
sv4r6s38:       at org.apache.hadoop.metrics2.lib.DefaultMetricsSystem.&lt;clinit&gt;(DefaultMetricsSystem.java:34)
sv4r6s38:       at org.apache.hadoop.security.UgiInstrumentation.create(UgiInstrumentation.java:51)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.initialize(UserGroupInformation.java:209)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.ensureInitialized(UserGroupInformation.java:177)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.isSecurityEnabled(UserGroupInformation.java:229)
sv4r6s38:       at org.apache.hadoop.security.KerberosName.&lt;clinit&gt;(KerberosName.java:83)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.initialize(UserGroupInformation.java:202)
sv4r6s38:       at org.apache.hadoop.security.UserGroupInformation.ensureInitialized(UserGroupInformation.java:177)
</pre><p>you need to copy under <code class="filename">hbase/lib</code>, the
          <code class="filename">commons-configuration-X.jar</code> you find in your Hadoop's
          <code class="filename">lib</code> directory. That should fix the above complaint. </p></div><div class="section" title="15.13.2.&nbsp;...cannot communicate with client version..."><div class="titlepage"><div><div><h3 class="title"><a name="trouble.wrong.version"></a>15.13.2.&nbsp;...cannot communicate with client version...</h3></div></div></div><p>If you see something like the following in your logs <code class="computeroutput">... 2012-09-24
          10:20:52,168 FATAL org.apache.hadoop.hbase.master.HMaster: Unhandled exception. Starting
          shutdown. org.apache.hadoop.ipc.RemoteException: Server IPC version 7 cannot communicate
          with client version 4 ...</code> ...are you trying to talk to an Hadoop 2.0.x
        from an HBase that has an Hadoop 1.0.x client? Use the HBase built against Hadoop 2.0 or
        rebuild your HBase passing the <span class="command"><strong>-Dhadoop.profile=2.0</strong></span> attribute to Maven
        (See <a class="xref" href="#maven.build.hadoop" title="18.4.1.3.&nbsp;Building against various hadoop versions.">Section&nbsp;18.4.1.3, &#8220;Building against various hadoop versions.&#8221;</a> for more). </p></div></div><div class="section" title="15.14.&nbsp;IPC Configuration Conflicts with Hadoop"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e16399"></a>15.14.&nbsp;IPC Configuration Conflicts with Hadoop</h2></div></div></div><p>If the Hadoop configuration is loaded after the HBase configuration, and you have
      configured custom IPC settings in both HBase and Hadoop, the Hadoop values may overwrite the
      HBase values. There is normally no need to change these settings for HBase, so this problem is
      an edge case. However, <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11492" target="_top">HBASE-11492</a> renames
      these settings for HBase to remove the chance of a conflict. Each of the setting names have
      been prefixed with <code class="literal">hbase.</code>, as shown in the following table. No action is
      required related to these changes unless you are already experiencing a conflict.</p><p>These changes were backported to HBase 0.98.x and apply to all newer versions.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><thead><tr><th>Pre-0.98.x</th><th>0.98-x And Newer</th></tr></thead><tbody><tr><td><p><code class="code">ipc.server.listen.queue.size</code></p></td><td><p><code class="code">hbase.ipc.server.listen.queue.size</code></p></td></tr><tr><td><p><code class="code">ipc.server.max.callqueue.size</code></p></td><td><p><code class="code">hbase.ipc.server.max.callqueue.size</code></p></td></tr><tr><td><p><code class="code">ipc.server.callqueue.handler.factor</code></p></td><td><p><code class="code">hbase.ipc.server.callqueue.handler.factor</code></p></td></tr><tr><td><p><code class="code">ipc.server.callqueue.read.share</code></p></td><td><p><code class="code">hbase.ipc.server.callqueue.read.share</code></p></td></tr><tr><td><p><code class="code">ipc.server.callqueue.type</code></p></td><td><p><code class="code">hbase.ipc.server.callqueue.type</code></p></td></tr><tr><td><p><code class="code">ipc.server.queue.max.call.delay</code></p></td><td><p><code class="code">hbase.ipc.server.queue.max.call.delay</code></p></td></tr><tr><td><p><code class="code">ipc.server.max.callqueue.length</code></p></td><td><p><code class="code">hbase.ipc.server.max.callqueue.length</code></p></td></tr><tr><td><p><code class="code">ipc.server.read.threadpool.size</code></p></td><td><p><code class="code">hbase.ipc.server.read.threadpool.size</code></p></td></tr><tr><td><p><code class="code">ipc.server.tcpkeepalive</code></p></td><td><p><code class="code">hbase.ipc.server.tcpkeepalive</code></p></td></tr><tr><td><p><code class="code">ipc.server.tcpnodelay</code></p></td><td><p><code class="code">hbase.ipc.server.tcpnodelay</code></p></td></tr><tr><td><p><code class="code">ipc.client.call.purge.timeout</code></p></td><td><p><code class="code">hbase.ipc.client.call.purge.timeout</code></p></td></tr><tr><td><p><code class="code">ipc.client.connection.maxidletime</code></p></td><td><p><code class="code">hbase.ipc.client.connection.maxidletime</code></p></td></tr><tr><td><p><code class="code">ipc.client.idlethreshold</code></p></td><td><p><code class="code">hbase.ipc.client.idlethreshold</code></p></td></tr><tr><td><p><code class="code">ipc.client.kill.max</code></p></td><td><p><code class="code">hbase.ipc.client.kill.max</code></p></td></tr><tr><td><p><code class="code">ipc.server.scan.vtime.weight </code></p></td><td><p><code class="code">hbase.ipc.server.scan.vtime.weight </code></p></td></tr></tbody></table></div></div><div class="section" title="15.15.&nbsp;HBase and HDFS"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e16556"></a>15.15.&nbsp;HBase and HDFS</h2></div></div></div><p>General configuration guidance for Apache HDFS is out of the scope of this guide. Refer to
      the documentation available at <a class="link" href="http://hadoop.apache.org/" target="_top">http://hadoop.apache.org/</a> for extensive
      information about configuring HDFS. This section deals with HDFS in terms of HBase. </p><p>In most cases, HBase stores its data in Apache HDFS. This includes the HFiles containing
      the data, as well as the write-ahead logs (WALs) which store data before it is written to the
      HFiles and protect against RegionServer crashes. HDFS provides reliability and protection to
      data in HBase because it is distributed. To operate with the most efficiency, HBase needs data
    to be available locally. Therefore, it is a good practice to run an HDFS datanode on each
    RegionServer.</p><div class="variablelist" title="Important Information and Guidelines for HBase and HDFS"><p class="title"><b>Important Information and Guidelines for HBase and HDFS</b></p><dl><dt><span class="term">HBase is a client of HDFS.</span></dt><dd><p>HBase is an HDFS client, using the HDFS <code class="code">DFSClient</code> class, and references
            to this class appear in HBase logs with other HDFS client log messages.</p></dd><dt><span class="term">Configuration is necessary in multiple places.</span></dt><dd><p>Some HDFS configurations relating to HBase need to be done at the HDFS (server) side.
            Others must be done within HBase (at the client side). Other settings need
            to be set at both the server and client side.
          </p></dd><dt><span class="term">Write errors which affect HBase may be logged in the HDFS logs rather than HBase logs.</span></dt><dd><p>When writing, HDFS pipelines communications from one datanode to another. HBase
            communicates to both the HDFS namenode and datanode, using the HDFS client classes.
            Communication problems between datanodes are logged in the HDFS logs, not the HBase
            logs.</p><p>HDFS writes are always local when possible. HBase RegionServers should not
            experience many write errors, because they write the local datanode. If the datanode
            cannot replicate the blocks, the errors are logged in HDFS, not in the HBase
            RegionServer logs.</p></dd><dt><span class="term">HBase communicates with HDFS using two different ports.</span></dt><dd><p>HBase communicates with datanodes using the <code class="code">ipc.Client</code> interface and
            the <code class="code">DataNode</code> class. References to these will appear in HBase logs. Each of
            these communication channels use a different port (50010 and 50020 by default). The
            ports are configured in the HDFS configuration, via the
              <code class="code">dfs.datanode.address</code> and <code class="code">dfs.datanode.ipc.address</code>
            parameters.</p></dd><dt><span class="term">Errors may be logged in HBase, HDFS, or both.</span></dt><dd><p>When troubleshooting HDFS issues in HBase, check logs in both places for errors.</p></dd><dt><span class="term">HDFS takes a while to mark a node as dead. You can configure HDFS to avoid using stale
          datanodes.</span></dt><dd><p>By default, HDFS does not mark a node as dead until it is unreachable for 630
            seconds. In Hadoop 1.1 and Hadoop 2.x, this can be alleviated by enabling checks for
            stale datanodes, though this check is disabled by default. You can enable the check for
            reads and writes separately, via <code class="code">dfs.namenode.avoid.read.stale.datanode</code> and
              <code class="code">dfs.namenode.avoid.write.stale.datanode settings</code>. A stale datanode is one
            that has not been reachable for <code class="code">dfs.namenode.stale.datanode.interval</code>
            (default is 30 seconds). Stale datanodes are avoided, and marked as the last possible
            target for a read or write operation. For configuration details, see the HDFS
            documentation.</p></dd><dt><span class="term">Settings for HDFS retries and timeouts are important to HBase.</span></dt><dd><p>You can configure settings for various retries and timeouts. Always refer to the
            HDFS documentation for current recommendations and defaults. Some of the settings
            important to HBase are listed here. Defaults are current as of Hadoop 2.3. Check the
            Hadoop documentation for the most current values and recommendations.</p><div class="variablelist" title="Retries"><p class="title"><b>Retries</b></p><dl><dt><span class="term"><code class="code">ipc.client.connect.max.retries</code> (default: 10)</span></dt><dd><p>The number of times a client will attempt to establish a connection with the
                  server. This value sometimes needs to be increased. You can specify different
                  setting for the maximum number of retries if a timeout occurs. For SASL
                  connections, the number of retries is hard-coded at 15 and cannot be
                  configured.</p></dd><dt><span class="term"><code class="code">ipc.client.connect.max.retries.on.timeouts</code> (default: 45)</span></dt><dd><p>The number of times a client will attempt to establish a connection
                with the server in the event of a timeout. If some retries are due to timeouts and
                some are due to other reasons, this counter is added to
                <code class="code">ipc.client.connect.max.retries</code>, so the maximum number of retries for
                all reasons could be the combined value.</p></dd><dt><span class="term"><code class="code">dfs.client.block.write.retries</code> (default: 3)</span></dt><dd><p>How many times the client attempts to write to the datanode. After the
              number of retries is reached, the client reconnects to the namenode to get a new
              location of a datanode. You can try increasing this value.</p></dd></dl></div><div class="variablelist" title="HDFS Heartbeats"><p class="title"><b>HDFS Heartbeats</b></p><p>HDFS heartbeats are entirely on the HDFS side, between the namenode and datanodes.</p><dl><dt><span class="term"><code class="code">dfs.heartbeat.interval</code> (default: 3)</span></dt><dd><p>The interval at which a node heartbeats.</p></dd><dt><span class="term"><code class="code">dfs.namenode.heartbeat.recheck-interval</code> (default: 300000)</span></dt><dd><p>The interval of time between heartbeat checks. The total time before a node is
                  marked as stale is determined by the following formula, which works out to 10
                  minutes and 30 seconds:</p><pre class="screen"> 2 * (dfs.namenode.heartbeat.recheck-interval) + 10 * 1000 * (dfs.heartbeat.interval)</pre></dd><dt><span class="term"><code class="code">dfs.namenode.stale.datanode.interval</code> (default: 3000)</span></dt><dd><p>How long (in milliseconds) a node can go without a heartbeat before it is
                  determined to be stale, if the other options to do with stale datanodes are
                  configured (off by default).</p></dd></dl></div></dd></dl></div><div class="variablelist" title="Connection Timeouts"><p class="title"><b>Connection Timeouts</b></p><p>Connection timeouts occur between the client (HBASE) and the HDFS datanode. They may
        occur when establishing a connection, attempting to read, or attempting to write. The two
        settings below are used in combination, and affect connections between the DFSClient and the
        datanode, the ipc.cClient and the datanode, and communication between two datanodes. </p><dl><dt><span class="term"><code class="code">dfs.client.socket-timeout</code> (default: 60000)</span></dt><dd><p>The amount of time before a client connection times out when establishing a
            connection or reading. The value is expressed in milliseconds, so the default is 60
            seconds.</p></dd><dt><span class="term"><code class="code">dfs.datanode.socket.write.timeout</code> (default: 480000)</span></dt><dd><p>The amount of time before a write operation times out. The default is 8
            minutes, expressed as milliseconds.</p></dd></dl></div><div class="variablelist" title="Typical Error Logs"><p class="title"><b>Typical Error Logs</b></p><p>The following types of errors are often seen in the logs.</p><dl><dt><span class="term"><code class="code">INFO HDFS.DFSClient: Failed to connect to /xxx50010, add to deadNodes and
            continue java.net.SocketTimeoutException: 60000 millis timeout while waiting for channel
            to be ready for connect. ch : java.nio.channels.SocketChannel[connection-pending
            remote=/region-server-1:50010]</code></span></dt><dd><p>All datanodes for a block are dead, and recovery is not possible. Here is the
            sequence of events that leads to this error:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The client attempts to connect to a dead datanode.</p></li><li class="listitem"><p>The connection fails, so the client moves down the list of datanodes and tries
                the next one. It also fails.</p></li><li class="listitem"><p>When the client exhausts its entire list, it sleeps for 3 seconds and requests a
              new list. It is very likely to receive the exact same list as before, in which case
              the error occurs again.</p></li></ul></div></dd><dt><span class="term"><code class="code">INFO org.apache.hadoop.HDFS.DFSClient: Exception in createBlockOutputStream
            java.net.SocketTimeoutException: 69000 millis timeout while waiting for channel to be
            ready for connect. ch : java.nio.channels.SocketChannel[connection-pending remote=/
            xxx:50010]</code></span></dt><dd><p>This type of error indicates a write issue. In this case, the master wants to split
            the log. It does not have a local datanode so it tries to connect to a remote datanode,
            but the datanode is dead.</p><p>In this situation, there will be three retries (by default). If all retries fail, a
            message like the following is logged:</p><pre class="screen">
WARN HDFS.DFSClient: DataStreamer Exception: java.io.IOException: Unable to create new block
          </pre><p>If the operation was an attempt to split the log, the following type of message may
            also appear:</p><pre class="screen">
FATAL wal.HLogSplitter: WriterThread-xxx Got while writing log entry to log            
          </pre></dd></dl></div></div><div class="section" title="15.16.&nbsp;Running unit or integration tests"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.tests"></a>15.16.&nbsp;Running unit or integration tests</h2></div></div></div><div class="section" title="15.16.1.&nbsp;Runtime exceptions from MiniDFSCluster when running tests"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.HDFS-2556"></a>15.16.1.&nbsp;Runtime exceptions from MiniDFSCluster when running tests</h3></div></div></div><p>If you see something like the following</p><pre class="programlisting">...
java.lang.NullPointerException: null
at org.apache.hadoop.hdfs.MiniDFSCluster.startDataNodes
at org.apache.hadoop.hdfs.MiniDFSCluster.&lt;init&gt;
at org.apache.hadoop.hbase.MiniHBaseCluster.&lt;init&gt;
at org.apache.hadoop.hbase.HBaseTestingUtility.startMiniDFSCluster
at org.apache.hadoop.hbase.HBaseTestingUtility.startMiniCluster
...</pre><p> or</p><pre class="programlisting">...
java.io.IOException: Shutting down
at org.apache.hadoop.hbase.MiniHBaseCluster.init
at org.apache.hadoop.hbase.MiniHBaseCluster.&lt;init&gt;
at org.apache.hadoop.hbase.MiniHBaseCluster.&lt;init&gt;
at org.apache.hadoop.hbase.HBaseTestingUtility.startMiniHBaseCluster
at org.apache.hadoop.hbase.HBaseTestingUtility.startMiniCluster
...</pre><p>... then try issuing the command <span class="command"><strong>umask 022</strong></span> before launching tests.
        This is a workaround for <a class="link" href="https://issues.apache.org/jira/browse/HDFS-2556" target="_top">HDFS-2556</a>
      </p></div></div><div class="section" title="15.17.&nbsp;Case Studies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.casestudy"></a>15.17.&nbsp;Case Studies</h2></div></div></div><p>For Performance and Troubleshooting Case Studies, see <a class="xref" href="#casestudies" title="Chapter&nbsp;16.&nbsp;Apache HBase Case Studies">Chapter&nbsp;16, <i>Apache HBase Case Studies</i></a>. </p></div><div class="section" title="15.18.&nbsp;Cryptographic Features"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trouble.crypto"></a>15.18.&nbsp;Cryptographic Features</h2></div></div></div><div class="section" title="15.18.1.&nbsp;sun.security.pkcs11.wrapper.PKCS11Exception: CKR_ARGUMENTS_BAD"><div class="titlepage"><div><div><h3 class="title"><a name="trouble.crypto.HBASE-10132"></a>15.18.1.&nbsp;sun.security.pkcs11.wrapper.PKCS11Exception: CKR_ARGUMENTS_BAD</h3></div></div></div><p>This problem manifests as exceptions ultimately caused by:</p><pre class="programlisting">
Caused by: sun.security.pkcs11.wrapper.PKCS11Exception: CKR_ARGUMENTS_BAD
	at sun.security.pkcs11.wrapper.PKCS11.C_DecryptUpdate(Native Method)
	at sun.security.pkcs11.P11Cipher.implDoFinal(P11Cipher.java:795)
</pre><p> This problem appears to affect some versions of OpenJDK 7 shipped by some Linux
        vendors. NSS is configured as the default provider. If the host has an x86_64 architecture,
        depending on if the vendor packages contain the defect, the NSS provider will not function
        correctly. </p><p> To work around this problem, find the JRE home directory and edit the file
          <code class="filename">lib/security/java.security</code>. Edit the file to comment out the line: </p><pre class="programlisting">
security.provider.1=sun.security.pkcs11.SunPKCS11 ${java.home}/lib/security/nss.cfg
</pre><p> Then renumber the remaining providers accordingly. </p></div></div><div class="section" title="15.19.&nbsp;Operating System Specific Issues"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e16806"></a>15.19.&nbsp;Operating System Specific Issues</h2></div></div></div><div class="section" title="15.19.1.&nbsp;Page Allocation Failure"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e16809"></a>15.19.1.&nbsp;Page Allocation Failure</h3></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This issue is known to affect CentOS 6.2 and possibly CentOS 6.5. It may also affect
        some versions of Red Hat Enterprise Linux, according to <a class="link" href="https://bugzilla.redhat.com/show_bug.cgi?id=770545" target="_top">https://bugzilla.redhat.com/show_bug.cgi?id=770545</a>.</p></div><p>Some users have reported seeing the following error:</p><pre class="screen">kernel: java: page allocation failure. order:4, mode:0x20</pre><p>Raising the value of <code class="code">min_free_kbytes</code> was reported to fix this problem. This
      parameter is set to a percentage of the amount of RAM on your system, and is described in more
      detail at <a class="link" href="http://www.centos.org/docs/5/html/5.1/Deployment_Guide/s3-proc-sys-vm.html" target="_top">http://www.centos.org/docs/5/html/5.1/Deployment_Guide/s3-proc-sys-vm.html</a>. </p><p>To find the current value on your system, run the following command:</p><pre class="screen">[user@host]# <strong class="userinput"><code>cat /proc/sys/vm/min_free_kbytes</code></strong></pre><p>Next, raise the value. Try doubling, then quadrupling the value. Note that setting the
        value too low or too high could have detrimental effects on your system. Consult your
        operating system vendor for specific recommendations.</p><p>Use the following command to modify the value of <code class="code">min_free_kbytes</code>,
        substituting <em class="replaceable"><code>&lt;value&gt;</code></em> with your intended value:</p><pre class="screen">[user@host]# <strong class="userinput"><code>echo &lt;value&gt; &gt; /proc/sys/vm/min_free_kbytes</code></strong></pre></div></div><div class="section" title="15.20.&nbsp;JDK Issues"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e16848"></a>15.20.&nbsp;JDK Issues</h2></div></div></div><div class="section" title="15.20.1.&nbsp;NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e16851"></a>15.20.1.&nbsp;NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet</h3></div></div></div><p>
If you see this in your logs:
    </p><pre class="programlisting">Caused by: java.lang.NoSuchMethodError: java.util.concurrent.ConcurrentHashMap.keySet()Ljava/util/concurrent/ConcurrentHashMap$KeySetView;
  at org.apache.hadoop.hbase.master.ServerManager.findServerWithSameHostnamePortWithLock(ServerManager.java:393)
  at org.apache.hadoop.hbase.master.ServerManager.checkAndRecordNewServer(ServerManager.java:307)
  at org.apache.hadoop.hbase.master.ServerManager.regionServerStartup(ServerManager.java:244)
  at org.apache.hadoop.hbase.master.MasterRpcServices.regionServerStartup(MasterRpcServices.java:304)
  at org.apache.hadoop.hbase.protobuf.generated.RegionServerStatusProtos$RegionServerStatusService$2.callBlockingMethod(RegionServerStatusProtos.java:7910)
  at org.apache.hadoop.hbase.ipc.RpcServer.call(RpcServer.java:2020)
  ... 4 more</pre><p>
then check if you compiled with jdk8 and tried to run it on jdk7.  If so, this won't work.
Run on jdk8 or recompile with jdk7.  See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10607" target="_top">HBASE-10607 [JDK8] NoSuchMethodError involving ConcurrentHashMap.keySet if running on JRE 7</a>.
</p></div></div></div><div class="chapter" title="Chapter&nbsp;16.&nbsp;Apache HBase Case Studies"><div class="titlepage"><div><div><h2 class="title"><a name="casestudies"></a>Chapter&nbsp;16.&nbsp;Apache HBase Case Studies</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#casestudies.overview">16.1. Overview</a></span></dt><dt><span class="section"><a href="#casestudies.schema">16.2. Schema Design</a></span></dt><dt><span class="section"><a href="#casestudies.perftroub">16.3. Performance/Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="#casestudies.slownode">16.3.1. Case Study #1 (Performance Issue On A Single Node)</a></span></dt><dt><span class="section"><a href="#casestudies.perf.1">16.3.2. Case Study #2 (Performance Research 2012)</a></span></dt><dt><span class="section"><a href="#casestudies.perf.2">16.3.3. Case Study #3 (Performance Research 2010))</a></span></dt><dt><span class="section"><a href="#casestudies.max.transfer.threads">16.3.4. Case Study #4 (max.transfer.threads Config)</a></span></dt></dl></dd></dl></div><div class="section" title="16.1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="casestudies.overview"></a>16.1.&nbsp;Overview</h2></div></div></div><p> This chapter will describe a variety of performance and troubleshooting case studies that
      can provide a useful blueprint on diagnosing Apache HBase cluster issues. </p><p> For more information on Performance and Troubleshooting, see <a class="xref" href="#performance" title="Chapter&nbsp;14.&nbsp;Apache HBase Performance Tuning">Chapter&nbsp;14, <i>Apache HBase Performance Tuning</i></a> and <a class="xref" href="#trouble" title="Chapter&nbsp;15.&nbsp;Troubleshooting and Debugging Apache HBase">Chapter&nbsp;15, <i>Troubleshooting and Debugging Apache HBase</i></a>. </p></div><div class="section" title="16.2.&nbsp;Schema Design"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="casestudies.schema"></a>16.2.&nbsp;Schema Design</h2></div></div></div><p>See the schema design case studies here: <a class="xref" href="#schema.casestudies" title="6.11.&nbsp;Schema Design Case Studies">Section&nbsp;6.11, &#8220;Schema Design Case Studies&#8221;</a>
    </p></div><div class="section" title="16.3.&nbsp;Performance/Troubleshooting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="casestudies.perftroub"></a>16.3.&nbsp;Performance/Troubleshooting</h2></div></div></div><div class="section" title="16.3.1.&nbsp;Case Study #1 (Performance Issue On A Single Node)"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.slownode"></a>16.3.1.&nbsp;Case Study #1 (Performance Issue On A Single Node)</h3></div></div></div><div class="section" title="16.3.1.1.&nbsp;Scenario"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e16891"></a>16.3.1.1.&nbsp;Scenario</h4></div></div></div><p> Following a scheduled reboot, one data node began exhibiting unusual behavior.
          Routine MapReduce jobs run against HBase tables which regularly completed in five or six
          minutes began taking 30 or 40 minutes to finish. These jobs were consistently found to be
          waiting on map and reduce tasks assigned to the troubled data node (e.g., the slow map
          tasks all had the same Input Split). The situation came to a head during a distributed
          copy, when the copy was severely prolonged by the lagging node. </p></div><div class="section" title="16.3.1.2.&nbsp;Hardware"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e16896"></a>16.3.1.2.&nbsp;Hardware</h4></div></div></div><div class="itemizedlist" title="Datanodes:"><p class="title"><b>Datanodes:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Two 12-core processors</p></li><li class="listitem"><p>Six Enerprise SATA disks</p></li><li class="listitem"><p>24GB of RAM</p></li><li class="listitem"><p>Two bonded gigabit NICs</p></li></ul></div><div class="itemizedlist" title="Network:"><p class="title"><b>Network:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>10 Gigabit top-of-rack switches</p></li><li class="listitem"><p>20 Gigabit bonded interconnects between racks.</p></li></ul></div></div><div class="section" title="16.3.1.3.&nbsp;Hypotheses"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e16923"></a>16.3.1.3.&nbsp;Hypotheses</h4></div></div></div><div class="section" title="16.3.1.3.1.&nbsp;HBase &#34;Hot Spot&#34; Region"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e16926"></a>16.3.1.3.1.&nbsp;HBase "Hot Spot" Region</h5></div></div></div><p> We hypothesized that we were experiencing a familiar point of pain: a "hot spot"
            region in an HBase table, where uneven key-space distribution can funnel a huge number
            of requests to a single HBase region, bombarding the RegionServer process and cause slow
            response time. Examination of the HBase Master status page showed that the number of
            HBase requests to the troubled node was almost zero. Further, examination of the HBase
            logs showed that there were no region splits, compactions, or other region transitions
            in progress. This effectively ruled out a "hot spot" as the root cause of the observed
            slowness. </p></div><div class="section" title="16.3.1.3.2.&nbsp;HBase Region With Non-Local Data"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e16931"></a>16.3.1.3.2.&nbsp;HBase Region With Non-Local Data</h5></div></div></div><p> Our next hypothesis was that one of the MapReduce tasks was requesting data from
            HBase that was not local to the datanode, thus forcing HDFS to request data blocks from
            other servers over the network. Examination of the datanode logs showed that there were
            very few blocks being requested over the network, indicating that the HBase region was
            correctly assigned, and that the majority of the necessary data was located on the node.
            This ruled out the possibility of non-local data causing a slowdown. </p></div><div class="section" title="16.3.1.3.3.&nbsp;Excessive I/O Wait Due To Swapping Or An Over-Worked Or Failing Hard Disk"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e16936"></a>16.3.1.3.3.&nbsp;Excessive I/O Wait Due To Swapping Or An Over-Worked Or Failing Hard Disk</h5></div></div></div><p> After concluding that the Hadoop and HBase were not likely to be the culprits, we
            moved on to troubleshooting the datanode's hardware. Java, by design, will periodically
            scan its entire memory space to do garbage collection. If system memory is heavily
            overcommitted, the Linux kernel may enter a vicious cycle, using up all of its resources
            swapping Java heap back and forth from disk to RAM as Java tries to run garbage
            collection. Further, a failing hard disk will often retry reads and/or writes many times
            before giving up and returning an error. This can manifest as high iowait, as running
            processes wait for reads and writes to complete. Finally, a disk nearing the upper edge
            of its performance envelope will begin to cause iowait as it informs the kernel that it
            cannot accept any more data, and the kernel queues incoming data into the dirty write
            pool in memory. However, using <code class="code">vmstat(1)</code> and <code class="code">free(1)</code>, we could
            see that no swap was being used, and the amount of disk IO was only a few kilobytes per
            second. </p></div><div class="section" title="16.3.1.3.4.&nbsp;Slowness Due To High Processor Usage"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e16947"></a>16.3.1.3.4.&nbsp;Slowness Due To High Processor Usage</h5></div></div></div><p> Next, we checked to see whether the system was performing slowly simply due to very
            high computational load. <code class="code">top(1)</code> showed that the system load was higher than
            normal, but <code class="code">vmstat(1)</code> and <code class="code">mpstat(1)</code> showed that the amount of
            processor being used for actual computation was low. </p></div><div class="section" title="16.3.1.3.5.&nbsp;Network Saturation (The Winner)"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e16961"></a>16.3.1.3.5.&nbsp;Network Saturation (The Winner)</h5></div></div></div><p> Since neither the disks nor the processors were being utilized heavily, we moved on
            to the performance of the network interfaces. The datanode had two gigabit ethernet
            adapters, bonded to form an active-standby interface. <code class="code">ifconfig(8)</code> showed
            some unusual anomalies, namely interface errors, overruns, framing errors. While not
            unheard of, these kinds of errors are exceedingly rare on modern hardware which is
            operating as it should: </p><pre class="screen">		
$ /sbin/ifconfig bond0
bond0  Link encap:Ethernet  HWaddr 00:00:00:00:00:00  
inet addr:10.x.x.x  Bcast:10.x.x.255  Mask:255.255.255.0
UP BROADCAST RUNNING MASTER MULTICAST  MTU:1500  Metric:1
RX packets:2990700159 errors:12 dropped:0 overruns:1 frame:6          &lt;--- Look Here! Errors!
TX packets:3443518196 errors:0 dropped:0 overruns:0 carrier:0
collisions:0 txqueuelen:0 
RX bytes:2416328868676 (2.4 TB)  TX bytes:3464991094001 (3.4 TB)
        </pre><p> These errors immediately lead us to suspect that one or more of the ethernet
            interfaces might have negotiated the wrong line speed. This was confirmed both by
            running an ICMP ping from an external host and observing round-trip-time in excess of
            700ms, and by running <code class="code">ethtool(8)</code> on the members of the bond interface and
            discovering that the active interface was operating at 100Mbs/, full duplex. </p><pre class="screen">		
$ sudo ethtool eth0
Settings for eth0:
Supported ports: [ TP ]
Supported link modes:   10baseT/Half 10baseT/Full 
                       100baseT/Half 100baseT/Full 
                       1000baseT/Full 
Supports auto-negotiation: Yes
Advertised link modes:  10baseT/Half 10baseT/Full 
                       100baseT/Half 100baseT/Full 
                       1000baseT/Full 
Advertised pause frame use: No
Advertised auto-negotiation: Yes
Link partner advertised link modes:  Not reported
Link partner advertised pause frame use: No
Link partner advertised auto-negotiation: No
Speed: 100Mb/s                                     &lt;--- Look Here!  Should say 1000Mb/s!
Duplex: Full
Port: Twisted Pair
PHYAD: 1
Transceiver: internal
Auto-negotiation: on
MDI-X: Unknown
Supports Wake-on: umbg
Wake-on: g
Current message level: 0x00000003 (3)
Link detected: yes
          </pre><p> In normal operation, the ICMP ping round trip time should be around 20ms, and the
            interface speed and duplex should read, "1000MB/s", and, "Full", respectively. </p></div></div><div class="section" title="16.3.1.4.&nbsp;Resolution"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e16980"></a>16.3.1.4.&nbsp;Resolution</h4></div></div></div><p> After determining that the active ethernet adapter was at the incorrect speed, we
          used the <code class="code">ifenslave(8)</code> command to make the standby interface the active
          interface, which yielded an immediate improvement in MapReduce performance, and a 10 times
          improvement in network throughput: </p><p> On the next trip to the datacenter, we determined that the line speed issue was
          ultimately caused by a bad network cable, which was replaced. </p></div></div><div class="section" title="16.3.2.&nbsp;Case Study #2 (Performance Research 2012)"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.perf.1"></a>16.3.2.&nbsp;Case Study #2 (Performance Research 2012)</h3></div></div></div><p> Investigation results of a self-described "we're not sure what's wrong, but it seems
        slow" problem. <a class="link" href="http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html" target="_top">http://gbif.blogspot.com/2012/03/hbase-performance-evaluation-continued.html</a>
      </p></div><div class="section" title="16.3.3.&nbsp;Case Study #3 (Performance Research 2010))"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.perf.2"></a>16.3.3.&nbsp;Case Study #3 (Performance Research 2010))</h3></div></div></div><p> Investigation results of general cluster performance from 2010. Although this research
        is on an older version of the codebase, this writeup is still very useful in terms of
        approach. <a class="link" href="http://hstack.org/hbase-performance-testing/" target="_top">http://hstack.org/hbase-performance-testing/</a>
      </p></div><div class="section" title="16.3.4.&nbsp;Case Study #4 (max.transfer.threads Config)"><div class="titlepage"><div><div><h3 class="title"><a name="casestudies.max.transfer.threads"></a>16.3.4.&nbsp;Case Study #4 (max.transfer.threads Config)</h3></div></div></div><p> Case study of configuring <code class="code">max.transfer.threads</code> (previously known as
        <code class="code">xcievers</code>) and diagnosing errors from misconfigurations. <a class="link" href="http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html" target="_top">http://www.larsgeorge.com/2012/03/hadoop-hbase-and-xceivers.html</a>
      </p><p> See also <a class="xref" href="#dfs.datanode.max.transfer.threads" title="2.1.1.6.&nbsp;dfs.datanode.max.transfer.threads">Section&nbsp;2.1.1.6, &#8220;<code class="varname">dfs.datanode.max.transfer.threads</code>&#8221;</a>. </p></div></div></div><div class="chapter" title="Chapter&nbsp;17.&nbsp;Apache HBase Operational Management"><div class="titlepage"><div><div><h2 class="title"><a name="ops_mgt"></a>Chapter&nbsp;17.&nbsp;Apache HBase Operational Management</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#tools">17.1. HBase Tools and Utilities</a></span></dt><dd><dl><dt><span class="section"><a href="#canary">17.1.1. Canary</a></span></dt><dt><span class="section"><a href="#health.check">17.1.2. Health Checker</a></span></dt><dt><span class="section"><a href="#driver">17.1.3. Driver</a></span></dt><dt><span class="section"><a href="#hbck">17.1.4. HBase <span class="application">hbck</span></a></span></dt><dt><span class="section"><a href="#hfile_tool2">17.1.5. HFile Tool</a></span></dt><dt><span class="section"><a href="#wal_tools">17.1.6. WAL Tools</a></span></dt><dt><span class="section"><a href="#compression.tool">17.1.7. Compression Tool</a></span></dt><dt><span class="section"><a href="#copytable">17.1.8. CopyTable</a></span></dt><dt><span class="section"><a href="#export">17.1.9. Export</a></span></dt><dt><span class="section"><a href="#import">17.1.10. Import</a></span></dt><dt><span class="section"><a href="#importtsv">17.1.11. ImportTsv</a></span></dt><dt><span class="section"><a href="#completebulkload">17.1.12. CompleteBulkLoad</a></span></dt><dt><span class="section"><a href="#walplayer">17.1.13. WALPlayer</a></span></dt><dt><span class="section"><a href="#rowcounter">17.1.14. RowCounter and CellCounter</a></span></dt><dt><span class="section"><a href="#mlockall">17.1.15. mlockall</a></span></dt><dt><span class="section"><a href="#compaction.tool">17.1.16. Offline Compaction Tool</a></span></dt><dt><span class="section"><a href="#d2875e17611">17.1.17. <span class="command"><strong>hbase clean</strong></span></a></span></dt><dt><span class="section"><a href="#d2875e17628">17.1.18. <span class="command"><strong>hbase pe</strong></span></a></span></dt><dt><span class="section"><a href="#d2875e17652">17.1.19. <span class="command"><strong>hbase ltt</strong></span></a></span></dt></dl></dd><dt><span class="section"><a href="#ops.regionmgt">17.2. Region Management</a></span></dt><dd><dl><dt><span class="section"><a href="#ops.regionmgt.majorcompact">17.2.1. Major Compaction</a></span></dt><dt><span class="section"><a href="#ops.regionmgt.merge">17.2.2. Merge</a></span></dt></dl></dd><dt><span class="section"><a href="#node.management">17.3. Node Management</a></span></dt><dd><dl><dt><span class="section"><a href="#decommission">17.3.1. Node Decommission</a></span></dt><dt><span class="section"><a href="#rolling">17.3.2. Rolling Restart</a></span></dt><dt><span class="section"><a href="#adding.new.node">17.3.3. Adding a New Node</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase_metrics">17.4. HBase Metrics</a></span></dt><dd><dl><dt><span class="section"><a href="#metric_setup">17.4.1. Metric Setup</a></span></dt><dt><span class="section"><a href="#d2875e18060">17.4.2. Disabling Metrics</a></span></dt><dt><span class="section"><a href="#discovering.available.metrics">17.4.3. Discovering Available Metrics</a></span></dt><dt><span class="section"><a href="#d2875e18196">17.4.4. Units of Measure for Metrics</a></span></dt><dt><span class="section"><a href="#master_metrics">17.4.5. Most Important Master Metrics</a></span></dt><dt><span class="section"><a href="#rs_metrics">17.4.6. Most Important RegionServer Metrics</a></span></dt></dl></dd><dt><span class="section"><a href="#ops.monitoring">17.5. HBase Monitoring</a></span></dt><dd><dl><dt><span class="section"><a href="#ops.monitoring.overview">17.5.1. Overview</a></span></dt><dt><span class="section"><a href="#ops.slow.query">17.5.2. Slow Query Log</a></span></dt><dt><span class="section"><a href="#d2875e18551">17.5.3. Block Cache Monitoring</a></span></dt></dl></dd><dt><span class="section"><a href="#cluster_replication">17.6. Cluster Replication</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e18651">17.6.1. Life of a WAL Edit</a></span></dt><dt><span class="section"><a href="#d2875e18741">17.6.2. Replication Internals</a></span></dt><dt><span class="section"><a href="#d2875e18820">17.6.3. Replication Configuration Options</a></span></dt><dt><span class="section"><a href="#d2875e18938">17.6.4. Replication Implementation Details</a></span></dt></dl></dd><dt><span class="section"><a href="#ops.backup">17.7. HBase Backup</a></span></dt><dd><dl><dt><span class="section"><a href="#ops.backup.fullshutdown">17.7.1. Full Shutdown Backup</a></span></dt><dt><span class="section"><a href="#ops.backup.live.replication">17.7.2. Live Cluster Backup - Replication</a></span></dt><dt><span class="section"><a href="#ops.backup.live.copytable">17.7.3. Live Cluster Backup - CopyTable</a></span></dt><dt><span class="section"><a href="#ops.backup.live.export">17.7.4. Live Cluster Backup - Export</a></span></dt></dl></dd><dt><span class="section"><a href="#ops.snapshots">17.8. HBase Snapshots</a></span></dt><dd><dl><dt><span class="section"><a href="#ops.snapshots.configuration">17.8.1. Configuration</a></span></dt><dt><span class="section"><a href="#ops.snapshots.takeasnapshot">17.8.2. Take a Snapshot</a></span></dt><dt><span class="section"><a href="#ops.snapshots.list">17.8.3. Listing Snapshots</a></span></dt><dt><span class="section"><a href="#ops.snapshots.delete">17.8.4. Deleting Snapshots</a></span></dt><dt><span class="section"><a href="#ops.snapshots.clone">17.8.5. Clone a table from snapshot</a></span></dt><dt><span class="section"><a href="#ops.snapshots.restore">17.8.6. Restore a snapshot</a></span></dt><dt><span class="section"><a href="#ops.snapshots.acls">17.8.7. Snapshots operations and ACLs</a></span></dt><dt><span class="section"><a href="#ops.snapshots.export">17.8.8. Export to another cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#ops.capacity">17.9. Capacity Planning and Region Sizing</a></span></dt><dd><dl><dt><span class="section"><a href="#ops.capacity.nodes">17.9.1. Node count and hardware/VM configuration</a></span></dt><dt><span class="section"><a href="#ops.capacity.regions">17.9.2. Determining region count and size</a></span></dt><dt><span class="section"><a href="#ops.capacity.config">17.9.3. Initial configuration and tuning</a></span></dt></dl></dd><dt><span class="section"><a href="#table.rename">17.10. Table Rename</a></span></dt></dl></div><p> This chapter will cover operational tools and practices required of a running Apache HBase
    cluster. The subject of operations is related to the topics of <a class="xref" href="#trouble" title="Chapter&nbsp;15.&nbsp;Troubleshooting and Debugging Apache HBase">Chapter&nbsp;15, <i>Troubleshooting and Debugging Apache HBase</i></a>, <a class="xref" href="#performance" title="Chapter&nbsp;14.&nbsp;Apache HBase Performance Tuning">Chapter&nbsp;14, <i>Apache HBase Performance Tuning</i></a>, and <a class="xref" href="#configuration" title="Chapter&nbsp;2.&nbsp;Apache HBase Configuration">Chapter&nbsp;2, <i>Apache HBase Configuration</i></a> but is a distinct topic in itself. </p><div class="section" title="17.1.&nbsp;HBase Tools and Utilities"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tools"></a>17.1.&nbsp;HBase Tools and Utilities</h2></div></div></div><p>HBase provides several tools for administration, analysis, and debugging of your cluster.
      The entry-point to most of these tools is the <code class="filename">bin/hbase</code> command, though
      some tools are available in the <code class="filename">dev-support/</code> directory.</p><p>To see usage instructions for <code class="filename">bin/hbase</code> command, run it with no
      arguments, or with the <code class="option">-h</code> argument. These are the usage instructions for
      HBase 0.98.x. Some commands, such as <span class="command"><strong>version</strong></span>, <span class="command"><strong>pe</strong></span>,
        <span class="command"><strong>ltt</strong></span>, <span class="command"><strong>clean</strong></span>, are not available in previous
      versions.</p><pre class="screen">
$ <strong class="userinput"><code>bin/hbase</code></strong>
Usage: hbase [&lt;options&gt;] &lt;command&gt; [&lt;args&gt;]
Options:
  --config DIR    Configuration direction to use. Default: ./conf
  --hosts HOSTS   Override the list in 'regionservers' file

Commands:
Some commands take arguments. Pass no args or -h for usage.
  shell           Run the HBase shell
  hbck            Run the hbase 'fsck' tool
  hlog            Write-ahead-log analyzer
  hfile           Store file analyzer
  zkcli           Run the ZooKeeper shell
  upgrade         Upgrade hbase
  master          Run an HBase HMaster node
  regionserver    Run an HBase HRegionServer node
  zookeeper       Run a Zookeeper server
  rest            Run an HBase REST server
  thrift          Run the HBase Thrift server
  thrift2         Run the HBase Thrift2 server
  clean           Run the HBase clean up script
  classpath       Dump hbase CLASSPATH
  mapredcp        Dump CLASSPATH entries required by mapreduce
  pe              Run PerformanceEvaluation
  ltt             Run LoadTestTool
  version         Print the version
  CLASSNAME       Run the class named CLASSNAME      
    </pre><p>Some of the tools and utilities below are Java classes which are passed directly to the
        <code class="filename">bin/hbase</code> command, as referred to in the last line of the usage
      instructions. Others, such as <span class="command"><strong>hbase shell</strong></span> (<a class="xref" href="#shell" title="Chapter&nbsp;4.&nbsp;The Apache HBase Shell">Chapter&nbsp;4, <i>The Apache HBase Shell</i></a>),
        <span class="command"><strong>hbase upgrade</strong></span> (<a class="xref" href="#upgrading" title="Chapter&nbsp;3.&nbsp;Upgrading">Chapter&nbsp;3, <i>Upgrading</i></a>), and <span class="command"><strong>hbase
        thrift</strong></span> (<a class="xref" href="#thrift" title="Chapter&nbsp;12.&nbsp;Thrift API and Filter Language">Chapter&nbsp;12, <i>Thrift API and Filter Language</i></a>), are documented elsewhere in this guide.</p><div class="section" title="17.1.1.&nbsp;Canary"><div class="titlepage"><div><div><h3 class="title"><a name="canary"></a>17.1.1.&nbsp;Canary</h3></div></div></div><p> There is a Canary class can help users to canary-test the HBase cluster status, with
        every column-family for every regions or regionservers granularity. To see the usage, use
        the <code class="literal">--help</code> parameter. </p><pre class="screen">$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.tool.Canary -help

Usage: bin/hbase org.apache.hadoop.hbase.tool.Canary [opts] [table1 [table2]...] | [regionserver1 [regionserver2]..]
 where [opts] are:
   -help          Show this help and exit.
   -regionserver  replace the table argument to regionserver,
      which means to enable regionserver mode
   -daemon        Continuous check at defined intervals.
   -interval &lt;N&gt;  Interval between checks (sec)
   -e             Use region/regionserver as regular expression
      which means the region/regionserver is regular expression pattern
   -f &lt;B&gt;         stop whole program if first error occurs, default is true
   -t &lt;N&gt;         timeout for a check, default is 600000 (milliseconds)</pre><p> This tool will return non zero error codes to user for collaborating with other
        monitoring tools, such as Nagios. The error code definitions are: </p><pre class="programlisting">private static final int USAGE_EXIT_CODE = 1;
private static final int INIT_ERROR_EXIT_CODE = 2;
private static final int TIMEOUT_ERROR_EXIT_CODE = 3;
private static final int ERROR_EXIT_CODE = 4;</pre><p> Here are some examples based on the following given case. There are two HTable called
        test-01 and test-02, they have two column family cf1 and cf2 respectively, and deployed on
        the 3 regionservers. see following table. </p><div class="informaltable"><table border="1"><colgroup><col align="center" class="regionserver"><col align="center" class="test-01"><col align="center" class="test-02"></colgroup><thead><tr><th align="center">RegionServer</th><th align="center">test-01</th><th align="center">test-02</th></tr></thead><tbody><tr><td align="center">rs1</td><td align="center">r1</td><td align="center">r2</td></tr><tr><td align="center">rs2</td><td align="center">r2</td><td align="center">&nbsp;</td></tr><tr><td align="center">rs3</td><td align="center">r2</td><td align="center">r1</td></tr></tbody></table></div><p> Following are some examples based on the previous given case. </p><div class="section" title="17.1.1.1.&nbsp;Canary test for every column family (store) of every region of every table"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17146"></a>17.1.1.1.&nbsp;Canary test for every column family (store) of every region of every table</h4></div></div></div><pre class="screen">$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.tool.Canary
            
3/12/09 03:26:32 INFO tool.Canary: read from region test-01,,1386230156732.0e3c7d77ffb6361ea1b996ac1042ca9a. column family cf1 in 2ms
13/12/09 03:26:32 INFO tool.Canary: read from region test-01,,1386230156732.0e3c7d77ffb6361ea1b996ac1042ca9a. column family cf2 in 2ms
13/12/09 03:26:32 INFO tool.Canary: read from region test-01,0004883,1386230156732.87b55e03dfeade00f441125159f8ca87. column family cf1 in 4ms
13/12/09 03:26:32 INFO tool.Canary: read from region test-01,0004883,1386230156732.87b55e03dfeade00f441125159f8ca87. column family cf2 in 1ms
...
13/12/09 03:26:32 INFO tool.Canary: read from region test-02,,1386559511167.aa2951a86289281beee480f107bb36ee. column family cf1 in 5ms
13/12/09 03:26:32 INFO tool.Canary: read from region test-02,,1386559511167.aa2951a86289281beee480f107bb36ee. column family cf2 in 3ms
13/12/09 03:26:32 INFO tool.Canary: read from region test-02,0004883,1386559511167.cbda32d5e2e276520712d84eaaa29d84. column family cf1 in 31ms
13/12/09 03:26:32 INFO tool.Canary: read from region test-02,0004883,1386559511167.cbda32d5e2e276520712d84eaaa29d84. column family cf2 in 8ms
</pre><p> So you can see, table test-01 has two regions and two column families, so the Canary
          tool will pick 4 small piece of data from 4 (2 region * 2 store) different stores. This is
          a default behavior of the this tool does. </p></div><div class="section" title="17.1.1.2.&nbsp;Canary test for every column family (store) of every region of specific table(s)"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17153"></a>17.1.1.2.&nbsp;Canary test for every column family (store) of every region of specific
          table(s)</h4></div></div></div><p> You can also test one or more specific tables.</p><pre class="screen">$ ${HBASE_HOME}/bin/hbase orghapache.hadoop.hbase.tool.Canary test-01 test-02</pre></div><div class="section" title="17.1.1.3.&nbsp;Canary test with regionserver granularity"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17160"></a>17.1.1.3.&nbsp;Canary test with regionserver granularity</h4></div></div></div><p> This will pick one small piece of data from each regionserver, and can also put your
          resionserver name as input options for canary-test specific regionservers.</p><pre class="screen">$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.tool.Canary -regionserver
            
13/12/09 06:05:17 INFO tool.Canary: Read from table:test-01 on region server:rs2 in 72ms
13/12/09 06:05:17 INFO tool.Canary: Read from table:test-02 on region server:rs3 in 34ms
13/12/09 06:05:17 INFO tool.Canary: Read from table:test-01 on region server:rs1 in 56ms</pre></div><div class="section" title="17.1.1.4.&nbsp;Canary test with regular expression pattern"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17167"></a>17.1.1.4.&nbsp;Canary test with regular expression pattern</h4></div></div></div><p> This will test both table test-01 and test-02.</p><pre class="screen">$ ${HBASE_HOME}/bin/hbase orghapache.hadoop.hbase.tool.Canary -e test-0[1-2]</pre></div><div class="section" title="17.1.1.5.&nbsp;Run canary test as daemon mode"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17174"></a>17.1.1.5.&nbsp;Run canary test as daemon mode</h4></div></div></div><p> Run repeatedly with interval defined in option -interval whose default value is 6
          seconds. This daemon will stop itself and return non-zero error code if any error occurs,
          due to the default value of option -f is true.</p><pre class="screen">$ ${HBASE_HOME}/bin/hbase orghapache.hadoop.hbase.tool.Canary -daemon</pre><p>Run repeatedly with internal 5 seconds and will not stop itself even error occurs in
          the test.</p><pre class="screen">$ ${HBASE_HOME}/bin/hbase orghapache.hadoop.hbase.tool.Canary -daemon -interval 50000 -f false</pre></div><div class="section" title="17.1.1.6.&nbsp;Force timeout if canary test stuck"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17185"></a>17.1.1.6.&nbsp;Force timeout if canary test stuck</h4></div></div></div><p>In some cases, we suffered the request stucked on the regionserver and not response
          back to the client. The regionserver in problem, would also not indicated to be dead by
          Master, which would bring the clients hung. So we provide the timeout option to kill the
          canary test forcefully and return non-zero error code as well. This run sets the timeout
          value to 60 seconds, the default value is 600 seconds.</p><pre class="screen">$ ${HBASE_HOME}/bin/hbase orghapache.hadoop.hbase.tool.Canary -t 600000</pre></div></div><div class="section" title="17.1.2.&nbsp;Health Checker"><div class="titlepage"><div><div><h3 class="title"><a name="health.check"></a>17.1.2.&nbsp;Health Checker</h3></div></div></div><p>You can configure HBase to run a script on a period and if it fails N times
        (configurable), have the server exit. See <a class="link" href="" target="_top">HBASE-7351 Periodic health check script</a> for configurations and
        detail. </p></div><div class="section" title="17.1.3.&nbsp;Driver"><div class="titlepage"><div><div><h3 class="title"><a name="driver"></a>17.1.3.&nbsp;Driver</h3></div></div></div><p>Several frequently-accessed utilities are provided as <code class="code">Driver</code> classes, and executed by
        the <code class="filename">bin/hbase</code> command. These utilities represent MapReduce jobs which
        run on your cluster. They are run in the following way, replacing
          <em class="replaceable"><code>UtilityName</code></em> with the utility you want to run. This command
        assumes you have set the environment variable <code class="literal">HBASE_HOME</code> to the directory
        where HBase is unpacked on your server.</p><pre class="screen">
${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.mapreduce.<em class="replaceable"><code>UtilityName</code></em>        
      </pre><p>The following utilities are available:</p><div class="variablelist"><dl><dt><span class="term"><span class="command"><strong>LoadIncrementalHFiles</strong></span></span></dt><dd><p>Complete a bulk data load.</p></dd><dt><span class="term"><span class="command"><strong>CopyTable</strong></span></span></dt><dd><p>Export a table from the local cluster to a peer cluster.</p></dd><dt><span class="term"><span class="command"><strong>Export</strong></span></span></dt><dd><p>Write table data to HDFS.</p></dd><dt><span class="term"><span class="command"><strong>Import</strong></span></span></dt><dd><p>Import data written by a previous <span class="command"><strong>Export</strong></span> operation.</p></dd><dt><span class="term"><span class="command"><strong>ImportTsv</strong></span></span></dt><dd><p>Import data in TSV format.</p></dd><dt><span class="term"><span class="command"><strong>RowCounter</strong></span></span></dt><dd><p>Count rows in an HBase table.</p></dd><dt><span class="term"><span class="command"><strong>replication.VerifyReplication</strong></span></span></dt><dd><p>Compare the data from tables in two different clusters. WARNING: It
            doesn't work for incrementColumnValues'd cells since the timestamp is changed. Note that
          this command is in a different package than the others.</p></dd></dl></div><p>Each command except <span class="command"><strong>RowCounter</strong></span> accepts a single
        <code class="literal">--help</code> argument to print usage instructions.</p></div><div class="section" title="17.1.4.&nbsp;HBase hbck"><div class="titlepage"><div><div><h3 class="title"><a name="hbck"></a>17.1.4.&nbsp;HBase <span class="application">hbck</span></h3></div><div><h4 class="subtitle">An <span class="command"><strong>fsck</strong></span> for your HBase install</h4></div></div></div><p>To run <span class="application">hbck</span> against your HBase cluster run <span class="command"><strong>$
          ./bin/hbase hbck</strong></span> At the end of the command's output it prints
          <code class="literal">OK</code> or <code class="literal">INCONSISTENCY</code>. If your cluster reports
        inconsistencies, pass <span class="command"><strong>-details</strong></span> to see more detail emitted. If
        inconsistencies, run <span class="command"><strong>hbck</strong></span> a few times because the inconsistency may be
        transient (e.g. cluster is starting up or a region is splitting). Passing
          <span class="command"><strong>-fix</strong></span> may correct the inconsistency (This latter is an experimental
        feature). </p><p>For more information, see <a class="xref" href="#hbck.in.depth" title="Appendix&nbsp;C.&nbsp;hbck In Depth">Appendix&nbsp;C, <i>hbck In Depth</i></a>. </p></div><div class="section" title="17.1.5.&nbsp;HFile Tool"><div class="titlepage"><div><div><h3 class="title"><a name="hfile_tool2"></a>17.1.5.&nbsp;HFile Tool</h3></div></div></div><p>See <a class="xref" href="#hfile_tool" title="9.7.7.4.2.&nbsp;HFile Tool">Section&nbsp;9.7.7.4.2, &#8220;HFile Tool&#8221;</a>.</p></div><div class="section" title="17.1.6.&nbsp;WAL Tools"><div class="titlepage"><div><div><h3 class="title"><a name="wal_tools"></a>17.1.6.&nbsp;WAL Tools</h3></div></div></div><div class="section" title="17.1.6.1.&nbsp;FSHLog tool"><div class="titlepage"><div><div><h4 class="title"><a name="hlog_tool"></a>17.1.6.1.&nbsp;<code class="classname">FSHLog</code> tool</h4></div></div></div><p>The main method on <code class="classname">FSHLog</code> offers manual split and dump
          facilities. Pass it WALs or the product of a split, the content of the
            <code class="filename">recovered.edits</code>. directory.</p><p>You can get a textual dump of a WAL file content by doing the following:</p><pre class="screen"> $ ./bin/hbase org.apache.hadoop.hbase.regionserver.wal.FSHLog --dump hdfs://example.org:8020/hbase/.logs/example.org,60020,1283516293161/10.10.21.10%3A60020.1283973724012 </pre><p>The return code will be non-zero if issues with the file so you can test wholesomeness
          of file by redirecting <code class="varname">STDOUT</code> to <code class="code">/dev/null</code> and testing the
          program return.</p><p>Similarly you can force a split of a log file directory by doing:</p><pre class="screen"> $ ./bin/hbase org.apache.hadoop.hbase.regionserver.wal.FSHLog --split hdfs://example.org:8020/hbase/.logs/example.org,60020,1283516293161/</pre><div class="section" title="17.1.6.1.1.&nbsp;HLogPrettyPrinter"><div class="titlepage"><div><div><h5 class="title"><a name="hlog_tool.prettyprint"></a>17.1.6.1.1.&nbsp;<code class="classname">HLogPrettyPrinter</code></h5></div></div></div><p><code class="classname">HLogPrettyPrinter</code> is a tool with configurable options to
            print the contents of an HLog. </p></div></div></div><div class="section" title="17.1.7.&nbsp;Compression Tool"><div class="titlepage"><div><div><h3 class="title"><a name="compression.tool"></a>17.1.7.&nbsp;Compression Tool</h3></div></div></div><p>See <a class="xref" href="#compression.test" title="E.3.1.6.&nbsp;CompressionTest">Section&nbsp;E.3.1.6, &#8220;CompressionTest&#8221;</a>.</p></div><div class="section" title="17.1.8.&nbsp;CopyTable"><div class="titlepage"><div><div><h3 class="title"><a name="copytable"></a>17.1.8.&nbsp;CopyTable</h3></div></div></div><p> CopyTable is a utility that can copy part or of all of a table, either to the same
        cluster or another cluster. The target table must first exist. The usage is as
        follows:</p><pre class="screen">
$ <strong class="userinput"><code>./bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --help </code></strong>       
/bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --help
Usage: CopyTable [general options] [--starttime=X] [--endtime=Y] [--new.name=NEW] [--peer.adr=ADR] &lt;tablename&gt;

Options:
 rs.class     hbase.regionserver.class of the peer cluster, 
              specify if different from current cluster
 rs.impl      hbase.regionserver.impl of the peer cluster,
 startrow     the start row
 stoprow      the stop row
 starttime    beginning of the time range (unixtime in millis)
              without endtime means from starttime to forever
 endtime      end of the time range.  Ignored if no starttime specified.
 versions     number of cell versions to copy
 new.name     new table's name
 peer.adr     Address of the peer cluster given in the format
              hbase.zookeeer.quorum:hbase.zookeeper.client.port:zookeeper.znode.parent
 families     comma-separated list of families to copy
              To copy from cf1 to cf2, give sourceCfName:destCfName.
              To keep the same name, just give "cfName"
 all.cells    also copy delete markers and deleted cells

Args:
 tablename    Name of the table to copy

Examples:
 To copy 'TestTable' to a cluster that uses replication for a 1 hour window:
 $ bin/hbase org.apache.hadoop.hbase.mapreduce.CopyTable --starttime=1265875194289 --endtime=1265878794289 --peer.adr=server1,server2,server3:2181:/hbase --families=myOldCf:myNewCf,cf2,cf3 TestTable

For performance consider the following general options:
  It is recommended that you set the following to &gt;=100. A higher value uses more memory but
  decreases the round trip time to the server and may increase performance.
    -Dhbase.client.scanner.caching=100
  The following should always be set to false, to prevent writing data twice, which may produce
  inaccurate results.
    -Dmapred.map.tasks.speculative.execution=false       
      </pre><div class="note" title="Scanner Caching" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Scanner Caching</h3><p>Caching for the input Scan is configured via <code class="code">hbase.client.scanner.caching</code>
          in the job configuration. </p></div><div class="note" title="Versions" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Versions</h3><p>By default, CopyTable utility only copies the latest version of row cells unless
            <code class="code">--versions=n</code> is explicitly specified in the command. </p></div><p> See Jonathan Hsieh's <a class="link" href="http://www.cloudera.com/blog/2012/06/online-hbase-backups-with-copytable-2/" target="_top">Online
          HBase Backups with CopyTable</a> blog post for more on <span class="command"><strong>CopyTable</strong></span>.
      </p></div><div class="section" title="17.1.9.&nbsp;Export"><div class="titlepage"><div><div><h3 class="title"><a name="export"></a>17.1.9.&nbsp;Export</h3></div></div></div><p>Export is a utility that will dump the contents of table to HDFS in a sequence file.
        Invoke via:</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.Export &lt;tablename&gt; &lt;outputdir&gt; [&lt;versions&gt; [&lt;starttime&gt; [&lt;endtime&gt;]]]
</pre><p>Note: caching for the input Scan is configured via
          <code class="code">hbase.client.scanner.caching</code> in the job configuration. </p></div><div class="section" title="17.1.10.&nbsp;Import"><div class="titlepage"><div><div><h3 class="title"><a name="import"></a>17.1.10.&nbsp;Import</h3></div></div></div><p>Import is a utility that will load data that has been exported back into HBase. Invoke
        via:</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.Import &lt;tablename&gt; &lt;inputdir&gt;
</pre><p>To import 0.94 exported files in a 0.96 cluster or onwards, you need to set system
        property "hbase.import.version" when running the import command as below:</p><pre class="screen">$ bin/hbase -Dhbase.import.version=0.94 org.apache.hadoop.hbase.mapreduce.Import &lt;tablename&gt; &lt;inputdir&gt;
</pre></div><div class="section" title="17.1.11.&nbsp;ImportTsv"><div class="titlepage"><div><div><h3 class="title"><a name="importtsv"></a>17.1.11.&nbsp;ImportTsv</h3></div></div></div><p>ImportTsv is a utility that will load data in TSV format into HBase. It has two distinct
        usages: loading data from TSV format in HDFS into HBase via Puts, and preparing StoreFiles
        to be loaded via the <code class="code">completebulkload</code>. </p><p>To load data via Puts (i.e., non-bulk loading):</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c &lt;tablename&gt; &lt;hdfs-inputdir&gt;
</pre><p>To generate StoreFiles for bulk-loading:</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=a,b,c -Dimporttsv.bulk.output=hdfs://storefile-outputdir &lt;tablename&gt; &lt;hdfs-data-inputdir&gt;
</pre><p>These generated StoreFiles can be loaded into HBase via <a class="xref" href="#completebulkload" title="17.1.12.&nbsp;CompleteBulkLoad">Section&nbsp;17.1.12, &#8220;CompleteBulkLoad&#8221;</a>. </p><div class="section" title="17.1.11.1.&nbsp;ImportTsv Options"><div class="titlepage"><div><div><h4 class="title"><a name="importtsv.options"></a>17.1.11.1.&nbsp;ImportTsv Options</h4></div></div></div><p>Running <span class="command"><strong>ImportTsv</strong></span> with no arguments prints brief usage
          information:</p><pre class="screen">
Usage: importtsv -Dimporttsv.columns=a,b,c &lt;tablename&gt; &lt;inputdir&gt;

Imports the given input directory of TSV data into the specified table.

The column names of the TSV data must be specified using the -Dimporttsv.columns
option. This option takes the form of comma-separated column names, where each
column name is either a simple column family, or a columnfamily:qualifier. The special
column name HBASE_ROW_KEY is used to designate that this column should be used
as the row key for each imported record. You must specify exactly one column
to be the row key, and you must specify a column name for every column that exists in the
input data.

By default importtsv will load data directly into HBase. To instead generate
HFiles of data to prepare for a bulk data load, pass the option:
  -Dimporttsv.bulk.output=/path/for/output
  Note: the target table will be created with default column family descriptors if it does not already exist.

Other options that may be specified with -D include:
  -Dimporttsv.skip.bad.lines=false - fail if encountering an invalid line
  '-Dimporttsv.separator=|' - eg separate on pipes instead of tabs
  -Dimporttsv.timestamp=currentTimeAsLong - use the specified timestamp for the import
  -Dimporttsv.mapper.class=my.Mapper - A user-defined Mapper to use instead of org.apache.hadoop.hbase.mapreduce.TsvImporterMapper
        </pre></div><div class="section" title="17.1.11.2.&nbsp;ImportTsv Example"><div class="titlepage"><div><div><h4 class="title"><a name="importtsv.example"></a>17.1.11.2.&nbsp;ImportTsv Example</h4></div></div></div><p>For example, assume that we are loading data into a table called 'datatsv' with a
          ColumnFamily called 'd' with two columns "c1" and "c2". </p><p>Assume that an input file exists as follows:
          </p><pre class="screen">
row1	c1	c2
row2	c1	c2
row3	c1	c2
row4	c1	c2
row5	c1	c2
row6	c1	c2
row7	c1	c2
row8	c1	c2
row9	c1	c2
row10	c1	c2
          </pre><p>
        </p><p>For ImportTsv to use this imput file, the command line needs to look like this:</p><pre class="screen">
 HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar importtsv -Dimporttsv.columns=HBASE_ROW_KEY,d:c1,d:c2 -Dimporttsv.bulk.output=hdfs://storefileoutput datatsv hdfs://inputfile
 </pre><p> ... and in this example the first column is the rowkey, which is why the
          HBASE_ROW_KEY is used. The second and third columns in the file will be imported as "d:c1"
          and "d:c2", respectively. </p></div><div class="section" title="17.1.11.3.&nbsp;ImportTsv Warning"><div class="titlepage"><div><div><h4 class="title"><a name="importtsv.warning"></a>17.1.11.3.&nbsp;ImportTsv Warning</h4></div></div></div><p>If you have preparing a lot of data for bulk loading, make sure the target HBase table
          is pre-split appropriately. </p></div><div class="section" title="17.1.11.4.&nbsp;See Also"><div class="titlepage"><div><div><h4 class="title"><a name="importtsv.also"></a>17.1.11.4.&nbsp;See Also</h4></div></div></div><p>For more information about bulk-loading HFiles into HBase, see <a class="xref" href="#arch.bulk.load" title="9.8.&nbsp;Bulk Loading">Section&nbsp;9.8, &#8220;Bulk Loading&#8221;</a></p></div></div><div class="section" title="17.1.12.&nbsp;CompleteBulkLoad"><div class="titlepage"><div><div><h3 class="title"><a name="completebulkload"></a>17.1.12.&nbsp;CompleteBulkLoad</h3></div></div></div><p>The <code class="code">completebulkload</code> utility will move generated StoreFiles into an HBase
        table. This utility is often used in conjunction with output from <a class="xref" href="#importtsv" title="17.1.11.&nbsp;ImportTsv">Section&nbsp;17.1.11, &#8220;ImportTsv&#8221;</a>. </p><p>There are two ways to invoke this utility, with explicit classname and via the
        driver:</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles &lt;hdfs://storefileoutput&gt; &lt;tablename&gt;
</pre><p> .. and via the Driver..</p><pre class="screen">HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar completebulkload &lt;hdfs://storefileoutput&gt; &lt;tablename&gt;
</pre><div class="section" title="17.1.12.1.&nbsp;CompleteBulkLoad Warning"><div class="titlepage"><div><div><h4 class="title"><a name="completebulkload.warning"></a>17.1.12.1.&nbsp;CompleteBulkLoad Warning</h4></div></div></div><p>Data generated via MapReduce is often created with file permissions that are not
          compatible with the running HBase process. Assuming you're running HDFS with permissions
          enabled, those permissions will need to be updated before you run CompleteBulkLoad.</p><p>For more information about bulk-loading HFiles into HBase, see <a class="xref" href="#arch.bulk.load" title="9.8.&nbsp;Bulk Loading">Section&nbsp;9.8, &#8220;Bulk Loading&#8221;</a>. </p></div></div><div class="section" title="17.1.13.&nbsp;WALPlayer"><div class="titlepage"><div><div><h3 class="title"><a name="walplayer"></a>17.1.13.&nbsp;WALPlayer</h3></div></div></div><p>WALPlayer is a utility to replay WAL files into HBase. </p><p>The WAL can be replayed for a set of tables or all tables, and a timerange can be
        provided (in milliseconds). The WAL is filtered to this set of tables. The output can
        optionally be mapped to another set of tables. </p><p>WALPlayer can also generate HFiles for later bulk importing, in that case only a single
        table and no mapping can be specified. </p><p>Invoke via:</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer [options] &lt;wal inputdir&gt; &lt;tables&gt; [&lt;tableMappings&gt;]&gt;
</pre><p>For example:</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.WALPlayer /backuplogdir oldTable1,oldTable2 newTable1,newTable2
</pre><p> WALPlayer, by default, runs as a mapreduce job. To NOT run WALPlayer as a mapreduce job
        on your cluster, force it to run all in the local process by adding the flags
          <code class="code">-Dmapreduce.jobtracker.address=local</code> on the command line. </p></div><div class="section" title="17.1.14.&nbsp;RowCounter and CellCounter"><div class="titlepage"><div><div><h3 class="title"><a name="rowcounter"></a>17.1.14.&nbsp;RowCounter and CellCounter</h3></div></div></div><p><a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html" target="_top">RowCounter</a>
        is a mapreduce job to count all the rows of a table. This is a good utility to use as a
        sanity check to ensure that HBase can read all the blocks of a table if there are any
        concerns of metadata inconsistency. It will run the mapreduce all in a single process but it
        will run faster if you have a MapReduce cluster in place for it to exploit.</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.RowCounter &lt;tablename&gt; [&lt;column1&gt; &lt;column2&gt;...]
</pre><p>Note: caching for the input Scan is configured via
          <code class="code">hbase.client.scanner.caching</code> in the job configuration. </p><p>HBase ships another diagnostic mapreduce job called <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/CellCounter.html" target="_top">CellCounter</a>.
        Like RowCounter, it gathers more fine-grained statistics about your table. The statistics
        gathered by RowCounter are more fine-grained and include: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Total number of rows in the table.</p></li><li class="listitem"><p>Total number of CFs across all rows.</p></li><li class="listitem"><p>Total qualifiers across all rows.</p></li><li class="listitem"><p>Total occurrence of each CF.</p></li><li class="listitem"><p>Total occurrence of each qualifier.</p></li><li class="listitem"><p>Total number of versions of each qualifier.</p></li></ul></div><p>The program allows you to limit the scope of the run. Provide a row regex or prefix to
        limit the rows to analyze. Use <code class="code">hbase.mapreduce.scan.column.family</code> to specify
        scanning a single column family.</p><pre class="screen">$ bin/hbase org.apache.hadoop.hbase.mapreduce.CellCounter &lt;tablename&gt; &lt;outputDir&gt; [regex or prefix]</pre><p>Note: just like RowCounter, caching for the input Scan is configured via
          <code class="code">hbase.client.scanner.caching</code> in the job configuration. </p></div><div class="section" title="17.1.15.&nbsp;mlockall"><div class="titlepage"><div><div><h3 class="title"><a name="mlockall"></a>17.1.15.&nbsp;mlockall</h3></div></div></div><p>It is possible to optionally pin your servers in physical memory making them less likely
        to be swapped out in oversubscribed environments by having the servers call <a class="link" href="http://linux.die.net/man/2/mlockall" target="_top">mlockall</a> on startup. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4391" target="_top">HBASE-4391 Add ability to
          start RS as root and call mlockall</a> for how to build the optional library and have
        it run on startup. </p></div><div class="section" title="17.1.16.&nbsp;Offline Compaction Tool"><div class="titlepage"><div><div><h3 class="title"><a name="compaction.tool"></a>17.1.16.&nbsp;Offline Compaction Tool</h3></div></div></div><p>See the usage for the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/CompactionTool.html" target="_top">Compaction
          Tool</a>. Run it like this <span class="command"><strong>./bin/hbase
          org.apache.hadoop.hbase.regionserver.CompactionTool</strong></span>
      </p></div><div class="section" title="17.1.17.&nbsp;hbase clean"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e17611"></a>17.1.17.&nbsp;<span class="command"><strong>hbase clean</strong></span></h3></div></div></div><p>The <span class="command"><strong>hbase clean</strong></span> command cleans HBase data from ZooKeeper, HDFS, or
        both. It is appropriate to use for testing. Run it with no options for usage instructions.
        The <span class="command"><strong>hbase clean</strong></span> command was introduced in HBase 0.98.</p><pre class="screen">
$ <strong class="userinput"><code>bin/hbase clean</code></strong>
Usage: hbase clean (--cleanZk|--cleanHdfs|--cleanAll)
Options:
        --cleanZk   cleans hbase related data from zookeeper.
        --cleanHdfs cleans hbase related data from hdfs.
        --cleanAll  cleans hbase related data from both zookeeper and hdfs.        
      </pre></div><div class="section" title="17.1.18.&nbsp;hbase pe"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e17628"></a>17.1.18.&nbsp;<span class="command"><strong>hbase pe</strong></span></h3></div></div></div><p>The <span class="command"><strong>hbase pe</strong></span> command is a shortcut provided to run the
          <code class="code">org.apache.hadoop.hbase.PerformanceEvaluation</code> tool, which is used for
        testing. The <span class="command"><strong>hbase pe</strong></span> command was introduced in HBase 0.98.4.</p><p>The PerformanceEvaluation tool accepts many different options and commands. For usage
        instructions, run the command with no options.</p><p>To run PerformanceEvaluation prior to HBase 0.98.4, issue the command
          <span class="command"><strong>hbase org.apache.hadoop.hbase.PerformanceEvaluation</strong></span>.</p><p>The PerformanceEvaluation tool has received many updates in recent HBase releases,
        including support for namespaces, support for tags, cell-level ACLs and visibility labels,
        multiget support for RPC calls, increased sampling sizes, an option to randomly sleep during
        testing, and ability to "warm up" the cluster before testing starts.</p></div><div class="section" title="17.1.19.&nbsp;hbase ltt"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e17652"></a>17.1.19.&nbsp;<span class="command"><strong>hbase ltt</strong></span></h3></div></div></div><p>The <span class="command"><strong>hbase ltt</strong></span> command is a shortcut provided to run the
        <code class="code">org.apache.hadoop.hbase.util.LoadTestTool</code> utility, which is used for
        testing. The <span class="command"><strong>hbase ltt</strong></span> command was introduced in HBase 0.98.4.</p><p>You must specify either <code class="option">-write</code> or <code class="option">-update-read</code> as the
        first option. For general usage instructions, pass the <code class="option">-h</code> option.</p><p>To run LoadTestTool prior to HBase 0.98.4, issue the command <span class="command"><strong>hbase
          org.apache.hadoop.hbase.util.LoadTestTool</strong></span>.</p><p>The LoadTestTool has received many updates in recent HBase releases, including support
        for namespaces, support for tags, cell-level ACLS and visibility labels, testing
        security-related features, ability to specify the number of regions per server, tests for
        multi-get RPC calls, and tests relating to replication.</p></div></div><div class="section" title="17.2.&nbsp;Region Management"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ops.regionmgt"></a>17.2.&nbsp;Region Management</h2></div></div></div><div class="section" title="17.2.1.&nbsp;Major Compaction"><div class="titlepage"><div><div><h3 class="title"><a name="ops.regionmgt.majorcompact"></a>17.2.1.&nbsp;Major Compaction</h3></div></div></div><p>Major compactions can be requested via the HBase shell or <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact%28java.lang.String%29" target="_top">HBaseAdmin.majorCompact</a>. </p><p>Note: major compactions do NOT do region merges. See <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a> for more information about compactions. </p></div><div class="section" title="17.2.2.&nbsp;Merge"><div class="titlepage"><div><div><h3 class="title"><a name="ops.regionmgt.merge"></a>17.2.2.&nbsp;Merge</h3></div></div></div><p>Merge is a utility that can merge adjoining regions in the same table (see
        org.apache.hadoop.hbase.util.Merge).</p><pre class="programlisting">$ bin/hbase org.apache.hadoop.hbase.util.Merge &lt;tablename&gt; &lt;region1&gt; &lt;region2&gt;
</pre><p>If you feel you have too many regions and want to consolidate them, Merge is the utility
        you need. Merge must run be done when the cluster is down. See the <a class="link" href="http://ofps.oreilly.com/titles/9781449396107/performance.html" target="_top">O'Reilly HBase
          Book</a> for an example of usage. </p><p>You will need to pass 3 parameters to this application. The first one is the table name.
        The second one is the fully qualified name of the first region to merge, like
        "table_name,\x0A,1342956111995.7cef47f192318ba7ccc75b1bbf27a82b.". The third one is the
        fully qualified name for the second region to merge. </p><p>Additionally, there is a Ruby script attached to <a class="link" href="https://issues.apache.org/jira/browse/HBASE-1621" target="_top">HBASE-1621</a> for region
        merging. </p></div></div><div class="section" title="17.3.&nbsp;Node Management"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="node.management"></a>17.3.&nbsp;Node Management</h2></div></div></div><div class="section" title="17.3.1.&nbsp;Node Decommission"><div class="titlepage"><div><div><h3 class="title"><a name="decommission"></a>17.3.1.&nbsp;Node Decommission</h3></div></div></div><p>You can stop an individual RegionServer by running the following script in the HBase
        directory on the particular node:</p><pre class="screen">$ ./bin/hbase-daemon.sh stop regionserver</pre><p> The RegionServer will first close all regions and then shut itself down. On shutdown,
        the RegionServer's ephemeral node in ZooKeeper will expire. The master will notice the
        RegionServer gone and will treat it as a 'crashed' server; it will reassign the nodes the
        RegionServer was carrying. </p><div class="note" title="Disable the Load Balancer before Decommissioning a node" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Disable the Load Balancer before Decommissioning a node</h3><p>If the load balancer runs while a node is shutting down, then there could be
          contention between the Load Balancer and the Master's recovery of the just decommissioned
          RegionServer. Avoid any problems by disabling the balancer first. See <a class="xref" href="#lb" title="Load Balancer">Load Balancer</a> below. </p></div><div class="note" title="Kill Node Tool" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Kill Node Tool</h3><p>In hbase-2.0, in the bin directory, we added a script named
          <code class="filename">considerAsDead.sh</code> that can be used to kill a regionserver.
          Hardware issues could be detected by specialized monitoring tools before the 
          zookeeper timeout has expired. <code class="filename">considerAsDead.sh</code> is a
          simple function to mark a RegionServer as dead.  It deletes all the znodes
          of the server, starting the recovery process.  Plug in the script into
          your monitoring/fault detection tools to initiate faster failover. Be
          careful how you use this disruptive tool. Copy the script if you need to
          make use of it in a version of hbase previous to hbase-2.0.
        </p></div><p> A downside to the above stop of a RegionServer is that regions could be offline for a
        good period of time. Regions are closed in order. If many regions on the server, the first
        region to close may not be back online until all regions close and after the master notices
        the RegionServer's znode gone. In Apache HBase 0.90.2, we added facility for having a node
        gradually shed its load and then shutdown itself down. Apache HBase 0.90.2 added the
          <code class="filename">graceful_stop.sh</code> script. Here is its usage:</p><pre class="screen">$ ./bin/graceful_stop.sh
Usage: graceful_stop.sh [--config &amp;conf-dir&gt;] [--restart] [--reload] [--thrift] [--rest] &amp;hostname&gt;
 thrift      If we should stop/start thrift before/after the hbase stop/start
 rest        If we should stop/start rest before/after the hbase stop/start
 restart     If we should restart after graceful stop
 reload      Move offloaded regions back on to the stopped server
 debug       Move offloaded regions back on to the stopped server
 hostname    Hostname of server we are to stop</pre><p> To decommission a loaded RegionServer, run the following: <span class="command"><strong>$
          ./bin/graceful_stop.sh HOSTNAME</strong></span> where <code class="varname">HOSTNAME</code> is the host
        carrying the RegionServer you would decommission. </p><div class="note" title="On HOSTNAME" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">On <code class="varname">HOSTNAME</code></h3><p>The <code class="varname">HOSTNAME</code> passed to <code class="filename">graceful_stop.sh</code> must
          match the hostname that hbase is using to identify RegionServers. Check the list of
          RegionServers in the master UI for how HBase is referring to servers. Its usually hostname
          but can also be FQDN. Whatever HBase is using, this is what you should pass the
            <code class="filename">graceful_stop.sh</code> decommission script. If you pass IPs, the script
          is not yet smart enough to make a hostname (or FQDN) of it and so it will fail when it
          checks if server is currently running; the graceful unloading of regions will not run.
        </p></div><p> The <code class="filename">graceful_stop.sh</code> script will move the regions off the
        decommissioned RegionServer one at a time to minimize region churn. It will verify the
        region deployed in the new location before it will moves the next region and so on until the
        decommissioned server is carrying zero regions. At this point, the
          <code class="filename">graceful_stop.sh</code> tells the RegionServer <span class="command"><strong>stop</strong></span>. The
        master will at this point notice the RegionServer gone but all regions will have already
        been redeployed and because the RegionServer went down cleanly, there will be no WAL logs to
        split. </p><div class="note" title="Load Balancer" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="lb"></a>Load Balancer</h3><p> It is assumed that the Region Load Balancer is disabled while the
            <span class="command"><strong>graceful_stop</strong></span> script runs (otherwise the balancer and the
          decommission script will end up fighting over region deployments). Use the shell to
          disable the balancer:</p><pre class="programlisting">hbase(main):001:0&gt; balance_switch false
true
0 row(s) in 0.3590 seconds</pre><p> This turns the balancer OFF. To reenable, do:</p><pre class="programlisting">hbase(main):001:0&gt; balance_switch true
false
0 row(s) in 0.3590 seconds</pre><p>The <span class="command"><strong>graceful_stop</strong></span> will check the balancer and if enabled, will turn
          it off before it goes to work. If it exits prematurely because of error, it will not have
          reset the balancer. Hence, it is better to manage the balancer apart from
            <span class="command"><strong>graceful_stop</strong></span> reenabling it after you are done w/ graceful_stop.
        </p></div><div class="section" title="17.3.1.1.&nbsp;Decommissioning several Regions Servers concurrently"><div class="titlepage"><div><div><h4 class="title"><a name="draining.servers"></a>17.3.1.1.&nbsp;Decommissioning several Regions Servers concurrently</h4></div></div></div><p>If you have a large cluster, you may want to decommission more than one machine at a
          time by gracefully stopping mutiple RegionServers concurrently. To gracefully drain
          multiple regionservers at the same time, RegionServers can be put into a "draining" state.
          This is done by marking a RegionServer as a draining node by creating an entry in
          ZooKeeper under the <code class="filename">hbase_root/draining</code> znode. This znode has format
            <code class="code">name,port,startcode</code> just like the regionserver entries under
            <code class="filename">hbase_root/rs</code> znode. </p><p>Without this facility, decommissioning mulitple nodes may be non-optimal because
          regions that are being drained from one region server may be moved to other regionservers
          that are also draining. Marking RegionServers to be in the draining state prevents this
          from happening. See this <a class="link" href="http://inchoate-clatter.blogspot.com/2012/03/hbase-ops-automation.html" target="_top">blog
            post</a> for more details.</p></div><div class="section" title="17.3.1.2.&nbsp;Bad or Failing Disk"><div class="titlepage"><div><div><h4 class="title"><a name="bad.disk"></a>17.3.1.2.&nbsp;Bad or Failing Disk</h4></div></div></div><p>It is good having <a class="xref" href="#dfs.datanode.failed.volumes.tolerated" title="2.6.2.2.1.&nbsp;dfs.datanode.failed.volumes.tolerated">Section&nbsp;2.6.2.2.1, &#8220;dfs.datanode.failed.volumes.tolerated&#8221;</a> set if you have a decent number of
          disks per machine for the case where a disk plain dies. But usually disks do the "John
          Wayne" -- i.e. take a while to go down spewing errors in <code class="filename">dmesg</code> -- or
          for some reason, run much slower than their companions. In this case you want to
          decommission the disk. You have two options. You can <a class="link" href="http://wiki.apache.org/hadoop/FAQ#I_want_to_make_a_large_cluster_smaller_by_taking_out_a_bunch_of_nodes_simultaneously._How_can_this_be_done.3F" target="_top">decommission
            the datanode</a> or, less disruptive in that only the bad disks data will be
          rereplicated, can stop the datanode, unmount the bad volume (You can't umount a volume
          while the datanode is using it), and then restart the datanode (presuming you have set
          dfs.datanode.failed.volumes.tolerated &gt; 0). The regionserver will throw some errors in its
          logs as it recalibrates where to get its data from -- it will likely roll its WAL log too
          -- but in general but for some latency spikes, it should keep on chugging. </p><div class="note" title="Short Circuit Reads" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Short Circuit Reads</h3><p>If you are doing short-circuit reads, you will have to move the regions off the
            regionserver before you stop the datanode; when short-circuiting reading, though chmod'd
            so regionserver cannot have access, because it already has the files open, it will be
            able to keep reading the file blocks from the bad disk even though the datanode is down.
            Move the regions back after you restart the datanode.</p></div></div></div><div class="section" title="17.3.2.&nbsp;Rolling Restart"><div class="titlepage"><div><div><h3 class="title"><a name="rolling"></a>17.3.2.&nbsp;Rolling Restart</h3></div></div></div><p>Some cluster configuration changes require either the entire cluster, or the
          RegionServers, to be restarted in order to pick up the changes. In addition, rolling
          restarts are supported for upgrading to a minor or maintenance release, and to a major
          release if at all possible. See the release notes for release you want to upgrade to, to
          find out about limitations to the ability to perform a rolling upgrade.</p><p>There are multiple ways to restart your cluster nodes, depending on your situation.
        These methods are detailed below.</p><div class="section" title="17.3.2.1.&nbsp;Using the rolling-restart.sh Script"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17858"></a>17.3.2.1.&nbsp;Using the <span class="command"><strong>rolling-restart.sh</strong></span> Script</h4></div></div></div><p>HBase ships with a script, <code class="filename">bin/rolling-restart.sh</code>, that allows
          you to perform rolling restarts on the entire cluster, the master only, or the
          RegionServers only. The script is provided as a template for your own script, and is not
          explicitly tested. It requires password-less SSH login to be configured and assumes that
          you have deployed using a tarball. The script requires you to set some environment
          variables before running it. Examine the script and modify it to suit your needs.</p><div class="example"><a name="d2875e17869"></a><p class="title"><b>Example&nbsp;17.1.&nbsp;<code class="filename">rolling-restart.sh</code> General Usage</b></p><div class="example-contents"><pre class="screen">
$ <strong class="userinput"><code>./bin/rolling-restart.sh --help</code></strong>
Usage: rolling-restart.sh [--config &lt;hbase-confdir&gt;] [--rs-only] [--master-only] [--graceful] [--maxthreads xx]          
        </pre></div></div><br class="example-break"><div class="variablelist"><dl><dt><span class="term">Rolling Restart on RegionServers Only</span></dt><dd><p>To perform a rolling restart on the RegionServers only, use the
                  <code class="code">--rs-only</code> option. This might be necessary if you need to reboot the
                individual RegionServer or if you make a configuration change that only affects
                RegionServers and not the other HBase processes.</p><p>If you need to restart only a single RegionServer, or if you need to do extra
                actions during the restart, use the <code class="filename">bin/graceful_stop.sh</code>
                command instead. See <a class="xref" href="#rolling.restart.manual" title="17.3.2.2.&nbsp;Manual Rolling Restart">Section&nbsp;17.3.2.2, &#8220;Manual Rolling Restart&#8221;</a>.</p></dd><dt><span class="term">Rolling Restart on Masters Only</span></dt><dd><p>To perform a rolling restart on the active and backup Masters, use the
                  <code class="code">--master-only</code> option. You might use this if you know that your
                configuration change only affects the Master and not the RegionServers, or if you
                need to restart the server where the active Master is running.</p><p>If you are not running backup Masters, the Master is simply restarted. If you
                are running backup Masters, they are all stopped before any are restarted, to avoid
                a race condition in ZooKeeper to determine which is the new Master. First the main
                Master is restarted, then the backup Masters are restarted. Directly after restart,
                it checks for and cleans out any regions in transition before taking on its normal
                workload.</p></dd><dt><span class="term">Graceful Restart</span></dt><dd><p>If you specify the <code class="code">--graceful</code> option, RegionServers are restarted
                using the <code class="filename">bin/graceful_stop.sh</code> script, which moves regions off
                a RegionServer before restarting it. This is safer, but can delay the
                restart.</p></dd><dt><span class="term">Limiting the Number of Threads</span></dt><dd><p>To limit the rolling restart to using only a specific number of threads, use the
                  <code class="code">--maxthreads</code> option.</p></dd></dl></div></div><div class="section" title="17.3.2.2.&nbsp;Manual Rolling Restart"><div class="titlepage"><div><div><h4 class="title"><a name="rolling.restart.manual"></a>17.3.2.2.&nbsp;Manual Rolling Restart</h4></div></div></div><p>To retain more control over the process, you may wish to manually do a rolling restart
          across your cluster. This uses the <span class="command"><strong>graceful-stop.sh</strong></span> command <a class="xref" href="#decommission" title="17.3.1.&nbsp;Node Decommission">Section&nbsp;17.3.1, &#8220;Node Decommission&#8221;</a>. In this method, you can restart each RegionServer
          individually and then move its old regions back into place, retaining locality. If you
          also need to restart the Master, you need to do it separately, and restart the Master
          before restarting the RegionServers using this method. The following is an example of such
          a command. You may need to tailor it to your environment. This script does a rolling
          restart of RegionServers only. It disables the load balancer before moving the
          regions.</p><pre class="screen">
$ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &amp;&gt; /tmp/log.txt &amp;;     
        </pre><p>Monitor the output of the <code class="filename">/tmp/log.txt</code> file to follow the
          progress of the script. </p></div><div class="section" title="17.3.2.3.&nbsp;Logic for Crafting Your Own Rolling Restart Script"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e17945"></a>17.3.2.3.&nbsp;Logic for Crafting Your Own Rolling Restart Script</h4></div></div></div><p>Use the following guidelines if you want to create your own rolling restart script.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Extract the new release, verify its configuration, and synchronize it to all nodes
              of your cluster using <span class="command"><strong>rsync</strong></span>, <span class="command"><strong>scp</strong></span>, or another
              secure synchronization mechanism.</p></li><li class="listitem"><p>Use the hbck utility to ensure that the cluster is consistent.</p><pre class="screen">
$ ./bin/hbck            
          </pre><p>Perform repairs if required. See <a class="xref" href="#hbck" title="17.1.4.&nbsp;HBase hbck">Section&nbsp;17.1.4, &#8220;HBase <span class="application">hbck</span>&#8221;</a> for details.</p></li><li class="listitem"><p>Restart the master first. You may need to modify these commands if your
            new HBase directory is different from the old one, such as for an upgrade.</p><pre class="screen">
$ ./bin/hbase-daemon.sh stop master; ./bin/hbase-daemon.sh start master            
          </pre></li><li class="listitem"><p>Gracefully restart each RegionServer, using a script such as the
            following, from the Master.</p><pre class="screen">
$ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i; done &amp;&gt; /tmp/log.txt &amp;            
          </pre><p>If you are running Thrift or REST servers, pass the --thrift or --rest options.
              For other available options, run the <span class="command"><strong>bin/graceful-stop.sh --help</strong></span>
              command.</p><p>It is important to drain HBase regions slowly when restarting multiple
              RegionServers. Otherwise, multiple regions go offline simultaneously and must be
              reassigned to other nodes, which may also go offline soon. This can negatively affect
              performance. You can inject delays into the script above, for instance, by adding a
              Shell command such as <span class="command"><strong>sleep</strong></span>. To wait for 5 minutes between each
              RegionServer restart, modify the above script to the following:</p><pre class="screen">
$ for i in `cat conf/regionservers|sort`; do ./bin/graceful_stop.sh --restart --reload --debug $i &amp; sleep 5m; done &amp;&gt; /tmp/log.txt &amp;            
          </pre></li><li class="listitem"><p>Restart the Master again, to clear out the dead servers list and re-enable
          the load balancer.</p></li><li class="listitem"><p>Run the <span class="command"><strong>hbck</strong></span> utility again, to be sure the cluster is
            consistent.</p></li></ol></div></div></div><div class="section" title="17.3.3.&nbsp;Adding a New Node"><div class="titlepage"><div><div><h3 class="title"><a name="adding.new.node"></a>17.3.3.&nbsp;Adding a New Node</h3></div></div></div><p>Adding a new regionserver in HBase is essentially free, you simply start it like this:
          <span class="command"><strong>$ ./bin/hbase-daemon.sh start regionserver</strong></span> and it will register itself
        with the master. Ideally you also started a DataNode on the same machine so that the RS can
        eventually start to have local files. If you rely on ssh to start your daemons, don't forget
        to add the new hostname in <code class="filename">conf/regionservers</code> on the master. </p><p>At this point the region server isn't serving data because no regions have moved to it
        yet. If the balancer is enabled, it will start moving regions to the new RS. On a
        small/medium cluster this can have a very adverse effect on latency as a lot of regions will
        be offline at the same time. It is thus recommended to disable the balancer the same way
        it's done when decommissioning a node and move the regions manually (or even better, using a
        script that moves them one by one). </p><p>The moved regions will all have 0% locality and won't have any blocks in cache so the
        region server will have to use the network to serve requests. Apart from resulting in higher
        latency, it may also be able to use all of your network card's capacity. For practical
        purposes, consider that a standard 1GigE NIC won't be able to read much more than
          <span class="emphasis"><em>100MB/s</em></span>. In this case, or if you are in a OLAP environment and
        require having locality, then it is recommended to major compact the moved regions. </p></div></div><div class="section" title="17.4.&nbsp;HBase Metrics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase_metrics"></a>17.4.&nbsp;HBase Metrics</h2></div></div></div><p>HBase emits metrics which adhere to the <a class="link" href="http://hadoop.apache.org/core/docs/current/api/org/apache/hadoop/metrics/package-summary.html" target="_top">Hadoop metrics</a> API. Starting with HBase 0.95<sup>[<a name="d2875e18027" href="#ftn.d2875e18027" class="footnote">1</a>]</sup>,
      HBase is configured to emit a default
      set of metrics with a default sampling period of every 10 seconds. You can use HBase
      metrics in conjunction with Ganglia. You can also filter which metrics are emitted and extend
      the metrics framework to capture custom metrics appropriate for your environment.</p><div class="section" title="17.4.1.&nbsp;Metric Setup"><div class="titlepage"><div><div><h3 class="title"><a name="metric_setup"></a>17.4.1.&nbsp;Metric Setup</h3></div></div></div><p>For HBase 0.95 and newer, HBase ships with a default metrics configuration, or
          <em class="firstterm">sink</em>. This includes a wide variety of individual metrics, and emits
        them every 10 seconds by default. To configure metrics for a given region server, edit the
          <code class="filename">conf/hadoop-metrics2-hbase.properties</code> file. Restart the region server
        for the changes to take effect.</p><p>To change the sampling rate for the default sink, edit the line beginning with
          <code class="literal">*.period</code>. To filter which metrics are emitted or to extend the metrics
        framework, see <a class="link" href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html" target="_top">http://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html</a>
      </p><div class="note" title="HBase Metrics and Ganglia" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="rs_metrics_ganglia"></a>HBase Metrics and Ganglia</h3><p>By default, HBase emits a large number of metrics per region server. Ganglia may have
          difficulty processing all these metrics. Consider increasing the capacity of the Ganglia
          server or reducing the number of metrics emitted by HBase. See <a class="link" href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/metrics2/package-summary.html#filtering" target="_top">Metrics Filtering</a>.</p></div></div><div class="section" title="17.4.2.&nbsp;Disabling Metrics"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e18060"></a>17.4.2.&nbsp;Disabling Metrics</h3></div></div></div><p>To disable metrics for a region server, edit the
          <code class="filename">conf/hadoop-metrics2-hbase.properties</code> file and comment out any
        uncommented lines. Restart the region server for the changes to take effect.</p></div><div class="section" title="17.4.3.&nbsp;Discovering Available Metrics"><div class="titlepage"><div><div><h3 class="title"><a name="discovering.available.metrics"></a>17.4.3.&nbsp;Discovering Available Metrics</h3></div></div></div><p>Rather than listing each metric which HBase emits by default, you can browse through the
        available metrics, either as a JSON output or via JMX. Different metrics are
        exposed for the Master process and each region server process.</p><div class="procedure" title="Procedure&nbsp;17.1.&nbsp;Access a JSON Output of Available Metrics"><a name="d2875e18073"></a><p class="title"><b>Procedure&nbsp;17.1.&nbsp;Access a JSON Output of Available Metrics</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>After starting HBase, access the region server's web UI, at
              <code class="literal">http://REGIONSERVER_HOSTNAME:60030</code> by default (or port 16030 in HBase 1.0+).</p></li><li class="step" title="Step 2"><p>Click the <span class="guilabel">Metrics Dump</span> link near the top. The metrics for the region server are
            presented as a dump of the JMX bean in JSON format. This will dump out all metrics names and their
            values.
            To include metrics descriptions in the listing &#8212; this can be useful when you are exploring
            what is available &#8212; add a query string of
            <code class="literal">?description=true</code> so your URL becomes
            <code class="literal">http://REGIONSERVER_HOSTNAME:60030/jmx?description=true</code>.
            Not all beans and attributes have descriptions.
          </p></li><li class="step" title="Step 3"><p>To view metrics for the Master, connect to the Master's web UI instead (defaults to
              <code class="literal">http://localhost:60010</code> or port 16010 in HBase 1.0+) and click its <span class="guilabel">Metrics
                Dump</span> link.
            To include metrics descriptions in the listing &#8212; this can be useful when you are exploring
            what is available &#8212; add a query string of
            <code class="literal">?description=true</code> so your URL becomes
            <code class="literal">http://REGIONSERVER_HOSTNAME:60010/jmx?description=true</code>.
            Not all beans and attributes have descriptions.
            </p></li></ol></div><div class="procedure" title="Procedure&nbsp;17.2.&nbsp;Browse the JMX Output of Available Metrics"><a name="d2875e18109"></a><p class="title"><b>Procedure&nbsp;17.2.&nbsp;Browse the JMX Output of Available Metrics</b></p><p>You can use many different tools to view JMX content by browsing MBeans. This
          procedure uses <span class="command"><strong>jvisualvm</strong></span>, which is an application usually available in the JDK.
            </p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Start HBase, if it is not already running.</p></li><li class="step" title="Step 2"><p>Run the command <span class="command"><strong>jvisualvm</strong></span> command on a host with a GUI display.
            You can launch it from the command line or another method appropriate for your operating
            system.</p></li><li class="step" title="Step 3"><p>Be sure the <span class="guilabel">VisualVM-MBeans</span> plugin is installed. Browse to <span class="guimenu">Tools</span> &#8594; <span class="guimenuitem">Plugins</span>. Click <span class="guilabel">Installed</span> and check whether the plugin is
            listed. If not, click <span class="guilabel">Available Plugins</span>, select it, and click
              <span class="guibutton">Install</span>. When finished, click
            <span class="guibutton">Close</span>.</p></li><li class="step" title="Step 4"><p>To view details for a given HBase process, double-click the process in the
              <span class="guilabel">Local</span> sub-tree in the left-hand panel. A detailed view opens in
            the right-hand panel. Click the <span class="guilabel">MBeans</span> tab which appears as a tab
            in the top of the right-hand panel.</p></li><li class="step" title="Step 5"><p>To access the HBase metrics, navigate to the appropriate sub-bean:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Master: <span class="guimenu">Hadoop</span> &#8594; <span class="guisubmenu">HBase</span> &#8594; <span class="guisubmenu">Master</span> &#8594; <span class="guisubmenu">Server</span></p></li><li class="listitem"><p>RegionServer: <span class="guimenu">Hadoop</span> &#8594; <span class="guisubmenu">HBase</span> &#8594; <span class="guisubmenu">RegionServer</span> &#8594; <span class="guisubmenu">Server</span></p></li></ul></div></li><li class="step" title="Step 6"><p>The name of each metric and its current value is displayed in the
              <span class="guilabel">Attributes</span> tab. For a view which includes more details, including
            the description of each attribute, click the <span class="guilabel">Metadata</span> tab.</p></li></ol></div></div><div class="section" title="17.4.4.&nbsp;Units of Measure for Metrics"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e18196"></a>17.4.4.&nbsp;Units of Measure for Metrics</h3></div></div></div><p>Different metrics are expressed in different units, as appropriate. Often, the unit of
        measure is in the name (as in the metric <code class="code">shippedKBs</code>). Otherwise, use the
        following guidelines. When in doubt, you may need to examine the source for a given
        metric.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Metrics that refer to a point in time are usually expressed as a timestamp.</p></li><li class="listitem"><p>Metrics that refer to an age (such as <code class="code">ageOfLastShippedOp</code>) are usually
            expressed in milliseconds.</p></li><li class="listitem"><p>Metrics that refer to memory sizes are in bytes.</p></li><li class="listitem"><p>Sizes of queues (such as <code class="code">sizeOfLogQueue</code>) are expressed as the number of
            items in the queue. Determine the size by multiplying by the block size (default is 64
            MB in HDFS).</p></li><li class="listitem"><p>Metrics that refer to things like the number of a given type of operations (such as
              <code class="code">logEditsRead</code>) are expressed as an integer.</p></li></ul></div></div><div class="section" title="17.4.5.&nbsp;Most Important Master Metrics"><div class="titlepage"><div><div><h3 class="title"><a name="master_metrics"></a>17.4.5.&nbsp;Most Important Master Metrics</h3></div></div></div><p>Note: Counts are usually over the last metrics reporting interval.</p><div class="variablelist"><dl><dt><span class="term">hbase.master.numRegionServers</span></dt><dd><p>Number of live regionservers</p></dd><dt><span class="term">hbase.master.numDeadRegionServers</span></dt><dd><p>Number of dead regionservers</p></dd><dt><span class="term">hbase.master.ritCount </span></dt><dd><p>The number of regions in transition</p></dd><dt><span class="term">hbase.master.ritCountOverThreshold</span></dt><dd><p>The number of regions that have been in transition longer than
            a threshold time (default: 60 seconds)</p></dd><dt><span class="term">hbase.master.ritOldestAge</span></dt><dd><p>The age of the longest region in transition, in milliseconds
            </p></dd></dl></div></div><div class="section" title="17.4.6.&nbsp;Most Important RegionServer Metrics"><div class="titlepage"><div><div><h3 class="title"><a name="rs_metrics"></a>17.4.6.&nbsp;Most Important RegionServer Metrics</h3></div></div></div><p>Note: Counts are usually over the last metrics reporting interval.</p><div class="variablelist"><dl><dt><span class="term">hbase.regionserver.regionCount</span></dt><dd><p>The number of regions hosted by the regionserver</p></dd><dt><span class="term">hbase.regionserver.storeFileCount</span></dt><dd><p>The number of store files on disk currently managed by the
            regionserver</p></dd><dt><span class="term">hbase.regionserver.storeFileSize</span></dt><dd><p>Aggregate size of the store files on disk</p></dd><dt><span class="term">hbase.regionserver.hlogFileCount</span></dt><dd><p>The number of write ahead logs not yet archived</p></dd><dt><span class="term">hbase.regionserver.totalRequestCount</span></dt><dd><p>The total number of requests received</p></dd><dt><span class="term">hbase.regionserver.readRequestCount</span></dt><dd><p>The number of read requests received</p></dd><dt><span class="term">hbase.regionserver.writeRequestCount</span></dt><dd><p>The number of write requests received</p></dd><dt><span class="term">hbase.regionserver.numOpenConnections</span></dt><dd><p>The number of open connections at the RPC layer</p></dd><dt><span class="term">hbase.regionserver.numActiveHandler</span></dt><dd><p>The number of RPC handlers actively servicing requests</p></dd><dt><span class="term">hbase.regionserver.numCallsInGeneralQueue</span></dt><dd><p>The number of currently enqueued user requests</p></dd><dt><span class="term">hbase.regionserver.numCallsInReplicationQueue</span></dt><dd><p>The number of currently enqueued operations received from
            replication</p></dd><dt><span class="term">hbase.regionserver.numCallsInPriorityQueue</span></dt><dd><p>The number of currently enqueued priority (internal housekeeping)
            requests</p></dd><dt><span class="term">hbase.regionserver.flushQueueLength</span></dt><dd><p>Current depth of the memstore flush queue. If increasing, we are falling
            behind with clearing memstores out to HDFS.</p></dd><dt><span class="term">hbase.regionserver.updatesBlockedTime</span></dt><dd><p>Number of milliseconds updates have been blocked so the memstore can be
            flushed</p></dd><dt><span class="term">hbase.regionserver.compactionQueueLength</span></dt><dd><p>Current depth of the compaction request queue. If increasing, we are
            falling behind with storefile compaction.</p></dd><dt><span class="term">hbase.regionserver.blockCacheHitCount</span></dt><dd><p>The number of block cache hits</p></dd><dt><span class="term">hbase.regionserver.blockCacheMissCount</span></dt><dd><p>The number of block cache misses</p></dd><dt><span class="term">hbase.regionserver.blockCacheExpressHitPercent </span></dt><dd><p>The percent of the time that requests with the cache turned on hit the
            cache</p></dd><dt><span class="term">hbase.regionserver.percentFilesLocal</span></dt><dd><p>Percent of store file data that can be read from the local DataNode,
            0-100</p></dd><dt><span class="term">hbase.regionserver.&lt;op&gt;_&lt;measure&gt;</span></dt><dd><p>Operation latencies, where &lt;op&gt; is one of Append, Delete, Mutate,
            Get, Replay, Increment; and where &lt;measure&gt; is one of min, max, mean, median,
            75th_percentile, 95th_percentile, 99th_percentile</p></dd><dt><span class="term">hbase.regionserver.slow&lt;op&gt;Count </span></dt><dd><p>The number of operations we thought were slow, where &lt;op&gt; is one
            of the list above</p></dd><dt><span class="term">hbase.regionserver.GcTimeMillis</span></dt><dd><p>Time spent in garbage collection, in milliseconds</p></dd><dt><span class="term">hbase.regionserver.GcTimeMillisParNew</span></dt><dd><p>Time spent in garbage collection of the young generation, in
            milliseconds</p></dd><dt><span class="term">hbase.regionserver.GcTimeMillisConcurrentMarkSweep</span></dt><dd><p>Time spent in garbage collection of the old generation, in
            milliseconds</p></dd><dt><span class="term">hbase.regionserver.authenticationSuccesses</span></dt><dd><p>Number of client connections where authentication succeeded</p></dd><dt><span class="term">hbase.regionserver.authenticationFailures</span></dt><dd><p>Number of client connection authentication failures</p></dd><dt><span class="term">hbase.regionserver.mutationsWithoutWALCount </span></dt><dd><p>Count of writes submitted with a flag indicating they should bypass the
            write ahead log</p></dd></dl></div></div></div><div class="section" title="17.5.&nbsp;HBase Monitoring"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ops.monitoring"></a>17.5.&nbsp;HBase Monitoring</h2></div></div></div><div class="section" title="17.5.1.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="ops.monitoring.overview"></a>17.5.1.&nbsp;Overview</h3></div></div></div><p>The following metrics are arguably the most important to monitor for each RegionServer
        for "macro monitoring", preferably with a system like <a class="link" href="http://opentsdb.net/" target="_top">OpenTSDB</a>. If your cluster is having performance
        issues it's likely that you'll see something unusual with this group. </p><div class="itemizedlist" title="HBase:"><p class="title"><b>HBase:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>See <a class="xref" href="#rs_metrics" title="17.4.6.&nbsp;Most Important RegionServer Metrics">Section&nbsp;17.4.6, &#8220;Most Important RegionServer Metrics&#8221;</a></p></li></ul></div><div class="itemizedlist" title="OS:"><p class="title"><b>OS:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>IO Wait</p></li><li class="listitem"><p>User CPU</p></li></ul></div><div class="itemizedlist" title="Java:"><p class="title"><b>Java:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>GC</p></li></ul></div><p> For more information on HBase metrics, see <a class="xref" href="#hbase_metrics" title="17.4.&nbsp;HBase Metrics">Section&nbsp;17.4, &#8220;HBase Metrics&#8221;</a>. </p></div><div class="section" title="17.5.2.&nbsp;Slow Query Log"><div class="titlepage"><div><div><h3 class="title"><a name="ops.slow.query"></a>17.5.2.&nbsp;Slow Query Log</h3></div></div></div><p>The HBase slow query log consists of parseable JSON structures describing the properties
        of those client operations (Gets, Puts, Deletes, etc.) that either took too long to run, or
        produced too much output. The thresholds for "too long to run" and "too much output" are
        configurable, as described below. The output is produced inline in the main region server
        logs so that it is easy to discover further details from context with other logged events.
        It is also prepended with identifying tags <code class="constant">(responseTooSlow)</code>,
          <code class="constant">(responseTooLarge)</code>, <code class="constant">(operationTooSlow)</code>, and
          <code class="constant">(operationTooLarge)</code> in order to enable easy filtering with grep, in
        case the user desires to see only slow queries. </p><div class="section" title="17.5.2.1.&nbsp;Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e18487"></a>17.5.2.1.&nbsp;Configuration</h4></div></div></div><p>There are two configuration knobs that can be used to adjust the thresholds for when
          queries are logged. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="varname">hbase.ipc.warn.response.time</code> Maximum number of milliseconds
              that a query can be run without being logged. Defaults to 10000, or 10 seconds. Can be
              set to -1 to disable logging by time. </p></li><li class="listitem"><p><code class="varname">hbase.ipc.warn.response.size</code> Maximum byte size of response that
              a query can return without being logged. Defaults to 100 megabytes. Can be set to -1
              to disable logging by size. </p></li></ul></div></div><div class="section" title="17.5.2.2.&nbsp;Metrics"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e18503"></a>17.5.2.2.&nbsp;Metrics</h4></div></div></div><p>The slow query log exposes to metrics to JMX.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="varname">hadoop.regionserver_rpc_slowResponse</code> a global metric reflecting
              the durations of all responses that triggered logging.</p></li><li class="listitem"><p><code class="varname">hadoop.regionserver_rpc_methodName.aboveOneSec</code> A metric
              reflecting the durations of all responses that lasted for more than one second.</p></li></ul></div></div><div class="section" title="17.5.2.3.&nbsp;Output"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e18519"></a>17.5.2.3.&nbsp;Output</h4></div></div></div><p>The output is tagged with operation e.g. <code class="constant">(operationTooSlow)</code> if
          the call was a client operation, such as a Put, Get, or Delete, which we expose detailed
          fingerprint information for. If not, it is tagged <code class="constant">(responseTooSlow)</code>
          and still produces parseable JSON output, but with less verbose information solely
          regarding its duration and size in the RPC itself. <code class="constant">TooLarge</code> is
          substituted for <code class="constant">TooSlow</code> if the response size triggered the logging,
          with <code class="constant">TooLarge</code> appearing even in the case that both size and duration
          triggered logging. </p></div><div class="section" title="17.5.2.4.&nbsp;Example"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e18539"></a>17.5.2.4.&nbsp;Example</h4></div></div></div><p>
          </p><pre class="programlisting">2011-09-08 10:01:25,824 WARN org.apache.hadoop.ipc.HBaseServer: (operationTooSlow): {"tables":{"riley2":{"puts":[{"totalColumns":11,"families":{"actions":[{"timestamp":1315501284459,"qualifier":"0","vlen":9667580},{"timestamp":1315501284459,"qualifier":"1","vlen":10122412},{"timestamp":1315501284459,"qualifier":"2","vlen":11104617},{"timestamp":1315501284459,"qualifier":"3","vlen":13430635}]},"row":"cfcd208495d565ef66e7dff9f98764da:0"}],"families":["actions"]}},"processingtimems":956,"client":"10.47.34.63:33623","starttimems":1315501284456,"queuetimems":0,"totalPuts":1,"class":"HRegionServer","responsesize":0,"method":"multiPut"}</pre><p>
        </p><p>Note that everything inside the "tables" structure is output produced by MultiPut's
          fingerprint, while the rest of the information is RPC-specific, such as processing time
          and client IP/port. Other client operations follow the same pattern and the same general
          structure, with necessary differences due to the nature of the individual operations. In
          the case that the call is not a client operation, that detailed fingerprint information
          will be completely absent. </p><p>This particular example, for example, would indicate that the likely cause of slowness
          is simply a very large (on the order of 100MB) multiput, as we can tell by the "vlen," or
          value length, fields of each put in the multiPut. </p></div></div><div class="section" title="17.5.3.&nbsp;Block Cache Monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e18551"></a>17.5.3.&nbsp;Block Cache Monitoring</h3></div></div></div><p>Starting with HBase 0.98, the HBase Web UI includes the ability to monitor and report on
        the performance of the block cache. To view the block cache reports, click <span class="guimenu">Tasks</span> &#8594; <span class="guisubmenu">Show Non-RPC Tasks</span> &#8594; <span class="guimenuitem">Block Cache</span>. Following are a few examples of the reporting capabilities.</p><div class="figure"><a name="d2875e18564"></a><p class="title"><b>Figure&nbsp;17.1.&nbsp;Basic Info</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/bc_basic.png" width="100%" alt="Basic Info"></td></tr></table><div class="caption"><p>Shows the cache implementation</p></div></div></div></div><br class="figure-break"><div class="figure"><a name="d2875e18573"></a><p class="title"><b>Figure&nbsp;17.2.&nbsp;Config</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/bc_config.png" width="100%" alt="Config"></td></tr></table><div class="caption"><p>Shows all cache configuration options.</p></div></div></div></div><br class="figure-break"><div class="figure"><a name="d2875e18582"></a><p class="title"><b>Figure&nbsp;17.3.&nbsp;Stats</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/bc_stats.png" width="100%" alt="Stats"></td></tr></table><div class="caption"><p>Shows statistics about the performance of the cache.</p></div></div></div></div><br class="figure-break"><div class="figure"><a name="d2875e18591"></a><p class="title"><b>Figure&nbsp;17.4.&nbsp;L1 and L2</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="100%"><tr><td><img src="images/bc_l1.png" width="100%" alt="L1 and L2"></td></tr></table><div class="caption"><p>Shows information about the L1 and L2 caches.</p></div></div></div></div><br class="figure-break"><p>This is not an exhaustive list of all the screens and reports available. Have a look in
        the Web UI.</p></div></div><div class="section" title="17.6.&nbsp;Cluster Replication"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cluster_replication"></a>17.6.&nbsp;Cluster Replication</h2></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This information was previously available at <a class="link" href="http://hbase.apache.org/replication.html" target="_top">Cluster Replication</a>. </p></div><p>HBase provides a replication mechanism to copy data between HBase
      clusters. Replication can be used as a disaster recovery solution and as a mechanism for high
      availability. You can also use replication to separate web-facing operations from back-end
      jobs such as MapReduce.</p><p>In terms of architecture, HBase replication is master-push. This takes advantage of the
      fact that each region server has its own write-ahead log (WAL). One master cluster can
      replicate to any number of slave clusters, and each region server replicates its own stream of
      edits. For more information on the different properties of master/slave replication and other
      types of replication, see the article <a class="link" href="http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html" target="_top">How
        Google Serves Data From Multiple Datacenters</a>.</p><p>Replication is asynchronous, allowing clusters to be geographically distant or to have
      some gaps in availability. This also means that data between master and slave clusters will
      not be instantly consistent. Rows inserted on the master are not immediately available or
      consistent with rows on the slave clusters. rows inserted on the master cluster won&#8217;t be
      available at the same time on the slave clusters. The goal is eventual consistency. </p><p>The replication format used in this design is conceptually the same as the <em class="firstterm"><a class="link" href="http://dev.mysql.com/doc/refman/5.1/en/replication-formats.html" target="_top">statement-based
          replication</a></em> design used by MySQL. Instead of SQL statements, entire
      WALEdits (consisting of multiple cell inserts coming from Put and Delete operations on the
      clients) are replicated in order to maintain atomicity. </p><p>The WALs for each region server must be kept in HDFS as long as they are needed to
      replicate data to any slave cluster. Each region server reads from the oldest log it needs to
      replicate and keeps track of the current position inside ZooKeeper to simplify failure
      recovery. That position, as well as the queue of WALs to process, may be different for every
      slave cluster.</p><p>The clusters participating in replication can be of different sizes. The master
      cluster relies on randomization to attempt to balance the stream of replication on the slave clusters</p><p>HBase supports master/master and cyclic replication as well as replication to multiple
      slaves.</p><div class="figure"><a name="d2875e18634"></a><p class="title"><b>Figure&nbsp;17.5.&nbsp;Replication Architecture Overview</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/replication_overview.png" alt="Replication Architecture Overview"><div class="caption"><p>Illustration of the replication architecture in HBase, as described in the prior
            text.</p></div></div></div></div><br class="figure-break"><p title="Enabling and Configuring Replication"><b>Enabling and Configuring Replication.&nbsp;</b>See the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/replication/package-summary.html#requirements" target="_top">
          API documentation for replication</a> for information on enabling and configuring
        replication.</p><div class="section" title="17.6.1.&nbsp;Life of a WAL Edit"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e18651"></a>17.6.1.&nbsp;Life of a WAL Edit</h3></div></div></div><p>A single WAL edit goes through several steps in order to be replicated to a slave
        cluster.</p><div class="orderedlist" title="When the slave responds correctly:"><p class="title"><b>When the slave responds correctly:</b></p><ol class="orderedlist" type="1"><li class="listitem"><p>A HBase client uses a Put or Delete operation to manipulate data in HBase.</p></li><li class="listitem"><p>The region server writes the request to the WAL in a way that would allow it to be
            replayed if it were not written successfully.</p></li><li class="listitem"><p>If the changed cell corresponds to a column family that is scoped for replication,
            the edit is added to the queue for replication.</p></li><li class="listitem"><p>In a separate thread, the edit is read from the log, as part of a batch process.
            Only the KeyValues that are eligible for replication are kept. Replicable KeyValues are
            part of a column family whose schema is scoped GLOBAL, are not part of a catalog such as
              <code class="code">hbase:meta</code>, and did not originate from the target slave cluster, in the
            case of cyclic replication.</p></li><li class="listitem"><p>The edit is tagged with the master's UUID and added to a buffer. When the buffer is
            filled, or the reader reaches the end of the file, the buffer is sent to a random region
            server on the slave cluster.</p></li><li class="listitem"><p>The region server reads the edits sequentially and separates them into buffers, one
            buffer per table. After all edits are read, each buffer is flushed using <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>, HBase's normal client. The master's UUID is preserved in the edits
            they are applied, in order to allow for cyclic replication.</p></li><li class="listitem"><p>In the master, the offset for the WAL that is currently being replicated is
            registered in ZooKeeper.</p></li></ol></div><div class="orderedlist" title="When the slave does not respond:"><p class="title"><b>When the slave does not respond:</b></p><ol class="orderedlist" type="1"><li class="listitem"><p>The first three steps, where the edit is inserted, are identical.</p></li><li class="listitem"><p>Again in a separate thread, the region server reads, filters, and edits the log
            edits in the same way as above. The slave region server does not answer the RPC
            call.</p></li><li class="listitem"><p>The master sleeps and tries again a configurable number of times.</p></li><li class="listitem"><p>If the slave region server is still not available, the master selects a new subset
            of region server to replicate to, and tries again to send the buffer of edits.</p></li><li class="listitem"><p>Meanwhile, the WALs are rolled and stored in a queue in ZooKeeper. Logs that are
              <em class="firstterm">archived</em> by their region server, by moving them from the region
            server's log directory to a central log directory, will update their paths in the
            in-memory queue of the replicating thread.</p></li><li class="listitem"><p>When the slave cluster is finally available, the buffer is applied in the same way
            as during normal processing. The master region server will then replicate the backlog of
            logs that accumulated during the outage.</p></li></ol></div><div class="note" title="Spreading Queue Failover Load" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="cluster.replication.spreading.load"></a>Spreading Queue Failover Load</h3><p>When replication is active, a subset of RegionServers in the source cluster are
          responsible for shipping edits to the sink. This function must be failed over like all
          other RegionServer functions should a process or node crash. The following configuration
          settings are recommended for maintaining an even distribution of replication activity
          over the remaining live servers in the source cluster: Set
            <code class="code">replication.source.maxretriesmultiplier</code> to
            <code class="literal">300</code> (5 minutes), and
            <code class="code">replication.sleep.before.failover</code> to
            <code class="literal">30000</code> (30 seconds) in the source cluster site configuration.
        </p></div><div class="note" title="Preserving Tags During Replication" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="cluster.replication.preserving.tags"></a>Preserving Tags During Replication</h3><p>By default, the codec used for replication between clusters strips tags, such as
          cell-level ACLs, from cells. To prevent the tags from being stripped, you can use a
          different codec which does not strip them. Configure
            <code class="code">hbase.replication.rpc.codec</code> to use
            <code class="literal">org.apache.hadoop.hbase.codec.KeyValueCodecWithTags</code>, on both the
          source and sink RegionServers involved in the replication. This option was introduced in
            <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10322" target="_top">HBASE-10322</a>.</p></div></div><div class="section" title="17.6.2.&nbsp;Replication Internals"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e18741"></a>17.6.2.&nbsp;Replication Internals</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Replication State in ZooKeeper</span></dt><dd><p>HBase replication maintains its state in ZooKeeper. By default, the state is
              contained in the base node <code class="filename">/hbase/replication</code>. This node contains
              two child nodes, the <code class="code">Peers</code> znode and the <code class="code">RS</code> znode.</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Replication may be disrupted and data loss may occur if you delete the
                replication tree (<code class="filename">/hbase/replication/</code>) from ZooKeeper. This is
                despite the information about invariants at <a class="xref" href="#design.invariants.zk.data" title="18.10.4.1.&nbsp;No permanent state in ZooKeeper">Section&nbsp;18.10.4.1, &#8220;No permanent state in ZooKeeper&#8221;</a>. Follow progress on this issue at <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10295" target="_top">HBASE-10295</a>.</p></div></dd><dt><span class="term">The <code class="code">Peers</code> Znode</span></dt><dd><p>The <code class="code">peers</code> znode is stored in
                <code class="filename">/hbase/replication/peers</code> by default. It consists of a list of
              all peer replication clusters, along with the status of each of them. The value of
              each peer is its cluster key, which is provided in the HBase Shell. The cluster key
              contains a list of ZooKeeper nodes in the cluster's quorum, the client port for the
              ZooKeeper quorum, and the base znode for HBase in HDFS on that cluster.</p><pre class="screen">
/hbase/replication/peers
  /1 [Value: zk1.host.com,zk2.host.com,zk3.host.com:2181:/hbase]
  /2 [Value: zk5.host.com,zk6.host.com,zk7.host.com:2181:/hbase]            
          </pre><p>Each peer has a child znode which indicates whether or not replication is enabled
              on that cluster. These peer-state znodes do not contain any child znodes, but only
              contain a Boolean value. This value is read and maintained by the
                R<code class="code">eplicationPeer.PeerStateTracker</code> class.</p><pre class="screen">
/hbase/replication/peers
  /1/peer-state [Value: ENABLED]
  /2/peer-state [Value: DISABLED]
          </pre></dd><dt><span class="term">The <code class="code">RS</code> Znode</span></dt><dd><p>The <code class="code">rs</code> znode contains a list of WAL logs which need to be replicated.
              This list is divided into a set of queues organized by region server and the peer
              cluster the region server is shipping the logs to. The rs znode has one child znode
              for each region server in the cluster. The child znode name is the region server's
              hostname, client port, and start code. This list includes both live and dead region
              servers.</p><pre class="screen">
/hbase/replication/rs
  /hostname.example.org,6020,1234
  /hostname2.example.org,6020,2856            
          </pre><p>Each <code class="code">rs</code> znode contains a list of WAL replication queues, one queue
              for each peer cluster it replicates to. These queues are represented by child znodes
              named by the cluster ID of the peer cluster they represent.</p><pre class="screen">
/hbase/replication/rs
  /hostname.example.org,6020,1234
    /1
    /2            
          </pre><p>Each queue has one child znode for each WAL log that still needs to be replicated.
              the value of these child znodes is the last position that was replicated. This
              position is updated each time a WAL log is replicated.</p><pre class="screen">
/hbase/replication/rs
  /hostname.example.org,6020,1234
    /1
      23522342.23422 [VALUE: 254]
      12340993.22342 [VALUE: 0]            
          </pre></dd></dl></div></div><div class="section" title="17.6.3.&nbsp;Replication Configuration Options"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e18820"></a>17.6.3.&nbsp;Replication Configuration Options</h3></div></div></div><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><p><code class="code">zookeeper.znode.parent</code></p></td><td><p>The name of the base ZooKeeper znode used for HBase</p></td><td><p><code class="literal">/hbase</code></p></td></tr><tr><td><p><code class="code">zookeeper.znode.replication</code></p></td><td><p>The name of the base znode used for replication</p></td><td><p><code class="literal">replication</code></p></td></tr><tr><td><p><code class="code">zookeeper.znode.replication.peers</code></p></td><td><p>The name of the <code class="code">peer</code> znode</p></td><td><p><code class="literal">peers</code></p></td></tr><tr><td><p><code class="code">zookeeper.znode.replication.peers.state</code></p></td><td><p>The name of <code class="code">peer-state</code> znode</p></td><td><p><code class="literal">peer-state</code></p></td></tr><tr><td><p><code class="code">zookeeper.znode.replication.rs</code></p></td><td><p>The name of the <code class="code">rs</code> znode</p></td><td><p><code class="literal">rs</code></p></td></tr><tr><td><p><code class="code">hbase.replication</code></p></td><td><p>Whether replication is enabled or disabled on a given cluster</p></td><td><p><code class="literal">false</code></p></td></tr><tr><td><p><code class="code">eplication.sleep.before.failover</code></p></td><td><p>How many milliseconds a worker should sleep before attempting to replicate
              a dead region server's WAL queues.</p></td><td><p><code class="literal"></code></p></td></tr><tr><td><p><code class="code">replication.executor.workers</code></p></td><td><p>The number of region servers a given region server should attempt to
                failover simultaneously.</p></td><td><p><code class="literal">1</code></p></td></tr></tbody></table></div></div><div class="section" title="17.6.4.&nbsp;Replication Implementation Details"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e18938"></a>17.6.4.&nbsp;Replication Implementation Details</h3></div></div></div><p title="Choosing Region Servers to Replicate To"><b>Choosing Region Servers to Replicate To.&nbsp;</b>When a master cluster region server initiates a replication source to a slave cluster,
          it first connects to the slave's ZooKeeper ensemble using the provided cluster key . It
          then scans the <code class="filename">rs/</code> directory to discover all the available sinks
          (region servers that are accepting incoming streams of edits to replicate) and randomly
          chooses a subset of them using a configured ratio which has a default value of 10%. For
          example, if a slave cluster has 150 machines, 15 will be chosen as potential recipient for
          edits that this master cluster region server sends. Because this selection is performed by
          each master region server, the probability that all slave region servers are used is very
          high, and this method works for clusters of any size. For example, a master cluster of 10
          machines replicating to a slave cluster of 5 machines with a ratio of 10% causes the
          master cluster region servers to choose one machine each at random.</p><p>A ZooKeeper watcher is placed on the
            <code class="filename">${<em class="replaceable"><code>zookeeper.znode.parent</code></em>}/rs</code> node of the
        slave cluster by each of the master cluster's region servers. This watch is used to monitor
        changes in the composition of the slave cluster. When nodes are removed from the slave
        cluster, or if nodes go down or come back up, the master cluster's region servers will
        respond by selecting a new pool of slave region servers to replicate to.</p><p title="Keeping Track of Logs"><b>Keeping Track of Logs.&nbsp;</b>Each master cluster region server has its own znode in the replication znodes
          hierarchy. It contains one znode per peer cluster (if 5 slave clusters, 5 znodes are
          created), and each of these contain a queue of WALs to process. Each of these queues will
          track the WALs created by that region server, but they can differ in size. For example, if
          one slave cluster becomes unavailable for some time, the WALs should not be deleted, so
          they need to stay in the queue while the others are processed. See <a class="xref" href="#rs.failover.details" title="Region Server Failover">Region Server Failover</a> for an example.</p><p>When a source is instantiated, it contains the current WAL that the region server is
        writing to. During log rolling, the new file is added to the queue of each slave cluster's
        znode just before it is made available. This ensures that all the sources are aware that a
        new log exists before the region server is able to append edits into it, but this operations
        is now more expensive. The queue items are discarded when the replication thread cannot read
        more entries from a file (because it reached the end of the last block) and there are other
        files in the queue. This means that if a source is up to date and replicates from the log
        that the region server writes to, reading up to the "end" of the current file will not
        delete the item in the queue.</p><p>A log can be archived if it is no longer used or if the number of logs exceeds
          <code class="code">hbase.regionserver.maxlogs</code> because the insertion rate is faster than regions
        are flushed. When a log is archived, the source threads are notified that the path for that
        log changed. If a particular source has already finished with an archived log, it will just
        ignore the message. If the log is in the queue, the path will be updated in memory. If the
        log is currently being replicated, the change will be done atomically so that the reader
        doesn't attempt to open the file when has already been moved. Because moving a file is a
        NameNode operation , if the reader is currently reading the log, it won't generate any
        exception.</p><p title="Reading, Filtering and Sending Edits"><b>Reading, Filtering and Sending Edits.&nbsp;</b>By default, a source attempts to read from a WAL and ship log entries to a sink as
          quickly as possible. Speed is limited by the filtering of log entries Only KeyValues that
          are scoped GLOBAL and that do not belong to catalog tables will be retained. Speed is also
          limited by total size of the list of edits to replicate per slave, which is limited to 64
          MB by default. With this configuration, a master cluster region server with three slaves
          would use at most 192 MB to store data to replicate. This does not account for the data
          which was filtered but not garbage collected.</p><p>Once the maximum size of edits has been buffered or the reader reaces the end of the
        WAL, the source thread stops reading and chooses at random a sink to replicate to (from the
        list that was generated by keeping only a subset of slave region servers). It directly
        issues a RPC to the chosen region server and waits for the method to return. If the RPC was
        successful, the source determines whether the current file has been emptied or it contains
        more data which needs to be read. If the file has been emptied, the source deletes the znode
        in the queue. Otherwise, it registers the new offset in the log's znode. If the RPC threw an
        exception, the source will retry 10 times before trying to find a different sink.</p><p title="Cleaning Logs"><b>Cleaning Logs.&nbsp;</b>If replication is not enabled, the master's log-cleaning thread deletes old logs using
          a configured TTL. This TTL-based method does not work well with replication, because
          archived logs which have exceeded their TTL may still be in a queue. The default behavior
          is augmented so that if a log is past its TTL, the cleaning thread looks up every queue
          until it finds the log, while caching queues it has found. If the log is not found in any
          queues, the log will be deleted. The next time the cleaning process needs to look for a
          log, it starts by using its cached list.</p><p title="Region Server Failover"><a name="rs.failover.details"></a><b>Region Server Failover.&nbsp;</b>When no region servers are failing, keeping track of the logs in ZooKeeper adds no
          value. Unfortunately, region servers do fail, and since ZooKeeper is highly available, it
          is useful for managing the transfer of the queues in the event of a failure.</p><p>Each of the master cluster region servers keeps a watcher on every other region server,
        in order to be notified when one dies (just as the master does). When a failure happens,
        they all race to create a znode called <code class="literal">lock</code> inside the dead region
        server's znode that contains its queues. The region server that creates it successfully then
        transfers all the queues to its own znode, one at a time since ZooKeeper does not support
        renaming queues. After queues are all transferred, they are deleted from the old location.
        The znodes that were recovered are renamed with the ID of the slave cluster appended with
        the name of the dead server.</p><p>Next, the master cluster region server creates one new source thread per copied queue,
        and each of the source threads follows the read/filter/ship pattern. The main difference is
        that those queues will never receive new data, since they do not belong to their new region
        server. When the reader hits the end of the last log, the queue's znode is deleted and the
        master cluster region server closes that replication source.</p><p>Given a master cluster with 3 region servers replicating to a single slave with id
          <code class="literal">2</code>, the following hierarchy represents what the znodes layout could be
        at some point in time. The region servers' znodes all contain a <code class="literal">peers</code>
        znode which contains a single queue. The znode names in the queues represent the actual file
        names on HDFS in the form
            <code class="literal"><em class="replaceable"><code>address</code></em>,<em class="replaceable"><code>port</code></em>.<em class="replaceable"><code>timestamp</code></em></code>.</p><pre class="screen">
/hbase/replication/rs/
  1.1.1.1,60020,123456780/
    2/
      1.1.1.1,60020.1234  (Contains a position)
      1.1.1.1,60020.1265
  1.1.1.2,60020,123456790/
    2/
      1.1.1.2,60020.1214  (Contains a position)
      1.1.1.2,60020.1248
      1.1.1.2,60020.1312
  1.1.1.3,60020,    123456630/
    2/
      1.1.1.3,60020.1280  (Contains a position)            
          </pre><p>Assume that 1.1.1.2 loses its ZooKeeper session. The survivors will race to create a
        lock, and, arbitrarily, 1.1.1.3 wins. It will then start transferring all the queues to its
        local peers znode by appending the name of the dead server. Right before 1.1.1.3 is able to
        clean up the old znodes, the layout will look like the following:</p><pre class="screen">
/hbase/replication/rs/
  1.1.1.1,60020,123456780/
    2/
      1.1.1.1,60020.1234  (Contains a position)
      1.1.1.1,60020.1265
  1.1.1.2,60020,123456790/
    lock
    2/
      1.1.1.2,60020.1214  (Contains a position)
      1.1.1.2,60020.1248
      1.1.1.2,60020.1312
  1.1.1.3,60020,123456630/
    2/
      1.1.1.3,60020.1280  (Contains a position)

    2-1.1.1.2,60020,123456790/
      1.1.1.2,60020.1214  (Contains a position)
      1.1.1.2,60020.1248
      1.1.1.2,60020.1312            
          </pre><p>Some time later, but before 1.1.1.3 is able to finish replicating the last WAL from
        1.1.1.2, it dies too. Some new logs were also created in the normal queues. The last region
        server will then try to lock 1.1.1.3's znode and will begin transferring all the queues. The
        new layout will be:</p><pre class="screen">
/hbase/replication/rs/
  1.1.1.1,60020,123456780/
    2/
      1.1.1.1,60020.1378  (Contains a position)

    2-1.1.1.3,60020,123456630/
      1.1.1.3,60020.1325  (Contains a position)
      1.1.1.3,60020.1401

    2-1.1.1.2,60020,123456790-1.1.1.3,60020,123456630/
      1.1.1.2,60020.1312  (Contains a position)
  1.1.1.3,60020,123456630/
    lock
    2/
      1.1.1.3,60020.1325  (Contains a position)
      1.1.1.3,60020.1401

    2-1.1.1.2,60020,123456790/
      1.1.1.2,60020.1312  (Contains a position)            
          </pre><p title="Replication Metrics"><b>Replication Metrics.&nbsp;</b>The following metrics are exposed at the global region server level and (since HBase
          0.95) at the peer level:</p><div class="variablelist"><dl><dt><span class="term"><code class="code">source.sizeOfLogQueue</code></span></dt><dd><p>number of WALs to process (excludes the one which is being processed) at the
              Replication source</p></dd><dt><span class="term"><code class="code">source.shippedOps</code></span></dt><dd><p>number of mutations shipped</p></dd><dt><span class="term"><code class="code">source.logEditsRead</code></span></dt><dd><p>number of mutations read from HLogs at the replication source</p></dd><dt><span class="term"><code class="code">source.ageOfLastShippedOp</code></span></dt><dd><p>age of last batch that was shipped by the replication source</p></dd></dl></div></div></div><div class="section" title="17.7.&nbsp;HBase Backup"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ops.backup"></a>17.7.&nbsp;HBase Backup</h2></div></div></div><p>There are two broad strategies for performing HBase backups: backing up with a full
      cluster shutdown, and backing up on a live cluster. Each approach has pros and cons. </p><p>For additional information, see <a class="link" href="http://blog.sematext.com/2011/03/11/hbase-backup-options/" target="_top">HBase Backup
        Options</a> over on the Sematext Blog. </p><div class="section" title="17.7.1.&nbsp;Full Shutdown Backup"><div class="titlepage"><div><div><h3 class="title"><a name="ops.backup.fullshutdown"></a>17.7.1.&nbsp;Full Shutdown Backup</h3></div></div></div><p>Some environments can tolerate a periodic full shutdown of their HBase cluster, for
        example if it is being used a back-end analytic capacity and not serving front-end
        web-pages. The benefits are that the NameNode/Master are RegionServers are down, so there is
        no chance of missing any in-flight changes to either StoreFiles or metadata. The obvious con
        is that the cluster is down. The steps include: </p><div class="section" title="17.7.1.1.&nbsp;Stop HBase"><div class="titlepage"><div><div><h4 class="title"><a name="ops.backup.fullshutdown.stop"></a>17.7.1.1.&nbsp;Stop HBase</h4></div></div></div><p> </p></div><div class="section" title="17.7.1.2.&nbsp;Distcp"><div class="titlepage"><div><div><h4 class="title"><a name="ops.backup.fullshutdown.distcp"></a>17.7.1.2.&nbsp;Distcp</h4></div></div></div><p>Distcp could be used to either copy the contents of the HBase directory in HDFS to
          either the same cluster in another directory, or to a different cluster. </p><p>Note: Distcp works in this situation because the cluster is down and there are no
          in-flight edits to files. Distcp-ing of files in the HBase directory is not generally
          recommended on a live cluster. </p></div><div class="section" title="17.7.1.3.&nbsp;Restore (if needed)"><div class="titlepage"><div><div><h4 class="title"><a name="ops.backup.fullshutdown.restore"></a>17.7.1.3.&nbsp;Restore (if needed)</h4></div></div></div><p>The backup of the hbase directory from HDFS is copied onto the 'real' hbase directory
          via distcp. The act of copying these files creates new HDFS metadata, which is why a
          restore of the NameNode edits from the time of the HBase backup isn't required for this
          kind of restore, because it's a restore (via distcp) of a specific HDFS directory (i.e.,
          the HBase part) not the entire HDFS file-system. </p></div></div><div class="section" title="17.7.2.&nbsp;Live Cluster Backup - Replication"><div class="titlepage"><div><div><h3 class="title"><a name="ops.backup.live.replication"></a>17.7.2.&nbsp;Live Cluster Backup - Replication</h3></div></div></div><p>This approach assumes that there is a second cluster. See the HBase page on <a class="link" href="http://hbase.apache.org/replication.html" target="_top">replication</a> for more
        information. </p></div><div class="section" title="17.7.3.&nbsp;Live Cluster Backup - CopyTable"><div class="titlepage"><div><div><h3 class="title"><a name="ops.backup.live.copytable"></a>17.7.3.&nbsp;Live Cluster Backup - CopyTable</h3></div></div></div><p>The <a class="xref" href="#copytable" title="17.1.8.&nbsp;CopyTable">Section&nbsp;17.1.8, &#8220;CopyTable&#8221;</a> utility could either be used to copy data from one table to another
        on the same cluster, or to copy data to another table on another cluster. </p><p>Since the cluster is up, there is a risk that edits could be missed in the copy process.
      </p></div><div class="section" title="17.7.4.&nbsp;Live Cluster Backup - Export"><div class="titlepage"><div><div><h3 class="title"><a name="ops.backup.live.export"></a>17.7.4.&nbsp;Live Cluster Backup - Export</h3></div></div></div><p>The <a class="xref" href="#export" title="17.1.9.&nbsp;Export">Section&nbsp;17.1.9, &#8220;Export&#8221;</a> approach dumps the content of a table to HDFS on the same cluster. To
        restore the data, the <a class="xref" href="#import" title="17.1.10.&nbsp;Import">Section&nbsp;17.1.10, &#8220;Import&#8221;</a> utility would be used. </p><p>Since the cluster is up, there is a risk that edits could be missed in the export
        process. </p></div></div><div class="section" title="17.8.&nbsp;HBase Snapshots"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ops.snapshots"></a>17.8.&nbsp;HBase Snapshots</h2></div></div></div><p>HBase Snapshots allow you to take a snapshot of a table without too much impact on Region
      Servers. Snapshot, Clone and restore operations don't involve data copying. Also, Exporting
      the snapshot to another cluster doesn't have impact on the Region Servers. </p><p>Prior to version 0.94.6, the only way to backup or to clone a table is to use
      CopyTable/ExportTable, or to copy all the hfiles in HDFS after disabling the table. The
      disadvantages of these methods are that you can degrade region server performance (Copy/Export
      Table) or you need to disable the table, that means no reads or writes; and this is usually
      unacceptable. </p><div class="section" title="17.8.1.&nbsp;Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.configuration"></a>17.8.1.&nbsp;Configuration</h3></div></div></div><p>To turn on the snapshot support just set the <code class="varname">hbase.snapshot.enabled</code>
        property to true. (Snapshots are enabled by default in 0.95+ and off by default in
        0.94.6+)</p><pre class="programlisting">
  &lt;property&gt;
    &lt;name&gt;hbase.snapshot.enabled&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
        </pre></div><div class="section" title="17.8.2.&nbsp;Take a Snapshot"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.takeasnapshot"></a>17.8.2.&nbsp;Take a Snapshot</h3></div></div></div><p>You can take a snapshot of a table regardless of whether it is enabled or disabled. The
        snapshot operation doesn't involve any data copying.</p><pre class="screen">
$ ./bin/hbase shell
hbase&gt; snapshot 'myTable', 'myTableSnapshot-122112'
        </pre><p title="Take a Snapshot Without Flushing"><b>Take a Snapshot Without Flushing.&nbsp;</b>The default behavior is to perform a flush of data in memory before the snapshot is
          taken. This means that data in memory is included in the snapshot. In most cases, this is
          the desired behavior. However, if your set-up can tolerate data in memory being excluded
          from the snapshot, you can use the <code class="option">SKIP_FLUSH</code> option of the
            <span class="command"><strong>snapshot</strong></span> command to disable and flushing while taking the
          snapshot.</p><pre class="screen">hbase&gt; snapshot 'mytable', 'snapshot123', {SKIP_FLUSH =&gt; true}</pre><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>There is no way to determine or predict whether a very concurrent insert or update
          will be included in a given snapshot, whether flushing is enabled or disabled. A snapshot
          is only a representation of a table during a window of time. The amount of time the
          snapshot operation will take to reach each Region Server may vary from a few seconds to a
          minute, depending on the resource load and speed of the hardware or network, among other
          factors. There is also no way to know whether a given insert or update is in memory or has
          been flushed.</p></div></div><div class="section" title="17.8.3.&nbsp;Listing Snapshots"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.list"></a>17.8.3.&nbsp;Listing Snapshots</h3></div></div></div><p>List all snapshots taken (by printing the names and relative information).</p><pre class="screen">
$ ./bin/hbase shell
hbase&gt; list_snapshots
        </pre></div><div class="section" title="17.8.4.&nbsp;Deleting Snapshots"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.delete"></a>17.8.4.&nbsp;Deleting Snapshots</h3></div></div></div><p>You can remove a snapshot, and the files retained for that snapshot will be removed if
        no longer needed.</p><pre class="screen">
$ ./bin/hbase shell
hbase&gt; delete_snapshot 'myTableSnapshot-122112'
        </pre></div><div class="section" title="17.8.5.&nbsp;Clone a table from snapshot"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.clone"></a>17.8.5.&nbsp;Clone a table from snapshot</h3></div></div></div><p>From a snapshot you can create a new table (clone operation) with the same data that you
        had when the snapshot was taken. The clone operation, doesn't involve data copies, and a
        change to the cloned table doesn't impact the snapshot or the original table.</p><pre class="screen">
$ ./bin/hbase shell
hbase&gt; clone_snapshot 'myTableSnapshot-122112', 'myNewTestTable'
        </pre></div><div class="section" title="17.8.6.&nbsp;Restore a snapshot"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.restore"></a>17.8.6.&nbsp;Restore a snapshot</h3></div></div></div><p>The restore operation requires the table to be disabled, and the table will be restored
        to the state at the time when the snapshot was taken, changing both data and schema if
        required.</p><pre class="screen">
$ ./bin/hbase shell
hbase&gt; disable 'myTable'
hbase&gt; restore_snapshot 'myTableSnapshot-122112'
        </pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Since Replication works at log level and snapshots at file-system level, after a
          restore, the replicas will be in a different state from the master. If you want to use
          restore, you need to stop replication and redo the bootstrap. </p></div><p>In case of partial data-loss due to misbehaving client, instead of a full restore that
        requires the table to be disabled, you can clone the table from the snapshot and use a
        Map-Reduce job to copy the data that you need, from the clone to the main one. </p></div><div class="section" title="17.8.7.&nbsp;Snapshots operations and ACLs"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.acls"></a>17.8.7.&nbsp;Snapshots operations and ACLs</h3></div></div></div><p>If you are using security with the AccessController Coprocessor (See <a class="xref" href="#hbase.accesscontrol.configuration" title="8.3.2.&nbsp;Access Control Labels (ACLs)">Section&nbsp;8.3.2, &#8220;Access Control Labels (ACLs)&#8221;</a>), only a global administrator can take,
        clone, or restore a snapshot, and these actions do not capture the ACL rights. This means
        that restoring a table preserves the ACL rights of the existing table, while cloning a table
        creates a new table that has no ACL rights until the administrator adds them.</p></div><div class="section" title="17.8.8.&nbsp;Export to another cluster"><div class="titlepage"><div><div><h3 class="title"><a name="ops.snapshots.export"></a>17.8.8.&nbsp;Export to another cluster</h3></div></div></div><p>The ExportSnapshot tool copies all the data related to a snapshot (hfiles, logs,
        snapshot metadata) to another cluster. The tool executes a Map-Reduce job, similar to
        distcp, to copy files between the two clusters, and since it works at file-system level the
        hbase cluster does not have to be online.</p><p>To copy a snapshot called MySnapshot to an HBase cluster srv2 (hdfs:///srv2:8082/hbase)
        using 16 mappers:</p><pre class="programlisting">$ bin/hbase class org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot -copy-to hdfs://srv2:8082/hbase -mappers 16</pre><p title="Limiting Bandwidth Consumption"><b>Limiting Bandwidth Consumption.&nbsp;</b>You can limit the bandwidth consumption when exporting a snapshot, by specifying the
            <code class="code">-bandwidth</code> parameter, which expects an integer representing megabytes per
          second. The following example limits the above example to 200 MB/sec.</p><pre class="programlisting">$ bin/hbase class org.apache.hadoop.hbase.snapshot.ExportSnapshot -snapshot MySnapshot -copy-to hdfs://srv2:8082/hbase -mappers 16 -bandwidth 200</pre></div></div><div class="section" title="17.9.&nbsp;Capacity Planning and Region Sizing"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ops.capacity"></a>17.9.&nbsp;Capacity Planning and Region Sizing</h2></div></div></div><p>There are several considerations when planning the capacity for an HBase cluster and
      performing the initial configuration. Start with a solid understanding of how HBase handles
      data internally.</p><div class="section" title="17.9.1.&nbsp;Node count and hardware/VM configuration"><div class="titlepage"><div><div><h3 class="title"><a name="ops.capacity.nodes"></a>17.9.1.&nbsp;Node count and hardware/VM configuration</h3></div></div></div><div class="section" title="17.9.1.1.&nbsp;Physical data size"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.nodes.datasize"></a>17.9.1.1.&nbsp;Physical data size</h4></div></div></div><p>Physical data size on disk is distinct from logical size of your data and is affected
          by the following: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Increased by HBase overhead</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>See <a class="xref" href="#keyvalue" title="9.7.7.6.&nbsp;KeyValue">Section&nbsp;9.7.7.6, &#8220;KeyValue&#8221;</a> and <a class="xref" href="#keysize" title="6.3.3.&nbsp;Try to minimize row and column sizes">Section&nbsp;6.3.3, &#8220;Try to minimize row and column sizes&#8221;</a>. At least 24 bytes per key-value (cell), can be more. Small
                  keys/values means more relative overhead.</p></li><li class="listitem"><p>KeyValue instances are aggregated into blocks, which are indexed. Indexes also
                  have to be stored. Blocksize is configurable on a per-ColumnFamily basis. See <a class="xref" href="#regions.arch" title="9.7.&nbsp;Regions">Section&nbsp;9.7, &#8220;Regions&#8221;</a>.</p></li></ul></div></li><li class="listitem"><p>Decreased by <a class="xref" href="#compression" title="Appendix&nbsp;E.&nbsp;Compression and Data Block Encoding In HBase">compression</a> and data block encoding, depending on data. See
              also <a class="link" href="http://search-hadoop.com/m/lL12B1PFVhp1" target="_top">this thread</a>. You might
              want to test what compression and encoding (if any) make sense for your data.</p></li><li class="listitem"><p>Increased by size of region server <a class="xref" href="#wal" title="9.6.5.&nbsp;Write Ahead Log (WAL)">WAL</a> (usually fixed and negligible - less than half of RS
              memory size, per RS).</p></li><li class="listitem"><p>Increased by HDFS replication - usually x3.</p></li></ul></div><p>Aside from the disk space necessary to store the data, one RS may not be able to serve
          arbitrarily large amounts of data due to some practical limits on region count and size
          (see <a class="xref" href="#ops.capacity.regions" title="17.9.2.&nbsp;Determining region count and size">below</a>).</p></div><div class="section" title="17.9.1.2.&nbsp;Read/Write throughput"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.nodes.throughput"></a>17.9.1.2.&nbsp;Read/Write throughput</h4></div></div></div><p>Number of nodes can also be driven by required thoughput for reads and/or writes. The
          throughput one can get per node depends a lot on data (esp. key/value sizes) and request
          patterns, as well as node and system configuration. Planning should be done for peak load
          if it is likely that the load would be the main driver of the increase of the node count.
          PerformanceEvaluation and <a class="xref" href="#ycsb">YCSB</a> tools can be used to test single node or a test
          cluster.</p><p>For write, usually 5-15Mb/s per RS can be expected, since every region server has only
          one active WAL. There's no good estimate for reads, as it depends vastly on data,
          requests, and cache hit rate. <a class="xref" href="#perf.casestudy" title="14.14.&nbsp;Case Studies">Section&nbsp;14.14, &#8220;Case Studies&#8221;</a> might be helpful.</p></div><div class="section" title="17.9.1.3.&nbsp;JVM GC limitations"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.nodes.gc"></a>17.9.1.3.&nbsp;JVM GC limitations</h4></div></div></div><p>RS cannot currently utilize very large heap due to cost of GC. There's also no good
          way of running multiple RS-es per server (other than running several VMs per machine).
          Thus, ~20-24Gb or less memory dedicated to one RS is recommended. GC tuning is required
          for large heap sizes. See <a class="xref" href="#gcpause" title="14.3.1.1.&nbsp;Long GC pauses">Section&nbsp;14.3.1.1, &#8220;Long GC pauses&#8221;</a>, <a class="xref" href="#trouble.log.gc" title="15.2.3.&nbsp;JVM Garbage Collection Logs">Section&nbsp;15.2.3, &#8220;JVM Garbage Collection Logs&#8221;</a> and elsewhere (TODO: where?)</p></div></div><div class="section" title="17.9.2.&nbsp;Determining region count and size"><div class="titlepage"><div><div><h3 class="title"><a name="ops.capacity.regions"></a>17.9.2.&nbsp;Determining region count and size</h3></div></div></div><p>Generally less regions makes for a smoother running cluster (you can always manually
        split the big regions later (if necessary) to spread the data, or request load, over the
        cluster); 20-200 regions per RS is a reasonable range. The number of regions cannot be
        configured directly (unless you go for fully <a class="xref" href="#disable.splitting" title="2.6.2.7.&nbsp;Managed Splitting">manual splitting</a>); adjust the region size to achieve the target
        region size given table size.</p><p>When configuring regions for multiple tables, note that most region settings can be set
        on a per-table basis via <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HTableDescriptor.html" target="_top">HTableDescriptor</a>,
        as well as shell commands. These settings will override the ones in
          <code class="varname">hbase-site.xml</code>. That is useful if your tables have different
        workloads/use cases.</p><p>Also note that in the discussion of region sizes here, <span class="bold"><strong>HDFS replication factor is not (and should not be) taken into account, whereas
          other factors <a class="xref" href="#ops.capacity.nodes.datasize" title="17.9.1.1.&nbsp;Physical data size">above</a> should be.</strong></span> So, if your data is compressed and
        replicated 3 ways by HDFS, "9 Gb region" means 9 Gb of compressed data. HDFS replication
        factor only affects your disk usage and is invisible to most HBase code.</p><div class="section" title="17.9.2.1.&nbsp;Viewing the Current Number of Regions"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e19314"></a>17.9.2.1.&nbsp;Viewing the Current Number of Regions</h4></div></div></div><p>You can view the current number of regions for a given table using the HMaster UI. In
          the <span class="guilabel">Tables</span> section, the number of online regions for each table is
          listed in the <span class="guilabel">Online Regions</span> column. This total only includes the
          in-memory state and does not include disabled or offline regions. If you do not want to
          use the HMaster UI, you can determine the number of regions by counting the number of
          subdirectories of the /hbase/&lt;table&gt;/ subdirectories in HDFS, or by running the
            <span class="command"><strong>bin/hbase hbck</strong></span> command. Each of these methods may return a slightly
          different number, depending on the status of each region.</p></div><div class="section" title="17.9.2.2.&nbsp;Number of regions per RS - upper bound"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.regions.count"></a>17.9.2.2.&nbsp;Number of regions per RS - upper bound</h4></div></div></div><p>In production scenarios, where you have a lot of data, you are normally concerned with
          the maximum number of regions you can have per server. <a class="xref" href="#too_many_regions" title="9.7.1.1.&nbsp;Why cannot I have too many regions?">Section&nbsp;9.7.1.1, &#8220;Why cannot I have too many regions?&#8221;</a>
          has technical discussion on the subject. Basically, the maximum number of regions is
          mostly determined by memstore memory usage. Each region has its own memstores; these grow
          up to a configurable size; usually in 128-256 MB range, see <a class="xref" href="#hbase.hregion.memstore.flush.size" title="hbase.hregion.memstore.flush.size"><code class="varname">hbase.hregion.memstore.flush.size</code></a>. One memstore exists per column family (so
          there's only one per region if there's one CF in the table). The RS dedicates some
          fraction of total memory to its memstores (see <a class="xref" href="#">???</a>). If this memory is exceeded (too
          much memstore usage), it can cause undesirable consequences such as unresponsive server or
          compaction storms. A good starting point for the number of regions per RS (assuming one
          table) is:</p><pre class="programlisting">((RS memory) * (total memstore fraction)) / ((memstore size)*(# column families))</pre><p>This formula is pseudo-code. Here are two formulas using the actual tunable
          parameters, first for HBase 0.98+ and second for HBase 0.94.x.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>HBase 0.98.x:<code class="code">((RS Xmx) * hbase.regionserver.global.memstore.size) /
                (hbase.hregion.memstore.flush.size * (# column families))</code></p></li><li class="listitem"><p>HBase 0.94.x:<code class="code">((RS Xmx) * hbase.regionserver.global.memstore.upperLimit) /
                (hbase.hregion.memstore.flush.size * (# column families))</code></p></li></ul></div><p>If a given RegionServer has 16 GB of RAM, with default settings, the formula works out
          to 16384*0.4/128 ~ 51 regions per RS is a starting point. The formula can be extended to
          multiple tables; if they all have the same configuration, just use the total number of
          families.</p><p>This number can be adjusted; the formula above assumes all your regions are filled at
          approximately the same rate. If only a fraction of your regions are going to be actively
          written to, you can divide the result by that fraction to get a larger region count. Then,
          even if all regions are written to, all region memstores are not filled evenly, and
          eventually jitter appears even if they are (due to limited number of concurrent flushes).
          Thus, one can have as many as 2-3 times more regions than the starting point; however,
          increased numbers carry increased risk.</p><p>For write-heavy workload, memstore fraction can be increased in configuration at the
          expense of block cache; this will also allow one to have more regions.</p></div><div class="section" title="17.9.2.3.&nbsp;Number of regions per RS - lower bound"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.regions.mincount"></a>17.9.2.3.&nbsp;Number of regions per RS - lower bound</h4></div></div></div><p>HBase scales by having regions across many servers. Thus if you have 2 regions for
          16GB data, on a 20 node machine your data will be concentrated on just a few machines -
          nearly the entire cluster will be idle. This really can't be stressed enough, since a
          common problem is loading 200MB data into HBase and then wondering why your awesome 10
          node cluster isn't doing anything.</p><p>On the other hand, if you have a very large amount of data, you may also want to go
          for a larger number of regions to avoid having regions that are too large.</p></div><div class="section" title="17.9.2.4.&nbsp;Maximum region size"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.regions.size"></a>17.9.2.4.&nbsp;Maximum region size</h4></div></div></div><p>For large tables in production scenarios, maximum region size is mostly limited by
          compactions - very large compactions, esp. major, can degrade cluster performance.
          Currently, the recommended maximum region size is 10-20Gb, and 5-10Gb is optimal. For
          older 0.90.x codebase, the upper-bound of regionsize is about 4Gb, with a default of
          256Mb.</p><p>The size at which the region is split into two is generally configured via <a class="xref" href="#hbase.hregion.max.filesize" title="hbase.hregion.max.filesize"><code class="varname">hbase.hregion.max.filesize</code></a>; for details, see <a class="xref" href="#arch.region.splits" title="9.7.4.&nbsp;Region Splits">Section&nbsp;9.7.4, &#8220;Region Splits&#8221;</a>.</p><p>If you cannot estimate the size of your tables well, when starting off, it's probably
          best to stick to the default region size, perhaps going smaller for hot tables (or
          manually split hot regions to spread the load over the cluster), or go with larger region
          sizes if your cell sizes tend to be largish (100k and up).</p><p>In HBase 0.98, experimental stripe compactions feature was added that would allow for
          larger regions, especially for log data. See <a class="xref" href="#ops.stripe" title="9.7.7.7.3.&nbsp;Experimental: Stripe Compactions">Section&nbsp;9.7.7.7.3, &#8220;Experimental: Stripe Compactions&#8221;</a>.</p></div><div class="section" title="17.9.2.5.&nbsp;Total data size per region server"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.regions.total"></a>17.9.2.5.&nbsp;Total data size per region server</h4></div></div></div><p>According to above numbers for region size and number of regions per region server, in
          an optimistic estimate 10 GB x 100 regions per RS will give up to 1TB served per region
          server, which is in line with some of the reported multi-PB use cases. However, it is
          important to think about the data vs cache size ratio at the RS level. With 1TB of data
          per server and 10 GB block cache, only 1% of the data will be cached, which may barely
          cover all block indices.</p></div></div><div class="section" title="17.9.3.&nbsp;Initial configuration and tuning"><div class="titlepage"><div><div><h3 class="title"><a name="ops.capacity.config"></a>17.9.3.&nbsp;Initial configuration and tuning</h3></div></div></div><p>First, see <a class="xref" href="#important_configurations" title="2.6.&nbsp;The Important Configurations">Section&nbsp;2.6, &#8220;The Important Configurations&#8221;</a>. Note that some configurations, more than others,
        depend on specific scenarios. Pay special attention to:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="xref" href="#hbase.regionserver.handler.count" title="hbase.regionserver.handler.count"><code class="varname">hbase.regionserver.handler.count</code></a> - request handler thread count, vital
            for high-throughput workloads.</p></li><li class="listitem"><p><a class="xref" href="#config.wals" title="2.6.2.6.&nbsp;Configuring the size and number of WAL files">Section&nbsp;2.6.2.6, &#8220;Configuring the size and number of WAL files&#8221;</a> - the blocking number of WAL files depends on your memstore
            configuration and should be set accordingly to prevent potential blocking when doing
            high volume of writes.</p></li></ul></div><p>Then, there are some considerations when setting up your cluster and tables.</p><div class="section" title="17.9.3.1.&nbsp;Compactions"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.config.compactions"></a>17.9.3.1.&nbsp;Compactions</h4></div></div></div><p>Depending on read/write volume and latency requirements, optimal compaction settings
          may be different. See <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a> for some details.</p><p>When provisioning for large data sizes, however, it's good to keep in mind that
          compactions can affect write throughput. Thus, for write-intensive workloads, you may opt
          for less frequent compactions and more store files per regions. Minimum number of files
          for compactions (<code class="varname">hbase.hstore.compaction.min</code>) can be set to higher
          value; <a class="xref" href="#hbase.hstore.blockingStoreFiles" title="hbase.hstore.blockingStoreFiles"><code class="varname">hbase.hstore.blockingStoreFiles</code></a> should also be increased, as more files
          might accumulate in such case. You may also consider manually managing compactions: <a class="xref" href="#managed.compactions" title="2.6.2.8.&nbsp;Managed Compactions">Section&nbsp;2.6.2.8, &#8220;Managed Compactions&#8221;</a></p></div><div class="section" title="17.9.3.2.&nbsp;Pre-splitting the table"><div class="titlepage"><div><div><h4 class="title"><a name="ops.capacity.config.presplit"></a>17.9.3.2.&nbsp;Pre-splitting the table</h4></div></div></div><p>Based on the target number of the regions per RS (see <a class="xref" href="#ops.capacity.regions.count" title="17.9.2.2.&nbsp;Number of regions per RS - upper bound">above</a>) and number of RSes, one can pre-split the table at
          creation time. This would both avoid some costly splitting as the table starts to fill up,
          and ensure that the table starts out already distributed across many servers.</p><p>If the table is expected to grow large enough to justify that, at least one region per
          RS should be created. It is not recommended to split immediately into the full target
          number of regions (e.g. 50 * number of RSes), but a low intermediate value can be chosen.
          For multiple tables, it is recommended to be conservative with presplitting (e.g.
          pre-split 1 region per RS at most), especially if you don't know how much each table will
          grow. If you split too much, you may end up with too many regions, with some tables having
          too many small regions.</p><p>For pre-splitting howto, see <a class="xref" href="#manual_region_splitting_decisions" title="9.7.5.&nbsp;Manual Region Splitting">Section&nbsp;9.7.5, &#8220;Manual Region Splitting&#8221;</a> and
            <a class="xref" href="#precreate.regions" title="14.8.2.&nbsp; Table Creation: Pre-Creating Regions">Section&nbsp;14.8.2, &#8220; Table Creation: Pre-Creating Regions &#8221;</a>.</p></div></div></div><div class="section" title="17.10.&nbsp;Table Rename"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="table.rename"></a>17.10.&nbsp;Table Rename</h2></div></div></div><p>In versions 0.90.x of hbase and earlier, we had a simple script that would rename the hdfs
      table directory and then do an edit of the hbase:meta table replacing all mentions of the old
      table name with the new. The script was called <span class="command"><strong>./bin/rename_table.rb</strong></span>. The
      script was deprecated and removed mostly because it was unmaintained and the operation
      performed by the script was brutal. </p><p> As of hbase 0.94.x, you can use the snapshot facility renaming a table. Here is how you
      would do it using the hbase shell:</p><pre class="screen">hbase shell&gt; disable 'tableName'
hbase shell&gt; snapshot 'tableName', 'tableSnapshot'
hbase shell&gt; clone_snapshot 'tableSnapshot', 'newTableName'
hbase shell&gt; delete_snapshot 'tableSnapshot'
hbase shell&gt; drop 'tableName'</pre><p>or in code it would be as follows:</p><pre class="programlisting">void rename(HBaseAdmin admin, String oldTableName, String newTableName) {
  String snapshotName = randomName();
  admin.disableTable(oldTableName);
  admin.snapshot(snapshotName, oldTableName);
  admin.cloneSnapshot(snapshotName, newTableName);
  admin.deleteSnapshot(snapshotName);
  admin.deleteTable(oldTableName);
}</pre></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d2875e18027" href="#d2875e18027" class="para">1</a>] </sup>The Metrics system was redone in
          HBase 0.96. See <a class="link" href="https://blogs.apache.org/hbase/entry/migration_to_the_new_metrics" target="_top">Migration
            to the New Metrics Hotness &#8211; Metrics2</a> by Elliot Clark for detail</p></div></div></div><div class="chapter" title="Chapter&nbsp;18.&nbsp;Building and Developing Apache HBase"><div class="titlepage"><div><div><h2 class="title"><a name="developer"></a>Chapter&nbsp;18.&nbsp;Building and Developing Apache HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#getting.involved">18.1. Getting Involved</a></span></dt><dd><dl><dt><span class="section"><a href="#mailing.list">18.1.1. Mailing Lists</a></span></dt><dt><span class="section"><a href="#irc">18.1.2. Internet Relay Chat (IRC)</a></span></dt><dt><span class="section"><a href="#jira">18.1.3. Jira</a></span></dt></dl></dd><dt><span class="section"><a href="#repos">18.2. Apache HBase Repositories</a></span></dt><dt><span class="section"><a href="#ides">18.3. IDEs</a></span></dt><dd><dl><dt><span class="section"><a href="#eclipse">18.3.1. Eclipse</a></span></dt><dt><span class="section"><a href="#d2875e19785">18.3.2. IntelliJ IDEA</a></span></dt><dt><span class="section"><a href="#d2875e19822">18.3.3. Other IDEs</a></span></dt></dl></dd><dt><span class="section"><a href="#build">18.4. Building Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#build.basic">18.4.1. Basic Compile</a></span></dt></dl></dd><dt><span class="section"><a href="#releasing">18.5. Releasing Apache HBase</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e20056">18.5.1. Building against HBase 0.96-0.98</a></span></dt><dt><span class="section"><a href="#maven.release">18.5.2. Making a Release Candidate</a></span></dt><dt><span class="section"><a href="#maven.snapshot">18.5.3. Publishing a SNAPSHOT to maven</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.rc.voting">18.6. Voting on Release Candidates</a></span></dt><dt><span class="section"><a href="#documentation">18.7. Generating the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#hbase.org">18.8. Updating hbase.apache.org</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.org.site.contributing">18.8.1. Contributing to hbase.apache.org</a></span></dt><dt><span class="section"><a href="#hbase.org.site.publishing">18.8.2. Publishing hbase.apache.org</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.tests">18.9. Tests</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.moduletests">18.9.1. Apache HBase Modules</a></span></dt><dt><span class="section"><a href="#hbase.unittests">18.9.2. Unit Tests</a></span></dt><dt><span class="section"><a href="#hbase.unittests.cmds">18.9.3. Running tests</a></span></dt><dt><span class="section"><a href="#hbase.tests.writing">18.9.4. Writing Tests</a></span></dt><dt><span class="section"><a href="#integration.tests">18.9.5. Integration Tests</a></span></dt></dl></dd><dt><span class="section"><a href="#developing">18.10. Developer Guidelines</a></span></dt><dd><dl><dt><span class="section"><a href="#codelines">18.10.1. Codelines</a></span></dt><dt><span class="section"><a href="#d2875e21113">18.10.2. Release Managers</a></span></dt><dt><span class="section"><a href="#code.standards">18.10.3. Code Standards</a></span></dt><dt><span class="section"><a href="#design.invariants">18.10.4. Invariants</a></span></dt><dt><span class="section"><a href="#run.insitu">18.10.5. Running In-Situ</a></span></dt><dt><span class="section"><a href="#add.metrics">18.10.6. Adding Metrics</a></span></dt><dt><span class="section"><a href="#git.best.practices">18.10.7. Git Best Practices</a></span></dt><dt><span class="section"><a href="#submitting.patches">18.10.8. Submitting Patches</a></span></dt></dl></dd></dl></div><p>This chapter contains information and guidelines for building and releasing HBase code and
        documentation. Being familiar with these guidelines will help the HBase committers to use
        your contributions more easily.</p><div class="section" title="18.1.&nbsp;Getting Involved"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="getting.involved"></a>18.1.&nbsp;Getting Involved</h2></div></div></div><p>Apache HBase gets better only when people contribute! If you are looking to contribute
            to Apache HBase, look for <a class="link" href="https://issues.apache.org/jira/issues/?jql=project%20%3D%20HBASE%20AND%20labels%20in%20(beginner)" target="_top">issues in JIRA tagged with the label 'beginner'</a>. These are issues HBase
            contributors have deemed worthy but not of immediate priority and a good way to ramp on
            HBase internals. See <a class="link" href="http://search-hadoop.com/m/DHED43re96" target="_top">What label
                is used for issues that are good on ramps for new contributors?</a> from the dev
            mailing list for background.</p><p>Before you get started submitting code to HBase, please refer to <a class="xref" href="#developing" title="18.10.&nbsp;Developer Guidelines">Section&nbsp;18.10, &#8220;Developer Guidelines&#8221;</a>.</p><p>As Apache HBase is an Apache Software Foundation project, see <a class="xref" href="#asf" title="Appendix&nbsp;K.&nbsp;HBase and the Apache Software Foundation">Appendix&nbsp;K, <i>HBase and the Apache Software Foundation</i></a>
            for more information about how the ASF functions. </p><div class="section" title="18.1.1.&nbsp;Mailing Lists"><div class="titlepage"><div><div><h3 class="title"><a name="mailing.list"></a>18.1.1.&nbsp;Mailing Lists</h3></div></div></div><p>Sign up for the dev-list and the user-list.  See the
                <a class="link" href="http://hbase.apache.org/mail-lists.html" target="_top">mailing lists</a> page.
                Posing questions - and helping to answer other people's questions - is encouraged!
                There are varying levels of experience on both lists so patience and politeness are encouraged (and please
                stay on topic.)
            </p></div><div class="section" title="18.1.2.&nbsp;Internet Relay Chat (IRC)"><div class="titlepage"><div><div><h3 class="title"><a name="irc"></a>18.1.2.&nbsp;Internet Relay Chat (IRC)</h3></div></div></div><p>For real-time questions and discussions, use the <code class="literal">#hbase</code> IRC
                channel on the <a class="link" href="https://freenode.net/" target="_top">FreeNode</a> IRC network.
                FreeNode offers a web-based client, but most people prefer a native client, and
                several clients are available for each operating system.</p></div><div class="section" title="18.1.3.&nbsp;Jira"><div class="titlepage"><div><div><h3 class="title"><a name="jira"></a>18.1.3.&nbsp;Jira</h3></div></div></div><p>Check for existing issues in <a class="link" href="https://issues.apache.org/jira/browse/HBASE" target="_top">Jira</a>. If it's
                either a new feature request, enhancement, or a bug, file a ticket. </p><p>To check for existing issues which you can tackle as a beginner, search for <a class="link" href="https://issues.apache.org/jira/issues/?jql=project%20%3D%20HBASE%20AND%20labels%20in%20(beginner)" target="_top">issues in JIRA tagged with the label 'beginner'</a>.</p><div class="itemizedlist" title="JIRA Priorities"><a name="jira.priorities"></a><p class="title"><b>JIRA Priorities</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Blocker: Should only be used if the issue WILL cause data loss or cluster
                        instability reliably.</p></li><li class="listitem"><p>Critical: The issue described can cause data loss or cluster instability
                        in some cases.</p></li><li class="listitem"><p>Major: Important but not tragic issues, like updates to the client API
                        that will add a lot of much-needed functionality or significant bugs that
                        need to be fixed but that don't cause data loss.</p></li><li class="listitem"><p>Minor: Useful enhancements and annoying but not damaging bugs.</p></li><li class="listitem"><p>Trivial: Useful enhancements but generally cosmetic.</p></li></ul></div><div class="example"><a name="submitting.patches.jira.code"></a><p class="title"><b>Example&nbsp;18.1.&nbsp;Code Blocks in Jira Comments</b></p><div class="example-contents"><p>A commonly used macro in Jira is {code}. Everything inside the tags is
                    preformatted, as in this example.</p><pre class="programlisting">
{code}
code snippet
{code}
            </pre></div></div><br class="example-break"></div></div><div class="section" title="18.2.&nbsp;Apache HBase Repositories"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="repos"></a>18.2.&nbsp;Apache HBase Repositories</h2></div></div></div><p>There are two different repositories for Apache HBase: Subversion (SVN) and Git. GIT
            is our repository of record for all but the Apache HBase website. We used to be on SVN.
            We migrated. See <a class="link" href="https://issues.apache.org/jira/browse/INFRA-7768" target="_top">Migrate Apache HBase SVN Repos to Git</a>. Updating hbase.apache.org still
            requires use of SVN (See <a class="xref" href="#hbase.org" title="18.8.&nbsp;Updating hbase.apache.org">Section&nbsp;18.8, &#8220;Updating hbase.apache.org&#8221;</a>). See <a class="link" href="http://hbase.apache.org/source-repository.html" target="_top">Source Code
                Management</a> page for contributor and committer links or seach for HBase on the
                <a class="link" href="http://git.apache.org/" target="_top">Apache Git</a> page.</p></div><div class="section" title="18.3.&nbsp;IDEs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ides"></a>18.3.&nbsp;IDEs</h2></div></div></div><div class="section" title="18.3.1.&nbsp;Eclipse"><div class="titlepage"><div><div><h3 class="title"><a name="eclipse"></a>18.3.1.&nbsp;Eclipse</h3></div></div></div><div class="section" title="18.3.1.1.&nbsp;Code Formatting"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.code.formatting"></a>18.3.1.1.&nbsp;Code Formatting</h4></div></div></div><p>Under the <code class="filename">dev-support/</code> folder, you will find
                        <code class="filename">hbase_eclipse_formatter.xml</code>. We encourage you to have
                    this formatter in place in eclipse when editing HBase code.</p><div class="procedure" title="Procedure&nbsp;18.1.&nbsp;Load the HBase Formatter Into Eclipse"><a name="d2875e19579"></a><p class="title"><b>Procedure&nbsp;18.1.&nbsp;Load the HBase Formatter Into Eclipse</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Open the <span class="guimenu">Eclipse</span> &#8594; <span class="guimenuitem">Preferences</span> menu item.</p></li><li class="step" title="Step 2"><p>In Preferences, click the <span class="guimenu">Java</span> &#8594; <span class="guisubmenu">Code Style</span> &#8594; <span class="guimenuitem">Formatter</span> menu item.</p></li><li class="step" title="Step 3"><p>Click <span class="guibutton">Import</span> and browse to the location of the
                                <code class="filename">hbase_eclipse_formatter.xml</code> file, which is in
                            the <code class="filename">dev-support/</code> directory. Click
                                <span class="guibutton">Apply</span>.</p></li><li class="step" title="Step 4"><p>Still in Preferences, click <span class="guimenu">Java Editor</span> &#8594; <span class="guimenuitem">Save Actions</span>. Be sure the following options are selected:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Perform the selected actions on save</p></li><li class="listitem"><p>Format source code</p></li><li class="listitem"><p>Format edited lines</p></li></ul></div><p>Click <span class="guibutton">Apply</span>. Close all dialog boxes and return
                            to the main window.</p></li></ol></div><p>In addition to the automatic formatting, make sure you follow the style
                    guidelines explained in <a class="xref" href="#common.patch.feedback" title="18.10.3.2.&nbsp;Code Formatting Conventions">Section&nbsp;18.10.3.2, &#8220;Code Formatting Conventions&#8221;</a></p><p>Also, no <code class="code">@author</code> tags - that's a rule. Quality Javadoc comments
                    are appreciated. And include the Apache license.</p></div><div class="section" title="18.3.1.2.&nbsp;Eclipse Git Plugin"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.git.plugin"></a>18.3.1.2.&nbsp;Eclipse Git Plugin</h4></div></div></div><p>If you cloned the project via git, download and install the Git plugin (EGit).
                    Attach to your local git repo (via the <span class="guilabel">Git Repositories</span>
                    window) and you'll be able to see file revision history, generate patches,
                    etc.</p></div><div class="section" title="18.3.1.3.&nbsp;HBase Project Setup in Eclipse using m2eclipse"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.maven.setup"></a>18.3.1.3.&nbsp;HBase Project Setup in Eclipse using <code class="code">m2eclipse</code></h4></div></div></div><p>The easiest way is to use the <span class="command"><strong>m2eclipse</strong></span> plugin for Eclipse.
                    Eclipse Indigo or newer includes <span class="command"><strong>m2eclipse</strong></span>, or you can
                    download it from <a class="link" href="http://www.eclipse.org/m2e/" target="_top">http://www.eclipse.org/m2e/</a>/. It provides Maven integration for
                    Eclipse, and even lets you use the direct Maven commands from within Eclipse to
                    compile and test your project.</p><p>To import the project, click <span class="guimenu">File</span> &#8594; <span class="guisubmenu">Import</span> &#8594; <span class="guisubmenu">Maven</span> &#8594; <span class="guimenuitem">Existing Maven Projects</span> and select the HBase root directory. <code class="code">m2eclipse</code>
                    locates all the hbase modules for you.</p><p>If you install <span class="command"><strong>m2eclipse</strong></span> and import HBase in your
                    workspace, do the following to fix your eclipse Build Path. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Remove <code class="filename">target</code> folder</p></li><li class="listitem"><p>Add <code class="filename">target/generated-jamon</code> and
                                <code class="filename">target/generated-sources/java</code> folders.</p></li><li class="listitem"><p>Remove from your Build Path the exclusions on the
                                <code class="filename">src/main/resources</code> and
                                <code class="filename">src/test/resources</code> to avoid error message in
                            the console, such as the following:</p><pre class="screen">Failed to execute goal 
org.apache.maven.plugins:maven-antrun-plugin:1.6:run (default) on project hbase:
'An Ant BuildException has occured: Replace: source file .../target/classes/hbase-default.xml 
doesn't exist</pre><p>This will also reduce the eclipse build cycles and make your life
                            easier when developing. </p></li></ol></div></div><div class="section" title="18.3.1.4.&nbsp;HBase Project Setup in Eclipse Using the Command Line"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.commandline"></a>18.3.1.4.&nbsp;HBase Project Setup in Eclipse Using the Command Line</h4></div></div></div><p>Instead of using <code class="code">m2eclipse</code>, you can generate the Eclipse files
                    from the command line. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>First, run the following command, which builds HBase. You only need to
                            do this once.</p><pre class="programlisting">mvn clean install -DskipTests</pre></li><li class="listitem"><p>Close Eclipse, and execute the following command from the terminal, in
                            your local HBase project directory, to generate new
                                <code class="filename">.project</code> and <code class="filename">.classpath</code>
                            files.</p><pre class="programlisting">mvn eclipse:eclipse</pre></li><li class="listitem"><p>Reopen Eclipse and import the <code class="filename">.project</code> file in
                            the HBase directory to a workspace.</p></li></ol></div></div><div class="section" title="18.3.1.5.&nbsp;Maven Classpath Variable"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.maven.class"></a>18.3.1.5.&nbsp;Maven Classpath Variable</h4></div></div></div><p>The <code class="varname">$M2_REPO</code> classpath variable needs to be set up for the
                    project. This needs to be set to your local Maven repository, which is usually
                        <code class="filename">~/.m2/repository</code></p><p>If this classpath variable is not configured, you will see compile errors in
                    Eclipse like this: </p><pre class="screen">
Description	Resource	Path	Location	Type
The project cannot be built until build path errors are resolved	hbase		Unknown	Java Problem
Unbound classpath variable: 'M2_REPO/asm/asm/3.1/asm-3.1.jar' in project 'hbase'	hbase		Build path	Build Path Problem
Unbound classpath variable: 'M2_REPO/com/google/guava/guava/r09/guava-r09.jar' in project 'hbase'	hbase		Build path	Build Path Problem
Unbound classpath variable: 'M2_REPO/com/google/protobuf/protobuf-java/2.3.0/protobuf-java-2.3.0.jar' in project 'hbase'	hbase		Build path	Build Path Problem Unbound classpath variable:
                </pre></div><div class="section" title="18.3.1.6.&nbsp;Eclipse Known Issues"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.issues"></a>18.3.1.6.&nbsp;Eclipse Known Issues</h4></div></div></div><p>Eclipse will currently complain about <code class="filename">Bytes.java</code>. It is
                    not possible to turn these errors off.</p><pre class="screen">
Description	Resource	Path	Location	Type
Access restriction: The method arrayBaseOffset(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar	Bytes.java	/hbase/src/main/java/org/apache/hadoop/hbase/util	line 1061	Java Problem
Access restriction: The method arrayIndexScale(Class) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar	Bytes.java	/hbase/src/main/java/org/apache/hadoop/hbase/util	line 1064	Java Problem
Access restriction: The method getLong(Object, long) from the type Unsafe is not accessible due to restriction on required library /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Classes/classes.jar	Bytes.java	/hbase/src/main/java/org/apache/hadoop/hbase/util	line 1111	Java Problem
             </pre></div><div class="section" title="18.3.1.7.&nbsp;Eclipse - More Information"><div class="titlepage"><div><div><h4 class="title"><a name="eclipse.more"></a>18.3.1.7.&nbsp;Eclipse - More Information</h4></div></div></div><p>For additional information on setting up Eclipse for HBase development on
                    Windows, see <a class="link" href="http://michaelmorello.blogspot.com/2011/09/hbase-subversion-eclipse-windows.html" target="_top">Michael Morello's blog</a> on the topic. </p></div></div><div class="section" title="18.3.2.&nbsp;IntelliJ IDEA"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e19785"></a>18.3.2.&nbsp;IntelliJ IDEA</h3></div></div></div><p>You can set up IntelliJ IDEA for similar functinoality as Eclipse. Follow these steps.</p><div class="orderedlist" title="Project Setup in IntelliJ IDEA"><p class="title"><b>Project Setup in IntelliJ IDEA</b></p><ol class="orderedlist" type="1"><li class="listitem"><p>Select <span class="guimenu">Import Project</span> &#8594; <span class="guisubmenu">Import Project From External Model</span> &#8594; <span class="guimenuitem">Maven</span></p></li><li class="listitem"><p>You do not need to select a profile. Be sure <span class="guilabel">Maven project
                            required</span> is selected, and click
                        <span class="guibutton">Next</span>.</p></li><li class="listitem"><p>Select the location for the JDK.</p></li></ol></div><p title="Using the HBase Formatter in IntelliJ IDEA"><b>Using the HBase Formatter in IntelliJ IDEA.&nbsp;</b>Using the Eclipse Code Formatter plugin for IntelliJ IDEA, you can import the
                    HBase code formatter described in <a class="xref" href="#eclipse.code.formatting" title="18.3.1.1.&nbsp;Code Formatting">Section&nbsp;18.3.1.1, &#8220;Code Formatting&#8221;</a>.</p></div><div class="section" title="18.3.3.&nbsp;Other IDEs"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e19822"></a>18.3.3.&nbsp;Other IDEs</h3></div></div></div><p>It would be userful to mirror the <a class="xref" href="#eclipse" title="18.3.1.&nbsp;Eclipse">Section&nbsp;18.3.1, &#8220;Eclipse&#8221;</a> set-up instructions
                for other IDEs. If you would like to assist, please have a look at <a class="link" href="https://issues.apache.org/jira/browse/HBASE-11704" target="_top">HBASE-11704</a>.</p></div></div><div class="section" title="18.4.&nbsp;Building Apache HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="build"></a>18.4.&nbsp;Building Apache HBase</h2></div></div></div><div class="section" title="18.4.1.&nbsp;Basic Compile"><div class="titlepage"><div><div><h3 class="title"><a name="build.basic"></a>18.4.1.&nbsp;Basic Compile</h3></div></div></div><p>HBase is compiled using Maven. You must use Maven 3.x. To check your Maven
                version, run the command <span class="command"><strong>mvn -version</strong></span>.</p><div class="note" title="JDK Version Requirements" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">JDK Version Requirements</h3><p> Starting with HBase 1.0 you must use Java 7 or later to build from source
                    code. See <a class="xref" href="#java" title="Table&nbsp;2.1.&nbsp;Java">Table&nbsp;2.1, &#8220;Java&#8221;</a> for more complete information about supported
                    JDK versions. </p></div><div class="section" title="18.4.1.1.&nbsp;Maven Build Commands"><div class="titlepage"><div><div><h4 class="title"><a name="maven.build.commands"></a>18.4.1.1.&nbsp;Maven Build Commands</h4></div></div></div><p>All commands are executed from the local HBase project directory. </p><div class="section" title="18.4.1.1.1.&nbsp;Package"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e19855"></a>18.4.1.1.1.&nbsp;Package</h5></div></div></div><p>The simplest command to compile HBase from its java source code is to use
                        the <code class="code">package</code> target, which builds JARs with the compiled
                        files.</p><pre class="programlisting">mvn package -DskipTests</pre><p>Or, to clean up before compiling:</p><pre class="programlisting">mvn clean package -DskipTests</pre><p>With Eclipse set up as explained above in <a class="xref" href="#eclipse" title="18.3.1.&nbsp;Eclipse">Section&nbsp;18.3.1, &#8220;Eclipse&#8221;</a>, you
                        can also use the <span class="guimenu">Build</span> command in Eclipse. To create the
                        full installable HBase package takes a little bit more work, so read on.
                    </p></div><div class="section" title="18.4.1.1.2.&nbsp;Compile"><div class="titlepage"><div><div><h5 class="title"><a name="maven.build.commands.compile"></a>18.4.1.1.2.&nbsp;Compile</h5></div></div></div><p>The <code class="code">compile</code> target does not create the JARs with the compiled
                        files.</p><pre class="programlisting">mvn compile</pre><pre class="programlisting">mvn clean compile</pre></div><div class="section" title="18.4.1.1.3.&nbsp;Install"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e19888"></a>18.4.1.1.3.&nbsp;Install</h5></div></div></div><p>To install the JARs in your <code class="filename">~/.m2/</code> directory, use the
                            <code class="code">install</code> target.</p><pre class="programlisting">mvn install</pre><pre class="programlisting">mvn clean install</pre><pre class="programlisting">mvn clean install -DskipTests</pre></div></div><div class="section" title="18.4.1.2.&nbsp;Running all or individual Unit Tests"><div class="titlepage"><div><div><h4 class="title"><a name="maven.build.commands.unitall"></a>18.4.1.2.&nbsp;Running all or individual Unit Tests</h4></div></div></div><p>See the <a class="xref" href="#hbase.unittests.cmds" title="18.9.3.&nbsp;Running tests">Section&nbsp;18.9.3, &#8220;Running tests&#8221;</a> section in <a class="xref" href="#hbase.unittests" title="18.9.2.&nbsp;Unit Tests">Section&nbsp;18.9.2, &#8220;Unit Tests&#8221;</a></p></div><div class="section" title="18.4.1.3.&nbsp;Building against various hadoop versions."><div class="titlepage"><div><div><h4 class="title"><a name="maven.build.hadoop"></a>18.4.1.3.&nbsp;Building against various hadoop versions.</h4></div></div></div><p>As of 0.96, Apache HBase supports building against Apache Hadoop versions:
                    1.0.3, 2.0.0-alpha and 3.0.0-SNAPSHOT. By default, in 0.96 and earlier, we will
                    build with Hadoop-1.0.x. As of 0.98, Hadoop 1.x is deprecated and Hadoop 2.x is
                    the default. To change the version to build against, add a hadoop.profile
                    property when you invoke <span class="command"><strong>mvn</strong></span>:</p><pre class="programlisting">mvn -Dhadoop.profile=1.0 ...</pre><p> The above will build against whatever explicit hadoop 1.x version we have in
                    our <code class="filename">pom.xml</code> as our '1.0' version. Tests may not all pass so
                    you may need to pass <code class="code">-DskipTests</code> unless you are inclined to fix the
                    failing tests.</p><div class="note" title="'dependencyManagement.dependencies.dependency.artifactId' for org.apache.hbase:${compat.module}:test-jar with value '${compat.module}' does not match a valid id pattern" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="maven.build.passing.default.profile"></a>'dependencyManagement.dependencies.dependency.artifactId' for
                        org.apache.hbase:${compat.module}:test-jar with value '${compat.module}'
                        does not match a valid id pattern</h3><p>You will see ERRORs like the above title if you pass the
                            <span class="emphasis"><em>default</em></span> profile; e.g. if you pass
                            <span class="property">hadoop.profile=1.1</span> when building 0.96 or
                            <span class="property">hadoop.profile=2.0</span> when building hadoop 0.98; just
                        drop the hadoop.profile stipulation in this case to get your build to run
                        again. This seems to be a maven pecularity that is probably fixable but
                        we've not spent the time trying to figure it.</p></div><p> Similarly, for 3.0, you would just replace the profile value. Note that
                    Hadoop-3.0.0-SNAPSHOT does not currently have a deployed maven artificat - you
                    will need to build and install your own in your local maven repository if you
                    want to run against this profile. </p><p> In earilier versions of Apache HBase, you can build against older versions of
                    Apache Hadoop, notably, Hadoop 0.22.x and 0.23.x. If you are running, for
                    example HBase-0.94 and wanted to build against Hadoop 0.23.x, you would run
                    with:</p><pre class="programlisting">mvn -Dhadoop.profile=22 ...</pre></div><div class="section" title="18.4.1.4.&nbsp;Build Protobuf"><div class="titlepage"><div><div><h4 class="title"><a name="build.protobuf"></a>18.4.1.4.&nbsp;Build Protobuf</h4></div></div></div><p>You may need to change the protobuf definitions that reside in the
                        <code class="filename">hbase-protocol</code> module or other modules.</p><p> The protobuf files are located in
                        <code class="filename">hbase-protocol/src/main/protobuf</code>. For the change to be
                    effective, you will need to regenerate the classes. You can use maven profile
                        <code class="code">compile-protobuf</code> to do this.</p><pre class="programlisting">mvn compile -Pcompile-protobuf</pre><p>You may also want to define <code class="varname">protoc.path</code> for the protoc
                    binary, using the following command:</p><pre class="programlisting">
mvn compile -Pcompile-protobuf -Dprotoc.path=/opt/local/bin/protoc
             </pre><p>Read the <code class="filename">hbase-protocol/README.txt</code> for more details.
                </p></div><div class="section" title="18.4.1.5.&nbsp;Build Thrift"><div class="titlepage"><div><div><h4 class="title"><a name="build.thrift"></a>18.4.1.5.&nbsp;Build Thrift</h4></div></div></div><p>You may need to change the thrift definitions that reside in the
                  <code class="filename">hbase-thrift</code> module or other modules.</p><p>The thrift files are located in
                  <code class="filename">hbase-thrift/src/main/resources</code>.
                  For the change to be effective, you will need to regenerate the classes.
                  You can use maven profile  <code class="code">compile-thrift</code> to do this.</p><pre class="programlisting">mvn compile -Pcompile-thrift</pre><p>You may also want to define <code class="varname">thrift.path</code> for the thrift
                  binary, using the following command:</p><pre class="programlisting">
                  mvn compile -Pcompile-thrift -Dthrift.path=/opt/local/bin/thrift
                </pre></div><div class="section" title="18.4.1.6.&nbsp;Build a Tarball"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e20006"></a>18.4.1.6.&nbsp;Build a Tarball</h4></div></div></div><p>You can build a tarball without going through the release process described in
                        <a class="xref" href="#releasing" title="18.5.&nbsp;Releasing Apache HBase">Section&nbsp;18.5, &#8220;Releasing Apache HBase&#8221;</a>, by running the following command:</p><pre class="screen">mvn -DskipTests clean install &amp;&amp; mvn -DskipTests package assembly:single</pre><p>The distribution tarball is built in
                            <code class="filename">hbase-assembly/target/hbase-<em class="replaceable"><code>&lt;version&gt;</code></em>-bin.tar.gz</code>.</p></div><div class="section" title="18.4.1.7.&nbsp;Build Gotchas"><div class="titlepage"><div><div><h4 class="title"><a name="build.gotchas"></a>18.4.1.7.&nbsp;Build Gotchas</h4></div></div></div><p>If you see <code class="code">Unable to find resource 'VM_global_library.vm'</code>, ignore
                    it. Its not an error. It is <a class="link" href="http://jira.codehaus.org/browse/MSITE-286" target="_top">officially
                        ugly</a> though. </p></div><div class="section" title="18.4.1.8.&nbsp;Building in snappy compression support"><div class="titlepage"><div><div><h4 class="title"><a name="build.snappy"></a>18.4.1.8.&nbsp;Building in snappy compression support</h4></div></div></div><p>Pass <code class="code">-Psnappy</code> to trigger the <code class="code">hadoop-snappy</code> maven profile
                    for building Google Snappy native libraries into HBase. See also <a class="xref" href="#snappy.compression.installation" title="E.3.1.5.&nbsp;Install Snappy Support">Section&nbsp;E.3.1.5, &#8220;Install Snappy Support&#8221;</a></p></div></div></div><div class="section" title="18.5.&nbsp;Releasing Apache HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="releasing"></a>18.5.&nbsp;Releasing Apache HBase</h2></div></div></div><div class="note" title="Building against HBase 1.x" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Building against HBase 1.x</h3><p>HBase 1.x requires Java 7 to build. See <a class="xref" href="#java" title="Table&nbsp;2.1.&nbsp;Java">Table&nbsp;2.1, &#8220;Java&#8221;</a> for Java
                requirements per HBase release.</p></div><div class="section" title="18.5.1.&nbsp;Building against HBase 0.96-0.98"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e20056"></a>18.5.1.&nbsp;Building against HBase 0.96-0.98</h3></div></div></div><p>HBase 0.96.x will run on Hadoop 1.x or Hadoop 2.x. HBase 0.98 still runs on both,
                but HBase 0.98 deprecates use of Hadoop 1. HBase 1.x will <span class="emphasis"><em>not</em></span>
                run on Hadoop 1. In the following procedures, we make a distinction between HBase
                1.x builds and the awkward process involved building HBase 0.96/0.98 for either
                Hadoop 1 or Hadoop 2 targets. </p><p>You must choose which Hadoop to build against. It is not possible to build a
                single HBase binary that runs against both Hadoop 1 and Hadoop 2. Hadoop is included
                in the build, because it is needed to run HBase in standalone mode. Therefore, the
                set of modules included in the tarball changes, depending on the build target. To
                determine which HBase you have, look at the HBase version. The Hadoop version is
                embedded within it.</p><p>Maven, our build system, natively does not allow a single product to be built
                against different dependencies. Also, Maven cannot change the set of included
                modules and write out the correct <code class="filename">pom.xml</code> files with
                appropriate dependencies, even using two build targets, one for Hadoop 1 and another
                for Hadoop 2. A prerequisite step is required, which takes as input the current
                    <code class="filename">pom.xml</code>s and generates Hadoop 1 or Hadoop 2 versions using
                a script in the <code class="filename">dev-tools/</code> directory, called
                        <code class="filename">generate-hadoop<em class="replaceable"><code>X</code></em>-poms.sh</code>
                where <em class="replaceable"><code>X</code></em> is either <code class="literal">1</code> or
                    <code class="literal">2</code>. You then reference these generated poms when you build.
                For now, just be aware of the difference between HBase 1.x builds and those of HBase
                0.96-0.98. This difference is important to the build instructions.</p><div class="example"><a name="mvn.settings.file"></a><p class="title"><b>Example&nbsp;18.2.&nbsp;Example <code class="filename">~/.m2/settings.xml</code> File</b></p><div class="example-contents"><p>Publishing to maven requires you sign the artifacts you want to upload. For
                    the build to sign them for you, you a properly configured
                        <code class="filename">settings.xml</code> in your local repository under
                        <code class="filename">.m2</code>, such as the following.</p><pre class="programlisting">&lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                      http://maven.apache.org/xsd/settings-1.0.0.xsd"&gt;
  &lt;servers&gt;
    &lt;!- To publish a snapshot of some part of Maven --&gt;
    &lt;server&gt;
      &lt;id&gt;apache.snapshots.https&lt;/id&gt;
      &lt;username&gt;YOUR_APACHE_ID
      &lt;/username&gt;
      &lt;password&gt;YOUR_APACHE_PASSWORD
      &lt;/password&gt;
    &lt;/server&gt;
    &lt;!-- To publish a website using Maven --&gt;
    &lt;!-- To stage a release of some part of Maven --&gt;
    &lt;server&gt;
      &lt;id&gt;apache.releases.https&lt;/id&gt;
      &lt;username&gt;YOUR_APACHE_ID
      &lt;/username&gt;
      &lt;password&gt;YOUR_APACHE_PASSWORD
      &lt;/password&gt;
    &lt;/server&gt;
  &lt;/servers&gt;
  &lt;profiles&gt;
    &lt;profile&gt;
      &lt;id&gt;apache-release&lt;/id&gt;
      &lt;properties&gt;
    &lt;gpg.keyname&gt;YOUR_KEYNAME&lt;/gpg.keyname&gt;
    &lt;!--Keyname is something like this ... 00A5F21E... do gpg --list-keys to find it--&gt;
    &lt;gpg.passphrase&gt;YOUR_KEY_PASSWORD
    &lt;/gpg.passphrase&gt;
      &lt;/properties&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
&lt;/settings&gt;
                </pre></div></div><br class="example-break"></div><div class="section" title="18.5.2.&nbsp;Making a Release Candidate"><div class="titlepage"><div><div><h3 class="title"><a name="maven.release"></a>18.5.2.&nbsp;Making a Release Candidate</h3></div></div></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>These instructions are for building HBase 1.0.x. For building earlier
                    versions, the process is different. See this section under the respective
                    release documentation folders. </p></div><p title="Point Releases"><b>Point Releases.&nbsp;</b>If you are making a point release (for example to quickly address a critical
                    incompatability or security problem) off of a release branch instead of a
                    development branch, the tagging instructions are slightly different. I'll prefix
                    those special steps with <span class="emphasis"><em>Point Release Only</em></span>. </p><p title="Before You Begin"><b>Before You Begin.&nbsp;</b>Before you make a release candidate, do a practice run by deploying a
                    snapshot. Before you start, check to be sure recent builds have been passing for
                    the branch from where you are going to take your release. You should also have
                    tried recent branch tips out on a cluster under load, perhaps by running the
                        <code class="code">hbase-it</code> integration test suite for a few hours to 'burn in'
                    the near-candidate bits. </p><div class="note" title="Point Release Only" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Point Release Only</h3><p>At this point you should tag the previous release branch (ex: 0.96.1) with the
                    new point release tag (e.g. 0.96.1.1 tag). Any commits with changes for the
                    point release should be appled to the new tag. </p></div><p>The Hadoop <a class="link" href="http://wiki.apache.org/hadoop/HowToRelease" target="_top">How To
                    Release</a> wiki page is used as a model for most of the instructions below,
                and may have more detail on particular sections, so it is worth review.</p><div class="note" title="Specifying the Heap Space for Maven on OSX" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Specifying the Heap Space for Maven on OSX</h3><p>On OSX, you may need to specify the heap space for Maven commands, by setting
                    the <code class="varname">MAVEN_OPTS</code> variable to <code class="literal">-Xmx3g</code>. You can
                    prefix the variable to the Maven command, as in the following example:</p><pre class="screen">MAVEN_OPTS="-Xmx2g" mvn package</pre><p>You could also set this in an environment variable or alias in your
                    shell.</p></div><div class="procedure" title="Procedure&nbsp;18.2.&nbsp;Release Procedure"><a name="d2875e20155"></a><p class="title"><b>Procedure&nbsp;18.2.&nbsp;Release Procedure</b></p><p>The script <code class="filename">dev-support/make_rc.sh</code> automates many of these
                    steps. It does not do the modification of the <code class="filename">CHANGES.txt</code>
                    for the release, the close of the staging repository in Apache Maven (human
                    intervention is needed here), the checking of the produced artifacts to ensure
                    they are 'good' -- e.g. extracting the produced tarballs, verifying that they
                    look right, then starting HBase and checking that everything is running
                    correctly, then the signing and pushing of the tarballs to <a class="link" href="http://people.apache.org" target="_top">people.apache.org</a>. The script
                    handles everything else, and comes in handy.</p><ol class="procedure" type="1"><li class="step" title="Update the CHANGES.txt file and the POM files."><p class="title"><b>Update the <code class="filename">CHANGES.txt</code> file and the POM files.</b></p><p>Update <code class="filename">CHANGES.txt</code> with the changes since the last
                        release. Make sure the URL to the JIRA points to the proper location which
                        lists fixes for this release. Adjust the version in all the POM files
                        appropriately. If you are making a release candidate, you must remove the
                            <code class="literal">-SNAPSHOT</code> label from all versions. If you are running
                        this receipe to publish a snapshot, you must keep the
                            <code class="literal">-SNAPSHOT</code> suffix on the hbase version. The <a class="link" href="http://mojo.codehaus.org/versions-maven-plugin/" target="_top">Versions
                            Maven Plugin</a> can be of use here. To set a version in all the many
                        poms of the hbase multi-module project, use a command like the
                        following:</p><pre class="programlisting">
$ mvn clean org.codehaus.mojo:versions-maven-plugin:1.3.1:set -DnewVersion=0.96.0
                    </pre><p>Checkin the <code class="filename">CHANGES.txt</code> and any version
                        changes.</p></li><li class="step" title="Update the documentation."><p class="title"><b>Update the documentation.</b></p><p> Update the documentation under <code class="filename">src/main/docbkx</code>. This
                        usually involves copying the latest from trunk and making version-particular
                        adjustments to suit this release candidate version. </p></li><li class="step" title="Build the source tarball."><p class="title"><b>Build the source tarball.</b></p><p>Now, build the source tarball. This tarball is Hadoop-version-independent.
                        It is just the pure source code and documentation without a particular
                        hadoop taint, etc. Add the <code class="varname">-Prelease</code> profile when
                        building. It checks files for licenses and will fail the build if unlicensed
                        files are present.</p><pre class="programlisting">
$ mvn clean install -DskipTests assembly:single -Dassembly.file=hbase-assembly/src/main/assembly/src.xml -Prelease
                        </pre><p>Extract the tarball and make sure it looks good. A good test for the src
                        tarball being 'complete' is to see if you can build new tarballs from this
                        source bundle. If the source tarball is good, save it off to a
                            <span class="emphasis"><em>version directory</em></span>, a directory somewhere where you
                        are collecting all of the tarballs you will publish as part of the release
                        candidate. For example if you were building a hbase-0.96.0 release
                        candidate, you might call the directory
                        <code class="filename">hbase-0.96.0RC0</code>. Later you will publish this directory
                        as our release candidate up on <a class="link" href="people.apache.org/~YOU" target="_top">people.apache.org/<em class="replaceable"><code>~YOU</code></em>/</a>. </p></li><li class="step" title="Build the binary tarball."><p class="title"><b>Build the binary tarball.</b></p><p>Next, build the binary tarball. Add the <code class="varname">-Prelease</code>
                        profile when building. It checks files for licenses and will fail the build
                        if unlicensed files are present. Do it in two steps.</p><ol type="a" class="substeps"><li class="step" title="Step 4.a"><p>First install into the local repository</p><pre class="programlisting">
$ mvn clean install -DskipTests -Prelease</pre></li><li class="step" title="Step 4.b"><p>Next, generate documentation and assemble the tarball.</p><pre class="programlisting">
$ mvn install -DskipTests site assembly:single -Prelease</pre></li></ol><p> Otherwise, the build complains that hbase modules are not in the maven
                        repository when you try to do it at once, especially on fresh repository. It
                        seems that you need the install goal in both steps.</p><p>Extract the generated tarball and check it out. Look at the documentation,
                        see if it runs, etc. If good, copy the tarball to the above mentioned
                            <span class="emphasis"><em>version directory</em></span>. </p></li><li class="step" title="Create a new tag."><p class="title"><b>Create a new tag.</b></p><div class="note" title="Point Release Only" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Point Release Only</h3><p>The following step that creates a new tag can be skipped since you've
                            already created the point release tag</p></div><p>Tag the release at this point since it looks good. If you find an issue
                        later, you can delete the tag and start over. Release needs to be tagged for
                        the next step.</p></li><li class="step" title="Deploy to the Maven Repository."><p class="title"><b>Deploy to the Maven Repository.</b></p><p>Next, deploy HBase to the Apache Maven repository, using the
                            <code class="varname">apache-release</code> profile instead of the
                            <code class="varname">release</code> profile when running the <span class="command"><strong>mvn
                            deploy</strong></span> command. This profile invokes the Apache pom referenced
                        by our pom files, and also signs your artifacts published to Maven, as long
                        as the <code class="filename">settings.xml</code> is configured correctly, as
                        described in <a class="xref" href="#mvn.settings.file" title="Example&nbsp;18.2.&nbsp;Example ~/.m2/settings.xml File">Example&nbsp;18.2, &#8220;Example <code class="filename">~/.m2/settings.xml</code> File&#8221;</a>.</p><pre class="programlisting">
$ mvn deploy -DskipTests -Papache-release</pre><p>This command copies all artifacts up to a temporary staging Apache mvn
                        repository in an 'open' state. More work needs to be done on these maven
                        artifacts to make them generally available. </p></li><li class="step" title="Make the Release Candidate available."><p class="title"><b>Make the Release Candidate available.</b></p><p>The artifacts are in the maven repository in the staging area in the
                        'open' state. While in this 'open' state you can check out what you've
                        published to make sure all is good. To do this, login at <a class="link" href="http://repository.apache.org" target="_top">repository.apache.org</a>
                        using your Apache ID. Find your artifacts in the staging repository. Browse
                        the content. Make sure all artifacts made it up and that the poms look
                        generally good. If it checks out, 'close' the repo. This will make the
                        artifacts publically available. You will receive an email with the URL to
                        give out for the temporary staging repository for others to use trying out
                        this new release candidate. Include it in the email that announces the
                        release candidate. Folks will need to add this repo URL to their local poms
                        or to their local <code class="filename">settings.xml</code> file to pull the
                        published release candidate artifacts. If the published artifacts are
                        incomplete or have problems, just delete the 'open' staged artifacts.</p><div class="note" title="hbase-downstreamer" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">hbase-downstreamer</h3><p> See the <a class="link" href="https://github.com/saintstack/hbase-downstreamer" target="_top">hbase-downstreamer</a> test for a simple example of a project
                            that is downstream of HBase an depends on it. Check it out and run its
                            simple test to make sure maven artifacts are properly deployed to the
                            maven repository. Be sure to edit the pom to point to the proper staging
                            repository. Make sure you are pulling from the repository when tests run
                            and that you are not getting from your local repository, by either
                            passing the <code class="code">-U</code> flag or deleting your local repo content and
                            check maven is pulling from remote out of the staging repository.
                        </p></div><p>See <a class="link" href="http://www.apache.org/dev/publishing-maven-artifacts.html" target="_top">Publishing Maven Artifacts</a> for some pointers on this maven
                        staging process.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>We no longer publish using the maven release plugin. Instead we do
                                <span class="command"><strong>mvn deploy</strong></span>. It seems to give us a backdoor to
                            maven release publishing. If there is no <span class="emphasis"><em>-SNAPSHOT</em></span>
                            on the version string, then we are 'deployed' to the apache maven
                            repository staging directory from which we can publish URLs for
                            candidates and later, if they pass, publish as release (if a
                                <span class="emphasis"><em>-SNAPSHOT</em></span> on the version string, deploy will
                            put the artifacts up into apache snapshot repos). </p></div><p>If the HBase version ends in <code class="varname">-SNAPSHOT</code>, the artifacts
                        go elsewhere. They are put into the Apache snapshots repository directly and
                        are immediately available. Making a SNAPSHOT release, this is what you want
                        to happen.</p></li><li class="step" title="If you used the make_rc.sh script instead of doing the above manually, do your sanity checks now."><p class="title"><b>If you used the <code class="filename">make_rc.sh</code> script instead of doing
                        the above manually, do your sanity checks now.</b></p><p> At this stage, you have two tarballs in your 'version directory' and a
                        set of artifacts in a staging area of the maven repository, in the 'closed'
                        state. These are publicly accessible in a temporary staging repository whose
                        URL you should have gotten in an email. The above mentioned script,
                            <code class="filename">make_rc.sh</code> does all of the above for you minus the
                        check of the artifacts built, the closing of the staging repository up in
                        maven, and the tagging of the release. If you run the script, do your checks
                        at this stage verifying the src and bin tarballs and checking what is up in
                        staging using hbase-downstreamer project. Tag before you start the build.
                        You can always delete it if the build goes haywire. </p></li><li class="step" title="Sign and upload your version directory to people.apache.org."><p class="title"><b>Sign and upload your version directory to <a class="link" href="http://people.apache.org" target="_top">people.apache.org</a>.</b></p><p> If all checks out, next put the <span class="emphasis"><em>version directory</em></span> up
                        on <a class="link" href="http://people.apache.org" target="_top">people.apache.org</a>. You
                        will need to sign and fingerprint them before you push them up. In the
                            <span class="emphasis"><em>version directory</em></span> run the following commands:
                    </p><pre class="programlisting">
$ for i in *.tar.gz; do echo $i; gpg --print-mds $i &gt; $i.mds ; done
$ for i in *.tar.gz; do echo $i; gpg --armor --output $i.asc --detach-sig $i  ; done
$ cd ..
# Presuming our 'version directory' is named 0.96.0RC0, now copy it up to people.apache.org.
$ rsync -av 0.96.0RC0 people.apache.org:public_html
                    </pre><p>Make sure the <a class="link" href="http://people.apache.org" target="_top">people.apache.org</a> directory is showing and that the mvn repo
                        URLs are good. Announce the release candidate on the mailing list and call a
                        vote. </p></li></ol></div></div><div class="section" title="18.5.3.&nbsp;Publishing a SNAPSHOT to maven"><div class="titlepage"><div><div><h3 class="title"><a name="maven.snapshot"></a>18.5.3.&nbsp;Publishing a SNAPSHOT to maven</h3></div></div></div><p>Make sure your <code class="filename">settings.xml</code> is set up properly, as in <a class="xref" href="#mvn.settings.file" title="Example&nbsp;18.2.&nbsp;Example ~/.m2/settings.xml File">Example&nbsp;18.2, &#8220;Example <code class="filename">~/.m2/settings.xml</code> File&#8221;</a>. Make sure the hbase version includes
                    <code class="varname">-SNAPSHOT</code> as a suffix. Following is an example of publishing
                SNAPSHOTS of a release that had an hbase version of 0.96.0 in its poms.</p><pre class="programlisting">
 $ mvn clean install -DskipTests  javadoc:aggregate site assembly:single -Prelease
 $ mvn -DskipTests  deploy -Papache-release</pre><p>The <code class="filename">make_rc.sh</code> script mentioned above (see <a class="xref" href="#maven.release" title="18.5.2.&nbsp;Making a Release Candidate">Section&nbsp;18.5.2, &#8220;Making a Release Candidate&#8221;</a>) can help you publish <code class="varname">SNAPSHOTS</code>.
                Make sure your <code class="varname">hbase.version</code> has a <code class="varname">-SNAPSHOT</code>
                suffix before running the script. It will put a snapshot up into the apache snapshot
                repository for you. </p></div></div><div class="section" title="18.6.&nbsp;Voting on Release Candidates"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.rc.voting"></a>18.6.&nbsp;Voting on Release Candidates</h2></div></div></div><p> Everyone is encouraged to try and vote on HBase release candidates. Only the votes of
            PMC members are binding. PMC members, please read this WIP doc on policy voting for a
            release candidate, <a class="link" href="https://github.com/rectang/asfrelease/blob/master/release.md" target="_top">Release
                Policy</a>. <span class="quote">&#8220;<span class="quote">Before casting +1 binding votes, individuals are required to
                download the signed source code package onto their own hardware, compile it as
                provided, and test the resulting executable on their own platform, along with also
                validating cryptographic signatures and verifying that the package meets the
                requirements of the ASF policy on releases.</span>&#8221;</span> Regards the latter, run
                <span class="command"><strong>mvn apache-rat:check</strong></span> to verify all files are suitably licensed.
            See <a class="link" href="http://search-hadoop.com/m/DHED4dhFaU" target="_top">HBase, mail # dev - On
                recent discussion clarifying ASF release policy</a>. for how we arrived at this
            process. </p></div><div class="section" title="18.7.&nbsp;Generating the HBase Reference Guide"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="documentation"></a>18.7.&nbsp;Generating the HBase Reference Guide</h2></div></div></div><p>The manual is marked up using <a class="link" href="http://www.docbook.org/" target="_top">docbook</a>. We then use the <a class="link" href="http://code.google.com/p/docbkx-tools/" target="_top">docbkx maven plugin</a> to
            transform the markup to html. This plugin is run when you specify the
                <span class="command"><strong>site</strong></span> goal as in when you run <span class="command"><strong>mvn site</strong></span> or you
            can call the plugin explicitly to just generate the manual by doing <span class="command"><strong>mvn
                docbkx:generate-html</strong></span>. When you run <span class="command"><strong>mvn site</strong></span>, the
            documentation is generated twice, once to generate the multipage manual and then again
            for the single page manual, which is easier to search. See <a class="xref" href="#appendix_contributing_to_documentation" title="Appendix&nbsp;A.&nbsp;Contributing to Documentation">Appendix&nbsp;A, <i>Contributing to Documentation</i></a> for more information on building
            the documentation. </p></div><div class="section" title="18.8.&nbsp;Updating hbase.apache.org"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.org"></a>18.8.&nbsp;Updating <a class="link" href="http://hbase.apache.org" target="_top">hbase.apache.org</a></h2></div></div></div><div class="section" title="18.8.1.&nbsp;Contributing to hbase.apache.org"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.org.site.contributing"></a>18.8.1.&nbsp;Contributing to hbase.apache.org</h3></div></div></div><p>See <a class="xref" href="#appendix_contributing_to_documentation" title="Appendix&nbsp;A.&nbsp;Contributing to Documentation">Appendix&nbsp;A, <i>Contributing to Documentation</i></a> for more information
                on contributing to the documentation or website.</p></div><div class="section" title="18.8.2.&nbsp;Publishing hbase.apache.org"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.org.site.publishing"></a>18.8.2.&nbsp;Publishing <a class="link" href="http://hbase.apache.org" target="_top">hbase.apache.org</a></h3></div></div></div><p>As of <a class="link" href="https://issues.apache.org/jira/browse/INFRA-5680" target="_top">INFRA-5680 Migrate apache hbase website</a>, to publish the website, build
                it using Maven, and then deploy it over a checkout of
                    <code class="filename">https://svn.apache.org/repos/asf/hbase/hbase.apache.org/trunk</code>
                and check in your changes. The script
                    <code class="filename">dev-scripts/publish_hbase_website.sh</code> is provided to
                automate this process and to be sure that stale files are removed from SVN. Review
                the script even if you decide to publish the website manually. Use the script as
                follows:</p><pre class="screen">$ <strong class="userinput"><code>publish_hbase_website.sh -h</code></strong>
Usage: publish_hbase_website.sh [-i | -a] [-g &lt;dir&gt;] [-s &lt;dir&gt;]
 -h          Show this message
 -i          Prompts the user for input
 -a          Does not prompt the user. Potentially dangerous.
 -g          The local location of the HBase git repository
 -s          The local location of the HBase svn checkout
 Either --interactive or --silent is required.
 Edit the script to set default Git and SVN directories.
            </pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The SVN commit takes a long time.</p></div></div></div><div class="section" title="18.9.&nbsp;Tests"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.tests"></a>18.9.&nbsp;Tests</h2></div></div></div><p> Developers, at a minimum, should familiarize themselves with the unit test detail;
            unit tests in HBase have a character not usually seen in other projects.</p><p>This information is about unit tests for HBase itself. For developing unit tests for
            your HBase applications, see <a class="xref" href="#unit.tests" title="Chapter&nbsp;19.&nbsp;Unit Testing HBase Applications">Chapter&nbsp;19, <i>Unit Testing HBase Applications</i></a>.</p><div class="section" title="18.9.1.&nbsp;Apache HBase Modules"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.moduletests"></a>18.9.1.&nbsp;Apache HBase Modules</h3></div></div></div><p>As of 0.96, Apache HBase is split into multiple modules. This creates
                "interesting" rules for how and where tests are written. If you are writing code for
                    <code class="classname">hbase-server</code>, see <a class="xref" href="#hbase.unittests" title="18.9.2.&nbsp;Unit Tests">Section&nbsp;18.9.2, &#8220;Unit Tests&#8221;</a> for
                how to write your tests. These tests can spin up a minicluster and will need to be
                categorized. For any other module, for example <code class="classname">hbase-common</code>,
                the tests must be strict unit tests and just test the class under test - no use of
                the HBaseTestingUtility or minicluster is allowed (or even possible given the
                dependency tree).</p><div class="section" title="18.9.1.1.&nbsp;Testing the HBase Shell"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.moduletest.shell"></a>18.9.1.1.&nbsp;Testing the HBase Shell</h4></div></div></div><p>
      The HBase shell and its tests are predominantly written in jruby. In order to make these
      tests run as a part of the standard build, there is a single JUnit test,
      <code class="classname">TestShell</code>, that takes care of loading the jruby implemented tests and
      running them. You can run all of these tests from the top level with:
    </p><pre class="programlisting">
      mvn clean test -Dtest=TestShell
    </pre><p>
      Alternatively, you may limit the shell tests that run using the system variable
      <code class="classname">shell.test</code>. This value may specify a particular test case by name. For
      example, the tests that cover the shell commands for altering tables are contained in the test
      case <code class="classname">AdminAlterTableTest</code> and you can run them with:
    </p><pre class="programlisting">
      mvn clean test -Dtest=TestShell -Dshell.test=AdminAlterTableTest
    </pre><p>
      You may also use a <a class="link" href="http://docs.ruby-doc.com/docs/ProgrammingRuby/html/language.html#UJ" target="_top">Ruby Regular Expression
      literal</a> (in the <code class="classname">/pattern/</code> style) to select a set of test cases.
      You can run all of the HBase admin related tests, including both the normal administration and
      the security administration, with the command:
    </p><pre class="programlisting">
      mvn clean test -Dtest=TestShell -Dshell.test=/.*Admin.*Test/
    </pre><p>
      In the event of a test failure, you can see details by examining the XML version of the
      surefire report results
    </p><pre class="programlisting">
      vim hbase-shell/target/surefire-reports/TEST-org.apache.hadoop.hbase.client.TestShell.xml
    </pre></div><div class="section" title="18.9.1.2.&nbsp;Running Tests in other Modules"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.moduletest.run"></a>18.9.1.2.&nbsp;Running Tests in other Modules</h4></div></div></div><p>If the module you are developing in has no other dependencies on other HBase modules, then
  you can cd into that module and just run:</p><pre class="programlisting">mvn test</pre><p>which will just run the tests IN THAT MODULE. If there are other dependencies on other modules,
  then you will have run the command from the ROOT HBASE DIRECTORY. This will run the tests in the other
  modules, unless you specify to skip the tests in that module. For instance, to skip the tests in the hbase-server module,
  you would run:</p><pre class="programlisting">mvn clean test -PskipServerTests</pre><p>from the top level directory to run all the tests in modules other than hbase-server. Note that you
  can specify to skip tests in multiple modules as well as just for a single module. For example, to skip
  the tests in <code class="classname">hbase-server</code> and <code class="classname">hbase-common</code>, you would run:</p><pre class="programlisting">mvn clean test -PskipServerTests -PskipCommonTests</pre><p>Also, keep in mind that if you are running tests in the <code class="classname">hbase-server</code> module you will need to
  apply the maven profiles discussed in <a class="xref" href="#hbase.unittests.cmds" title="18.9.3.&nbsp;Running tests">Section&nbsp;18.9.3, &#8220;Running tests&#8221;</a> to get the tests to run properly.</p></div></div><div class="section" title="18.9.2.&nbsp;Unit Tests"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.unittests"></a>18.9.2.&nbsp;Unit Tests</h3></div></div></div><p>Apache HBase unit tests are subdivided into four categories: small, medium, large, and
integration with corresponding JUnit <a class="link" href="http://www.junit.org/node/581" target="_top">categories</a>:
<code class="classname">SmallTests</code>, <code class="classname">MediumTests</code>,
<code class="classname">LargeTests</code>, <code class="classname">IntegrationTests</code>.
JUnit categories are denoted using java annotations and look like this in your unit test code.</p><pre class="programlisting">...
@Category(SmallTests.class)
public class TestHRegionInfo {
  @Test
  public void testCreateHRegionInfoName() throws Exception {
    // ...
  }
}</pre><p>The above example shows how to mark a unit test as belonging to the
                    <code class="literal">small</code> category. All unit tests in HBase have a
                categorization. </p><p> The first three categories, <code class="literal">small</code>, <code class="literal">medium</code>,
                and <code class="literal">large</code>, are for tests run when you type <code class="code">$ mvn
                    test</code>. In other words, these three categorizations are for HBase unit
                tests. The <code class="literal">integration</code> category is not for unit tests, but for
                integration tests. These are run when you invoke <code class="code">$ mvn verify</code>.
                Integration tests are described in <a class="xref" href="#integration.tests" title="18.9.5.&nbsp;Integration Tests">Section&nbsp;18.9.5, &#8220;Integration Tests&#8221;</a>.</p><p>HBase uses a patched maven surefire plugin and maven profiles to implement
                its unit test characterizations. </p><p>Keep reading to figure which annotation of the set small, medium, and large to
                put on your new HBase unit test. </p><div class="variablelist" title="Categorizing Tests"><p class="title"><b>Categorizing Tests</b></p><dl><dt><a name="hbase.unittests.small"></a><span class="term">Small Tests<a class="indexterm" name="d2875e20618"></a></span></dt><dd><p>
                            <span class="emphasis"><em>Small</em></span> tests are executed in a shared JVM. We put in
                            this category all the tests that can be executed quickly in a shared
                            JVM. The maximum execution time for a small test is 15 seconds, and
                            small tests should not use a (mini)cluster.</p></dd><dt><a name="hbase.unittests.medium"></a><span class="term">Medium Tests<a class="indexterm" name="d2875e20630"></a></span></dt><dd><p><span class="emphasis"><em>Medium</em></span> tests represent tests that must be
                            executed before proposing a patch. They are designed to run in less than
                            30 minutes altogether, and are quite stable in their results. They are
                            designed to last less than 50 seconds individually. They can use a
                            cluster, and each of them is executed in a separate JVM. </p></dd><dt><a name="hbase.unittests.large"></a><span class="term">Large Tests<a class="indexterm" name="d2875e20641"></a></span></dt><dd><p><span class="emphasis"><em>Large</em></span> tests are everything else. They are
                            typically large-scale tests, regression tests for specific bugs, timeout
                            tests, performance tests. They are executed before a commit on the
                            pre-integration machines. They can be run on the developer machine as
                            well. </p></dd><dt><a name="hbase.unittests.integration"></a><span class="term">Integration
                            Tests<a class="indexterm" name="d2875e20652"></a></span></dt><dd><p><span class="emphasis"><em>Integration</em></span> tests are system level tests. See
                                <a class="xref" href="#integration.tests" title="18.9.5.&nbsp;Integration Tests">Section&nbsp;18.9.5, &#8220;Integration Tests&#8221;</a> for more info. </p></dd></dl></div></div><div class="section" title="18.9.3.&nbsp;Running tests"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.unittests.cmds"></a>18.9.3.&nbsp;Running tests</h3></div></div></div><div class="section" title="18.9.3.1.&nbsp;Default: small and medium category tests"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.unittests.cmds.test"></a>18.9.3.1.&nbsp;Default: small and medium category tests </h4></div></div></div><p>Running <code class="code">mvn test</code> will
                    execute all small tests in a single JVM (no fork) and then medium tests in a
                    separate JVM for each test instance. Medium tests are NOT executed if there is
                    an error in a small test. Large tests are NOT executed. There is one report for
                    small tests, and one report for medium tests if they are executed. </p></div><div class="section" title="18.9.3.2.&nbsp;Running all tests"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.unittests.cmds.test.runAllTests"></a>18.9.3.2.&nbsp;Running all tests</h4></div></div></div><p>Running
                    <code class="code">mvn test -P runAllTests</code> will
                    execute small tests in a single JVM then medium and large tests in a separate
                    JVM for each test. Medium and large tests are NOT executed if there is an error
                    in a small test. Large tests are NOT executed if there is an error in a small or
                    medium test. There is one report for small tests, and one report for medium and
                    large tests if they are executed. </p></div><div class="section" title="18.9.3.3.&nbsp;Running a single test or all tests in a package"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.unittests.cmds.test.localtests.mytest"></a>18.9.3.3.&nbsp;Running a single test or all tests in a package</h4></div></div></div><p>To run an individual test, e.g. <code class="classname">MyTest</code>, rum <code class="code">mvn test -Dtest=MyTest</code> You can also pass multiple,
                    individual tests as a comma-delimited list: <code class="code">mvn test
                        -Dtest=MyTest1,MyTest2,MyTest3</code> You can also pass a package, which
                    will run all tests under the package: <code class="code">mvn test
                        '-Dtest=org.apache.hadoop.hbase.client.*'</code>
                </p><p> When <code class="code">-Dtest</code> is specified, the <code class="code">localTests</code> profile
                    will be used. It will use the official release of maven surefire, rather than
                    our custom surefire plugin, and the old connector (The HBase build uses a
                    patched version of the maven surefire plugin). Each junit test is executed in a
                    separate JVM (A fork per test class). There is no parallelization when tests are
                    running in this mode. You will see a new message at the end of the -report:
                        <code class="literal">"[INFO] Tests are skipped"</code>. It's harmless. However, you
                    need to make sure the sum of <code class="code">Tests run:</code> in the <code class="code">Results
                        :</code> section of test reports matching the number of tests you specified
                    because no error will be reported when a non-existent test case is specified.
                </p></div><div class="section" title="18.9.3.4.&nbsp;Other test invocation permutations"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.unittests.cmds.test.profiles"></a>18.9.3.4.&nbsp;Other test invocation permutations</h4></div></div></div><p>Running <span class="command"><strong>mvn test -P runSmallTests</strong></span> will execute "small"
                    tests only, using a single JVM. </p><p>Running <span class="command"><strong>mvn test -P runMediumTests</strong></span> will execute "medium"
                    tests only, launching a new JVM for each test-class. </p><p>Running <span class="command"><strong>mvn test -P runLargeTests</strong></span> will execute "large"
                    tests only, launching a new JVM for each test-class. </p><p>For convenience, you can run <span class="command"><strong>mvn test -P runDevTests</strong></span> to
                    execute both small and medium tests, using a single JVM. </p></div><div class="section" title="18.9.3.5.&nbsp;Running tests faster"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.unittests.test.faster"></a>18.9.3.5.&nbsp;Running tests faster</h4></div></div></div><p> By default, <code class="code">$ mvn test -P runAllTests</code> runs 5 tests in parallel.
                    It can be increased on a developer's machine. Allowing that you can have 2 tests
                    in parallel per core, and you need about 2GB of memory per test (at the
                    extreme), if you have an 8 core, 24GB box, you can have 16 tests in parallel.
                    but the memory available limits it to 12 (24/2), To run all tests with 12 tests
                    in parallel, do this: <span class="command"><strong>mvn test -P runAllTests
                        -Dsurefire.secondPartForkCount=12</strong></span>. If using a version earlier than 
                    2.0, do: <span class="command"><strong>mvn test -P runAllTests -Dsurefire.secondPartThreadCount=12
                    </strong></span>. To increase the speed, you can as well use a ramdisk. You will need 2GB 
                    of memory to run all tests. You will also need to delete the files between two 
                    test run. The typical way to configure a ramdisk on Linux is:</p><pre class="screen">$ sudo mkdir /ram2G
sudo mount -t tmpfs -o size=2048M tmpfs /ram2G</pre><p>You can then use it to run all HBase tests on 2.0 with the command: </p><pre class="screen">mvn test
                        -P runAllTests -Dsurefire.secondPartForkCount=12
                        -Dtest.build.data.basedirectory=/ram2G</pre><p>On earlier versions, use: </p><pre class="screen">mvn test
                        -P runAllTests -Dsurefire.secondPartThreadCount=12
                        -Dtest.build.data.basedirectory=/ram2G</pre></div><div class="section" title="18.9.3.6.&nbsp;hbasetests.sh"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.unittests.cmds.test.hbasetests"></a>18.9.3.6.&nbsp;<span class="command"><strong>hbasetests.sh</strong></span></h4></div></div></div><p>It's also possible to use the script <span class="command"><strong>hbasetests.sh</strong></span>. This
                    script runs the medium and large tests in parallel with two maven instances, and
                    provides a single report. This script does not use the hbase version of surefire
                    so no parallelization is being done other than the two maven instances the
                    script sets up. It must be executed from the directory which contains the
                        <code class="filename">pom.xml</code>.</p><p>For example running <span class="command"><strong>./dev-support/hbasetests.sh</strong></span> will
                    execute small and medium tests. Running <span class="command"><strong>./dev-support/hbasetests.sh
                        runAllTests</strong></span> will execute all tests. Running
                        <span class="command"><strong>./dev-support/hbasetests.sh replayFailed</strong></span> will rerun the
                    failed tests a second time, in a separate jvm and without parallelisation.
                </p></div><div class="section" title="18.9.3.7.&nbsp;Test Resource Checker"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.unittests.resource.checker"></a>18.9.3.7.&nbsp;Test Resource Checker<a class="indexterm" name="d2875e20788"></a></h4></div></div></div><p> A custom Maven SureFire plugin listener checks a number of resources before
                    and after each HBase unit test runs and logs its findings at the end of the test
                    output files which can be found in <code class="filename">target/surefire-reports</code>
                    per Maven module (Tests write test reports named for the test class into this
                    directory. Check the <code class="filename">*-out.txt</code> files). The resources
                    counted are the number of threads, the number of file descriptors, etc. If the
                    number has increased, it adds a <span class="emphasis"><em>LEAK?</em></span> comment in the logs.
                    As you can have an HBase instance running in the background, some threads can be
                    deleted/created without any specific action in the test. However, if the test
                    does not work as expected, or if the test should not impact these resources,
                    it's worth checking these log lines
                        <code class="computeroutput">...hbase.ResourceChecker(157): before...</code>
                    and <code class="computeroutput">...hbase.ResourceChecker(157): after...</code>.
                    For example: </p><pre class="screen">2012-09-26 09:22:15,315 INFO [pool-1-thread-1]
hbase.ResourceChecker(157): after:
regionserver.TestColumnSeeking#testReseeking Thread=65 (was 65),
OpenFileDescriptor=107 (was 107), MaxFileDescriptor=10240 (was 10240),
ConnectionCount=1 (was 1) </pre></div></div><div class="section" title="18.9.4.&nbsp;Writing Tests"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.tests.writing"></a>18.9.4.&nbsp;Writing Tests</h3></div></div></div><div class="section" title="18.9.4.1.&nbsp;General rules"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.tests.rules"></a>18.9.4.1.&nbsp;General rules</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>As much as possible, tests should be written as category small
                            tests.</p></li><li class="listitem"><p>All tests must be written to support parallel execution on the same
                            machine, hence they should not use shared resources as fixed ports or
                            fixed file names.</p></li><li class="listitem"><p>Tests should not overlog. More than 100 lines/second makes the logs
                            complex to read and use i/o that are hence not available for the other
                            tests.</p></li><li class="listitem"><p>Tests can be written with <code class="classname">HBaseTestingUtility</code>.
                            This class offers helper functions to create a temp directory and do the
                            cleanup, or to start a cluster.</p></li></ul></div></div><div class="section" title="18.9.4.2.&nbsp;Categories and execution time"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.tests.categories"></a>18.9.4.2.&nbsp;Categories and execution time</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>All tests must be categorized, if not they could be skipped.</p></li><li class="listitem"><p>All tests should be written to be as fast as possible.</p></li><li class="listitem"><p>Small category tests should last less than 15 seconds, and must not
                            have any side effect.</p></li><li class="listitem"><p>Medium category tests should last less than 50 seconds.</p></li><li class="listitem"><p>Large category tests should last less than 3 minutes. This should
                            ensure a good parallelization for people using it, and ease the analysis
                            when the test fails.</p></li></ul></div></div><div class="section" title="18.9.4.3.&nbsp;Sleeps in tests"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.tests.sleeps"></a>18.9.4.3.&nbsp;Sleeps in tests</h4></div></div></div><p>Whenever possible, tests should not use <code class="methodname">Thread.sleep</code>,
                    but rather waiting for the real event they need. This is faster and clearer for
                    the reader. Tests should not do a <code class="methodname">Thread.sleep</code> without
                    testing an ending condition. This allows understanding what the test is waiting
                    for. Moreover, the test will work whatever the machine performance is. Sleep
                    should be minimal to be as fast as possible. Waiting for a variable should be
                    done in a 40ms sleep loop. Waiting for a socket operation should be done in a
                    200 ms sleep loop. </p></div><div class="section" title="18.9.4.4.&nbsp;Tests using a cluster"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.tests.cluster"></a>18.9.4.4.&nbsp;Tests using a cluster </h4></div></div></div><p>Tests using a HRegion do not have to start a cluster: A region can use the
                    local file system. Start/stopping a cluster cost around 10 seconds. They should
                    not be started per test method but per test class. Started cluster must be
                    shutdown using <code class="methodname">HBaseTestingUtility#shutdownMiniCluster</code>,
                    which cleans the directories. As most as possible, tests should use the default
                    settings for the cluster. When they don't, they should document it. This will
                    allow to share the cluster later. </p></div></div><div class="section" title="18.9.5.&nbsp;Integration Tests"><div class="titlepage"><div><div><h3 class="title"><a name="integration.tests"></a>18.9.5.&nbsp;Integration Tests</h3></div></div></div><p>HBase integration/system tests are tests that are beyond HBase unit tests. They
                are generally long-lasting, sizeable (the test can be asked to 1M rows or 1B rows),
                targetable (they can take configuration that will point them at the ready-made
                cluster they are to run against; integration tests do not include cluster start/stop
                code), and verifying success, integration tests rely on public APIs only; they do
                not attempt to examine server internals asserting success/fail. Integration tests
                are what you would run when you need to more elaborate proofing of a release
                candidate beyond what unit tests can do. They are not generally run on the Apache
                Continuous Integration build server, however, some sites opt to run integration
                tests as a part of their continuous testing on an actual cluster. </p><p> Integration tests currently live under the <code class="filename">src/test</code>
                directory in the hbase-it submodule and will match the regex:
                    <code class="filename">**/IntegrationTest*.java</code>. All integration tests are also
                annotated with <code class="code">@Category(IntegrationTests.class)</code>. </p><p> Integration tests can be run in two modes: using a mini cluster, or against an
                actual distributed cluster. Maven failsafe is used to run the tests using the mini
                cluster. IntegrationTestsDriver class is used for executing the tests against a
                distributed cluster. Integration tests SHOULD NOT assume that they are running
                against a mini cluster, and SHOULD NOT use private API's to access cluster state. To
                interact with the distributed or mini cluster uniformly,
                    <code class="code">IntegrationTestingUtility</code>, and <code class="code">HBaseCluster</code> classes,
                and public client API's can be used. </p><p> On a distributed cluster, integration tests that use ChaosMonkey or otherwise
                manipulate services thru cluster manager (e.g. restart regionservers) use SSH to do
                it. To run these, test process should be able to run commands on remote end, so ssh
                should be configured accordingly (for example, if HBase runs under hbase user in
                your cluster, you can set up passwordless ssh for that user and run the test also
                under it). To facilitate that, <code class="code">hbase.it.clustermanager.ssh.user</code>,
                    <code class="code">hbase.it.clustermanager.ssh.opts</code> and
                    <code class="code">hbase.it.clustermanager.ssh.cmd</code> configuration settings can be used.
                "User" is the remote user that cluster manager should use to perform ssh commands.
                "Opts" contains additional options that are passed to SSH (for example, "-i
                /tmp/my-key"). Finally, if you have some custom environment setup, "cmd" is the
                override format for the entire tunnel (ssh) command. The default string is
                    {<code class="code">/usr/bin/ssh %1$s %2$s%3$s%4$s "%5$s"</code>} and is a good starting
                point. This is a standard Java format string with 5 arguments that is used to
                execute the remote command. The argument 1 (%1$s) is SSH options set the via opts
                setting or via environment variable, 2 is SSH user name, 3 is "@" if username is set
                or "" otherwise, 4 is the target host name, and 5 is the logical command to execute
                (that may include single quotes, so don't use them). For example, if you run the
                tests under non-hbase user and want to ssh as that user and change to hbase on
                remote machine, you can use {<code class="code">/usr/bin/ssh %1$s %2$s%3$s%4$s "su hbase - -c
                    \"%5$s\""</code>}. That way, to kill RS (for example) integration tests may run
                    {<code class="code">/usr/bin/ssh some-hostname "su hbase - -c \"ps aux | ... | kill
                    ...\""</code>}. The command is logged in the test logs, so you can verify it is
                correct for your environment. </p><div class="section" title="18.9.5.1.&nbsp;Running integration tests against mini cluster"><div class="titlepage"><div><div><h4 class="title"><a name="maven.build.commands.integration.tests.mini"></a>18.9.5.1.&nbsp;Running integration tests against mini cluster</h4></div></div></div><p>HBase 0.92 added a <code class="varname">verify</code> maven target. Invoking it, for
                    example by doing <code class="code">mvn verify</code>, will run all the phases up to and
                    including the verify phase via the maven <a class="link" href="http://maven.apache.org/plugins/maven-failsafe-plugin/" target="_top">failsafe
                        plugin</a>, running all the above mentioned HBase unit tests as well as
                    tests that are in the HBase integration test group. After you have completed
                        <span class="command"><strong>mvn install -DskipTests</strong></span> You can run just the integration
                    tests by invoking:</p><pre class="programlisting">
cd hbase-it
mvn verify</pre><p>If you just want to run the integration tests in top-level, you need to run
                    two commands. First: <span class="command"><strong>mvn failsafe:integration-test</strong></span> This
                    actually runs ALL the integration tests. </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This command will always output <code class="code">BUILD SUCCESS</code> even if there
                        are test failures. </p></div><p>At this point, you could grep the output by hand looking for failed tests.
                    However, maven will do this for us; just use: <span class="command"><strong>mvn
                        failsafe:verify</strong></span> The above command basically looks at all the test
                    results (so don't remove the 'target' directory) for test failures and reports
                    the results.</p><div class="section" title="18.9.5.1.1.&nbsp;Running a subset of Integration tests"><div class="titlepage"><div><div><h5 class="title"><a name="maven.build.commands.integration.tests2"></a>18.9.5.1.1.&nbsp;Running a subset of Integration tests</h5></div></div></div><p>This is very similar to how you specify running a subset of unit tests
                        (see above), but use the property <code class="code">it.test</code> instead of
                            <code class="code">test</code>. To just run
                            <code class="classname">IntegrationTestClassXYZ.java</code>, use: <span class="command"><strong>mvn
                            failsafe:integration-test -Dit.test=IntegrationTestClassXYZ</strong></span>
                        The next thing you might want to do is run groups of integration tests, say
                        all integration tests that are named IntegrationTestClassX*.java:
                            <span class="command"><strong>mvn failsafe:integration-test -Dit.test=*ClassX*</strong></span> This
                        runs everything that is an integration test that matches *ClassX*. This
                        means anything matching: "**/IntegrationTest*ClassX*". You can also run
                        multiple groups of integration tests using comma-delimited lists (similar to
                        unit tests). Using a list of matches still supports full regex matching for
                        each of the groups.This would look something like: <span class="command"><strong>mvn
                            failsafe:integration-test -Dit.test=*ClassX*, *ClassY</strong></span>
                    </p></div></div><div class="section" title="18.9.5.2.&nbsp;Running integration tests against distributed cluster"><div class="titlepage"><div><div><h4 class="title"><a name="maven.build.commands.integration.tests.distributed"></a>18.9.5.2.&nbsp;Running integration tests against distributed cluster</h4></div></div></div><p> If you have an already-setup HBase cluster, you can launch the integration
                    tests by invoking the class <code class="code">IntegrationTestsDriver</code>. You may have to
                    run test-compile first. The configuration will be picked by the bin/hbase
                    script. </p><pre class="programlisting">mvn test-compile</pre><p> Then
                    launch the tests with:</p><pre class="programlisting">bin/hbase [--config config_dir] org.apache.hadoop.hbase.IntegrationTestsDriver</pre><p>Pass <code class="code">-h</code> to get usage on this sweet tool. Running the
                    IntegrationTestsDriver without any argument will launch tests found under
                        <code class="code">hbase-it/src/test</code>, having
                        <code class="code">@Category(IntegrationTests.class)</code> annotation, and a name
                    starting with <code class="code">IntegrationTests</code>. See the usage, by passing -h, to
                    see how to filter test classes. You can pass a regex which is checked against
                    the full class name; so, part of class name can be used. IntegrationTestsDriver
                    uses Junit to run the tests. Currently there is no support for running
                    integration tests against a distributed cluster using maven (see <a class="link" href="https://issues.apache.org/jira/browse/HBASE-6201" target="_top">HBASE-6201</a>). </p><p> The tests interact with the distributed cluster by using the methods in the
                        <code class="code">DistributedHBaseCluster</code> (implementing
                    <code class="code">HBaseCluster</code>) class, which in turn uses a pluggable
                        <code class="code">ClusterManager</code>. Concrete implementations provide actual
                    functionality for carrying out deployment-specific and environment-dependent
                    tasks (SSH, etc). The default <code class="code">ClusterManager</code> is
                        <code class="code">HBaseClusterManager</code>, which uses SSH to remotely execute
                    start/stop/kill/signal commands, and assumes some posix commands (ps, etc). Also
                    assumes the user running the test has enough "power" to start/stop servers on
                    the remote machines. By default, it picks up <code class="code">HBASE_SSH_OPTS, HBASE_HOME,
                        HBASE_CONF_DIR</code> from the env, and uses
                        <code class="code">bin/hbase-daemon.sh</code> to carry out the actions. Currently tarball
                    deployments, deployments which uses hbase-daemons.sh, and <a class="link" href="http://incubator.apache.org/ambari/" target="_top">Apache Ambari</a>
                    deployments are supported. /etc/init.d/ scripts are not supported for now, but
                    it can be easily added. For other deployment options, a ClusterManager can be
                    implemented and plugged in. </p></div><div class="section" title="18.9.5.3.&nbsp;Destructive integration / system tests"><div class="titlepage"><div><div><h4 class="title"><a name="maven.build.commands.integration.tests.destructive"></a>18.9.5.3.&nbsp;Destructive integration / system tests</h4></div></div></div><p> In 0.96, a tool named <code class="code">ChaosMonkey</code> has been introduced. It is
                    modeled after the <a class="link" href="http://techblog.netflix.com/2012/07/chaos-monkey-released-into-wild.html" target="_top">same-named tool by Netflix</a>. Some of the tests use ChaosMonkey to
                    simulate faults in the running cluster in the way of killing random servers,
                    disconnecting servers, etc. ChaosMonkey can also be used as a stand-alone tool
                    to run a (misbehaving) policy while you are running other tests. </p><p> ChaosMonkey defines Action's and Policy's. Actions are sequences of events.
                    We have at least the following actions:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Restart active master (sleep 5 sec)</p></li><li class="listitem"><p>Restart random regionserver (sleep 5 sec)</p></li><li class="listitem"><p>Restart random regionserver (sleep 60 sec)</p></li><li class="listitem"><p>Restart META regionserver (sleep 5 sec)</p></li><li class="listitem"><p>Restart ROOT regionserver (sleep 5 sec)</p></li><li class="listitem"><p>Batch restart of 50% of regionservers (sleep 5 sec)</p></li><li class="listitem"><p>Rolling restart of 100% of regionservers (sleep 5 sec)</p></li></ul></div><p> Policies on the other hand are responsible for executing the actions based on
                    a strategy. The default policy is to execute a random action every minute based
                    on predefined action weights. ChaosMonkey executes predefined named policies
                    until it is stopped. More than one policy can be active at any time. </p><p> To run ChaosMonkey as a standalone tool deploy your HBase cluster as usual.
                    ChaosMonkey uses the configuration from the bin/hbase script, thus no extra
                    configuration needs to be done. You can invoke the ChaosMonkey by
                    running:</p><pre class="programlisting">bin/hbase org.apache.hadoop.hbase.util.ChaosMonkey</pre><p> This will output smt like: </p><pre class="screen">
12/11/19 23:21:57 INFO util.ChaosMonkey: Using ChaosMonkey Policy: class org.apache.hadoop.hbase.util.ChaosMonkey$PeriodicRandomActionPolicy, period:60000
12/11/19 23:21:57 INFO util.ChaosMonkey: Sleeping for 26953 to add jitter
12/11/19 23:22:24 INFO util.ChaosMonkey: Performing action: Restart active master
12/11/19 23:22:24 INFO util.ChaosMonkey: Killing master:master.example.com,60000,1353367210440
12/11/19 23:22:24 INFO hbase.HBaseCluster: Aborting Master: master.example.com,60000,1353367210440
12/11/19 23:22:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:master.example.com
12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:
12/11/19 23:22:25 INFO hbase.HBaseCluster: Waiting service:master to stop: master.example.com,60000,1353367210440
12/11/19 23:22:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep master | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:master.example.com
12/11/19 23:22:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:
12/11/19 23:22:25 INFO util.ChaosMonkey: Killed master server:master.example.com,60000,1353367210440
12/11/19 23:22:25 INFO util.ChaosMonkey: Sleeping for:5000
12/11/19 23:22:30 INFO util.ChaosMonkey: Starting master:master.example.com
12/11/19 23:22:30 INFO hbase.HBaseCluster: Starting Master on: master.example.com
12/11/19 23:22:30 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start master , hostname:master.example.com
12/11/19 23:22:31 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting master, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-master-master.example.com.out
....
12/11/19 23:22:33 INFO util.ChaosMonkey: Started master: master.example.com,60000,1353367210440
12/11/19 23:22:33 INFO util.ChaosMonkey: Sleeping for:51321
12/11/19 23:23:24 INFO util.ChaosMonkey: Performing action: Restart random region server
12/11/19 23:23:24 INFO util.ChaosMonkey: Killing region server:rs3.example.com,60020,1353367027826
12/11/19 23:23:24 INFO hbase.HBaseCluster: Aborting RS: rs3.example.com,60020,1353367027826
12/11/19 23:23:24 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 | xargs kill -s SIGKILL , hostname:rs3.example.com
12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:
12/11/19 23:23:25 INFO hbase.HBaseCluster: Waiting service:regionserver to stop: rs3.example.com,60020,1353367027826
12/11/19 23:23:25 INFO hbase.ClusterManager: Executing remote command: ps aux | grep regionserver | grep -v grep | tr -s ' ' | cut -d ' ' -f2 , hostname:rs3.example.com
12/11/19 23:23:25 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:
12/11/19 23:23:25 INFO util.ChaosMonkey: Killed region server:rs3.example.com,60020,1353367027826. Reported num of rs:6
12/11/19 23:23:25 INFO util.ChaosMonkey: Sleeping for:60000
12/11/19 23:24:25 INFO util.ChaosMonkey: Starting region server:rs3.example.com
12/11/19 23:24:25 INFO hbase.HBaseCluster: Starting RS on: rs3.example.com
12/11/19 23:24:25 INFO hbase.ClusterManager: Executing remote command: /homes/enis/code/hbase-0.94/bin/../bin/hbase-daemon.sh --config /homes/enis/code/hbase-0.94/bin/../conf start regionserver , hostname:rs3.example.com
12/11/19 23:24:26 INFO hbase.ClusterManager: Executed remote command, exit code:0 , output:starting regionserver, logging to /homes/enis/code/hbase-0.94/bin/../logs/hbase-enis-regionserver-rs3.example.com.out

12/11/19 23:24:27 INFO util.ChaosMonkey: Started region server:rs3.example.com,60020,1353367027826. Reported num of rs:6
</pre><p> As you can see from the log, ChaosMonkey started the default
                    PeriodicRandomActionPolicy, which is configured with all the available actions,
                    and ran RestartActiveMaster and RestartRandomRs actions. ChaosMonkey tool, if
                    run from command line, will keep on running until the process is killed. </p></div><div class="section" title="18.9.5.4.&nbsp;Passing individual Chaos Monkey per-test Settings/Properties"><div class="titlepage"><div><div><h4 class="title"><a name="chaos.monkey.properties"></a>18.9.5.4.&nbsp;Passing individual Chaos Monkey per-test Settings/Properties</h4></div></div></div><p> Since HBase version 1.0.0 (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-11348" target="_top">HBASE-11348</a>), the chaos monkeys is used to run integration tests can
                    be configured per test run. Users can create a java properties file and and pass
                    this to the chaos monkey with timing configurations. The properties file needs
                    to be in the HBase classpath. The various properties that can be configured and
                    their default values can be found listed in the
                        <code class="classname">org.apache.hadoop.hbase.chaos.factories.MonkeyConstants</code>
                    class. If any chaos monkey configuration is missing from the property file, then
                    the default values are assumed. For example:</p><pre class="programlisting">
$<strong class="userinput"><code>bin/hbase org.apache.hadoop.hbase.IntegrationTestIngest -m slowDeterministic -monkeyProps monkey.properties</code></strong>
    </pre><p>The above command will start the integration tests and chaos monkey passing
                    the properties file <code class="filename">monkey.properties</code>. Here is an example
                    chaos monkey file:</p><pre class="programlisting">
sdm.action1.period=120000
sdm.action2.period=40000
move.regions.sleep.time=80000
move.regions.max.time=1000000
move.regions.sleep.time=80000
batch.restart.rs.ratio=0.4f
    </pre></div></div></div><div class="section" title="18.10.&nbsp;Developer Guidelines"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="developing"></a>18.10.&nbsp;Developer Guidelines</h2></div></div></div><div class="section" title="18.10.1.&nbsp;Codelines"><div class="titlepage"><div><div><h3 class="title"><a name="codelines"></a>18.10.1.&nbsp;Codelines</h3></div></div></div><p>Most development is done on the master branch, which is named
              <code class="literal">master</code> in the Git repository. Previously, HBase used Subversion, in
              which the master branch was called <code class="literal">TRUNK</code>. Branches exist for minor
              releases, and important features and bug fixes are often back-ported.</p></div><div class="section" title="18.10.2.&nbsp;Release Managers"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e21113"></a>18.10.2.&nbsp;Release Managers</h3></div></div></div><p>Each maintained release branch has a release manager, who volunteers to coordinate
                new features and bug fixes are backported to that release. The release managers are
                    <a class="link" href="https://hbase.apache.org/team-list.html" target="_top">committers</a>. If
                you would like your feature or bug fix to be included in a given release,
                communicate with that release manager. If this list goes out of date or you can't
                reach the listed person, reach out to someone else on the list.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>End-of-life releases are not included in this list.</p></div><div class="table"><a name="d2875e21124"></a><p class="title"><b>Table&nbsp;18.1.&nbsp;Release Managers</b></p><div class="table-contents"><table summary="Release Managers" border="1"><colgroup><col><col></colgroup><thead><tr><th>Release</th><th>Release Manager</th></tr></thead><tbody><tr><td><p>0.98</p></td><td><p><a class="link" href="https://issues.apache.org/jira/secure/ViewProfile.jspa?name=apurtell" target="_top">Andrew Purtell</a></p></td></tr><tr><td><p>1.0</p></td><td><p><a class="link" href="https://issues.apache.org/jira/secure/ViewProfile.jspa?name=enis" target="_top">Enis Soztutar</a></p></td></tr></tbody></table></div></div><br class="table-break"></div><div class="section" title="18.10.3.&nbsp;Code Standards"><div class="titlepage"><div><div><h3 class="title"><a name="code.standards"></a>18.10.3.&nbsp;Code Standards</h3></div></div></div><p>See <a class="xref" href="#eclipse.code.formatting" title="18.3.1.1.&nbsp;Code Formatting">Section&nbsp;18.3.1.1, &#8220;Code Formatting&#8221;</a> and <a class="xref" href="#common.patch.feedback" title="18.10.3.2.&nbsp;Code Formatting Conventions">Section&nbsp;18.10.3.2, &#8220;Code Formatting Conventions&#8221;</a>. </p><div class="section" title="18.10.3.1.&nbsp;Interface Classifications"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e21160"></a>18.10.3.1.&nbsp;Interface Classifications</h4></div></div></div><p> Interfaces are classified both by audience and by stability level. These
                    labels appear at the head of a class. The conventions followed by HBase are
                    inherited by its parent project, Hadoop. </p><p>The following interface classifications are commonly used: </p><div class="variablelist" title="@InterfaceAudience"><p class="title"><b>@InterfaceAudience</b></p><dl><dt><span class="term"><code class="code">@InterfaceAudience.Public</code></span></dt><dd><p>APIs for users and HBase applications. These APIs will be
                                deprecated through major versions of HBase.</p></dd><dt><span class="term"><code class="code">@InterfaceAudience.Private</code></span></dt><dd><p>APIs for HBase internals developers. No guarantees on
                                compatibility or availability in future versions. Private interfaces
                                do not need an <code class="code">@InterfaceStability</code>
                                classification.</p></dd><dt><span class="term"><code class="code">@InterfaceAudience.LimitedPrivate(HBaseInterfaceAudience.COPROC)</code></span></dt><dd><p>APIs for HBase coprocessor writers. As of HBase
                                0.92/0.94/0.96/0.98 this api is still unstable. No guarantees on
                                compatibility with future versions.</p></dd><dt><span class="term">No <code class="code">@InterfaceAudience</code> Classification</span></dt><dd><p>Packages without an <code class="code">@InterfaceAudience</code> label are
                                considered private. Mark your new packages if publicly
                                accessible.</p></dd></dl></div><div class="note" title="Excluding Non-Public Interfaces from API Documentation" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Excluding Non-Public Interfaces from API Documentation</h3><p> Only interfaces classified <code class="code">@InterfaceAudience.Public</code> should
                        be included in API documentation (Javadoc). Committers must add new package
                        excludes <code class="code">ExcludePackageNames</code> section of the
                            <code class="filename">pom.xml</code> for new packages which do not contain
                        public classes. </p></div><div class="variablelist" title="@InterfaceStability"><p class="title"><b>@InterfaceStability</b></p><p><code class="code">@InterfaceStability</code> is important for packages marked
                            <code class="code">@InterfaceAudience.Public</code>.</p><dl><dt><span class="term"><code class="code">@InterfaceStability.Stable</code></span></dt><dd><p>Public packages marked as stable cannot be changed without a
                                deprecation path or a very good reason.</p></dd><dt><span class="term"><code class="code">@InterfaceStability.Unstable</code></span></dt><dd><p>Public packages marked as unstable can be changed without a
                                deprecation path.</p></dd><dt><span class="term"><code class="code">@InterfaceStability.Evolving</code></span></dt><dd><p>Public packages marked as evolving may be changed, but it is
                                discouraged.</p></dd><dt><span class="term">No <code class="code">@InterfaceStability</code> Label</span></dt><dd><p>Public classes with no <code class="code">@InterfaceStability</code> label are
                                discouraged, and should be considered implicitly unstable.</p></dd></dl></div><p> If you are unclear about how to mark packages, ask on the development list.
                </p></div><div class="section" title="18.10.3.2.&nbsp;Code Formatting Conventions"><div class="titlepage"><div><div><h4 class="title"><a name="common.patch.feedback"></a>18.10.3.2.&nbsp;Code Formatting Conventions</h4></div></div></div><p>Please adhere to the following guidelines so that your patches can be reviewed
                    more quickly. These guidelines have been developed based upon common feedback on
                    patches from new contributors.</p><p> See the <a class="link" href="http://www.oracle.com/technetwork/java/index-135089.html" target="_top">Code
                    Conventions for the Java Programming Language</a> for more information on
                    coding conventions in Java.</p><div class="section" title="18.10.3.2.1.&nbsp;Space Invaders"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.space.invaders"></a>18.10.3.2.1.&nbsp;Space Invaders</h5></div></div></div><p>Do not use extra spaces around brackets. Use the second style, rather than
                        the first.</p><pre class="programlisting">
if ( foo.equals( bar ) ) {     // don't do this
</pre><pre class="programlisting">
if (foo.equals(bar)) {
</pre><pre class="programlisting">
foo = barArray[ i ];     // don't do this
</pre><pre class="programlisting">
foo = barArray[i];
</pre></div><div class="section" title="18.10.3.2.2.&nbsp;Auto Generated Code"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.autogen"></a>18.10.3.2.2.&nbsp;Auto Generated Code</h5></div></div></div><p>Auto-generated code in Eclipse often uses bad variable names such as
                        <code class="literal">arg0</code>. Use more informative variable names. Use code
                        like the second example here.</p><pre class="programlisting">
 public void readFields(DataInput arg0) throws IOException {    // don't do this
   foo = arg0.readUTF();                                       // don't do this
</pre><pre class="programlisting">
 public void readFields(DataInput di) throws IOException {
   foo = di.readUTF();
</pre></div><div class="section" title="18.10.3.2.3.&nbsp;Long Lines"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.longlines"></a>18.10.3.2.3.&nbsp;Long Lines</h5></div></div></div><p> Keep lines less than 100 characters. You can configure your IDE to do
                        this automatically.</p><pre class="programlisting">
Bar bar = foo.veryLongMethodWithManyArguments(argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9);  // don't do this
</pre><pre class="programlisting">
Bar bar = foo.veryLongMethodWithManyArguments(
 argument1, argument2, argument3,argument4, argument5, argument6, argument7, argument8, argument9);
</pre></div><div class="section" title="18.10.3.2.4.&nbsp;Trailing Spaces"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.trailingspaces"></a>18.10.3.2.4.&nbsp;Trailing Spaces</h5></div></div></div><p> Trailing spaces are a common problem. Be sure there is a line break after
                        the end of your code, and avoid lines with nothing but whitespace. This
                        makes diffs more meaningful. You can configure your IDE to help with
                        this.</p><pre class="programlisting">
Bar bar = foo.getBar();     &lt;--- imagine there is an extra space(s) after the semicolon.
</pre></div><div class="section" title="18.10.3.2.5.&nbsp;API Documentation (Javadoc)"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.javadoc"></a>18.10.3.2.5.&nbsp;API Documentation (Javadoc)</h5></div></div></div><p>This is also a very common feedback item. Don't forget Javadoc!</p><p>Javadoc warnings are checked during precommit. If the precommit tool gives
                        you a '-1', please fix the javadoc issue. Your patch won't be committed if
                        it adds such warnings. </p></div><div class="section" title="18.10.3.2.6.&nbsp;Findbugs"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.findbugs"></a>18.10.3.2.6.&nbsp;Findbugs</h5></div></div></div><p>
                        <code class="code">Findbugs</code> is used to detect common bugs pattern. It is checked
                        during the precommit build by Apache's Jenkins. If errors are found, please
                        fix them. You can run findbugs locally with <span class="command"><strong>mvn
                            findbugs:findbugs</strong></span>, which will generate the
                        <code class="code">findbugs</code> files locally. Sometimes, you may have to write
                        code smarter than <code class="code">findbugs</code>. You can annotate your code to tell
                        <code class="code">findbugs</code> you know what you're doing, by annotating your
                        class with the following annotation:</p><pre class="programlisting">@edu.umd.cs.findbugs.annotations.SuppressWarnings(
value="HE_EQUALS_USE_HASHCODE",
justification="I know what I'm doing")</pre><p> It is important to use the Apache-licensed version of the annotations.
                    </p></div><div class="section" title="18.10.3.2.7.&nbsp;Javadoc - Useless Defaults"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.javadoc.defaults"></a>18.10.3.2.7.&nbsp;Javadoc - Useless Defaults</h5></div></div></div><p>Don't just leave the @param arguments the way your IDE generated
                        them.:</p><pre class="programlisting">
  /**
   *
   * @param bar             &lt;---- don't do this!!!!
   * @return                &lt;---- or this!!!!
   */
  public Foo getFoo(Bar bar);
</pre><p>Either add something descriptive to the @<code class="code">param</code> and
                        @<code class="code">return</code> lines, or just remove them. The preference is to
                        add something descriptive and useful.</p></div><div class="section" title="18.10.3.2.8.&nbsp;One Thing At A Time, Folks"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.onething"></a>18.10.3.2.8.&nbsp;One Thing At A Time, Folks</h5></div></div></div><p>If you submit a patch for one thing, don't do auto-reformatting or
                        unrelated reformatting of code on a completely different area of code. </p><p>Likewise, don't add unrelated cleanup or refactorings outside the scope of
                        your Jira. </p></div><div class="section" title="18.10.3.2.9.&nbsp;Ambigious Unit Tests"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.tests"></a>18.10.3.2.9.&nbsp;Ambigious Unit Tests</h5></div></div></div><p>Make sure that you're clear about what you are testing in your unit tests
                        and why. </p></div><div class="section" title="18.10.3.2.10.&nbsp;Implementing Writable"><div class="titlepage"><div><div><h5 class="title"><a name="common.patch.feedback.writable"></a>18.10.3.2.10.&nbsp;Implementing Writable</h5></div></div></div><div class="note" title="Applies pre-0.96 only" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Applies pre-0.96 only</h3><p>In 0.96, HBase moved to protocol buffers (protobufs). The below
                            section on Writables applies to 0.94.x and previous, not to 0.96 and
                            beyond. </p></div><p>Every class returned by RegionServers must implement the
                        <code class="code">Writable</code> interface. If you are creating a new class that
                        needs to implement this interface, do not forget the default constructor.
                    </p></div></div></div><div class="section" title="18.10.4.&nbsp;Invariants"><div class="titlepage"><div><div><h3 class="title"><a name="design.invariants"></a>18.10.4.&nbsp;Invariants</h3></div></div></div><p>We don't have many but what we have we list below.  All are subject to challenge of
           course but until then, please hold to the rules of the road.
           </p><div class="section" title="18.10.4.1.&nbsp;No permanent state in ZooKeeper"><div class="titlepage"><div><div><h4 class="title"><a name="design.invariants.zk.data"></a>18.10.4.1.&nbsp;No permanent state in ZooKeeper</h4></div></div></div><p>ZooKeeper state should transient (treat it like memory). If ZooKeeper state is
                    deleted, hbase should be able to recover and essentially be in the same
                    state.</p><div class="itemizedlist" title="Exceptions"><p class="title"><b>Exceptions</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>There are currently a few exceptions that we need to fix around
                            whether a table is enabled or disabled.</p></li><li class="listitem"><p>Replication data is currently stored only in ZooKeeper. Deleting
                            ZooKeeper data related to replication may cause replication to be
                            disabled. Do not delete the replication tree,
                                <code class="filename">/hbase/replication/</code>.</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Replication may be disrupted and data loss may occur if you delete
                                the replication tree (<code class="filename">/hbase/replication/</code>) from
                                ZooKeeper. Follow progress on this issue at <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10295" target="_top">HBASE-10295</a>.</p></div></li></ul></div></div></div><div class="section" title="18.10.5.&nbsp;Running In-Situ"><div class="titlepage"><div><div><h3 class="title"><a name="run.insitu"></a>18.10.5.&nbsp;Running In-Situ</h3></div></div></div><p>If you are developing Apache HBase, frequently it is useful to test your changes against a more-real cluster than what you find in unit tests. In this case, HBase can be run directly from the source in local-mode.
           All you need to do is run:
           </p><pre class="programlisting">${HBASE_HOME}/bin/start-hbase.sh</pre><p>
           This will spin up a full local-cluster, just as if you had packaged up HBase and installed it on your machine.
           </p><p>Keep in mind that you will need to have installed HBase into your local maven repository for the in-situ cluster to work properly. That is, you will need to run:</p><pre class="programlisting">mvn clean install -DskipTests</pre><p>to ensure that maven can find the correct classpath and dependencies. Generally, the above command
           is just a good thing to try running first, if maven is acting oddly.</p></div><div class="section" title="18.10.6.&nbsp;Adding Metrics"><div class="titlepage"><div><div><h3 class="title"><a name="add.metrics"></a>18.10.6.&nbsp;Adding Metrics</h3></div></div></div><p>
                  After adding a new feature a developer might want to add metrics.  HBase exposes
                  metrics using the Hadoop Metrics 2 system, so adding a new metric involves
                  exposing that metric to the hadoop system.  Unfortunately the API of metrics2
                  changed from hadoop 1 to hadoop 2.  In order to get around this a set of
                  interfaces and implementations have to be loaded at runtime.  To get an in-depth
                  look at the reasoning and structure of these classes you can read the blog post
                  located <a class="link" href="https://blogs.apache.org/hbase/entry/migration_to_the_new_metrics" target="_top">here</a>.
                  To add a metric to an existing MBean follow the short guide below:
              </p><div class="section" title="18.10.6.1.&nbsp;Add Metric name and Function to Hadoop Compat Interface."><div class="titlepage"><div><div><h4 class="title"><a name="d2875e21444"></a>18.10.6.1.&nbsp;Add Metric name and Function to Hadoop Compat Interface.</h4></div></div></div><p>
                     Inside of the source interface the corresponds to where the metrics are
                     generated (eg MetricsMasterSource for things coming from HMaster) create new
                     static strings for metric name and description.  Then add a new method that
                     will be called to add new reading.
                  </p></div><div class="section" title="18.10.6.2.&nbsp;Add the Implementation to Both Hadoop 1 and Hadoop 2 Compat modules."><div class="titlepage"><div><div><h4 class="title"><a name="d2875e21449"></a>18.10.6.2.&nbsp;Add the Implementation to Both Hadoop 1 and Hadoop 2 Compat modules.</h4></div></div></div><p>
                      Inside of the implementation of the source (eg. MetricsMasterSourceImpl
                      in the above example) create a new histogram, counter, gauge, or stat in the
                      init method.  Then in the method that was added to the interface wire up the
                      parameter passed in to the histogram.
                  </p><p>
                      Now add tests that make sure the data is correctly exported to the metrics 2
                      system. For this the MetricsAssertHelper is provided.
                  </p></div></div><div class="section" title="18.10.7.&nbsp;Git Best Practices"><div class="titlepage"><div><div><h3 class="title"><a name="git.best.practices"></a>18.10.7.&nbsp;Git Best Practices</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Use the correct method to create patches. See <a class="xref" href="#submitting.patches" title="18.10.8.&nbsp;Submitting Patches">Section&nbsp;18.10.8, &#8220;Submitting Patches&#8221;</a>.</p></li><li class="listitem"><p>Avoid git merges. Use <code class="code">git pull --rebase</code> or <code class="code">git
                            fetch</code> followed by <code class="code">git rebase</code>.</p></li><li class="listitem"><p>Do not use <code class="code">git push --force</code>. If the push does not work, fix
                        the problem or ask for help.</p></li></ul></div><p>Please contribute to this document if you think of other Git best
                practices.</p><div class="section" title="18.10.7.1.&nbsp;rebase_all_git_branches.sh"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e21485"></a>18.10.7.1.&nbsp;<code class="code">rebase_all_git_branches.sh</code></h4></div></div></div><p>The <code class="filename">dev-support/rebase_all_git_branches.sh</code> script is
                    provided to help keep your Git repository clean. Use the <code class="code">-h</code>
                    parameter to get usage instructions. The script automatically refreshes your
                    tracking branches, attempts an automatic rebase of each local branch against its
                    remote branch, and gives you the option to delete any branch which represents a
                    closed <code class="literal">HBASE-</code> JIRA. The script has one optional configuration
                    option, the location of your Git directory. You can set a default by editing the
                    script. Otherwise, you can pass the git directory manually by using the
                        <code class="code">-d</code> parameter, followed by an absolute or relative directory
                    name, or even '.' for the current working directory. The script checks the
                    directory for sub-directory called <code class="filename">.git/</code>, before
                    proceeding.</p></div></div><div class="section" title="18.10.8.&nbsp;Submitting Patches"><div class="titlepage"><div><div><h3 class="title"><a name="submitting.patches"></a>18.10.8.&nbsp;Submitting Patches</h3></div></div></div><p>HBase moved to GIT from SVN. Until we develop our own documentation for how to
                contribute patches in our new GIT context, caveat the fact that we have a different
                branching model and that we don't currently do the merge practice described in the
                following, the <a class="link" href="http://accumulo.apache.org/git.html" target="_top">accumulo doc
                    on how to contribute and develop</a> after our move to GIT is worth a read.
                See also <a class="xref" href="#git.best.practices" title="18.10.7.&nbsp;Git Best Practices">Section&nbsp;18.10.7, &#8220;Git Best Practices&#8221;</a>.</p><p>If you are new to submitting patches to open source or new to submitting patches
                to Apache, start by reading the <a class="link" href="http://commons.apache.org/patches.html" target="_top">On Contributing
                    Patches</a> page from <a class="link" href="http://commons.apache.org/" target="_top">Apache
                    Commons Project</a>. It provides a nice overview that applies equally to the
                Apache HBase Project.</p><div class="section" title="18.10.8.1.&nbsp;Create Patch"><div class="titlepage"><div><div><h4 class="title"><a name="submitting.patches.create"></a>18.10.8.1.&nbsp;Create Patch</h4></div></div></div><p>The script <code class="filename">dev-support/make_patch.sh</code> has been provided to
                    help you adhere to patch-creation guidelines. The script has the following syntax:
                </p><pre class="screen">$ make_patch.sh [-a] [-p &lt;patch_dir&gt;]</pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>If you do not pass a <code class="code">patch_dir</code>, the script defaults to
                                <code class="filename">~/patches/</code>. If the <code class="code">patch_dir</code> does
                            not exist, it is created.</p></li><li class="listitem"><p>By default, if an existing patch exists with the JIRA ID, the version
                            of the new patch is incremented
                                (<code class="filename">HBASE-XXXX-v3.patch</code>). If the <code class="code">-a</code>
                            option is passed, the version is not incremented, but the suffix
                                <code class="literal">-addendum</code> is added
                                (<code class="filename">HBASE-XXXX-v2-addendum.patch</code>). A second
                            addendum to a given version is not supported.</p></li><li class="listitem"><p>Detects whether you have more than one local commit on your branch. If
                            you do, the script offers you the chance to run <span class="command"><strong>git rebase
                                -i</strong></span> to squash the changes into a single commit so that it
                            can use <span class="command"><strong>git format-patch</strong></span>. If you decline, the script
                            uses <span class="command"><strong>git diff</strong></span> instead. The patch is saved in a
                            configurable directory and is ready to be attached to your JIRA.</p></li></ol></div><div class="itemizedlist" title="Patching Workflow"><p class="title"><b>Patching Workflow</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p><a name="patch.master.first"></a>Always patch against the master branch
                            first, even if you want to patch in another branch. HBase committers
                            always apply patches first to the master branch, and backport if
                            necessary.</p></li><li class="listitem"><p>Submit one single patch for a fix. If necessary, squash local commits
                            to merge local commits into a single one first. See this <a class="link" href="http://stackoverflow.com/questions/5308816/how-to-use-git-merge-squash" target="_top">Stack Overflow question</a> for more information about squashing
                            commits.</p></li><li class="listitem"><p><a name="submitting.patches.naming"></a>The patch should have the JIRA ID in the name. If you are generating
                            from a branch, include the target branch in the filename. A common
                            naming scheme for patches is:</p><pre class="screen">HBASE-<em class="replaceable"><code>XXXX</code></em>.patch</pre><pre class="screen">HBASE-<em class="replaceable"><code>XXXX</code></em>-0.90.patch     # to denote that the patch is against branch 0.90</pre><pre class="screen">HBASE-<em class="replaceable"><code>XXXX</code></em>-v3.patch       # to denote that this is the third version of the patch</pre></li><li class="listitem"><p><a name="submitting.patches.jira"></a>To submit a patch, first create it using one of the methods in <a class="xref" href="#patching.methods" title="Methods to Create Patches">Methods to Create Patches</a>. Next, attach the patch to the JIRA
                            (one patch for the whole fix), using the <span class="guimenu">More</span> &#8594; <span class="guimenuitem">Attach Files</span> dialog. Next, click the <span class="guibutton">Patch
                                Available</span> button, which triggers the Hudson job which
                            checks the patch for validity.</p><p>Please understand that not every patch may get committed, and that
                            feedback will likely be provided on the patch.</p></li><li class="listitem"><p>If your patch is longer than a single screen, also attach a Review
                            Board to the case. See <a class="xref" href="#reviewboard" title="18.10.8.4.&nbsp;ReviewBoard">Section&nbsp;18.10.8.4, &#8220;ReviewBoard&#8221;</a>.</p></li><li class="listitem"><p>If you need to revise your patch, leave the previous patch file(s)
                            attached to the JIRA, and upload the new one, following the naming
                            conventions in <a class="xref" href="#submitting.patches.create" title="18.10.8.1.&nbsp;Create Patch">Section&nbsp;18.10.8.1, &#8220;Create Patch&#8221;</a>. Cancel the
                            Patch Available flag and then re-trigger it, by toggling the
                                <span class="guibutton">Patch Available</span> button in JIRA. JIRA sorts
                            attached files by the time they were attached, and has no problem with
                            multiple attachments with the same name. However, at times it is easier
                            to refer to different version of a patch if you add
                                <code class="literal">-vX</code>, where the <em class="replaceable"><code>X</code></em> is
                            the version (starting with 2).</p></li><li class="listitem"><p>If you need to submit your patch against multiple branches, rather
                            than just master, name each version of the patch with the branch it is
                            for, following the naming conventions in <a class="xref" href="#submitting.patches.create" title="18.10.8.1.&nbsp;Create Patch">Section&nbsp;18.10.8.1, &#8220;Create Patch&#8221;</a>.</p></li></ul></div><div class="variablelist" title="Methods to Create Patches"><a name="patching.methods"></a><p class="title"><b>Methods to Create Patches</b></p><dl><dt><span class="term">Eclipse</span></dt><dd><p>Select the <span class="guimenu">Team</span> &#8594; <span class="guimenuitem">Create Patch</span> menu item.</p></dd><dt><span class="term">Git</span></dt><dd><p><code class="code">git format-patch</code> is preferred because it preserves
                                commit messages. Use <code class="code">git rebase -i</code> first, to combine
                                (squash) smaller commits into a single larger one.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Do not use <code class="code">--no-prefix</code>, even if you were in the
                                    habit of doing it previously.</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><pre class="screen">git format-patch origin/master --stdout &gt; HBASE-XXXX.patch</pre></li><li class="listitem"><pre class="screen">git diff origin/master &gt; HBASE-XXXX.patch</pre></li></ul></div><p>If your branch is based upon a different remote branch, replace
                                    <em class="replaceable"><code>origin/master</code></em> with the remote to
                                compare against.</p><p>If you are new to creating patches, it's a good idea to check out
                                a fresh branch and try to apply your patch to it. If you used
                                    <span class="command"><strong>git format-patch</strong></span>, apply the patch using
                                    <span class="command"><strong>git am</strong></span>. Otherwise, use <span class="command"><strong>git
                                    apply</strong></span>. If the patch does not apply correctly, fix the
                                problem and try again.</p></dd><dt><span class="term">Subversion</span></dt><dd><pre class="screen">svn diff &gt; HBASE-XXXX.patch</pre></dd></dl></div><p>Make sure you review <a class="xref" href="#eclipse.code.formatting" title="18.3.1.1.&nbsp;Code Formatting">Section&nbsp;18.3.1.1, &#8220;Code Formatting&#8221;</a> and <a class="xref" href="#common.patch.feedback" title="18.10.3.2.&nbsp;Code Formatting Conventions">Section&nbsp;18.10.3.2, &#8220;Code Formatting Conventions&#8221;</a> for code style. If your patch was
                    generated incorrectly or your code does not adhere to the code formatting
                    guidelines, you may be asked to redo some work.</p></div><div class="section" title="18.10.8.2.&nbsp;Unit Tests"><div class="titlepage"><div><div><h4 class="title"><a name="submitting.patches.tests"></a>18.10.8.2.&nbsp;Unit Tests</h4></div></div></div><p>Yes, please. Please try to include unit tests with every code patch (and
                    especially new classes and large changes). Make sure unit tests pass locally
                    before submitting the patch.</p><p>Also, see <a class="xref" href="#mockito" title="19.2.&nbsp;Mockito">Section&nbsp;19.2, &#8220;Mockito&#8221;</a>.</p><p>If you are creating a new unit test class, notice how other unit test classes
                    have classification/sizing annotations at the top and a static method on the
                    end. Be sure to include these in any new unit test files you generate. See <a class="xref" href="#hbase.tests" title="18.9.&nbsp;Tests">Section&nbsp;18.9, &#8220;Tests&#8221;</a> for more on how the annotations work. </p></div><div class="section" title="18.10.8.3.&nbsp;Integration Tests"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e21724"></a>18.10.8.3.&nbsp;Integration Tests</h4></div></div></div><p>Significant new features should provide an integration test in addition to
                    unit tests, suitable for exercising the new feature at different points in its
                    configuration space.</p></div><div class="section" title="18.10.8.4.&nbsp;ReviewBoard"><div class="titlepage"><div><div><h4 class="title"><a name="reviewboard"></a>18.10.8.4.&nbsp;ReviewBoard</h4></div></div></div><p>Patches larger than one screen, or patches that will be tricky to review,
                    should go through <a class="link" href="http://reviews.apache.org" target="_top">ReviewBoard</a>. </p><div class="procedure" title="Procedure&nbsp;18.3.&nbsp;Use ReviewBoard"><a name="d2875e21738"></a><p class="title"><b>Procedure&nbsp;18.3.&nbsp;Use ReviewBoard</b></p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>Register for an account if you don't already have one. It does not use
                            the credentials from <a class="link" href="http://issues.apache.org" target="_top">issues.apache.org</a>. Log in.</p></li><li class="step" title="Step 2"><p>Click <span class="guilabel">New Review Request</span>. </p></li><li class="step" title="Step 3"><p>Choose the <code class="literal">hbase-git</code> repository. Click Choose File
                            to select the diff and optionally a parent diff. Click <span class="guibutton">Create
                                Review Request</span>.</p></li><li class="step" title="Step 4"><p>Fill in the fields as required. At the minimum, fill in the
                                <span class="guilabel">Summary</span> and choose <code class="literal">hbase</code> as
                            the <span class="guilabel">Review Group</span>. If you fill in the
                                <span class="guilabel">Bugs</span> field, the review board links back to the
                            relevant JIRA. The more fields you fill in, the better. Click
                                <span class="guibutton">Publish</span> to make your review request public.
                            An email will be sent to everyone in the <code class="literal">hbase</code> group,
                            to review the patch.</p></li><li class="step" title="Step 5"><p>Back in your JIRA, click <span class="guimenu">More</span> &#8594; <span class="guisubmenu">Link</span> &#8594; <span class="guimenuitem">Web Link</span>, and paste in the URL of your ReviewBoard request. This
                            attaches the ReviewBoard to the JIRA, for easy access.</p></li><li class="step" title="Step 6"><p>To cancel the request, click <span class="guimenu">Close</span> &#8594; <span class="guimenuitem">Discarded</span>.</p></li></ol></div><p>For more information on how to use ReviewBoard, see <a class="link" href="http://www.reviewboard.org/docs/manual/1.5/" target="_top">the ReviewBoard
                        documentation</a>. </p></div><div class="section" title="18.10.8.5.&nbsp;Guide for HBase Committers"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e21808"></a>18.10.8.5.&nbsp;Guide for HBase Committers</h4></div></div></div><div class="section" title="18.10.8.5.1.&nbsp;New committers"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e21811"></a>18.10.8.5.1.&nbsp;New committers</h5></div></div></div><p>New committers are encouraged to first read Apache's generic committer
                        documentation: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="http://www.apache.org/dev/new-committers-guide.html" target="_top">Apache New Committer Guide</a>
                            </p></li><li class="listitem"><p><a class="link" href="http://www.apache.org/dev/committers.html" target="_top">Apache Committer FAQ</a>
                            </p></li></ul></div></div><div class="section" title="18.10.8.5.2.&nbsp;Review"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e21827"></a>18.10.8.5.2.&nbsp;Review</h5></div></div></div><p>HBase committers should, as often as possible, attempt to review patches
                        submitted by others. Ideally every submitted patch will get reviewed by a
                        committer <span class="emphasis"><em>within a few days</em></span>. If a committer reviews a
                        patch they have not authored, and believe it to be of sufficient quality,
                        then they can commit the patch, otherwise the patch should be cancelled with
                        a clear explanation for why it was rejected. </p><p>The list of submitted patches is in the <a class="link" href="https://issues.apache.org/jira/secure/IssueNavigator.jspa?mode=hide&amp;requestId=12312392" target="_top">HBase Review Queue</a>, which is ordered by time of last
                        modification. Committers should scan the list from top to bottom, looking
                        for patches that they feel qualified to review and possibly commit. </p><p>For non-trivial changes, it is required to get another committer to review
                        your own patches before commit. Use the <span class="guibutton">Submit Patch</span>
                        button in JIRA, just like other contributors, and then wait for a
                            <code class="literal">+1</code> response from another committer before committing.
                    </p></div><div class="section" title="18.10.8.5.3.&nbsp;Reject"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e21848"></a>18.10.8.5.3.&nbsp;Reject</h5></div></div></div><p>Patches which do not adhere to the guidelines in <a class="link" href="https://wiki.apache.org/hadoop/Hbase/HowToCommit/hadoop/Hbase/HowToContribute#" target="_top">HowToContribute</a> and to the <a class="link" href="https://wiki.apache.org/hadoop/Hbase/HowToCommit/hadoop/CodeReviewChecklist#" target="_top">code review checklist</a> should be rejected. Committers should
                        always be polite to contributors and try to instruct and encourage them to
                        contribute better patches. If a committer wishes to improve an unacceptable
                        patch, then it should first be rejected, and a new patch should be attached
                        by the committer for review. </p></div><div class="section" title="18.10.8.5.4.&nbsp;Commit"><div class="titlepage"><div><div><h5 class="title"><a name="committing.patches"></a>18.10.8.5.4.&nbsp;Commit</h5></div></div></div><p>Committers commit patches to the Apache HBase GIT repository. </p><div class="note" title="Before you commit!!!!" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Before you commit!!!!</h3><p>Make sure your local configuration is correct, especially your
                            identity and email. Examine the output of the <span class="command"><strong>$ git config
                                --list</strong></span> command and be sure it is correct. See this GitHub
                            article, <a class="link" href="https://help.github.com/articles/set-up-git" target="_top">Set Up Git</a> if you need pointers. </p></div><p>When you commit a patch, please: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Include the Jira issue id in the commit message, along with a
                                short description of the change and the name of the contributor if
                                it is not you. Be sure to get the issue ID right, as this causes
                                Jira to link to the change in Git (use the issue's
                                "All" tab to see these). </p></li><li class="listitem"><p>Commit the patch to a new branch based off master or other
                                intended branch. It's a good idea to call this branch by the JIRA
                                ID. Then check out the relevant target branch where you want to
                                commit, make sure your local branch has all remote changes, by doing
                                a <span class="command"><strong>git pull --rebase</strong></span> or another similar command,
                                cherry-pick the change into each relevant branch (such as master),
                                and do <span class="command"><strong>git push &lt;remote-server&gt;
                                    &lt;remote-branch&gt;</strong></span>.</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>If you do not have all remote changes, the push will fail. If
                                    the push fails for any reason, fix the problem or ask for help.
                                    Do not do a <span class="command"><strong>git push --force</strong></span>.</p></div><p>Before you can commit a patch, you need to determine how the patch
                                was created. The instructions and preferences around the way to
                                create patches have changed, and there will be a transition
                                periond.</p><div class="itemizedlist" title="Determine How a Patch Was Created"><p class="title"><b>Determine How a Patch Was Created</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>If the first few lines of the patch look like the headers
                                        of an email, with a From, Date, and Subject, it was created
                                        using <span class="command"><strong>git format-patch</strong></span>. This is the
                                        preference, because you can reuse the submitter's commit
                                        message. If the commit message is not appropriate, you can
                                        still use the commit, then run the command <span class="command"><strong>git
                                            rebase -i origin/master</strong></span>, and squash and reword
                                        as appropriate.</p></li><li class="listitem"><p>If the first line of the patch looks similar to the
                                        following, it was created using <span class="command"><strong>git diff</strong></span>
                                        without <code class="code">--no-prefix</code>. This is acceptable too.
                                        Notice the <code class="literal">a</code> and <code class="literal">b</code> in
                                        front of the file names. This is the indication that the
                                        patch was not created with <code class="code">--no-prefix</code>.</p><pre class="screen">diff --git <span class="emphasis"><em>a</em></span>/src/main/docbkx/developer.xml <span class="emphasis"><em>b</em></span>/src/main/docbkx/developer.xml</pre></li><li class="listitem"><p>If the first line of the patch looks similar to the
                                        following (without the <code class="literal">a</code> and
                                            <code class="literal">b</code>), the patch was created with
                                            <span class="command"><strong>git diff --no-prefix</strong></span> and you need to
                                        add <code class="code">-p0</code> to the <span class="command"><strong>git apply</strong></span>
                                        command below.</p><pre class="screen">diff --git src/main/docbkx/developer.xml src/main/docbkx/developer.xml</pre></li></ul></div><div class="example"><a name="d2875e21956"></a><p class="title"><b>Example&nbsp;18.3.&nbsp;Example of Committing a Patch</b></p><div class="example-contents"><p>One thing you will notice with these examples is that there
                                    are a lot of <span class="command"><strong>git pull</strong></span> commands. The only
                                    command that actually writes anything to the remote repository
                                    is <span class="command"><strong>git push</strong></span>, and you need to make absolutely
                                    sure you have the correct versions of everything and don't have
                                    any conflicts before pushing. The extra <span class="command"><strong>git
                                        pull</strong></span> commands are usually redundant, but better
                                    safe than sorry.</p><p>The first example shows how to apply a patch that was
                                    generated with <span class="command"><strong>git format-patch</strong></span> and apply it
                                    to the <code class="code">master</code> and <code class="code">branch-1</code> branches.
                                </p><p>The directive to use <span class="command"><strong>git format-patch</strong></span>
                                    rather than <span class="command"><strong>git diff</strong></span>, and not to use
                                        <code class="code">--no-prefix</code>, is a new one. See the second
                                    example for how to apply a patch created with <span class="command"><strong>git
                                        diff</strong></span>, and educate the person who created the
                                    patch.</p><pre class="screen">$ git checkout -b HBASE-XXXX
$ git am ~/Downloads/HBASE-XXXX-v2.patch
$ git checkout master
$ git pull --rebase
$ git cherry-pick &lt;sha-from-commit&gt;
# Resolve conflicts if necessary or ask the submitter to do it
$ git pull --rebase          # Better safe than sorry
$ git push origin master
$ git checkout branch-1
$ git pull --rebase
$ git cherry-pick &lt;sha-from-commit&gt;
# Resolve conflicts if necessary
$ git pull --rebase          # Better safe than sorry
$ git push origin branch-1
$ git branch -D HBASE-XXXX
                                </pre><p>This example shows how to commit a patch that was created
                                    using <span class="command"><strong>git diff</strong></span> without
                                        <code class="code">--no-prefix</code>. If the patch was created with
                                        <code class="code">--no-prefix</code>, add <code class="code">-p0</code> to the
                                        <span class="command"><strong>git apply</strong></span> command.</p><pre class="screen">$ git apply ~/Downloads/HBASE-XXXX-v2.patch 
$ git commit -m "HBASE-XXXX Really Good Code Fix (Joe Schmo)" -a # This extra step is needed for patches created with 'git diff'
$ git checkout master
$ git pull --rebase
$ git cherry-pick &lt;sha-from-commit&gt;
# Resolve conflicts if necessary or ask the submitter to do it
$ git pull --rebase          # Better safe than sorry
$ git push origin master
$ git checkout branch-1
$ git pull --rebase
$ git cherry-pick &lt;sha-from-commit&gt;
# Resolve conflicts if necessary or ask the submitter to do it
$ git pull --rebase           # Better safe than sorry
$ git push origin branch-1
$ git branch -D HBASE-XXXX</pre></div></div><br class="example-break"></li><li class="listitem"><p>Resolve the issue as fixed, thanking the contributor. Always set
                                the "Fix Version" at this point, but please only set a
                                single fix version for each branch where the change was committed,
                                the earliest release in that branch in which the change will appear.
                            </p></li></ol></div><div class="section" title="18.10.8.5.4.1.&nbsp;Commit Message Format"><div class="titlepage"><div><div><h6 class="title"><a name="d2875e22019"></a>18.10.8.5.4.1.&nbsp;Commit Message Format</h6></div></div></div><p>The commit message should contain the JIRA ID and a description of
                            what the patch does. The preferred commit message format is:</p><pre class="screen">&lt;jira-id&gt; &lt;jira-title&gt; (&lt;contributor-name-if-not-commit-author&gt;)</pre><pre class="screen">HBASE-12345 Fix All The Things (jane@example.com)</pre><p>If the contributor used <span class="command"><strong>git format-patch</strong></span> to
                            generate the patch, their commit message is in their patch and you can
                            use that, but be sure the JIRA ID is at the front of the commit message,
                            even if the contributor left it out.</p></div><div class="section" title="18.10.8.5.4.2.&nbsp;Add Amending-Author when a conflict cherrypick backporting"><div class="titlepage"><div><div><h6 class="title"><a name="committer.amending.author"></a>18.10.8.5.4.2.&nbsp;Add Amending-Author when a conflict cherrypick backporting</h6></div></div></div><p> We've established the practice of committing to trunk and then cherry
                            picking back to branches whenever possible. When there is a minor
                            conflict we can fix it up and just proceed with the commit. The
                            resulting commit retains the original author. When the amending author
                            is different from the original committer, add notice of this at the end
                            of the commit message as: <code class="varname">Amending-Author: Author
                                &lt;committer&amp;apache&gt;</code> See discussion at <a class="link" href="http://search-hadoop.com/m/DHED4wHGYS" target="_top">HBase, mail # dev
                                - [DISCUSSION] Best practice when amending commits cherry picked
                                from master to branch</a>. </p></div><div class="section" title="18.10.8.5.4.3.&nbsp;Committers are responsible for making sure commits do not break the build or tests"><div class="titlepage"><div><div><h6 class="title"><a name="committer.tests"></a>18.10.8.5.4.3.&nbsp;Committers are responsible for making sure commits do not break the
                            build or tests</h6></div></div></div><p> If a committer commits a patch, it is their responsibility to make
                            sure it passes the test suite. It is helpful if contributors keep an eye
                            out that their patch does not break the hbase build and/or tests, but
                            ultimately, a contributor cannot be expected to be aware of all the
                            particular vagaries and interconnections that occur in a project like
                            HBase. A committer should. </p></div><div class="section" title="18.10.8.5.4.4.&nbsp;Patching Etiquette"><div class="titlepage"><div><div><h6 class="title"><a name="git.patch.flow"></a>18.10.8.5.4.4.&nbsp;Patching Etiquette</h6></div></div></div><p>In the thread <a class="link" href="http://search-hadoop.com/m/DHED4EiwOz" target="_top">HBase, mail # dev - ANNOUNCEMENT: Git Migration In Progress (WAS =&gt;
                                Re: Git Migration)</a>, it was agreed on the following patch flow </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Develop and commit the patch against trunk/master
                                        first.</p></li><li class="listitem"><p>Try to cherry-pick the patch when backporting if
                                        possible.</p></li><li class="listitem"><p>If this does not work, manually commit the patch to the
                                        branch.</p></li></ol></div><p>
                        </p></div><div class="section" title="18.10.8.5.4.5.&nbsp;Merge Commits"><div class="titlepage"><div><div><h6 class="title"><a name="d2875e22068"></a>18.10.8.5.4.5.&nbsp;Merge Commits</h6></div></div></div><p>Avoid merge commits, as they create problems in the git
                            history.</p></div><div class="section" title="18.10.8.5.4.6.&nbsp;Committing Documentation"><div class="titlepage"><div><div><h6 class="title"><a name="d2875e22073"></a>18.10.8.5.4.6.&nbsp;Committing Documentation</h6></div></div></div><p>See <a class="xref" href="#appendix_contributing_to_documentation" title="Appendix&nbsp;A.&nbsp;Contributing to Documentation">Appendix&nbsp;A, <i>Contributing to Documentation</i></a>.</p></div></div></div><div class="section" title="18.10.8.6.&nbsp;Dialog"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e22080"></a>18.10.8.6.&nbsp;Dialog</h4></div></div></div><p>Committers should hang out in the #hbase room on irc.freenode.net for
                    real-time discussions. However any substantive discussion (as with any off-list
                    project-related discussion) should be re-iterated in Jira or on the developer
                    list. </p></div><div class="section" title="18.10.8.7.&nbsp;Do not edit JIRA comments"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e22085"></a>18.10.8.7.&nbsp;Do not edit JIRA comments</h4></div></div></div><p>Misspellings and/or bad grammar is preferable to the disruption a JIRA comment
                    edit causes: See the discussion at <a class="link" href="http://search-hadoop.com/?q=%5BReopened%5D+%28HBASE-451%29+Remove+HTableDescriptor+from+HRegionInfo&amp;fc_project=HBase" target="_top">Re:(HBASE-451) Remove HTableDescriptor from HRegionInfo</a>
                </p></div></div></div></div><div class="chapter" title="Chapter&nbsp;19.&nbsp;Unit Testing HBase Applications"><div class="titlepage"><div><div><h2 class="title"><a name="unit.tests"></a>Chapter&nbsp;19.&nbsp;Unit Testing HBase Applications</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e22105">19.1. JUnit</a></span></dt><dt><span class="section"><a href="#mockito">19.2. Mockito</a></span></dt><dt><span class="section"><a href="#d2875e22189">19.3. MRUnit</a></span></dt><dt><span class="section"><a href="#d2875e22218">19.4. Integration Testing with a HBase Mini-Cluster</a></span></dt></dl></div><p>This chapter discusses unit testing your HBase application using JUnit, Mockito, MRUnit,
        and HBaseTestingUtility. Much of the information comes from <a class="link" href="http://blog.cloudera.com/blog/2013/09/how-to-test-hbase-applications-using-popular-tools/" target="_top">a community blog post about testing HBase applications</a>. For information on unit
        tests for HBase itself, see <a class="xref" href="#hbase.tests" title="18.9.&nbsp;Tests">Section&nbsp;18.9, &#8220;Tests&#8221;</a>.</p><div class="section" title="19.1.&nbsp;JUnit"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22105"></a>19.1.&nbsp;JUnit</h2></div></div></div><p>HBase uses <a class="link" href="http://junit.org" target="_top">JUnit</a> 4 for unit tests</p><p>This example will add unit tests to the following example class:</p><pre class="programlisting">
public class MyHBaseDAO {

    public static void insertRecord(HTableInterface table, HBaseTestObj obj)
    throws Exception {
        Put put = createPut(obj);
        table.put(put);
    }
    
    private static Put createPut(HBaseTestObj obj) {
        Put put = new Put(Bytes.toBytes(obj.getRowKey()));
        put.add(Bytes.toBytes("CF"), Bytes.toBytes("CQ-1"),
                    Bytes.toBytes(obj.getData1()));
        put.add(Bytes.toBytes("CF"), Bytes.toBytes("CQ-2"),
                    Bytes.toBytes(obj.getData2()));
        return put;
    }
}                
            </pre><p>The first step is to add JUnit dependencies to your Maven POM file:</p><pre class="programlisting">
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;                
                </pre><p>Next, add some unit tests to your code. Tests are annotated with
                <code class="literal">@Test</code>. Here, the unit tests are in bold.</p><pre class="programlisting">
public class TestMyHbaseDAOData {
  @Test
  public void testCreatePut() throws Exception {
  HBaseTestObj obj = new HBaseTestObj();
  obj.setRowKey("ROWKEY-1");
  obj.setData1("DATA-1");
  obj.setData2("DATA-2");
  Put put = MyHBaseDAO.createPut(obj);
  <strong class="userinput"><code>assertEquals(obj.getRowKey(), Bytes.toString(put.getRow()));
  assertEquals(obj.getData1(), Bytes.toString(put.get(Bytes.toBytes("CF"), Bytes.toBytes("CQ-1")).get(0).getValue()));
  assertEquals(obj.getData2(), Bytes.toString(put.get(Bytes.toBytes("CF"), Bytes.toBytes("CQ-2")).get(0).getValue()));</code></strong>
  }
}                
            </pre><p>These tests ensure that your <code class="code">createPut</code> method creates, populates, and
            returns a <code class="code">Put</code> object with expected values. Of course, JUnit can do much
            more than this. For an introduction to JUnit, see <a class="link" href="https://github.com/junit-team/junit/wiki/Getting-started" target="_top">https://github.com/junit-team/junit/wiki/Getting-started</a>. </p></div><div class="section" title="19.2.&nbsp;Mockito"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mockito"></a>19.2.&nbsp;Mockito</h2></div></div></div><p>Mockito is a mocking framework. It goes further than JUnit by allowing you to test the
            interactions between objects without having to replicate the entire environment. You can
            read more about Mockito at its project site, <a class="link" href="https://code.google.com/p/mockito/" target="_top">https://code.google.com/p/mockito/</a>.</p><p>You can use Mockito to do unit testing on smaller units. For instance, you can mock a
                <code class="classname">org.apache.hadoop.hbase.Server</code> instance or a
                <code class="classname">org.apache.hadoop.hbase.master.MasterServices</code> interface
            reference rather than a full-blown
                <code class="classname">org.apache.hadoop.hbase.master.HMaster</code>.</p><p>This example builds upon the example code in <a class="xref" href="#unit.tests" title="Chapter&nbsp;19.&nbsp;Unit Testing HBase Applications">Chapter&nbsp;19, <i>Unit Testing HBase Applications</i></a>, to test the
                <code class="code">insertRecord</code> method.</p><p>First, add a dependency for Mockito to your Maven POM file.</p><pre class="programlisting">
&lt;dependency&gt;
    &lt;groupId&gt;org.mockito&lt;/groupId&gt;
    &lt;artifactId&gt;mockito-all&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;                   
                   </pre><p>Next, add a <code class="code">@RunWith</code> annotation to your test class, to direct it to use
            Mockito.</p><pre class="programlisting">
<strong class="userinput"><code>@RunWith(MockitoJUnitRunner.class)</code></strong>
public class TestMyHBaseDAO{
  @Mock 
  private HTableInterface table;
  @Mock
  private HTablePool hTablePool;
  @Captor
  private ArgumentCaptor putCaptor;

  @Test
  public void testInsertRecord() throws Exception {
    //return mock table when getTable is called
    when(hTablePool.getTable("tablename")).thenReturn(table);
    //create test object and make a call to the DAO that needs testing
    HBaseTestObj obj = new HBaseTestObj();
    obj.setRowKey("ROWKEY-1");
    obj.setData1("DATA-1");
    obj.setData2("DATA-2");
    MyHBaseDAO.insertRecord(table, obj);
    verify(table).put(putCaptor.capture());
    Put put = putCaptor.getValue();
  
    assertEquals(Bytes.toString(put.getRow()), obj.getRowKey());
    assert(put.has(Bytes.toBytes("CF"), Bytes.toBytes("CQ-1")));
    assert(put.has(Bytes.toBytes("CF"), Bytes.toBytes("CQ-2")));
    assertEquals(Bytes.toString(put.get(Bytes.toBytes("CF"),Bytes.toBytes("CQ-1")).get(0).getValue()), "DATA-1");
    assertEquals(Bytes.toString(put.get(Bytes.toBytes("CF"),Bytes.toBytes("CQ-2")).get(0).getValue()), "DATA-2");
  }
}                   
               </pre><p>This code populates <code class="code">HBaseTestObj</code> with &#8220;ROWKEY-1&#8221;, &#8220;DATA-1&#8221;, &#8220;DATA-2&#8221; as
            values. It then inserts the record into the mocked table. The Put that the DAO would
            have inserted is captured, and values are tested to verify that they are what you
            expected them to be.</p><p>The key here is to manage htable pool and htable instance creation outside the DAO.
            This allows you to mock them cleanly and test Puts as shown above. Similarly, you can
            now expand into other operations such as Get, Scan, or Delete.</p></div><div class="section" title="19.3.&nbsp;MRUnit"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22189"></a>19.3.&nbsp;MRUnit</h2></div></div></div><p><a class="link" href="http://mrunit.apache.org/" target="_top">Apache MRUnit</a> is a library that
            allows you to unit-test MapReduce jobs. You can use it to test HBase jobs in the same
            way as other MapReduce jobs.</p><p>Given a MapReduce job that writes to an HBase table called <code class="literal">MyTest</code>,
            which has one column family called <code class="literal">CF</code>, the reducer of such a job
            could look like the following:</p><pre class="programlisting">
public class MyReducer extends TableReducer&lt;Text, Text, ImmutableBytesWritable&gt; {
   public static final byte[] CF = "CF".getBytes();
   public static final byte[] QUALIFIER = "CQ-1".getBytes();
   public void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException {
     //bunch of processing to extract data to be inserted, in our case, lets say we are simply
     //appending all the records we receive from the mapper for this particular
     //key and insert one record into HBase
     StringBuffer data = new StringBuffer();
     Put put = new Put(Bytes.toBytes(key.toString()));
     for (Text val : values) {
         data = data.append(val);
     }
     put.add(CF, QUALIFIER, Bytes.toBytes(data.toString()));
     //write to HBase
     context.write(new ImmutableBytesWritable(Bytes.toBytes(key.toString())), put);
   }
 }                    
                </pre><p>To test this code, the first step is to add a dependency to MRUnit to your Maven POM
            file. </p><pre class="programlisting">
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.mrunit&lt;/groupId&gt;
   &lt;artifactId&gt;mrunit&lt;/artifactId&gt;
   &lt;version&gt;1.0.0 &lt;/version&gt;
   &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;                    
                    </pre><p>Next, use the ReducerDriver provided by MRUnit, in your Reducer job.</p><pre class="programlisting">
public class MyReducerTest {
    ReduceDriver&lt;Text, Text, ImmutableBytesWritable, Writable&gt; reduceDriver;
    byte[] CF = "CF".getBytes();
    byte[] QUALIFIER = "CQ-1".getBytes();

    @Before
    public void setUp() {
      MyReducer reducer = new MyReducer();
      reduceDriver = ReduceDriver.newReduceDriver(reducer);
    }
  
   @Test
   public void testHBaseInsert() throws IOException {
      String strKey = "RowKey-1", strValue = "DATA", strValue1 = "DATA1", 
strValue2 = "DATA2";
      List&lt;Text&gt; list = new ArrayList&lt;Text&gt;();
      list.add(new Text(strValue));
      list.add(new Text(strValue1));
      list.add(new Text(strValue2));
      //since in our case all that the reducer is doing is appending the records that the mapper   
      //sends it, we should get the following back
      String expectedOutput = strValue + strValue1 + strValue2;
     //Setup Input, mimic what mapper would have passed
      //to the reducer and run test
      reduceDriver.withInput(new Text(strKey), list);
      //run the reducer and get its output
      List&lt;Pair&lt;ImmutableBytesWritable, Writable&gt;&gt; result = reduceDriver.run();
    
      //extract key from result and verify
      assertEquals(Bytes.toString(result.get(0).getFirst().get()), strKey);
    
      //extract value for CF/QUALIFIER and verify
      Put a = (Put)result.get(0).getSecond();
      String c = Bytes.toString(a.get(CF, QUALIFIER).get(0).getValue());
      assertEquals(expectedOutput,c );
   }

}                    
                    </pre><p>Your MRUnit test verifies that the output is as expected, the Put that is inserted
            into HBase has the correct value, and the ColumnFamily and ColumnQualifier have the
            correct values.</p><p>MRUnit includes a MapperDriver to test mapping jobs, and you can use MRUnit to test
            other operations, including reading from HBase, processing data, or writing to
            HDFS,</p></div><div class="section" title="19.4.&nbsp;Integration Testing with a HBase Mini-Cluster"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22218"></a>19.4.&nbsp;Integration Testing with a HBase Mini-Cluster</h2></div></div></div><p>HBase ships with HBaseTestingUtility, which makes it easy to write integration tests
            using a <em class="firstterm">mini-cluster</em>. The first step is to add some dependencies
            to your Maven POM file. Check the versions to be sure they are appropriate.</p><pre class="programlisting">
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
    &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;type&gt;test-jar&lt;/type&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;
    &lt;artifactId&gt;hbase&lt;/artifactId&gt;
    &lt;version&gt;0.98.3&lt;/version&gt;
    &lt;type&gt;test-jar&lt;/type&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
        
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
    &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;type&gt;test-jar&lt;/type&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
    &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;
    &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;                    
                    </pre><p>This code represents an integration test for the MyDAO insert shown in <a class="xref" href="#unit.tests" title="Chapter&nbsp;19.&nbsp;Unit Testing HBase Applications">Chapter&nbsp;19, <i>Unit Testing HBase Applications</i></a>.</p><pre class="programlisting">
public class MyHBaseIntegrationTest {
    private static HBaseTestingUtility utility;
    byte[] CF = "CF".getBytes();
    byte[] QUALIFIER = "CQ-1".getBytes();
    
    @Before
    public void setup() throws Exception {
    	utility = new HBaseTestingUtility();
    	utility.startMiniCluster();
    }

    @Test
        public void testInsert() throws Exception {
       	 HTableInterface table = utility.createTable(Bytes.toBytes("MyTest"),
       			 Bytes.toBytes("CF"));
       	 HBaseTestObj obj = new HBaseTestObj();
       	 obj.setRowKey("ROWKEY-1");
       	 obj.setData1("DATA-1");
       	 obj.setData2("DATA-2");
       	 MyHBaseDAO.insertRecord(table, obj);
       	 Get get1 = new Get(Bytes.toBytes(obj.getRowKey()));
       	 get1.addColumn(CF, CQ1);
       	 Result result1 = table.get(get1);
       	 assertEquals(Bytes.toString(result1.getRow()), obj.getRowKey());
       	 assertEquals(Bytes.toString(result1.value()), obj.getData1());
       	 Get get2 = new Get(Bytes.toBytes(obj.getRowKey()));
       	 get2.addColumn(CF, CQ2);
       	 Result result2 = table.get(get2);
       	 assertEquals(Bytes.toString(result2.getRow()), obj.getRowKey());
       	 assertEquals(Bytes.toString(result2.value()), obj.getData2());
    }
}                    
                </pre><p>This code creates an HBase mini-cluster and starts it. Next, it creates a table called
                <code class="literal">MyTest</code> with one column family, <code class="literal">CF</code>. A record is
            inserted, a Get is performed from the same table, and the insertion is verified.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Starting the mini-cluster takes about 20-30 seconds, but that should be
                appropriate for integration testing. </p></div><p>To use an HBase mini-cluster on Microsoft Windows, you need to use a Cygwin
            environment.</p><p>See the paper at <a class="link" href="http://blog.sematext.com/2010/08/30/hbase-case-study-using-hbasetestingutility-for-local-testing-development/" target="_top">HBase Case-Study: Using HBaseTestingUtility for Local Testing and
                Development</a> (2010) for more information about HBaseTestingUtility.</p></div></div><div class="chapter" title="Chapter&nbsp;20.&nbsp;ZooKeeper"><div class="titlepage"><div><div><h2 class="title"><a name="zookeeper"></a>Chapter&nbsp;20.&nbsp;ZooKeeper<a class="indexterm" name="d2875e22256"></a></h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e22377">20.1. Using existing ZooKeeper ensemble</a></span></dt><dt><span class="section"><a href="#zk.sasl.auth">20.2. SASL Authentication with ZooKeeper</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e22443">20.2.1. Operating System Prerequisites</a></span></dt><dt><span class="section"><a href="#d2875e22524">20.2.2. HBase-managed Zookeeper Configuration</a></span></dt><dt><span class="section"><a href="#d2875e22601">20.2.3. External Zookeeper Configuration</a></span></dt><dt><span class="section"><a href="#d2875e22662">20.2.4. Zookeeper Server Authentication Log Output</a></span></dt><dt><span class="section"><a href="#d2875e22669">20.2.5. Zookeeper Client Authentication Log Output</a></span></dt><dt><span class="section"><a href="#d2875e22676">20.2.6. Configuration from Scratch</a></span></dt><dt><span class="section"><a href="#d2875e22687">20.2.7. Future improvements</a></span></dt></dl></dd></dl></div><p>A distributed Apache HBase installation depends on a running ZooKeeper cluster. All
    participating nodes and clients need to be able to access the running ZooKeeper ensemble. Apache
    HBase by default manages a ZooKeeper "cluster" for you. It will start and stop the ZooKeeper
    ensemble as part of the HBase start/stop process. You can also manage the ZooKeeper ensemble
    independent of HBase and just point HBase at the cluster it should use. To toggle HBase
    management of ZooKeeper, use the <code class="varname">HBASE_MANAGES_ZK</code> variable in
      <code class="filename">conf/hbase-env.sh</code>. This variable, which defaults to
      <code class="varname">true</code>, tells HBase whether to start/stop the ZooKeeper ensemble servers as
    part of HBase start/stop.</p><p>When HBase manages the ZooKeeper ensemble, you can specify ZooKeeper configuration using its
    native <code class="filename">zoo.cfg</code> file, or, the easier option is to just specify ZooKeeper
    options directly in <code class="filename">conf/hbase-site.xml</code>. A ZooKeeper configuration option
    can be set as a property in the HBase <code class="filename">hbase-site.xml</code> XML configuration file
    by prefacing the ZooKeeper option name with <code class="varname">hbase.zookeeper.property</code>. For
    example, the <code class="varname">clientPort</code> setting in ZooKeeper can be changed by setting the
      <code class="varname">hbase.zookeeper.property.clientPort</code> property. For all default values used
    by HBase, including ZooKeeper configuration, see <a class="xref" href="#hbase_default_configurations" title="HBase Default Configuration">HBase Default Configuration</a>. Look for the
      <code class="varname">hbase.zookeeper.property</code> prefix. For the full list of ZooKeeper configurations, see ZooKeeper's
          <code class="filename">zoo.cfg</code>. HBase does not ship with a <code class="filename">zoo.cfg</code> so
        you will need to browse the <code class="filename">conf</code> directory in an appropriate ZooKeeper
        download.</p><p>You must at least list the ensemble servers in <code class="filename">hbase-site.xml</code> using the
      <code class="varname">hbase.zookeeper.quorum</code> property. This property defaults to a single
    ensemble member at <code class="varname">localhost</code> which is not suitable for a fully distributed
    HBase. (It binds to the local machine only and remote clients will not be able to connect). </p><div class="note" title="How many ZooKeepers should I run?" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="how_many_zks"></a>How many ZooKeepers should I run?</h3><p>You can run a ZooKeeper ensemble that comprises 1 node only but in production it is
      recommended that you run a ZooKeeper ensemble of 3, 5 or 7 machines; the more members an
      ensemble has, the more tolerant the ensemble is of host failures. Also, run an odd number of
      machines. In ZooKeeper, an even number of peers is supported, but it is normally not used
      because an even sized ensemble requires, proportionally, more peers to form a quorum than an
      odd sized ensemble requires. For example, an ensemble with 4 peers requires 3 to form a
      quorum, while an ensemble with 5 also requires 3 to form a quorum. Thus, an ensemble of 5
      allows 2 peers to fail, and thus is more fault tolerant than the ensemble of 4, which allows
      only 1 down peer. </p><p>Give each ZooKeeper server around 1GB of RAM, and if possible, its own dedicated disk (A
      dedicated disk is the best thing you can do to ensure a performant ZooKeeper ensemble). For
      very heavily loaded clusters, run ZooKeeper servers on separate machines from RegionServers
      (DataNodes and TaskTrackers).</p></div><p>For example, to have HBase manage a ZooKeeper quorum on nodes
      <span class="emphasis"><em>rs{1,2,3,4,5}.example.com</em></span>, bound to port 2222 (the default is 2181)
    ensure <code class="varname">HBASE_MANAGE_ZK</code> is commented out or set to <code class="varname">true</code> in
      <code class="filename">conf/hbase-env.sh</code> and then edit <code class="filename">conf/hbase-site.xml</code>
    and set <code class="varname">hbase.zookeeper.property.clientPort</code> and
      <code class="varname">hbase.zookeeper.quorum</code>. You should also set
      <code class="varname">hbase.zookeeper.property.dataDir</code> to other than the default as the default
    has ZooKeeper persist data under <code class="filename">/tmp</code> which is often cleared on system
    restart. In the example below we have ZooKeeper persist to
      <code class="filename">/user/local/zookeeper</code>.</p><pre class="programlisting">
  &lt;configuration&gt;
    ...
    &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt;
      &lt;value&gt;2222&lt;/value&gt;
      &lt;description&gt;Property from ZooKeeper's config zoo.cfg.
      The port at which the clients will connect.
      &lt;/description&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
      &lt;value&gt;rs1.example.com,rs2.example.com,rs3.example.com,rs4.example.com,rs5.example.com&lt;/value&gt;
      &lt;description&gt;Comma separated list of servers in the ZooKeeper Quorum.
      For example, "host1.mydomain.com,host2.mydomain.com,host3.mydomain.com".
      By default this is set to localhost for local and pseudo-distributed modes
      of operation. For a fully-distributed setup, this should be set to a full
      list of ZooKeeper quorum servers. If HBASE_MANAGES_ZK is set in hbase-env.sh
      this is the list of servers which we will start/stop ZooKeeper on.
      &lt;/description&gt;
    &lt;/property&gt;
    &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
      &lt;value&gt;/usr/local/zookeeper&lt;/value&gt;
      &lt;description&gt;Property from ZooKeeper's config zoo.cfg.
      The directory where the snapshot is stored.
      &lt;/description&gt;
    &lt;/property&gt;
    ...
  &lt;/configuration&gt;</pre><div class="caution" title="What verion of ZooKeeper should I use?" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="zk.version"></a>What verion of ZooKeeper should I use?</h3><p>The newer version, the better. For example, some folks have been bitten by <a class="link" href="https://issues.apache.org/jira/browse/ZOOKEEPER-1277" target="_top">ZOOKEEPER-1277</a>. If
      running zookeeper 3.5+, you can ask hbase to make use of the new multi operation by enabling <a class="xref" href="#hbase.zookeeper.useMulti" title="hbase.zookeeper.useMulti"><code class="varname">hbase.zookeeper.useMulti</code></a>" in your <code class="filename">hbase-site.xml</code>. </p></div><div class="caution" title="ZooKeeper Maintenance" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">ZooKeeper Maintenance</h3><p>Be sure to set up the data dir cleaner described under <a class="link" href="http://zookeeper.apache.org/doc/r3.1.2/zookeeperAdmin.html#sc_maintenance" target="_top">Zookeeper
        Maintenance</a> else you could have 'interesting' problems a couple of months in; i.e.
      zookeeper could start dropping sessions if it has to run through a directory of hundreds of
      thousands of logs which is wont to do around leader reelection time -- a process rare but run
      on occasion whether because a machine is dropped or happens to hiccup.</p></div><div class="section" title="20.1.&nbsp;Using existing ZooKeeper ensemble"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22377"></a>20.1.&nbsp;Using existing ZooKeeper ensemble</h2></div></div></div><p>To point HBase at an existing ZooKeeper cluster, one that is not managed by HBase, set
        <code class="varname">HBASE_MANAGES_ZK</code> in <code class="filename">conf/hbase-env.sh</code> to
      false</p><pre class="screen">
  ...
  # Tell HBase whether it should manage its own instance of Zookeeper or not.
  export HBASE_MANAGES_ZK=false</pre><p>Next set ensemble locations and client port, if non-standard, in
        <code class="filename">hbase-site.xml</code>, or add a suitably configured
        <code class="filename">zoo.cfg</code> to HBase's <code class="filename">CLASSPATH</code>. HBase will prefer
      the configuration found in <code class="filename">zoo.cfg</code> over any settings in
        <code class="filename">hbase-site.xml</code>.</p><p>When HBase manages ZooKeeper, it will start/stop the ZooKeeper servers as a part of the
      regular start/stop scripts. If you would like to run ZooKeeper yourself, independent of HBase
      start/stop, you would do the following</p><pre class="screen">
${HBASE_HOME}/bin/hbase-daemons.sh {start,stop} zookeeper
</pre><p>Note that you can use HBase in this manner to spin up a ZooKeeper cluster, unrelated to
      HBase. Just make sure to set <code class="varname">HBASE_MANAGES_ZK</code> to <code class="varname">false</code>
      if you want it to stay up across HBase restarts so that when HBase shuts down, it doesn't take
      ZooKeeper down with it.</p><p>For more information about running a distinct ZooKeeper cluster, see the ZooKeeper <a class="link" href="http://hadoop.apache.org/zookeeper/docs/current/zookeeperStarted.html" target="_top">Getting
        Started Guide</a>. Additionally, see the <a class="link" href="http://wiki.apache.org/hadoop/ZooKeeper/FAQ#A7" target="_top">ZooKeeper Wiki</a> or the <a class="link" href="http://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html#sc_zkMulitServerSetup" target="_top">ZooKeeper
        documentation</a> for more information on ZooKeeper sizing. </p></div><div class="section" title="20.2.&nbsp;SASL Authentication with ZooKeeper"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="zk.sasl.auth"></a>20.2.&nbsp;SASL Authentication with ZooKeeper</h2></div></div></div><p>Newer releases of Apache HBase (&gt;= 0.92) will support connecting to a ZooKeeper Quorum
      that supports SASL authentication (which is available in Zookeeper versions 3.4.0 or
      later).</p><p>This describes how to set up HBase to mutually authenticate with a ZooKeeper Quorum.
      ZooKeeper/HBase mutual authentication (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-2418" target="_top">HBASE-2418</a>) is required
      as part of a complete secure HBase configuration (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-3025" target="_top">HBASE-3025</a>). For
      simplicity of explication, this section ignores additional configuration required (Secure HDFS
      and Coprocessor configuration). It's recommended to begin with an HBase-managed Zookeeper
      configuration (as opposed to a standalone Zookeeper quorum) for ease of learning. </p><div class="section" title="20.2.1.&nbsp;Operating System Prerequisites"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e22443"></a>20.2.1.&nbsp;Operating System Prerequisites</h3></div></div></div><p> You need to have a working Kerberos KDC setup. For each <code class="code">$HOST</code> that will
        run a ZooKeeper server, you should have a principle <code class="code">zookeeper/$HOST</code>. For each
        such host, add a service key (using the <code class="code">kadmin</code> or <code class="code">kadmin.local</code>
        tool's <code class="code">ktadd</code> command) for <code class="code">zookeeper/$HOST</code> and copy this file to
          <code class="code">$HOST</code>, and make it readable only to the user that will run zookeeper on
          <code class="code">$HOST</code>. Note the location of this file, which we will use below as
          <code class="filename">$PATH_TO_ZOOKEEPER_KEYTAB</code>. </p><p> Similarly, for each <code class="code">$HOST</code> that will run an HBase server (master or
        regionserver), you should have a principle: <code class="code">hbase/$HOST</code>. For each host, add a
        keytab file called <code class="filename">hbase.keytab</code> containing a service key for
          <code class="code">hbase/$HOST</code>, copy this file to <code class="code">$HOST</code>, and make it readable only
        to the user that will run an HBase service on <code class="code">$HOST</code>. Note the location of this
        file, which we will use below as <code class="filename">$PATH_TO_HBASE_KEYTAB</code>. </p><p> Each user who will be an HBase client should also be given a Kerberos principal. This
        principal should usually have a password assigned to it (as opposed to, as with the HBase
        servers, a keytab file) which only this user knows. The client's principal's
          <code class="code">maxrenewlife</code> should be set so that it can be renewed enough so that the user
        can complete their HBase client processes. For example, if a user runs a long-running HBase
        client process that takes at most 3 days, we might create this user's principal within
          <code class="code">kadmin</code> with: <code class="code">addprinc -maxrenewlife 3days</code>. The Zookeeper client
        and server libraries manage their own ticket refreshment by running threads that wake up
        periodically to do the refreshment. </p><p>On each host that will run an HBase client (e.g. <code class="code">hbase shell</code>), add the
        following file to the HBase home directory's <code class="filename">conf</code> directory:</p><pre class="programlisting">
Client {
  com.sun.security.auth.module.Krb5LoginModule required
  useKeyTab=false
  useTicketCache=true;
};
                </pre><p>We'll refer to this JAAS configuration file as <code class="filename">$CLIENT_CONF</code>
        below.</p></div><div class="section" title="20.2.2.&nbsp;HBase-managed Zookeeper Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e22524"></a>20.2.2.&nbsp;HBase-managed Zookeeper Configuration</h3></div></div></div><p>On each node that will run a zookeeper, a master, or a regionserver, create a <a class="link" href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jgss/tutorials/LoginConfigFile.html" target="_top">JAAS</a>
        configuration file in the conf directory of the node's <code class="filename">HBASE_HOME</code>
        directory that looks like the following:</p><pre class="programlisting">
Server {
  com.sun.security.auth.module.Krb5LoginModule required
  useKeyTab=true
  keyTab="$PATH_TO_ZOOKEEPER_KEYTAB"
  storeKey=true
  useTicketCache=false
  principal="zookeeper/$HOST";
};
Client {
  com.sun.security.auth.module.Krb5LoginModule required
  useKeyTab=true
  useTicketCache=false
  keyTab="$PATH_TO_HBASE_KEYTAB"
  principal="hbase/$HOST";
};
                </pre><p>where the <code class="filename">$PATH_TO_HBASE_KEYTAB</code> and
          <code class="filename">$PATH_TO_ZOOKEEPER_KEYTAB</code> files are what you created above, and
          <code class="code">$HOST</code> is the hostname for that node.</p><p>The <code class="code">Server</code> section will be used by the Zookeeper quorum server, while the
          <code class="code">Client</code> section will be used by the HBase master and regionservers. The path
        to this file should be substituted for the text <code class="filename">$HBASE_SERVER_CONF</code> in
        the <code class="filename">hbase-env.sh</code> listing below.</p><p> The path to this file should be substituted for the text
          <code class="filename">$CLIENT_CONF</code> in the <code class="filename">hbase-env.sh</code> listing below. </p><p>Modify your <code class="filename">hbase-env.sh</code> to include the following:</p><pre class="programlisting">
export HBASE_OPTS="-Djava.security.auth.login.config=$CLIENT_CONF"
export HBASE_MANAGES_ZK=true
export HBASE_ZOOKEEPER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
export HBASE_MASTER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
export HBASE_REGIONSERVER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
                </pre><p>where <code class="filename">$HBASE_SERVER_CONF</code> and <code class="filename">$CLIENT_CONF</code> are
        the full paths to the JAAS configuration files created above.</p><p>Modify your <code class="filename">hbase-site.xml</code> on each node that will run zookeeper,
        master or regionserver to contain:</p><pre class="programlisting">
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;$ZK_NODES&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.authProvider.1&lt;/name&gt;
    &lt;value&gt;org.apache.zookeeper.server.auth.SASLAuthenticationProvider&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.kerberos.removeHostFromPrincipal&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.kerberos.removeRealmFromPrincipal&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
                  </pre><p>where <code class="code">$ZK_NODES</code> is the comma-separated list of hostnames of the Zookeeper
        Quorum hosts.</p><p>Start your hbase cluster by running one or more of the following set of commands on the
        appropriate hosts: </p><pre class="screen">
bin/hbase zookeeper start
bin/hbase master start
bin/hbase regionserver start
                </pre></div><div class="section" title="20.2.3.&nbsp;External Zookeeper Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e22601"></a>20.2.3.&nbsp;External Zookeeper Configuration</h3></div></div></div><p>Add a JAAS configuration file that looks like:</p><pre class="programlisting">
Client {
  com.sun.security.auth.module.Krb5LoginModule required
  useKeyTab=true
  useTicketCache=false
  keyTab="$PATH_TO_HBASE_KEYTAB"
  principal="hbase/$HOST";
};
                </pre><p>where the <code class="filename">$PATH_TO_HBASE_KEYTAB</code> is the keytab created above for
        HBase services to run on this host, and <code class="code">$HOST</code> is the hostname for that node.
        Put this in the HBase home's configuration directory. We'll refer to this file's full
        pathname as <code class="filename">$HBASE_SERVER_CONF</code> below.</p><p>Modify your hbase-env.sh to include the following:</p><pre class="programlisting">
export HBASE_OPTS="-Djava.security.auth.login.config=$CLIENT_CONF"
export HBASE_MANAGES_ZK=false
export HBASE_MASTER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
export HBASE_REGIONSERVER_OPTS="-Djava.security.auth.login.config=$HBASE_SERVER_CONF"
                </pre><p>Modify your <code class="filename">hbase-site.xml</code> on each node that will run a master or
        regionserver to contain:</p><pre class="programlisting">
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;$ZK_NODES&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
                  
                </pre><p>where <code class="code">$ZK_NODES</code> is the comma-separated list of hostnames of the Zookeeper
        Quorum hosts.</p><p> Add a <code class="filename">zoo.cfg</code> for each Zookeeper Quorum host containing:</p><pre class="programlisting">
authProvider.1=org.apache.zookeeper.server.auth.SASLAuthenticationProvider
kerberos.removeHostFromPrincipal=true
kerberos.removeRealmFromPrincipal=true
                  </pre><p>Also on each of these hosts, create a JAAS configuration file containing:</p><pre class="programlisting">
Server {
  com.sun.security.auth.module.Krb5LoginModule required
  useKeyTab=true
  keyTab="$PATH_TO_ZOOKEEPER_KEYTAB"
  storeKey=true
  useTicketCache=false
  principal="zookeeper/$HOST";
};
                  </pre><p>where <code class="code">$HOST</code> is the hostname of each Quorum host. We will refer to the full
        pathname of this file as <code class="filename">$ZK_SERVER_CONF</code> below. </p><p> Start your Zookeepers on each Zookeeper Quorum host with:</p><pre class="programlisting">
SERVER_JVMFLAGS="-Djava.security.auth.login.config=$ZK_SERVER_CONF" bin/zkServer start
                  </pre><p> Start your HBase cluster by running one or more of the following set of commands on the
        appropriate nodes: </p><pre class="screen">
bin/hbase master start
bin/hbase regionserver start
                </pre></div><div class="section" title="20.2.4.&nbsp;Zookeeper Server Authentication Log Output"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e22662"></a>20.2.4.&nbsp;Zookeeper Server Authentication Log Output</h3></div></div></div><p>If the configuration above is successful, you should see something similar to the
        following in your Zookeeper server logs:</p><pre class="screen">
11/12/05 22:43:39 INFO zookeeper.Login: successfully logged in.
11/12/05 22:43:39 INFO server.NIOServerCnxnFactory: binding to port 0.0.0.0/0.0.0.0:2181
11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh thread started.
11/12/05 22:43:39 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:39 UTC 2011
11/12/05 22:43:39 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:39 UTC 2011
11/12/05 22:43:39 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:36:42 UTC 2011
..
11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler:
  Successfully authenticated client: authenticationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN;
  authorizationID=hbase/ip-10-166-175-249.us-west-1.compute.internal@HADOOP.LOCALDOMAIN.
11/12/05 22:43:59 INFO auth.SaslServerCallbackHandler: Setting authorizedID: hbase
11/12/05 22:43:59 INFO server.ZooKeeperServer: adding SASL authorization for authorizationID: hbase
                </pre></div><div class="section" title="20.2.5.&nbsp;Zookeeper Client Authentication Log Output"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e22669"></a>20.2.5.&nbsp;Zookeeper Client Authentication Log Output</h3></div></div></div><p>On the Zookeeper client side (HBase master or regionserver), you should see something
        similar to the following:</p><pre class="screen">
11/12/05 22:43:59 INFO zookeeper.ZooKeeper: Initiating client connection, connectString=ip-10-166-175-249.us-west-1.compute.internal:2181 sessionTimeout=180000 watcher=master:60000
11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Opening socket connection to server /10.166.175.249:2181
11/12/05 22:43:59 INFO zookeeper.RecoverableZooKeeper: The identifier of this process is 14851@ip-10-166-175-249
11/12/05 22:43:59 INFO zookeeper.Login: successfully logged in.
11/12/05 22:43:59 INFO client.ZooKeeperSaslClient: Client will use GSSAPI as SASL mechanism.
11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh thread started.
11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Socket connection established to ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, initiating session
11/12/05 22:43:59 INFO zookeeper.Login: TGT valid starting at:        Mon Dec 05 22:43:59 UTC 2011
11/12/05 22:43:59 INFO zookeeper.Login: TGT expires:                  Tue Dec 06 22:43:59 UTC 2011
11/12/05 22:43:59 INFO zookeeper.Login: TGT refresh sleeping until: Tue Dec 06 18:30:37 UTC 2011
11/12/05 22:43:59 INFO zookeeper.ClientCnxn: Session establishment complete on server ip-10-166-175-249.us-west-1.compute.internal/10.166.175.249:2181, sessionid = 0x134106594320000, negotiated timeout = 180000
                </pre></div><div class="section" title="20.2.6.&nbsp;Configuration from Scratch"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e22676"></a>20.2.6.&nbsp;Configuration from Scratch</h3></div></div></div><p>This has been tested on the current standard Amazon Linux AMI. First setup KDC and
        principals as described above. Next checkout code and run a sanity check.</p><pre class="screen">
git clone git://git.apache.org/hbase.git
cd hbase
mvn clean test -Dtest=TestZooKeeperACL
                </pre><p>Then configure HBase as described above. Manually edit target/cached_classpath.txt (see
        below): </p><pre class="screen">
bin/hbase zookeeper &amp;
bin/hbase master &amp;
bin/hbase regionserver &amp;
                </pre></div><div class="section" title="20.2.7.&nbsp;Future improvements"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e22687"></a>20.2.7.&nbsp;Future improvements</h3></div></div></div><div class="section" title="20.2.7.1.&nbsp;Fix target/cached_classpath.txt"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e22690"></a>20.2.7.1.&nbsp;Fix target/cached_classpath.txt</h4></div></div></div><p> You must override the standard hadoop-core jar file from the
            <code class="code">target/cached_classpath.txt</code> file with the version containing the
          HADOOP-7070 fix. You can use the following script to do this:</p><pre class="screen">
echo `find ~/.m2 -name "*hadoop-core*7070*SNAPSHOT.jar"` ':' `cat target/cached_classpath.txt` | sed 's/ //g' &gt; target/tmp.txt
mv target/tmp.txt target/cached_classpath.txt
                </pre></div><div class="section" title="20.2.7.2.&nbsp;Set JAAS configuration programmatically"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e22700"></a>20.2.7.2.&nbsp;Set JAAS configuration programmatically</h4></div></div></div><p>This would avoid the need for a separate Hadoop jar that fixes <a class="link" href="https://issues.apache.org/jira/browse/HADOOP-7070" target="_top">HADOOP-7070</a>.
        </p></div><div class="section" title="20.2.7.3.&nbsp;Elimination of kerberos.removeHostFromPrincipal and kerberos.removeRealmFromPrincipal"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e22708"></a>20.2.7.3.&nbsp;Elimination of <code class="code">kerberos.removeHostFromPrincipal</code> and
            <code class="code">kerberos.removeRealmFromPrincipal</code></h4></div></div></div><p></p></div></div></div></div><div class="chapter" title="Chapter&nbsp;21.&nbsp;Community"><div class="titlepage"><div><div><h2 class="title"><a name="community"></a>Chapter&nbsp;21.&nbsp;Community</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#decisions">21.1. Decisions</a></span></dt><dd><dl><dt><span class="section"><a href="#feature_branches">21.1.1. Feature Branches</a></span></dt><dt><span class="section"><a href="#patchplusonepolicy">21.1.2. Patch +1 Policy</a></span></dt><dt><span class="section"><a href="#hbase.fix.version.in.JIRA">21.1.3. How to set fix version in JIRA on issue resolve</a></span></dt><dt><span class="section"><a href="#hbase.when.to.close.JIRA">21.1.4. Policy on when to set a RESOLVED JIRA as CLOSED</a></span></dt><dt><span class="section"><a href="#no.permanent.state.in.zk">21.1.5. Only transient state in ZooKeeper!</a></span></dt></dl></dd><dt><span class="section"><a href="#community.roles">21.2. Community Roles</a></span></dt><dd><dl><dt><span class="section"><a href="#OWNER">21.2.1. Component Owner/Lieutenant</a></span></dt></dl></dd><dt><span class="section"><a href="#hbase.commit.msg.format">21.3. Commit Message format</a></span></dt></dl></div><div class="section" title="21.1.&nbsp;Decisions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="decisions"></a>21.1.&nbsp;Decisions</h2></div></div></div><div class="section" title="21.1.1.&nbsp;Feature Branches"><div class="titlepage"><div><div><h3 class="title"><a name="feature_branches"></a>21.1.1.&nbsp;Feature Branches</h3></div></div></div><p>Feature Branches are easy to make. You do not have to be a committer to make one. Just
        request the name of your branch be added to JIRA up on the developer's mailing list and a
        committer will add it for you. Thereafter you can file issues against your feature branch in
        Apache HBase JIRA. Your code you keep elsewhere -- it should be public so it can be observed
        -- and you can update dev mailing list on progress. When the feature is ready for commit, 3
        +1s from committers will get your feature merged. See <a class="link" href="http://search-hadoop.com/m/asM982C5FkS1" target="_top">HBase, mail # dev - Thoughts
              about large feature dev branches</a></p></div><div class="section" title="21.1.2.&nbsp;Patch +1 Policy"><div class="titlepage"><div><div><h3 class="title"><a name="patchplusonepolicy"></a>21.1.2.&nbsp;Patch +1 Policy</h3></div></div></div><p> The below policy is something we put in place 09/2012. It is a suggested policy rather
        than a hard requirement. We want to try it first to see if it works before we cast it in
        stone. </p><p> Apache HBase is made of <a class="link" href="https://issues.apache.org/jira/browse/HBASE#selectedTab=com.atlassian.jira.plugin.system.project%3Acomponents-panel" target="_top">components</a>.
        Components have one or more <a class="xref" href="#OWNER" title="21.2.1.&nbsp;Component Owner/Lieutenant">Section&nbsp;21.2.1, &#8220;Component Owner/Lieutenant&#8221;</a>s. See the 'Description' field on the <a class="link" href="https://issues.apache.org/jira/browse/HBASE#selectedTab=com.atlassian.jira.plugin.system.project%3Acomponents-panel" target="_top">components</a>
        JIRA page for who the current owners are by component. </p><p> Patches that fit within the scope of a single Apache HBase component require, at least,
        a +1 by one of the component's owners before commit. If owners are absent -- busy or
        otherwise -- two +1s by non-owners will suffice. </p><p> Patches that span components need at least two +1s before they can be committed,
        preferably +1s by owners of components touched by the x-component patch (TODO: This needs
        tightening up but I think fine for first pass). </p><p> Any -1 on a patch by anyone vetos a patch; it cannot be committed until the
        justification for the -1 is addressed. </p></div><div class="section" title="21.1.3.&nbsp;How to set fix version in JIRA on issue resolve"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.fix.version.in.JIRA"></a>21.1.3.&nbsp;How to set fix version in JIRA on issue resolve</h3></div></div></div><p>Here is how <a class="link" href="http://search-hadoop.com/m/azemIi5RCJ1" target="_top">we agreed</a> to set versions in
        JIRA when we resolve an issue. If trunk is going to be 0.98.0 then: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p> Commit only to trunk: Mark with 0.98 </p></li><li class="listitem"><p> Commit to 0.95 and trunk : Mark with 0.98, and 0.95.x </p></li><li class="listitem"><p> Commit to 0.94.x and 0.95, and trunk: Mark with 0.98, 0.95.x, and 0.94.x </p></li><li class="listitem"><p> Commit to 89-fb: Mark with 89-fb. </p></li><li class="listitem"><p> Commit site fixes: no version </p></li></ul></div></div><div class="section" title="21.1.4.&nbsp;Policy on when to set a RESOLVED JIRA as CLOSED"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.when.to.close.JIRA"></a>21.1.4.&nbsp;Policy on when to set a RESOLVED JIRA as CLOSED</h3></div></div></div><p>We <a class="link" href="http://search-hadoop.com/m/4cIKs1iwXMS1" target="_top">agreed</a> that for issues that
        list multiple releases in their <span class="emphasis"><em>Fix Version/s</em></span> field, CLOSE the issue on
        the release of any of the versions listed; subsequent change to the issue must happen in a
        new JIRA. </p></div><div class="section" title="21.1.5.&nbsp;Only transient state in ZooKeeper!"><div class="titlepage"><div><div><h3 class="title"><a name="no.permanent.state.in.zk"></a>21.1.5.&nbsp;Only transient state in ZooKeeper!</h3></div></div></div><p> You should be able to kill the data in zookeeper and hbase should ride over it
        recreating the zk content as it goes. This is an old adage around these parts. We just made
        note of it now. We also are currently in violation of this basic tenet -- replication at
        least keeps permanent state in zk -- but we are working to undo this breaking of a golden
        rule. </p></div></div><div class="section" title="21.2.&nbsp;Community Roles"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="community.roles"></a>21.2.&nbsp;Community Roles</h2></div></div></div><div class="section" title="21.2.1.&nbsp;Component Owner/Lieutenant"><div class="titlepage"><div><div><h3 class="title"><a name="OWNER"></a>21.2.1.&nbsp;Component Owner/Lieutenant</h3></div></div></div><p> Component owners are listed in the description field on this Apache HBase JIRA <a class="link" href="https://issues.apache.org/jira/browse/HBASE#selectedTab=com.atlassian.jira.plugin.system.project%3Acomponents-panel" target="_top">components</a>
        page. The owners are listed in the 'Description' field rather than in the 'Component Lead'
        field because the latter only allows us list one individual whereas it is encouraged that
        components have multiple owners. </p><p> Owners or component lieutenants are volunteers who are (usually, but not necessarily)
        expert in their component domain and may have an agenda on how they think their Apache HBase
        component should evolve. </p><div class="orderedlist" title="Component Owner Duties"><p class="title"><b>Component Owner Duties</b></p><ol class="orderedlist" type="1"><li class="listitem"><p> Owners will try and review patches that land within their component's scope.
          </p></li><li class="listitem"><p> If applicable, if an owner has an agenda, they will publish their goals or the
            design toward which they are driving their component </p></li></ol></div><p> If you would like to be volunteer as a component owner, just write the dev list and
        we'll sign you up. Owners do not need to be committers. </p></div></div><div class="section" title="21.3.&nbsp;Commit Message format"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hbase.commit.msg.format"></a>21.3.&nbsp;Commit Message format</h2></div></div></div><p>We <a class="link" href="http://search-hadoop.com/m/Gwxwl10cFHa1" target="_top">agreed</a> to the following SVN
      commit message format:
      </p><pre class="programlisting">HBASE-xxxxx &lt;title&gt;. (&lt;contributor&gt;)</pre><p> If the person
      making the commit is the contributor, leave off the '(&lt;contributor&gt;)' element. </p></div></div><div class="appendix" title="Appendix&nbsp;A.&nbsp;Contributing to Documentation"><div class="titlepage"><div><div><h2 class="title"><a name="appendix_contributing_to_documentation"></a>Appendix&nbsp;A.&nbsp;Contributing to Documentation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e22874">A.1. Getting Access to the Wiki</a></span></dt><dt><span class="section"><a href="#d2875e22882">A.2. Contributing to Documentation or Other Strings</a></span></dt><dt><span class="section"><a href="#d2875e22953">A.3. Editing the HBase Website</a></span></dt><dt><span class="section"><a href="#d2875e22982">A.4. Editing the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#d2875e23001">A.5. Auto-Generated Content</a></span></dt><dt><span class="section"><a href="#d2875e23016">A.6. Multi-Page and Single-Page Output</a></span></dt><dt><span class="section"><a href="#d2875e23039">A.7. Images in the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#d2875e23055">A.8. Adding a New Chapter to the HBase Reference Guide</a></span></dt><dt><span class="section"><a href="#d2875e23066">A.9. Docbook Common Issues</a></span></dt></dl></div><p>The Apache HBase project welcomes contributions to all aspects of the project, including
        the documentation. In HBase, documentation includes the following areas, and probably some
        others:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The <a class="link" href="http://hbase.apache.org/book.html" target="_top">HBase Reference
                    Guide</a> (this book)</p></li><li class="listitem"><p>The <a class="link" href="http://hbase.apache.org/" target="_top">HBase website</a>e</p></li><li class="listitem"><p>The <a class="link" href="http://wiki.apache.org/hadoop/Hbase" target="_top">HBase
                Wiki</a></p></li><li class="listitem"><p>API documentation</p></li><li class="listitem"><p>Command-line utility output and help text</p></li><li class="listitem"><p>Web UI strings, explicit help text, context-sensitive strings, and others</p></li><li class="listitem"><p>Log messages</p></li><li class="listitem"><p>Comments in source files, configuration files, and others</p></li><li class="listitem"><p>Localization of any of the above into target languages other than English</p></li></ul></div><p>No matter which area you want to help out with, the first step is almost always to
        download (typically by cloning the Git repository) and familiarize yourself with the HBase
        source code. The only exception in the list above is the HBase Wiki, which is edited online.
        For information on downloading and building the source, see <a class="xref" href="#developer" title="Chapter&nbsp;18.&nbsp;Building and Developing Apache HBase">Chapter&nbsp;18, <i>Building and Developing Apache HBase</i></a>.</p><div class="section" title="A.1.&nbsp;Getting Access to the Wiki"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22874"></a>A.1.&nbsp;Getting Access to the Wiki</h2></div></div></div><p>The HBase Wiki is not well-maintained and much of its content has been moved into the
            HBase Reference Guide (this guide). However, some pages on the Wiki are well maintained,
            and it would be great to have some volunteers willing to help out with the Wiki. To
            request access to the Wiki, register a new account at <a class="link" href="https://wiki.apache.org/hadoop/Hbase?action=newaccount" target="_top">https://wiki.apache.org/hadoop/Hbase?action=newaccount</a>. Contact one of the
            HBase committers, who can either give you access or refer you to someone who can.</p></div><div class="section" title="A.2.&nbsp;Contributing to Documentation or Other Strings"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22882"></a>A.2.&nbsp;Contributing to Documentation or Other Strings</h2></div></div></div><p> If you spot an error in a string in a UI, utility, script, log message, or elsewhere,
            or you think something could be made more clear, or you think text needs to be added
            where it doesn't currently exist, the first step is to file a JIRA. Be sure to set the
            component to <code class="literal">Documentation</code> in addition any other involved components.
            Most components have one or more default owners, who monitor new issues which come into
            those queues. Regardless of whether you feel able to fix the bug, you should still file
            bugs where you see them.</p><p>If you want to try your hand at fixing your newly-filed bug, assign it to yourself.
            You will need to clone the HBase Git repository to your local system and work on the
            issue there. When you have developed a potential fix, submit it for review. If it
            addresses the issue and is seen as an improvement, one of the HBase committers will
            commit it to one or more branches, as appropriate.</p><div class="procedure" title="Procedure&nbsp;A.1.&nbsp;Suggested Work flow for Submitting Patches"><a name="submit_doc_patch_procedure"></a><p class="title"><b>Procedure&nbsp;A.1.&nbsp;Suggested Work flow for Submitting Patches</b></p><p>This procedure goes into more detail than Git pros will need, but is included in
                this appendix so that people unfamiliar with Git can feel confident contributing to
                HBase while they learn.</p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>If you have not already done so, clone the Git repository locally. You only
                    need to do this once.</p></li><li class="step" title="Step 2"><p>Fairly often, pull remote changes into your local repository by using the
                        <code class="code">git pull</code> command, while your master branch is checked
                    out.</p></li><li class="step" title="Step 3"><p>For each issue you work on, create a new branch. One convention that works
                    well for naming the branches is to name a given branch the same as the JIRA it
                    relates to:</p><pre class="screen">$ git checkout -b HBASE-123456</pre></li><li class="step" title="Step 4"><p>Make your suggested changes on your branch, committing your changes to your
                    local repository often. If you need to switch to working on a different issue,
                    remember to check out the appropriate branch.</p></li><li class="step" title="Step 5"><p>When you are ready to submit your patch, first be sure that HBase builds
                    cleanly and behaves as expected in your modified branch. If you have made
                    documentation changes, be sure the documentation and website builds.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Before you use the <code class="literal">site</code> target the very first time, be
                        sure you have built HBase at least once, in order to fetch all the Maven
                        dependencies you need.</p></div><pre class="screen">$ mvn clean install -DskipTests               # Builds HBase</pre><pre class="screen">$ mvn clean site -DskipTests                  # Builds the website and documentation</pre><p>If any errors occur, address them.</p></li><li class="step" title="Step 6"><p>If it takes you several days or weeks to implement your fix, or you know that
                    the area of the code you are working in has had a lot of changes lately, make
                    sure you rebase your branch against the remote master and take care of any
                    conflicts before submitting your patch.</p><pre class="screen">
$ git checkout HBASE-123456
$ git rebase origin/master                
                </pre></li><li class="step" title="Step 7"><p>Generate your patch against the remote master. Run the following command from
                    the top level of your git repository (usually called
                    <code class="literal">hbase</code>):</p><pre class="screen">$ git diff --no-prefix origin/master &gt; HBASE-123456.patch</pre><p>The name of the patch should contain the JIRA ID. Look over the patch file to
                    be sure that you did not change any additional files by accident and that there
                    are no other surprises. When you are satisfied, attach the patch to the JIRA and
                    click the <span class="guibutton">Patch Available</span> button. A reviewer
                    will review your patch. If you need to submit a new version of the patch, leave
                    the old one on the JIRA and add a version number to the name of the new
                    patch.</p></li><li class="step" title="Step 8"><p>After a change has been committed, there is no need to keep your local branch
                    around. Instead you should run <span class="command"><strong>git pull</strong></span> to get the new change
                    into your master branch.</p></li></ol></div></div><div class="section" title="A.3.&nbsp;Editing the HBase Website"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22953"></a>A.3.&nbsp;Editing the HBase Website</h2></div></div></div><p>The source for the HBase website is in the HBase source, in the
                <code class="filename">src/main/site/</code> directory. Within this directory, source for the
            individual pages is in the <code class="filename">xdocs/</code> directory, and images referenced
            in those pages are in the <code class="filename">images/</code> directory. This directory also
            stores images used in the HBase Reference Guide.</p><p>The website's pages are written in an HTML-like XML dialect called xdoc, which has a
            reference guide at <a class="link" href="http://maven.apache.org/archives/maven-1.x/plugins/xdoc/reference/xdocs.html" target="_top">http://maven.apache.org/archives/maven-1.x/plugins/xdoc/reference/xdocs.html</a>.
            You can edit these files in a plain-text editor, an IDE, or an XML editor such as
            XML Mind XML Editor (XXE) or Oxygen XML Author. </p><p>To preview your changes, build the website using the <span class="command"><strong>mvn clean site
                -DskipTests</strong></span> command. The HTML output resides in the
                <code class="filename">target/site/</code> directory. When you are satisfied with your
            changes, follow the procedure in <a class="xref" href="#submit_doc_patch_procedure" title="Procedure&nbsp;A.1.&nbsp;Suggested Work flow for Submitting Patches">Procedure&nbsp;A.1, &#8220;Suggested Work flow for Submitting Patches&#8221;</a> to submit
            your patch.</p></div><div class="section" title="A.4.&nbsp;Editing the HBase Reference Guide"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e22982"></a>A.4.&nbsp;Editing the HBase Reference Guide</h2></div></div></div><p>The source for the HBase Reference Guide is in the HBase source, in the
                <code class="filename">src/main/docbkx/</code> directory. It is written in <a class="link" href="http://www.docbook.org/" target="_top">Docbook</a> XML. Docbook can be
            intimidating, but you can typically follow the formatting of the surrounding file to get
            an idea of the mark-up. You can edit Docbook XML files using a plain-text editor, an
            XML-aware IDE, or a specialized XML editor.</p><p>Docbook's syntax can be picky. Before submitting a patch, be sure to build the output
            locally using the <span class="command"><strong>mvn site</strong></span> command. If you do not get any build
            errors, that means that the XML is well-formed, which means that each opening tag is
            balanced by a closing tag. Well-formedness is not exactly the same as validity. Check
            the output in <code class="filename">target/docbkx/</code> for any surprises before submitting a
            patch.</p></div><div class="section" title="A.5.&nbsp;Auto-Generated Content"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23001"></a>A.5.&nbsp;Auto-Generated Content</h2></div></div></div><p>Some parts of the HBase Reference Guide, most notably <a class="xref" href="#config.files" title="2.4.&nbsp;Configuration Files">Section&nbsp;2.4, &#8220;Configuration Files&#8221;</a>,
            are generated automatically, so that this area of the documentation stays in sync with
            the code. This is done by means of an XSLT transform, which you can examine in the
            source at <code class="filename">src/main/xslt/configuration_to_docbook_section.xsl</code>. This
            transforms the <code class="filename">hbase-common/src/main/resources/hbase-default.xml</code>
            file into a Docbook output which can be included in the Reference Guide. Sometimes, it
            is necessary to add configuration parameters or modify their descriptions. Make the
            modifications to the source file, and they will be included in the Reference Guide when
            it is rebuilt.</p><p>It is possible that other types of content can and will be automatically generated
            from HBase source files in the future.</p></div><div class="section" title="A.6.&nbsp;Multi-Page and Single-Page Output"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23016"></a>A.6.&nbsp;Multi-Page and Single-Page Output</h2></div></div></div><p>You can examine the <code class="literal">site</code> target in the Maven
                <code class="filename">pom.xml</code> file included at the top level of the HBase source for
            details on the process of building the website and documentation. The Reference Guide is
            built twice, once as a single-page output and once with one HTML file per chapter. The
            single-page output is located in <code class="filename">target/docbkx/book.html</code>, while the
            multi-page output's index page is at <code class="filename">target/docbkx/book/book.html</code>.
            Each of these outputs has its own <code class="filename">images/</code> and
                <code class="filename">css/</code> directories, which are created at build time.</p></div><div class="section" title="A.7.&nbsp;Images in the HBase Reference Guide"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23039"></a>A.7.&nbsp;Images in the HBase Reference Guide</h2></div></div></div><p>You can include images in the HBase Reference Guide. For accessibility reasons, it is
            recommended that you use a &lt;figure&gt; Docbook element for an image. This allows
            screen readers to navigate to the image and also provides alternative text for the
            image. The following is an example of a &lt;figure&gt; element.</p><pre class="programlisting">&lt;figure&gt;
  &lt;title&gt;HFile Version 1&lt;/title&gt;
  &lt;mediaobject&gt;
    &lt;imageobject&gt;
      &lt;imagedata fileref="timeline_consistency.png" /&gt;
    &lt;/imageobject&gt;
    &lt;textobject&gt;
      &lt;phrase&gt;HFile Version 1&lt;/phrase&gt;
    &lt;/textobject&gt;
  &lt;/mediaobject&gt;
&lt;/figure&gt;
        </pre><p>The &lt;textobject&gt; can contain a few sentences describing the image, rather than
            simply reiterating the title. You can optionally specify alignment and size options in
            the &lt;imagedata&gt; element.</p><p>When doing a local build, save the image to the
                <code class="filename">src/main/site/resources/images/</code> directory. In the
            &lt;imagedata&gt; element, refer to the image as above, with no directory component. The
            image will be copied to the appropriate target location during the build of the
            output.</p><p>When you submit a patch which includes adding an image to the HBase Reference Guide,
            attach the image to the JIRA. If the committer asks where the image should be committed,
            it should go into the above directory.</p></div><div class="section" title="A.8.&nbsp;Adding a New Chapter to the HBase Reference Guide"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23055"></a>A.8.&nbsp;Adding a New Chapter to the HBase Reference Guide</h2></div></div></div><p>If you want to add a new chapter to the HBase Reference Guide, the easiest way is to
            copy an existing chapter file, rename it, and change the ID and title elements near the
            top of the file. Delete the existing content and create the new content. Then open the
                <code class="filename">book.xml</code> file, which is the main file for the HBase Reference
            Guide, and use an &lt;xi:include&gt; element to include your new chapter in the
            appropriate location. Be sure to add your new file to your Git repository before
            creating your patch. Note that the <code class="filename">book.xml</code> file currently contains
            many chapters. You can only include a chapter at the same nesting levels as the other
            chapters in the file. When in doubt, check to see how other files have been
            included.</p></div><div class="section" title="A.9.&nbsp;Docbook Common Issues"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23066"></a>A.9.&nbsp;Docbook Common Issues</h2></div></div></div><p>The following Docbook issues come up often. Some of these are preferences, but others
            can create mysterious build errors or other problems.</p><div class="qandaset" title="Frequently Asked Questions"><a name="d2875e23071"></a><dl><dt>A.9.1. <a href="#d2875e23072">What can go where?</a></dt><dt>A.9.2. <a href="#d2875e23082">Paragraphs and Admonitions</a></dt><dt>A.9.3. <a href="#d2875e23091">Wrap textual &lt;listitem&gt; and &lt;entry&gt; contents in &lt;para&gt;
                        elements.</a></dt><dt>A.9.4. <a href="#d2875e23100">When to use &lt;command&gt;, &lt;code&gt;, &lt;programlisting&gt;,
                        &lt;screen&gt;</a></dt><dt>A.9.5. <a href="#d2875e23117">How to escape XML elements so that they show up as XML</a></dt><dt>A.9.6. <a href="#d2875e23124">Tips and tricks for making screen output look good</a></dt><dt>A.9.7. <a href="#d2875e23143">Isolate Changes for Easy Diff Review.</a></dt><dt>A.9.8. <a href="#d2875e23150">Syntax Highlighting</a></dt></dl><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"><col><tbody><tr class="question" title="A.9.1."><td align="left" valign="top"><a name="d2875e23072"></a><a name="d2875e23073"></a><p><b>A.9.1.</b></p></td><td align="left" valign="top"><p>What can go where?</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>There is often confusion about which child elements are valid in a given
                        context. When in doubt, <a class="link" href="http://docbook.org/tdg/en/html/docbook.html" target="_top">Docbook: The
                            Definitive Guide</a> is the best resource. It has an appendix which
                        is indexed by element and contains all valid child and parent elements of
                        any given element. If you edit Docbook often, a schema-aware XML editor
                        makes things easier.</p></td></tr><tr class="question" title="A.9.2."><td align="left" valign="top"><a name="d2875e23082"></a><a name="d2875e23083"></a><p><b>A.9.2.</b></p></td><td align="left" valign="top"><p>Paragraphs and Admonitions</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>It is a common pattern, and it is technically valid, to put an admonition
                        such as a &lt;note&gt; inside a &lt;para&gt; element. Because admonitions
                        render as block-level elements (they take the whole width of the page), it
                        is better to mark them up as siblings to the paragraphs around them, like
                        this:</p><pre class="programlisting">&lt;para&gt;This is the paragraph.&lt;/para&gt;
&lt;note&gt;
    &lt;para&gt;This is an admonition which occurs after the paragraph.&lt;/para&gt;
&lt;/note&gt;</pre></td></tr><tr class="question" title="A.9.3."><td align="left" valign="top"><a name="d2875e23091"></a><a name="d2875e23092"></a><p><b>A.9.3.</b></p></td><td align="left" valign="top"><p>Wrap textual &lt;listitem&gt; and &lt;entry&gt; contents in &lt;para&gt;
                        elements.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Because the contents of a &lt;listitem&gt; (an element in an itemized,
                        ordered, or variable list) or an &lt;entry&gt; (a cell in a table) can
                        consist of things other than plain text, they need to be wrapped in some
                        element. If they are plain text, they need to be inclosed in &lt;para&gt;
                        tags. This is tedious but necessary for validity.</p><pre class="programlisting">&lt;itemizedlist&gt;
    &lt;listitem&gt;
        &lt;para&gt;This is a paragraph.&lt;/para&gt;
    &lt;/listitem&gt;
    &lt;listitem&gt;
        &lt;screen&gt;This is screen output.&lt;/screen&gt;
    &lt;/listitem&gt;
&lt;/itemizedlist&gt;</pre></td></tr><tr class="question" title="A.9.4."><td align="left" valign="top"><a name="d2875e23100"></a><a name="d2875e23101"></a><p><b>A.9.4.</b></p></td><td align="left" valign="top"><p>When to use &lt;command&gt;, &lt;code&gt;, &lt;programlisting&gt;,
                        &lt;screen&gt;</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>The first two are in-line tags, which can occur within the flow of
                        paragraphs or titles. The second two are block elements.</p><p>Use &lt;command&gt; to mention a command such as <span class="command"><strong>hbase
                            shell</strong></span> in the flow of a sentence. Use &lt;code&gt; for other
                        inline text referring to code. Incidentally, use &lt;literal&gt; to specify
                        literal strings that should be typed or entered exactly as shown. Within a
                        &lt;screen&gt; listing, it can be helpful to use the &lt;userinput&gt; and
                        &lt;computeroutput&gt; elements to mark up the text further.</p><p>Use &lt;screen&gt; to display input and output as the user would
                            <span class="emphasis"><em>see</em></span> it on the screen, in a log file, etc. Use
                        &lt;programlisting&gt; only for blocks of code that occur within a file,
                        such as Java or XML code, or a Bash shell script.</p></td></tr><tr class="question" title="A.9.5."><td align="left" valign="top"><a name="d2875e23117"></a><a name="d2875e23118"></a><p><b>A.9.5.</b></p></td><td align="left" valign="top"><p>How to escape XML elements so that they show up as XML</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>For one-off instances or short in-line mentions, use the &amp;lt; and
                        &amp;gt; encoded characters. For longer mentions, or blocks of code, enclose
                        it with &amp;lt;![CDATA[]]&amp;gt;, which is much easier to maintain and
                        parse in the source files..</p></td></tr><tr class="question" title="A.9.6."><td align="left" valign="top"><a name="d2875e23124"></a><a name="d2875e23125"></a><p><b>A.9.6.</b></p></td><td align="left" valign="top"><p>Tips and tricks for making screen output look good</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Text within &lt;screen&gt; and &lt;programlisting&gt; elements is shown
                        exactly as it appears in the source, including indentation, tabs, and line
                        wrap.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Indent the starting and closing XML elements, but do not indent
                                the content. Also, to avoid having an extra blank line at the
                                beginning of the programlisting output, do not put the CDATA
                                element on its own line. For example:</p><pre class="programlisting">        &lt;programlisting&gt;
case $1 in
  --cleanZk|--cleanHdfs|--cleanAll)
    matches="yes" ;;
  *) ;;
esac
        &lt;/programlisting&gt;</pre></li><li class="listitem"><p>After pasting code into a programlisting, fix the indentation
                                manually, using two <span class="emphasis"><em>spaces</em></span> per desired
                                indentation. For screen output, be sure to include line breaks so
                                that the text is no longer than 100 characters.</p></li></ul></div></td></tr><tr class="question" title="A.9.7."><td align="left" valign="top"><a name="d2875e23143"></a><a name="d2875e23144"></a><p><b>A.9.7.</b></p></td><td align="left" valign="top"><p>Isolate Changes for Easy Diff Review.</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>Be careful with pretty-printing or re-formatting an entire XML file, even
                        if the formatting has degraded over time. If you need to reformat a file, do
                        that in a separate JIRA where you do not change any content. Be careful
                        because some XML editors do a bulk-reformat when you open a new file,
                        especially if you use GUI mode in the editor.</p></td></tr><tr class="question" title="A.9.8."><td align="left" valign="top"><a name="d2875e23150"></a><a name="d2875e23151"></a><p><b>A.9.8.</b></p></td><td align="left" valign="top"><p>Syntax Highlighting</p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>The HBase Reference Guide uses the <a class="link" href="http://sourceforge.net/projects/xslthl/files/xslthl/2.1.0/" target="_top">XSLT Syntax Highlighting</a> Maven module for syntax highlighting.
                        To enable syntax highlighting for a given &lt;programlisting&gt; or
                        &lt;screen&gt; (or possibly other elements), add the attribute
                                <code class="literal">language=<em class="replaceable"><code>LANGUAGE_OF_CHOICE</code></em></code>
                        to the element, as in the following example:</p><pre class="programlisting">
&lt;programlisting language="xml"&gt;
    &lt;foo&gt;bar&lt;/foo&gt;
    &lt;bar&gt;foo&lt;/bar&gt;
&lt;/programlisting&gt;</pre><p>Several syntax types are supported. The most interesting ones for the
                        HBase Reference Guide are <code class="literal">java</code>, <code class="literal">xml</code>,
                            <code class="literal">sql</code>, and <code class="literal">bourne</code> (for BASH shell
                        output or Linux command-line examples).</p></td></tr></tbody></table></div></div></div><div class="appendix" title="Appendix&nbsp;B.&nbsp;FAQ"><div class="titlepage"><div><div><h2 class="title"><a name="faq"></a>Appendix&nbsp;B.&nbsp;FAQ</h2></div></div></div><div class="qandaset" title="Frequently Asked Questions"><a name="d2875e23184"></a><dl><dt>B.1.  <a href="#d2875e23185">General</a></dt><dd><dl><dt>Q: <a href="#d2875e23188">When should I use HBase?</a></dt><dt>Q: <a href="#d2875e23197">Are there other HBase FAQs?</a></dt><dt>Q: <a href="#faq.sql">Does HBase support SQL?</a></dt><dt>Q: <a href="#d2875e23219">How can I find examples of NoSQL/HBase?</a></dt><dt>Q: <a href="#d2875e23228">What is the history of HBase?</a></dt></dl></dd><dt>B.2.  <a href="#d2875e23237">Upgrading</a></dt><dd><dl><dt>Q: <a href="#d2875e23240">How do I upgrade Maven-managed projects from HBase 0.94 to HBase 0.96+?</a></dt></dl></dd><dt>B.3.  <a href="#faq.arch">Architecture</a></dt><dd><dl><dt>Q: <a href="#faq.arch.regions">How does HBase handle Region-RegionServer assignment and locality?</a></dt></dl></dd><dt>B.4.  <a href="#faq.config">Configuration</a></dt><dd><dl><dt>Q: <a href="#faq.config.started">How can I get started with my first cluster?</a></dt><dt>Q: <a href="#faq.config.options">Where can I learn about the rest of the configuration options?</a></dt></dl></dd><dt>B.5.  <a href="#faq.design">Schema Design / Data Access</a></dt><dd><dl><dt>Q: <a href="#faq.design.schema">How should I design my schema in HBase?</a></dt><dt>Q: <a href="#d2875e23316">
                    How can I store (fill in the blank) in HBase?
            </a></dt><dt>Q: <a href="#secondary.indices">
                    How can I handle secondary indexes in HBase?
            </a></dt><dt>Q: <a href="#faq.changing.rowkeys">Can I change a table's rowkeys?</a></dt><dt>Q: <a href="#faq.apis">What APIs does HBase support?</a></dt></dl></dd><dt>B.6.  <a href="#faq.mapreduce">MapReduce</a></dt><dd><dl><dt>Q: <a href="#faq.mapreduce.use">How can I use MapReduce with HBase?</a></dt></dl></dd><dt>B.7.  <a href="#d2875e23368">Performance and Troubleshooting</a></dt><dd><dl><dt>Q: <a href="#d2875e23371">
                   How can I improve HBase cluster performance?
            </a></dt><dt>Q: <a href="#d2875e23380">
                    How can I troubleshoot my HBase cluster?
            </a></dt></dl></dd><dt>B.8.  <a href="#ec2">Amazon EC2</a></dt><dd><dl><dt>Q: <a href="#d2875e23392">
            I am running HBase on Amazon EC2 and...
            </a></dt></dl></dd><dt>B.9.  <a href="#d2875e23403">Operations</a></dt><dd><dl><dt>Q: <a href="#d2875e23406">
                    How do I manage my HBase cluster?
            </a></dt><dt>Q: <a href="#d2875e23415">
                    How do I back up my HBase cluster?
            </a></dt></dl></dd><dt>B.10.  <a href="#d2875e23424">HBase in Action</a></dt><dd><dl><dt>Q: <a href="#d2875e23427">Where can I find interesting videos and presentations on HBase?</a></dt></dl></dd></dl><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%"><col><tbody><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d2875e23185"></a>B.1. General</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#d2875e23188">When should I use HBase?</a></dt><dt>Q: <a href="#d2875e23197">Are there other HBase FAQs?</a></dt><dt>Q: <a href="#faq.sql">Does HBase support SQL?</a></dt><dt>Q: <a href="#d2875e23219">How can I find examples of NoSQL/HBase?</a></dt><dt>Q: <a href="#d2875e23228">What is the history of HBase?</a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23188"></a><a name="d2875e23189"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>When should I use HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>See the <a class="xref" href="#arch.overview" title="9.1.&nbsp;Overview">Section&nbsp;9.1, &#8220;Overview&#8221;</a> in the Architecture chapter.
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23197"></a><a name="d2875e23198"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>Are there other HBase FAQs?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
              See the FAQ that is up on the wiki, <a class="link" href="http://wiki.apache.org/hadoop/Hbase/FAQ" target="_top">HBase Wiki FAQ</a>.
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.sql"></a><a name="d2875e23208"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>Does HBase support SQL?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    Not really.  SQL-ish support for HBase via <a class="link" href="http://hive.apache.org/" target="_top">Hive</a> is in development, however Hive is based on MapReduce which is not generally suitable for low-latency requests.
                    See the <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a> section for examples on the HBase client.
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23219"></a><a name="d2875e23220"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>How can I find examples of NoSQL/HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>See the link to the BigTable paper in <a class="xref" href="#other.info" title="Appendix&nbsp;I.&nbsp;Other Information About HBase">Appendix&nbsp;I, <i>Other Information About HBase</i></a> in the appendix, as
                well as the other papers.
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23228"></a><a name="d2875e23229"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>What is the history of HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>See <a class="xref" href="#hbase.history" title="Appendix&nbsp;J.&nbsp;HBase History">Appendix&nbsp;J, <i>HBase History</i></a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d2875e23237"></a>B.2. Upgrading</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#d2875e23240">How do I upgrade Maven-managed projects from HBase 0.94 to HBase 0.96+?</a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23240"></a><a name="d2875e23241"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>How do I upgrade Maven-managed projects from HBase 0.94 to HBase 0.96+?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>In HBase 0.96, the project moved to a modular structure. Adjust your project's
              dependencies to rely upon the <code class="filename">hbase-client</code> module or another
              module as appropriate, rather than a single JAR. You can model your Maven depency
              after one of the following, depending on your targeted version of HBase. See <a class="xref" href="#upgrade0.96" title="3.5.&nbsp;Upgrading from 0.94.x to 0.96.x">Section&nbsp;3.5, &#8220;Upgrading from 0.94.x to 0.96.x&#8221;</a> or <a class="xref" href="#upgrade0.98" title="3.3.&nbsp;Upgrading from 0.96.x to 0.98.x">Section&nbsp;3.3, &#8220;Upgrading from 0.96.x to 0.98.x&#8221;</a> for more
              information.</p><div class="example"><a name="d2875e23254"></a><p class="title"><b>Example&nbsp;B.1.&nbsp;Maven Dependency for HBase 0.98</b></p><div class="example-contents"><pre class="programlisting">
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;
	&lt;artifactId&gt;hbase-client&lt;/artifactId&gt;
	&lt;version&gt;0.98.5-hadoop2&lt;/version&gt;
&lt;/dependency&gt;                
                </pre></div></div><br class="example-break"><div class="example"><a name="d2875e23259"></a><p class="title"><b>Example&nbsp;B.2.&nbsp;Maven Dependency for HBase 0.96</b></p><div class="example-contents"><pre class="programlisting">
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;
	&lt;artifactId&gt;hbase-client&lt;/artifactId&gt;
	&lt;version&gt;0.96.2-hadoop2&lt;/version&gt;
&lt;/dependency&gt;             
                </pre></div></div><br class="example-break"><div class="example"><a name="d2875e23264"></a><p class="title"><b>Example&nbsp;B.3.&nbsp;Maven Dependency for HBase 0.94</b></p><div class="example-contents"><pre class="programlisting">
&lt;dependency&gt;
	&lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;
	&lt;artifactId&gt;hbase&lt;/artifactId&gt;
	&lt;version&gt;0.94.3&lt;/version&gt;
&lt;/dependency&gt;            
                </pre></div></div><br class="example-break"></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.arch"></a>B.3. Architecture</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#faq.arch.regions">How does HBase handle Region-RegionServer assignment and locality?</a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.arch.regions"></a><a name="d2875e23273"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>How does HBase handle Region-RegionServer assignment and locality?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#regions.arch" title="9.7.&nbsp;Regions">Section&nbsp;9.7, &#8220;Regions&#8221;</a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.config"></a>B.4. Configuration</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#faq.config.started">How can I get started with my first cluster?</a></dt><dt>Q: <a href="#faq.config.options">Where can I learn about the rest of the configuration options?</a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.config.started"></a><a name="d2875e23285"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>How can I get started with my first cluster?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#quickstart" title="1.2.&nbsp;Quick Start - Standalone HBase">Section&nbsp;1.2, &#8220;Quick Start - Standalone HBase&#8221;</a>.
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.config.options"></a><a name="d2875e23294"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>Where can I learn about the rest of the configuration options?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#configuration" title="Chapter&nbsp;2.&nbsp;Apache HBase Configuration">Chapter&nbsp;2, <i>Apache HBase Configuration</i></a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.design"></a>B.5. Schema Design / Data Access</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#faq.design.schema">How should I design my schema in HBase?</a></dt><dt>Q: <a href="#d2875e23316">
                    How can I store (fill in the blank) in HBase?
            </a></dt><dt>Q: <a href="#secondary.indices">
                    How can I handle secondary indexes in HBase?
            </a></dt><dt>Q: <a href="#faq.changing.rowkeys">Can I change a table's rowkeys?</a></dt><dt>Q: <a href="#faq.apis">What APIs does HBase support?</a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.design.schema"></a><a name="d2875e23306"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>How should I design my schema in HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a> and <a class="xref" href="#schema" title="Chapter&nbsp;6.&nbsp;HBase and Schema Design">Chapter&nbsp;6, <i>HBase and Schema Design</i></a>
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23316"></a><a name="d2875e23317"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
                    How can I store (fill in the blank) in HBase?
            </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                See <a class="xref" href="#supported.datatypes" title="6.5.&nbsp; Supported Datatypes">Section&nbsp;6.5, &#8220; Supported Datatypes &#8221;</a>.
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="secondary.indices"></a><a name="d2875e23326"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
                    How can I handle secondary indexes in HBase?
            </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                See <a class="xref" href="#secondary.indexes" title="6.9.&nbsp; Secondary Indexes and Alternate Query Paths">Section&nbsp;6.9, &#8220; Secondary Indexes and Alternate Query Paths &#8221;</a>
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.changing.rowkeys"></a><a name="d2875e23335"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>Can I change a table's rowkeys?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p> This is a very common question. You can't. See <a class="xref" href="#changing.rowkeys" title="6.3.6.&nbsp;Immutability of Rowkeys">Section&nbsp;6.3.6, &#8220;Immutability of Rowkeys&#8221;</a>. </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.apis"></a><a name="d2875e23344"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>What APIs does HBase support?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#datamodel" title="Chapter&nbsp;5.&nbsp;Data Model">Chapter&nbsp;5, <i>Data Model</i></a>, <a class="xref" href="#client" title="9.3.&nbsp;Client">Section&nbsp;9.3, &#8220;Client&#8221;</a> and <a class="xref" href="#nonjava.jvm" title="11.1.&nbsp;Non-Java Languages Talking to the JVM">Section&nbsp;11.1, &#8220;Non-Java Languages Talking to the JVM&#8221;</a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="faq.mapreduce"></a>B.6. MapReduce</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#faq.mapreduce.use">How can I use MapReduce with HBase?</a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="faq.mapreduce.use"></a><a name="d2875e23360"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>How can I use MapReduce with HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#mapreduce" title="Chapter&nbsp;7.&nbsp;HBase and MapReduce">Chapter&nbsp;7, <i>HBase and MapReduce</i></a>
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d2875e23368"></a>B.7. Performance and Troubleshooting</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#d2875e23371">
                   How can I improve HBase cluster performance?
            </a></dt><dt>Q: <a href="#d2875e23380">
                    How can I troubleshoot my HBase cluster?
            </a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23371"></a><a name="d2875e23372"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
                   How can I improve HBase cluster performance?
            </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                See <a class="xref" href="#performance" title="Chapter&nbsp;14.&nbsp;Apache HBase Performance Tuning">Chapter&nbsp;14, <i>Apache HBase Performance Tuning</i></a>.
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23380"></a><a name="d2875e23381"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
                    How can I troubleshoot my HBase cluster?
            </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                See <a class="xref" href="#trouble" title="Chapter&nbsp;15.&nbsp;Troubleshooting and Debugging Apache HBase">Chapter&nbsp;15, <i>Troubleshooting and Debugging Apache HBase</i></a>.
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="ec2"></a>B.8. Amazon EC2</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#d2875e23392">
            I am running HBase on Amazon EC2 and...
            </a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23392"></a><a name="d2875e23393"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
            I am running HBase on Amazon EC2 and...
            </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
 	            EC2 issues are a special case.  See Troubleshooting <a class="xref" href="#trouble.ec2" title="15.12.&nbsp;Amazon EC2">Section&nbsp;15.12, &#8220;Amazon EC2&#8221;</a> and Performance <a class="xref" href="#perf.ec2" title="14.12.&nbsp;Amazon EC2">Section&nbsp;14.12, &#8220;Amazon EC2&#8221;</a> sections.
               </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d2875e23403"></a>B.9. Operations</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#d2875e23406">
                    How do I manage my HBase cluster?
            </a></dt><dt>Q: <a href="#d2875e23415">
                    How do I back up my HBase cluster?
            </a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23406"></a><a name="d2875e23407"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
                    How do I manage my HBase cluster?
            </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#ops_mgt" title="Chapter&nbsp;17.&nbsp;Apache HBase Operational Management">Chapter&nbsp;17, <i>Apache HBase Operational Management</i></a>
                </p></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23415"></a><a name="d2875e23416"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>
                    How do I back up my HBase cluster?
            </p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#ops.backup" title="17.7.&nbsp;HBase Backup">Section&nbsp;17.7, &#8220;HBase Backup&#8221;</a>
                </p></td></tr><tr class="qandadiv"><td align="left" valign="top" colspan="2"><h3 class="title"><a name="d2875e23424"></a>B.10. HBase in Action</h3></td></tr><tr class="toc"><td align="left" valign="top" colspan="2"><dl><dt>Q: <a href="#d2875e23427">Where can I find interesting videos and presentations on HBase?</a></dt></dl></td></tr><tr class="question" title="Q:"><td align="left" valign="top"><a name="d2875e23427"></a><a name="d2875e23428"></a><p><b>Q:</b></p></td><td align="left" valign="top"><p>Where can I find interesting videos and presentations on HBase?</p></td></tr><tr class="answer"><td align="left" valign="top"><p><b>A:</b></p></td><td align="left" valign="top"><p>
                    See <a class="xref" href="#other.info" title="Appendix&nbsp;I.&nbsp;Other Information About HBase">Appendix&nbsp;I, <i>Other Information About HBase</i></a>
                </p></td></tr></tbody></table></div></div><div class="appendix" title="Appendix&nbsp;C.&nbsp;hbck In Depth"><div class="titlepage"><div><div><h2 class="title"><a name="hbck.in.depth"></a>Appendix&nbsp;C.&nbsp;hbck In Depth</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e23441">C.1. Running hbck to identify inconsistencies</a></span></dt><dt><span class="section"><a href="#d2875e23459">C.2. Inconsistencies</a></span></dt><dt><span class="section"><a href="#d2875e23480">C.3. Localized repairs</a></span></dt><dt><span class="section"><a href="#d2875e23525">C.4. Region Overlap Repairs</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e23574">C.4.1. Special cases: Meta is not properly assigned</a></span></dt><dt><span class="section"><a href="#d2875e23584">C.4.2. Special cases: HBase version file is missing</a></span></dt><dt><span class="section"><a href="#d2875e23592">C.4.3. Special case: Root and META are corrupt.</a></span></dt><dt><span class="section"><a href="#d2875e23601">C.4.4. Special cases: Offline split parent</a></span></dt></dl></dd></dl></div><p>HBaseFsck (hbck) is a tool for checking for region consistency and table integrity problems
and repairing a corrupted HBase. It works in two basic modes -- a read-only inconsistency
identifying mode and a multi-phase read-write repair mode.
	</p><div class="section" title="C.1.&nbsp;Running hbck to identify inconsistencies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23441"></a>C.1.&nbsp;Running hbck to identify inconsistencies</h2></div></div></div><p>To check to see if your HBase cluster has corruptions, run hbck against your HBase cluster:</p><pre class="programlisting">
$ ./bin/hbase hbck
</pre><p>
At the end of the commands output it prints OK or tells you the number of INCONSISTENCIES
present. You may also want to run run hbck a few times because some inconsistencies can be
transient (e.g. cluster is starting up or a region is splitting). Operationally you may want to run
hbck regularly and setup alert (e.g. via nagios) if it repeatedly reports inconsistencies .
A run of hbck will report a list of inconsistencies along with a brief description of the regions and
tables affected. The using the <code class="code">-details</code> option will report more details including a representative
listing of all the splits present in all the tables.
	</p><pre class="programlisting">
$ ./bin/hbase hbck -details
</pre><p>If you just want to know if some tables are corrupted, you can limit hbck to identify inconsistencies
in only specific tables. For example the following command would only attempt to check table
TableFoo and TableBar. The benefit is that hbck will run in less time.</p><pre class="programlisting">
$ ./bin/hbase hbck TableFoo TableBar
</pre></div><div class="section" title="C.2.&nbsp;Inconsistencies"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23459"></a>C.2.&nbsp;Inconsistencies</h2></div></div></div><p>
	If after several runs, inconsistencies continue to be reported, you may have encountered a
corruption. These should be rare, but in the event they occur newer versions of HBase include
the hbck tool enabled with automatic repair options.
	</p><p>
	There are two invariants that when violated create inconsistencies in HBase:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>HBase&#8217;s region consistency invariant is satisfied if every region is assigned and
deployed on exactly one region server, and all places where this state kept is in
accordance.</p></li><li class="listitem"><p>HBase&#8217;s table integrity invariant is satisfied if for each table, every possible row key
resolves to exactly one region.</p></li></ul></div><p>
Repairs generally work in three phases -- a read-only information gathering phase that identifies
inconsistencies, a table integrity repair phase that restores the table integrity invariant, and then
finally a region consistency repair phase that restores the region consistency invariant.
Starting from version 0.90.0, hbck could detect region consistency problems report on a subset
of possible table integrity problems. It also included the ability to automatically fix the most
common inconsistency, region assignment and deployment consistency problems. This repair
could be done by using the <code class="code">-fix</code> command line option. These problems close regions if they are
open on the wrong server or on multiple region servers and also assigns regions to region
servers if they are not open.
</p><p>
Starting from HBase versions 0.90.7, 0.92.2 and 0.94.0, several new command line options are
introduced to aid repairing a corrupted HBase. This hbck sometimes goes by the nickname
&#8220;uberhbck&#8221;. Each particular version of uber hbck is compatible with the HBase&#8217;s of the same
major version (0.90.7 uberhbck can repair a 0.90.4). However, versions &lt;=0.90.6 and versions
&lt;=0.92.1 may require restarting the master or failing over to a backup master.
</p></div><div class="section" title="C.3.&nbsp;Localized repairs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23480"></a>C.3.&nbsp;Localized repairs</h2></div></div></div><p>
	When repairing a corrupted HBase, it is best to repair the lowest risk inconsistencies first.
These are generally region consistency repairs -- localized single region repairs, that only modify
in-memory data, ephemeral zookeeper data, or patch holes in the META table.
Region consistency requires that the HBase instance has the state of the region&#8217;s data in HDFS
(.regioninfo files), the region&#8217;s row in the hbase:meta table., and region&#8217;s deployment/assignments on
region servers and the master in accordance. Options for repairing region consistency include:
	</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-fixAssignments</code> (equivalent to the 0.90 <code class="code">-fix</code> option) repairs unassigned, incorrectly
assigned or multiply assigned regions.</p></li><li class="listitem"><p><code class="code">-fixMeta</code> which removes meta rows when corresponding regions are not present in
		  HDFS and adds new meta rows if they regions are present in HDFS while not in META.</p></li></ul></div><p>
	To fix deployment and assignment problems you can run this command:
</p><pre class="programlisting">
$ ./bin/hbase hbck -fixAssignments
</pre><p>To fix deployment and assignment problems as well as repairing incorrect meta rows you can
run this command:</p><pre class="programlisting">
$ ./bin/hbase hbck -fixAssignments -fixMeta
</pre><p>There are a few classes of table integrity problems that are low risk repairs. The first two are
degenerate (startkey == endkey) regions and backwards regions (startkey &gt; endkey). These are
automatically handled by sidelining the data to a temporary directory (/hbck/xxxx).
The third low-risk class is hdfs region holes. This can be repaired by using the:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-fixHdfsHoles</code> option for fabricating new empty regions on the file system.
If holes are detected you can use -fixHdfsHoles and should include -fixMeta and -fixAssignments to make the new region consistent.</p></li></ul></div><pre class="programlisting">
$ ./bin/hbase hbck -fixAssignments -fixMeta -fixHdfsHoles
</pre><p>Since this is a common operation, we&#8217;ve added a the <code class="code">-repairHoles</code> flag that is equivalent to the
previous command:</p><pre class="programlisting">
$ ./bin/hbase hbck -repairHoles
</pre><p>If inconsistencies still remain after these steps, you most likely have table integrity problems
related to orphaned or overlapping regions.</p></div><div class="section" title="C.4.&nbsp;Region Overlap Repairs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e23525"></a>C.4.&nbsp;Region Overlap Repairs</h2></div></div></div><p>Table integrity problems can require repairs that deal with overlaps. This is a riskier operation
because it requires modifications to the file system, requires some decision making, and may
require some manual steps. For these repairs it is best to analyze the output of a <code class="code">hbck -details</code>
run so that you isolate repairs attempts only upon problems the checks identify. Because this is
riskier, there are safeguard that should be used to limit the scope of the repairs.
WARNING: This is a relatively new and have only been tested on online but idle HBase instances
(no reads/writes). Use at your own risk in an active production environment!
The options for repairing table integrity violations include:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-fixHdfsOrphans</code> option for &#8220;adopting&#8221; a region directory that is missing a region
metadata file (the .regioninfo file).</p></li><li class="listitem"><p><code class="code">-fixHdfsOverlaps</code> ability for fixing overlapping regions</p></li></ul></div><p>When repairing overlapping regions, a region&#8217;s data can be modified on the file system in two
ways: 1) by merging regions into a larger region or 2) by sidelining regions by moving data to
&#8220;sideline&#8221; directory where data could be restored later. Merging a large number of regions is
technically correct but could result in an extremely large region that requires series of costly
compactions and splitting operations. In these cases, it is probably better to sideline the regions
that overlap with the most other regions (likely the largest ranges) so that merges can happen on
a more reasonable scale. Since these sidelined regions are already laid out in HBase&#8217;s native
directory and HFile format, they can be restored by using HBase&#8217;s bulk load mechanism.
The default safeguard thresholds are conservative. These options let you override the default
thresholds and to enable the large region sidelining feature.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-maxMerge &lt;n&gt;</code> maximum number of overlapping regions to merge</p></li><li class="listitem"><p><code class="code">-sidelineBigOverlaps</code> if more than maxMerge regions are overlapping, sideline attempt
to sideline the regions overlapping with the most other regions.</p></li><li class="listitem"><p><code class="code">-maxOverlapsToSideline &lt;n&gt;</code> if sidelining large overlapping regions, sideline at most n
regions.</p></li></ul></div><p>Since often times you would just want to get the tables repaired, you can use this option to turn
on all repair options:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">-repair</code> includes all the region consistency options and only the hole repairing table
integrity options.</p></li></ul></div><p>Finally, there are safeguards to limit repairs to only specific tables. For example the following
command would only attempt to check and repair table TableFoo and TableBar.</p><pre class="screen">
$ ./bin/hbase hbck -repair TableFoo TableBar
</pre><div class="section" title="C.4.1.&nbsp;Special cases: Meta is not properly assigned"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e23574"></a>C.4.1.&nbsp;Special cases: Meta is not properly assigned</h3></div></div></div><p>There are a few special cases that hbck can handle as well.
Sometimes the meta table&#8217;s only region is inconsistently assigned or deployed. In this case
there is a special <code class="code">-fixMetaOnly</code> option that can try to fix meta assignments.</p><pre class="screen">
$ ./bin/hbase hbck -fixMetaOnly -fixAssignments
</pre></div><div class="section" title="C.4.2.&nbsp;Special cases: HBase version file is missing"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e23584"></a>C.4.2.&nbsp;Special cases: HBase version file is missing</h3></div></div></div><p>HBase&#8217;s data on the file system requires a version file in order to start. If this flie is missing, you
can use the <code class="code">-fixVersionFile</code> option to fabricating a new HBase version file. This assumes that
the version of hbck you are running is the appropriate version for the HBase cluster.</p></div><div class="section" title="C.4.3.&nbsp;Special case: Root and META are corrupt."><div class="titlepage"><div><div><h3 class="title"><a name="d2875e23592"></a>C.4.3.&nbsp;Special case: Root and META are corrupt.</h3></div></div></div><p>The most drastic corruption scenario is the case where the ROOT or META is corrupted and
HBase will not start. In this case you can use the OfflineMetaRepair tool create new ROOT
and META regions and tables.
This tool assumes that HBase is offline. It then marches through the existing HBase home
directory, loads as much information from region metadata files (.regioninfo files) as possible
from the file system. If the region metadata has proper table integrity, it sidelines the original root
and meta table directories, and builds new ones with pointers to the region directories and their
data.</p><pre class="screen">
$ ./bin/hbase org.apache.hadoop.hbase.util.hbck.OfflineMetaRepair
</pre><p>NOTE: This tool is not as clever as uberhbck but can be used to bootstrap repairs that uberhbck
can complete.
If the tool succeeds you should be able to start hbase and run online repairs if necessary.</p></div><div class="section" title="C.4.4.&nbsp;Special cases: Offline split parent"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e23601"></a>C.4.4.&nbsp;Special cases: Offline split parent</h3></div></div></div><p>
Once a region is split, the offline parent will be cleaned up automatically. Sometimes, daughter regions
are split again before their parents are cleaned up. HBase can clean up parents in the right order. However,
there could be some lingering offline split parents sometimes. They are in META, in HDFS, and not deployed.
But HBase can't clean them up. In this case, you can use the <code class="code">-fixSplitParents</code> option to reset
them in META to be online and not split. Therefore, hbck can merge them with other regions if fixing
overlapping regions option is used.
    </p><p>
This option should not normally be used, and it is not in <code class="code">-fixAll</code>.
    </p></div></div></div><div class="appendix" title="Appendix&nbsp;D.&nbsp;Access Control Matrix"><div class="titlepage"><div><div><h2 class="title"><a name="appendix_acl_matrix"></a>Appendix&nbsp;D.&nbsp;Access Control Matrix</h2></div></div></div><p>The following matrix shows the minimum permission set required to perform operations in
        HBase. Before using the table, read through the information about how to interpret it.</p><div class="variablelist" title="Interpreting the ACL Matrix Table"><p class="title"><b>Interpreting the ACL Matrix Table</b></p><p>The following conventions are used in the ACL Matrix table:</p><dl><dt><span class="term">Scopes</span></dt><dd><p>Permissions are evaluated starting at the widest scope and working to the
              narrowest scope. A scope corresponds to a level of the data model. From broadest to
              narrowest, the scopes are as follows::</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Global</p></li><li class="listitem"><p>Namespace (NS)</p></li><li class="listitem"><p>Table</p></li><li class="listitem"><p>Column Family (CF)</p></li><li class="listitem"><p>Column Qualifier (CQ)</p></li><li class="listitem"><p>Cell</p></li></ul></div><p>For instance, a permission granted at table level dominates any grants done at
                    the Column Family, Column Qualifier, or cell level. The user can do what that
                    grant implies at any location in the table. A permission granted at global scope
                    dominates all: the user is always allowed to take that action everywhere.</p></dd><dt><span class="term">Permissions</span></dt><dd><p>Possible permissions include the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Superuser - a special user that belongs to group "supergroup" and has
                unlimited access</p></li><li class="listitem"><p>Admin (A)</p></li><li class="listitem"><p>Create (C)</p></li><li class="listitem"><p>Write (W)</p></li><li class="listitem"><p>Read (R)</p></li><li class="listitem"><p>Execute (X)</p></li></ul></div></dd></dl></div><p>For the most part, permissions work in an expected way, with the following caveats:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Having Write permission does not imply Read permission. It is possible and sometimes
          desirable for a user to be able to write data that same user cannot read. One such example
          is a log-writing process.</p></li><li class="listitem"><p>The <code class="systemitem">hbase:meta</code> table is readable by every user, regardless
            of the user's other grants or restrictions. This is a requirement for HBase to
            function correctly.</p></li><li class="listitem"><p><code class="code">CheckAndPut</code> and <code class="code">CheckAndDelete</code> operations will fail if
                the user does not have both Write and Read permission.</p></li><li class="listitem"><p><code class="code">Increment</code> and <code class="code">Append</code> operations do not require Read
                access.</p></li></ul></div><p>The following table is sorted by the interface that provides each operation. In case the
        table goes out of date, the unit tests which check for accuracy of permissions can be found
        in
            <code class="filename">hbase-server/src/test/java/org/apache/hadoop/hbase/security/access/TestAccessController.java</code>,
        and the access controls themselves can be examined in
            <code class="filename">hbase-server/src/main/java/org/apache/hadoop/hbase/security/access/AccessController.java</code>.</p><div class="table"><a name="d2875e23713"></a><p class="title"><b>Table&nbsp;D.1.&nbsp;ACL Matrix</b></p><div class="table-contents"><table summary="ACL Matrix" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Interface</th><th>Operation</th><th>Minimum Scope</th><th>Minimum Permission</th></tr></thead><tbody><tr><td rowspan="28">
                        
                        <p>Master</p>
                    </td><td>
                        <p>createTable</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>C</p>
                    </td></tr><tr><td>
                        <p>modifyTable</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>deleteTable</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>truncateTable</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>addColumn</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>modifyColumn</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>deleteColumn</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>disableTable</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>disableAclTable</p>
                    </td><td>
                        <p>None</p>
                    </td><td>
                        <p>Not allowed</p>
                    </td></tr><tr><td>
                        <p>enableTable</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>move</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>assign</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>unassign</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>regionOffline</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>balance</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>balanceSwitch</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>shutdown</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>stopMaster</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>snapshot</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>clone</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>restore</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>deleteSnapshot</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>createNamespace</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>deleteNamespace</p>
                    </td><td>
                        <p>Namespace</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>modifyNamespace</p>
                    </td><td>
                        <p>Namespace</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>flushTable</p>
                    </td><td>
                        <p>Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>getTableDescriptors</p>
                    </td><td>
                        <p>Global|Table</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>mergeRegions</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td rowspan="25">Region</td><td>open</td><td>Global</td><td>A</td></tr><tr><td>
                        <p>openRegion</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>close</td><td>Global</td><td>A</td></tr><tr><td>
                        <p>closeRegion</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>stopRegionServer</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                    <p>rollHLog</p>
                  </td><td>
                    <p>Global</p>
                  </td><td>
                    <p>A</p>
                  </td></tr><tr><td>
                        <p>mergeRegions</p>
                    </td><td>
                        <p>Global</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>append</td><td>Table|CF|CQ</td><td>W</td></tr><tr><td>delete</td><td>Table|CF|CQ|Cell (if the user has write permission for all cells)</td><td>W</td></tr><tr><td>exists</td><td>Table|CF|CQ</td><td>R</td></tr><tr><td>get</td><td>Table|CF|CQ</td><td>R</td></tr><tr><td>getClosestRowBefore</td><td>Table|CF|CQ</td><td>R</td></tr><tr><td>increment</td><td>Table|CF|CQ</td><td>W</td></tr><tr><td>put</td><td>Table|CF|CQ</td><td>W</td></tr><tr><td>
                        <p>flush</p>
                    </td><td>
                        <p>Global|Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>
                        <p>split</p>
                    </td><td>
                        <p>Global|Table</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>compact</p>
                    </td><td>
                        <p>Global|Table</p>
                    </td><td>
                        <p>A|C</p>
                    </td></tr><tr><td>bulkLoadHFile</td><td>Table</td><td>W</td></tr><tr><td>prepareBulkLoad</td><td>Table</td><td>C</td></tr><tr><td>cleanupBulkLoad</td><td>Table</td><td>W</td></tr><tr><td>checkAndDelete</td><td>Table|CF|CQ</td><td>RW</td></tr><tr><td>checkAndPut</td><td>Table|CF|CQ</td><td>RW</td></tr><tr><td>incrementColumnValue</td><td>Table|CF|CQ</td><td>RW</td></tr><tr><td>scannerClose</td><td>Table</td><td>R</td></tr><tr><td>scannerNext</td><td>Table</td><td>R</td></tr><tr><td>scannerOpen</td><td>Table|CQ|CF</td><td>R</td><td class="auto-generated">&nbsp;</td></tr><tr><td>
                        <p>Endpoint</p>
                    </td><td>
                        <p>invoke</p>
                    </td><td>Endpoint</td><td>
                        <p>X</p>
                    </td></tr><tr><td rowspan="4">
                        <p>AccessController</p>
                    </td><td>
                        <p>grant</p>
                    </td><td>Global|Table|NS</td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>revoke</p>
                    </td><td>Global|Table|NS</td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>getUserPermissions</p>
                    </td><td>
                        <p>Global|Table|NS</p>
                    </td><td>
                        <p>A</p>
                    </td></tr><tr><td>
                        <p>checkPermissions</p>
                    </td><td>
                        <p>Global|Table|NS</p>
                    </td><td>
                        <p>A</p>
                    </td></tr></tbody></table></div></div><br class="table-break"></div><div class="appendix" title="Appendix&nbsp;E.&nbsp;Compression and Data Block Encoding In HBase"><div class="titlepage"><div><div><h2 class="title"><a name="compression"></a>Appendix&nbsp;E.&nbsp;Compression and Data Block Encoding In
          HBase<a class="indexterm" name="d2875e24524"></a></h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e24649">E.1. Which Compressor or Data Block Encoder To Use</a></span></dt><dt><span class="section"><a href="#hadoop.native.lib">E.2. Making use of Hadoop Native Libraries in HBase</a></span></dt><dt><span class="section"><a href="#d2875e24742">E.3. Compressor Configuration, Installation, and Use</a></span></dt><dd><dl><dt><span class="section"><a href="#compressor.install">E.3.1. Configure HBase For Compressors</a></span></dt><dt><span class="section"><a href="#changing.compression">E.3.2. Enable Compression On a ColumnFamily</a></span></dt><dt><span class="section"><a href="#d2875e24887">E.3.3. Testing Compression Performance</a></span></dt></dl></dd><dt><span class="section"><a href="#data.block.encoding.enable">E.4. Enable Data Block Encoding</a></span></dt></dl></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Codecs mentioned in this section are for encoding and decoding data blocks or row keys.
       For information about replication codecs, see <a class="xref" href="#cluster.replication.preserving.tags" title="Preserving Tags During Replication">Preserving Tags During Replication</a>.</p></div><p>Some of the information in this section is pulled from a <a class="link" href="http://search-hadoop.com/m/lL12B1PFVhp1/v=threaded" target="_top">discussion</a> on the
      HBase Development mailing list.</p><p>HBase supports several different compression algorithms which can be enabled on a
      ColumnFamily. Data block encoding attempts to limit duplication of information in keys, taking
      advantage of some of the fundamental designs and patterns of HBase, such as sorted row keys
      and the schema of a given table. Compressors reduce the size of large, opaque byte arrays in
      cells, and can significantly reduce the storage space needed to store uncompressed
      data.</p><p>Compressors and data block encoding can be used together on the same ColumnFamily.</p><p title="Changes Take Effect Upon Compaction"><b>Changes Take Effect Upon Compaction.&nbsp;</b>If you change compression or encoding for a ColumnFamily, the changes take effect during
       compaction.</p><p>Some codecs take advantage of capabilities built into Java, such as GZip compression.
      Others rely on native libraries. Native libraries may be available as part of Hadoop, such as
      LZ4. In this case, HBase only needs access to the appropriate shared library. Other codecs,
      such as Google Snappy, need to be installed first. Some codecs are licensed in ways that
      conflict with HBase's license and cannot be shipped as part of HBase.</p><p>This section discusses common codecs that are used and tested with HBase. No matter what
      codec you use, be sure to test that it is installed correctly and is available on all nodes in
      your cluster. Extra operational steps may be necessary to be sure that codecs are available on
      newly-deployed nodes. You can use the <a class="xref" href="#compression.test" title="E.3.1.6.&nbsp;CompressionTest">Section&nbsp;E.3.1.6, &#8220;CompressionTest&#8221;</a> utility to check that a given codec is correctly
      installed.</p><p>To configure HBase to use a compressor, see <a class="xref" href="#compressor.install" title="E.3.1.&nbsp;Configure HBase For Compressors">Section&nbsp;E.3.1, &#8220;Configure HBase For Compressors&#8221;</a>. To enable a compressor for a ColumnFamily, see <a class="xref" href="#changing.compression" title="E.3.2.&nbsp;Enable Compression On a ColumnFamily">Section&nbsp;E.3.2, &#8220;Enable Compression On a ColumnFamily&#8221;</a>. To enable data block encoding for a ColumnFamily, see
      <a class="xref" href="#data.block.encoding.enable" title="E.4.&nbsp;Enable Data Block Encoding">Section&nbsp;E.4, &#8220;Enable Data Block Encoding&#8221;</a>.</p><div class="itemizedlist" title="Block Compressors"><p class="title"><b>Block Compressors</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>none</p></li><li class="listitem"><p>Snappy</p></li><li class="listitem"><p>LZO</p></li><li class="listitem"><p>LZ4</p></li><li class="listitem"><p>GZ</p></li></ul></div><div class="itemizedlist" title="Data Block Encoding Types"><a name="data.block.encoding.types"></a><p class="title"><b>Data Block Encoding Types</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>Prefix - Often, keys are very similar. Specifically, keys often share a common prefix
          and only differ near the end. For instance, one key might be
            <code class="literal">RowKey:Family:Qualifier0</code> and the next key might be
            <code class="literal">RowKey:Family:Qualifier1</code>. In Prefix encoding, an extra column is
          added which holds the length of the prefix shared between the current key and the previous
          key. Assuming the first key here is totally different from the key before, its prefix
          length is 0. The second key's prefix length is <code class="literal">23</code>, since they have the
          first 23 characters in common.</p><p>Obviously if the keys tend to have nothing in common, Prefix will not provide much
          benefit.</p><p>The following image shows a hypothetical ColumnFamily with no data block encoding.</p><div class="figure"><a name="d2875e24601"></a><p class="title"><b>Figure&nbsp;E.1.&nbsp;ColumnFamily with No Encoding</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="800"><tr><td><img src="images/data_block_no_encoding.png" width="800" alt="ColumnFamily with No Encoding"></td></tr></table><div class="caption"><p>A ColumnFamily with no encoding&gt;</p></div></div></div></div><br class="figure-break"><p>Here is the same data with prefix data encoding.</p><div class="figure"><a name="d2875e24612"></a><p class="title"><b>Figure&nbsp;E.2.&nbsp;ColumnFamily with Prefix Encoding</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="800"><tr><td><img src="images/data_block_prefix_encoding.png" width="800" alt="ColumnFamily with Prefix Encoding"></td></tr></table><div class="caption"><p>A ColumnFamily with prefix encoding</p></div></div></div></div><br class="figure-break"></li><li class="listitem"><p>Diff - Diff encoding expands upon Prefix encoding. Instead of considering the key
          sequentially as a monolithic series of bytes, each key field is split so that each part of
          the key can be compressed more efficiently. Two new fields are added: timestamp and type.
          If the ColumnFamily is the same as the previous row, it is omitted from the current row.
          If the key length, value length or type are the same as the previous row, the field is
          omitted. In addition, for increased compression, the timestamp is stored as a Diff from
          the previous row's timestamp, rather than being stored in full. Given the two row keys in
          the Prefix example, and given an exact match on timestamp and the same type, neither the
          value length, or type needs to be stored for the second row, and the timestamp value for
          the second row is just 0, rather than a full timestamp.</p><p>Diff encoding is disabled by default because writing and scanning are slower but more
          data is cached.</p><p>This image shows the same ColumnFamily from the previous images, with Diff encoding.</p><div class="figure"><a name="d2875e24628"></a><p class="title"><b>Figure&nbsp;E.3.&nbsp;ColumnFamily with Diff Encoding</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="800"><tr><td><img src="images/data_block_diff_encoding.png" width="800" alt="ColumnFamily with Diff Encoding"></td></tr></table><div class="caption"><p>A ColumnFamily with diff encoding</p></div></div></div></div><br class="figure-break"></li><li class="listitem"><p>Fast Diff - Fast Diff works similar to Diff, but uses a faster implementation. It also
          adds another field which stores a single bit to track whether the data itself is the same
          as the previous row. If it is, the data is not stored again. Fast Diff is the recommended
          codec to use if you have long keys or many columns. The data format is nearly identical to
        Diff encoding, so there is not an image to illustrate it.</p></li><li class="listitem"><p>Prefix Tree encoding was introduced as an experimental feature in HBase 0.96. It
          provides similar memory savings to the Prefix, Diff, and Fast Diff encoder, but provides
          faster random access at a cost of slower encoding speed. Prefix Tree may be appropriate
          for applications that have high block cache hit ratios. It introduces new 'tree' fields
          for the row and column. The row tree field contains a list of offsets/references
          corresponding to the cells in that row. This allows for a good deal of compression. For
          more details about Prefix Tree encoding, see <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4676" target="_top">HBASE-4676</a>. It is
          difficult to graphically illustrate a prefix tree, so no image is included. See the
          Wikipedia article for <a class="link" href="http://en.wikipedia.org/wiki/Trie" target="_top">Trie</a> for more general information
          about this data structure.</p></li></ul></div><div class="section" title="E.1.&nbsp;Which Compressor or Data Block Encoder To Use"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e24649"></a>E.1.&nbsp;Which Compressor or Data Block Encoder To Use</h2></div></div></div><p>The compression or codec type to use depends on the characteristics of your data.
        Choosing the wrong type could cause your data to take more space rather than less, and can
        have performance implications. In general, you need to weigh your options between smaller
        size and faster compression/decompression. Following are some general guidelines, expanded from a discussion at <a class="link" href="http://search-hadoop.com/m/lL12B1PFVhp1" target="_top">Documenting Guidance on compression and codecs</a>. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If you have long keys (compared to the values) or many columns, use a prefix
            encoder. FAST_DIFF is recommended, as more testing is needed for Prefix Tree
            encoding.</p></li><li class="listitem"><p>If the values are large (and not precompressed, such as images), use a data block
            compressor.</p></li><li class="listitem"><p>Use GZIP for <em class="firstterm">cold data</em>, which is accessed infrequently. GZIP
            compression uses more CPU resources than Snappy or LZO, but provides a higher
            compression ratio.</p></li><li class="listitem"><p>Use Snappy or LZO for <em class="firstterm">hot data</em>, which is accessed
            frequently. Snappy and LZO use fewer CPU resources than GZIP, but do not provide as high
          of a compression ratio.</p></li><li class="listitem"><p>In most cases, enabling Snappy or LZO by default is a good choice, because they have
            a low performance overhead and provide space savings.</p></li><li class="listitem"><p>Before Snappy became available by Google in 2011, LZO was the default. Snappy has
            similar qualities as LZO but has been shown to perform better.</p></li></ul></div></div><div class="section" title="E.2.&nbsp;Making use of Hadoop Native Libraries in HBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hadoop.native.lib"></a>E.2.&nbsp;Making use of Hadoop Native Libraries in HBase</h2></div></div></div><p>The Hadoop shared library has a bunch of facility including
        compression libraries and fast crc'ing. To make this facility available
        to HBase, do the following. HBase/Hadoop will fall back to use
        alternatives if it cannot find the native library versions -- or
        fail outright if you asking for an explicit compressor and there is
      no alternative available.</p><p>If you see the following in your HBase logs, you know that HBase was unable
      to locate the Hadoop native libraries:
      </p><pre class="programlisting">2014-08-07 09:26:20,139 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</pre><p>
      If the libraries loaded successfully, the WARN message does not show.
    </p><p>Lets presume your Hadoop shipped with a native library that
      suits the platform you are running HBase on.  To check if the Hadoop
      native library is available to HBase, run the following tool (available in 
      Hadoop 2.1 and greater):
      </p><pre class="programlisting">$ ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker
2014-08-26 13:15:38,717 WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
Native library checking:
hadoop: false
zlib:   false
snappy: false
lz4:    false
bzip2:  false
2014-08-26 13:15:38,863 INFO  [main] util.ExitUtil: Exiting with status 1</pre><p>
Above shows that the native hadoop library is not available in HBase context.
    </p><p>To fix the above, either copy the Hadoop native libraries local or symlink to
      them if the Hadoop and HBase stalls are adjacent in the filesystem. 
      You could also point at their location by setting the <code class="varname">LD_LIBRARY_PATH</code> environment
      variable.</p><p>Where the JVM looks to find native librarys is "system dependent"
      (See <code class="classname">java.lang.System#loadLibrary(name)</code>). On linux, by default,
      is going to look in <code class="filename">lib/native/PLATFORM</code> where <code class="varname">PLATFORM</code>
      is the label for the platform your HBase is installed on.
      On a local linux machine, it seems to be the concatenation of the java properties
      <code class="varname">os.name</code> and <code class="varname">os.arch</code> followed by whether 32 or 64 bit.
      HBase on startup prints out all of the java system properties so find the os.name and os.arch
      in the log. For example:
      </p><pre class="programlisting">....
      2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.name=Linux
      2014-08-06 15:27:22,853 INFO  [main] zookeeper.ZooKeeper: Client environment:os.arch=amd64
      ...
    </pre><p>
     So in this case, the PLATFORM string is <code class="varname">Linux-amd64-64</code>.
     Copying the Hadoop native libraries or symlinking at <code class="filename">lib/native/Linux-amd64-64</code>
     will ensure they are found.  Check with the Hadoop <code class="filename">NativeLibraryChecker</code>. 
    </p><p>Here is example of how to point at the Hadoop libs with <code class="varname">LD_LIBRARY_PATH</code>
      environment variable:
      </p><pre class="programlisting">$ LD_LIBRARY_PATH=~/hadoop-2.5.0-SNAPSHOT/lib/native ./bin/hbase --config ~/conf_hbase org.apache.hadoop.util.NativeLibraryChecker
2014-08-26 13:42:49,332 INFO  [main] bzip2.Bzip2Factory: Successfully loaded &amp; initialized native-bzip2 library system-native
2014-08-26 13:42:49,337 INFO  [main] zlib.ZlibFactory: Successfully loaded &amp; initialized native-zlib library
Native library checking:
hadoop: true /home/stack/hadoop-2.5.0-SNAPSHOT/lib/native/libhadoop.so.1.0.0
zlib:   true /lib64/libz.so.1
snappy: true /usr/lib64/libsnappy.so.1
lz4:    true revision:99
bzip2:  true /lib64/libbz2.so.1</pre><p>
Set in <code class="filename">hbase-env.sh</code> the LD_LIBRARY_PATH environment variable when starting your HBase.
    </p></div><div class="section" title="E.3.&nbsp;Compressor Configuration, Installation, and Use"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e24742"></a>E.3.&nbsp;Compressor Configuration, Installation, and Use</h2></div></div></div><div class="section" title="E.3.1.&nbsp;Configure HBase For Compressors"><div class="titlepage"><div><div><h3 class="title"><a name="compressor.install"></a>E.3.1.&nbsp;Configure HBase For Compressors</h3></div></div></div><p>Before HBase can use a given compressor, its libraries need to be available. Due to
          licensing issues, only GZ compression is available to HBase (via native Java libraries) in
          a default installation. Other compression libraries are available via the shared library
          bundled with your hadoop.  The hadoop native library needs to be findable when HBase
          starts.  See </p><div class="section" title="E.3.1.1.&nbsp;Compressor Support On the Master"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e24750"></a>E.3.1.1.&nbsp;Compressor Support On the Master</h4></div></div></div><p>A new configuration setting was introduced in HBase 0.95, to check the Master to
            determine which data block encoders are installed and configured on it, and assume that
            the entire cluster is configured the same. This option,
              <code class="code">hbase.master.check.compression</code>, defaults to <code class="literal">true</code>. This
            prevents the situation described in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-6370" target="_top">HBASE-6370</a>, where
            a table is created or modified to support a codec that a region server does not support,
            leading to failures that take a long time to occur and are difficult to debug. </p><p>If <code class="code">hbase.master.check.compression</code> is enabled, libraries for all desired
            compressors need to be installed and configured on the Master, even if the Master does
            not run a region server.</p></div><div class="section" title="E.3.1.2.&nbsp;Install GZ Support Via Native Libraries"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e24769"></a>E.3.1.2.&nbsp;Install GZ Support Via Native Libraries</h4></div></div></div><p>HBase uses Java's built-in GZip support unless the native Hadoop libraries are
            available on the CLASSPATH. The recommended way to add libraries to the CLASSPATH is to
            set the environment variable <code class="envar">HBASE_LIBRARY_PATH</code> for the user running
            HBase. If native libraries are not available and Java's GZIP is used, <code class="literal">Got
              brand-new compressor</code> reports will be present in the logs. See <a class="xref" href="#brand.new.compressor" title="15.9.2.10.&nbsp;Logs flooded with '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Got brand-new compressor' messages">Section&nbsp;15.9.2.10, &#8220;Logs flooded with '2011-01-10 12:40:48,407 INFO org.apache.hadoop.io.compress.CodecPool: Got
            brand-new compressor' messages&#8221;</a>).</p></div><div class="section" title="E.3.1.3.&nbsp;Install LZO Support"><div class="titlepage"><div><div><h4 class="title"><a name="lzo.compression"></a>E.3.1.3.&nbsp;Install LZO Support</h4></div></div></div><p>HBase cannot ship with LZO because of incompatibility between HBase, which uses an
            Apache Software License (ASL) and LZO, which uses a GPL license. See the <a class="link" href="http://wiki.apache.org/hadoop/UsingLzoCompression" target="_top">Using LZO
              Compression</a> wiki page for information on configuring LZO support for HBase. </p><p>If you depend upon LZO compression, consider configuring your RegionServers to fail
            to start if LZO is not available. See <a class="xref" href="#hbase.regionserver.codecs" title="E.3.1.7.&nbsp;Enforce Compression Settings On a RegionServer">Section&nbsp;E.3.1.7, &#8220;Enforce Compression Settings On a RegionServer&#8221;</a>.</p></div><div class="section" title="E.3.1.4.&nbsp;Configure LZ4 Support"><div class="titlepage"><div><div><h4 class="title"><a name="lz4.compression"></a>E.3.1.4.&nbsp;Configure LZ4 Support</h4></div></div></div><p>LZ4 support is bundled with Hadoop. Make sure the hadoop shared library
            (libhadoop.so) is accessible when you start
            HBase. After configuring your platform (see <a class="xref" href="#">???</a>), you can make a symbolic link from HBase to the native Hadoop
            libraries. This assumes the two software installs are colocated. For example, if my
            'platform' is Linux-amd64-64:
            </p><pre class="programlisting">$ cd $HBASE_HOME
$ mkdir lib/native
$ ln -s $HADOOP_HOME/lib/native lib/native/Linux-amd64-64</pre><p>
            Use the compression tool to check that LZ4 is installed on all nodes. Start up (or restart)
            HBase. Afterward, you can create and alter tables to enable LZ4 as a
            compression codec.:
            </p><pre class="screen">
hbase(main):003:0&gt; <strong class="userinput"><code>alter 'TestTable', {NAME =&gt; 'info', COMPRESSION =&gt; 'LZ4'}</code></strong>
            </pre><p>
          </p></div><div class="section" title="E.3.1.5.&nbsp;Install Snappy Support"><div class="titlepage"><div><div><h4 class="title"><a name="snappy.compression.installation"></a>E.3.1.5.&nbsp;Install Snappy Support</h4></div></div></div><p>HBase does not ship with Snappy support because of licensing issues. You can install
            Snappy binaries (for instance, by using <span class="command"><strong>yum install snappy</strong></span> on CentOS)
            or build Snappy from source. After installing Snappy, search for the shared library,
            which will be called <code class="filename">libsnappy.so.X</code> where X is a number. If you
            built from source, copy the shared library to a known location on your system, such as
              <code class="filename">/opt/snappy/lib/</code>.</p><p>In addition to the Snappy library, HBase also needs access to the Hadoop shared
            library, which will be called something like <code class="filename">libhadoop.so.X.Y</code>,
            where X and Y are both numbers. Make note of the location of the Hadoop library, or copy
            it to the same location as the Snappy library.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The Snappy and Hadoop libraries need to be available on each node of your cluster.
              See <a class="xref" href="#compression.test" title="E.3.1.6.&nbsp;CompressionTest">Section&nbsp;E.3.1.6, &#8220;CompressionTest&#8221;</a> to find out how to test that this is the case.</p><p>See <a class="xref" href="#hbase.regionserver.codecs" title="E.3.1.7.&nbsp;Enforce Compression Settings On a RegionServer">Section&nbsp;E.3.1.7, &#8220;Enforce Compression Settings On a RegionServer&#8221;</a> to configure your RegionServers to fail to
              start if a given compressor is not available.</p></div><p>Each of these library locations need to be added to the environment variable
              <code class="envar">HBASE_LIBRARY_PATH</code> for the operating system user that runs HBase. You
            need to restart the RegionServer for the changes to take effect.</p></div><div class="section" title="E.3.1.6.&nbsp;CompressionTest"><div class="titlepage"><div><div><h4 class="title"><a name="compression.test"></a>E.3.1.6.&nbsp;CompressionTest</h4></div></div></div><p>You can use the CompressionTest tool to verify that your compressor is available to
            HBase:</p><pre class="screen">
 $ hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://<em class="replaceable"><code>host/path/to/hbase</code></em> snappy       
          </pre></div><div class="section" title="E.3.1.7.&nbsp;Enforce Compression Settings On a RegionServer"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.codecs"></a>E.3.1.7.&nbsp;Enforce Compression Settings On a RegionServer</h4></div></div></div><p>You can configure a RegionServer so that it will fail to restart if compression is
            configured incorrectly, by adding the option hbase.regionserver.codecs to the
              <code class="filename">hbase-site.xml</code>, and setting its value to a comma-separated list
            of codecs that need to be available. For example, if you set this property to
              <code class="literal">lzo,gz</code>, the RegionServer would fail to start if both compressors
            were not available. This would prevent a new server from being added to the cluster
            without having codecs configured properly.</p></div></div><div class="section" title="E.3.2.&nbsp;Enable Compression On a ColumnFamily"><div class="titlepage"><div><div><h3 class="title"><a name="changing.compression"></a>E.3.2.&nbsp;Enable Compression On a ColumnFamily</h3></div></div></div><p>To enable compression for a ColumnFamily, use an <code class="code">alter</code> command. You do
          not need to re-create the table or copy data. If you are changing codecs, be sure the old
          codec is still available until all the old StoreFiles have been compacted.</p><div class="example"><a name="d2875e24872"></a><p class="title"><b>Example&nbsp;E.1.&nbsp;Enabling Compression on a ColumnFamily of an Existing Table using HBase
            Shell</b></p><div class="example-contents"><pre class="screen">
hbase&gt; disable 'test'
hbase&gt; alter 'test', {NAME =&gt; 'cf', COMPRESSION =&gt; 'GZ'}
hbase&gt; enable 'test'
        </pre></div></div><br class="example-break"><div class="example"><a name="d2875e24877"></a><p class="title"><b>Example&nbsp;E.2.&nbsp;Creating a New Table with Compression On a ColumnFamily</b></p><div class="example-contents"><pre class="screen">
hbase&gt; create 'test2', { NAME =&gt; 'cf2', COMPRESSION =&gt; 'SNAPPY' }         
          </pre></div></div><br class="example-break"><div class="example"><a name="d2875e24882"></a><p class="title"><b>Example&nbsp;E.3.&nbsp;Verifying a ColumnFamily's Compression Settings</b></p><div class="example-contents"><pre class="screen">
hbase&gt; describe 'test'
DESCRIPTION                                          ENABLED
 'test', {NAME =&gt; 'cf', DATA_BLOCK_ENCODING =&gt; 'NONE false
 ', BLOOMFILTER =&gt; 'ROW', REPLICATION_SCOPE =&gt; '0',
 VERSIONS =&gt; '1', COMPRESSION =&gt; 'GZ', MIN_VERSIONS
 =&gt; '0', TTL =&gt; 'FOREVER', KEEP_DELETED_CELLS =&gt; 'fa
 lse', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'false', B
 LOCKCACHE =&gt; 'true'}
1 row(s) in 0.1070 seconds
          </pre></div></div><br class="example-break"></div><div class="section" title="E.3.3.&nbsp;Testing Compression Performance"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e24887"></a>E.3.3.&nbsp;Testing Compression Performance</h3></div></div></div><p>HBase includes a tool called LoadTestTool which provides mechanisms to test your
          compression performance. You must specify either <code class="literal">-write</code> or
          <code class="literal">-update-read</code> as your first parameter, and if you do not specify another
        parameter, usage advice is printed for each option.</p><div class="example"><a name="d2875e24898"></a><p class="title"><b>Example&nbsp;E.4.&nbsp;<span class="command">LoadTestTool</span> Usage</b></p><div class="example-contents"><pre class="screen">
$ bin/hbase org.apache.hadoop.hbase.util.LoadTestTool -h            
usage: bin/hbase org.apache.hadoop.hbase.util.LoadTestTool &lt;options&gt;
Options:
 -batchupdate                 Whether to use batch as opposed to separate
                              updates for every column in a row
 -bloom &lt;arg&gt;                 Bloom filter type, one of [NONE, ROW, ROWCOL]
 -compression &lt;arg&gt;           Compression type, one of [LZO, GZ, NONE, SNAPPY,
                              LZ4]
 -data_block_encoding &lt;arg&gt;   Encoding algorithm (e.g. prefix compression) to
                              use for data blocks in the test column family, one
                              of [NONE, PREFIX, DIFF, FAST_DIFF, PREFIX_TREE].
 -encryption &lt;arg&gt;            Enables transparent encryption on the test table,
                              one of [AES]
 -generator &lt;arg&gt;             The class which generates load for the tool. Any
                              args for this class can be passed as colon
                              separated after class name
 -h,--help                    Show usage
 -in_memory                   Tries to keep the HFiles of the CF inmemory as far
                              as possible.  Not guaranteed that reads are always
                              served from inmemory
 -init_only                   Initialize the test table only, don't do any
                              loading
 -key_window &lt;arg&gt;            The 'key window' to maintain between reads and
                              writes for concurrent write/read workload. The
                              default is 0.
 -max_read_errors &lt;arg&gt;       The maximum number of read errors to tolerate
                              before terminating all reader threads. The default
                              is 10.
 -multiput                    Whether to use multi-puts as opposed to separate
                              puts for every column in a row
 -num_keys &lt;arg&gt;              The number of keys to read/write
 -num_tables &lt;arg&gt;            A positive integer number. When a number n is
                              speicfied, load test tool  will load n table
                              parallely. -tn parameter value becomes table name
                              prefix. Each table name is in format
                              &lt;tn&gt;_1...&lt;tn&gt;_n
 -read &lt;arg&gt;                  &lt;verify_percent&gt;[:&lt;#threads=20&gt;]
 -regions_per_server &lt;arg&gt;    A positive integer number. When a number n is
                              specified, load test tool will create the test
                              table with n regions per server
 -skip_init                   Skip the initialization; assume test table already
                              exists
 -start_key &lt;arg&gt;             The first key to read/write (a 0-based index). The
                              default value is 0.
 -tn &lt;arg&gt;                    The name of the table to read or write
 -update &lt;arg&gt;                &lt;update_percent&gt;[:&lt;#threads=20&gt;][:&lt;#whether to
                              ignore nonce collisions=0&gt;]
 -write &lt;arg&gt;                 &lt;avg_cols_per_key&gt;:&lt;avg_data_size&gt;[:&lt;#threads=20&gt;]
 -zk &lt;arg&gt;                    ZK quorum as comma-separated host names without
                              port numbers
 -zk_root &lt;arg&gt;               name of parent znode in zookeeper            
          </pre></div></div><br class="example-break"><div class="example"><a name="d2875e24905"></a><p class="title"><b>Example&nbsp;E.5.&nbsp;Example Usage of LoadTestTool</b></p><div class="example-contents"><pre class="screen">
$ hbase org.apache.hadoop.hbase.util.LoadTestTool -write 1:10:100 -num_keys 1000000
          -read 100:30 -num_tables 1 -data_block_encoding NONE -tn load_test_tool_NONE
          </pre></div></div><br class="example-break"></div></div><div class="section" title="E.4.&nbsp;Enable Data Block Encoding"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="data.block.encoding.enable"></a>E.4.&nbsp;Enable Data Block Encoding</h2></div></div></div><p>Codecs are built into HBase so no extra configuration is needed. Codecs are enabled on a
        table by setting the <code class="code">DATA_BLOCK_ENCODING</code> property. Disable the table before
        altering its DATA_BLOCK_ENCODING setting. Following is an example using HBase Shell:</p><div class="example"><a name="d2875e24918"></a><p class="title"><b>Example&nbsp;E.6.&nbsp;Enable Data Block Encoding On a Table</b></p><div class="example-contents"><pre class="screen">
hbase&gt;  disable 'test'
hbase&gt; alter 'test', { NAME =&gt; 'cf', DATA_BLOCK_ENCODING =&gt; 'FAST_DIFF' }
Updating all regions with the new schema...
0/1 regions updated.
1/1 regions updated.
Done.
0 row(s) in 2.2820 seconds
hbase&gt; enable 'test'
0 row(s) in 0.1580 seconds          
          </pre></div></div><br class="example-break"><div class="example"><a name="d2875e24923"></a><p class="title"><b>Example&nbsp;E.7.&nbsp;Verifying a ColumnFamily's Data Block Encoding</b></p><div class="example-contents"><pre class="screen">
hbase&gt; describe 'test'
DESCRIPTION                                          ENABLED
 'test', {NAME =&gt; 'cf', DATA_BLOCK_ENCODING =&gt; 'FAST true
 _DIFF', BLOOMFILTER =&gt; 'ROW', REPLICATION_SCOPE =&gt;
 '0', VERSIONS =&gt; '1', COMPRESSION =&gt; 'GZ', MIN_VERS
 IONS =&gt; '0', TTL =&gt; 'FOREVER', KEEP_DELETED_CELLS =
 &gt; 'false', BLOCKSIZE =&gt; '65536', IN_MEMORY =&gt; 'fals
 e', BLOCKCACHE =&gt; 'true'}
1 row(s) in 0.0650 seconds          
        </pre></div></div><br class="example-break"></div></div><div class="appendix" title="Appendix&nbsp;F.&nbsp;SQL over HBase"><div class="titlepage"><div><div><h2 class="title"><a name="sql"></a>Appendix&nbsp;F.&nbsp;SQL over HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#phoenix">F.1. Apache Phoenix</a></span></dt><dt><span class="section"><a href="#trafodion">F.2. Trafodion</a></span></dt></dl></div><div class="section" title="F.1.&nbsp;Apache Phoenix"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="phoenix"></a>F.1.&nbsp;Apache Phoenix</h2></div></div></div><p><a class="link" href="http://phoenix.apache.org" target="_top">Apache Phoenix</a></p></div><div class="section" title="F.2.&nbsp;Trafodion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="trafodion"></a>F.2.&nbsp;Trafodion</h2></div></div></div><p><a class="link" href="https://wiki.trafodion.org/" target="_top">Trafodion: Transactional SQL-on-HBase</a></p></div></div><div class="appendix" title="Appendix&nbsp;G.&nbsp;YCSB: The Yahoo! Cloud Serving Benchmark and HBase"><div class="titlepage"><div><div><h2 class="title"><a name="d2875e24943"></a>Appendix&nbsp;G.&nbsp;<a class="link" href="https://github.com/brianfrankcooper/YCSB/" target="_top">YCSB: The Yahoo! Cloud Serving Benchmark</a> and HBase</h2></div></div></div><p>TODO: Describe how YCSB is poor for putting up a decent cluster load.</p><p>TODO: Describe setup of YCSB for HBase.  In particular, presplit your tables before you start
          a run.  See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4163" target="_top">HBASE-4163 Create Split Strategy for YCSB Benchmark</a>
          for why and a little shell command for how to do it.</p><p>Ted Dunning redid YCSB so it's mavenized and added facility for verifying workloads.  See <a class="link" href="https://github.com/tdunning/YCSB" target="_top">Ted Dunning's YCSB</a>.</p></div><div class="appendix" title="Appendix&nbsp;H.&nbsp;HFile format"><div class="titlepage"><div><div><h2 class="title"><a name="hfile_format"></a>Appendix&nbsp;H.&nbsp;HFile format</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#hfilev1">H.1. HBase File Format (version 1)</a></span></dt><dd><dl><dt><span class="section"><a href="#hfilev1.overview">H.1.1. Overview of Version 1</a></span></dt><dt><span class="section"><a href="#d2875e24991">H.1.2.  Block index format in version 1 </a></span></dt></dl></dd><dt><span class="section"><a href="#hfilev2">H.2. 
      HBase file format with inline blocks (version 2)
      </a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e25020">H.2.1. Motivation </a></span></dt><dt><span class="section"><a href="#hfilev2.overview">H.2.2. Overview of Version 2</a></span></dt><dt><span class="section"><a href="#d2875e25043">H.2.3. Unified version 2 block format</a></span></dt><dt><span class="section"><a href="#d2875e25112">H.2.4.  Block index in version 2</a></span></dt><dt><span class="section"><a href="#d2875e25137">H.2.5. 
      Root block index format in version 2</a></span></dt><dt><span class="section"><a href="#d2875e25190">H.2.6. 
      Non-root block index format in version 2</a></span></dt><dt><span class="section"><a href="#d2875e25215">H.2.7. 
      Bloom filters in version 2</a></span></dt><dt><span class="section"><a href="#d2875e25252">H.2.8. File Info format in versions 1 and 2</a></span></dt><dt><span class="section"><a href="#d2875e25298">H.2.9. 
      Fixed file trailer format differences between versions 1 and 2</a></span></dt><dt><span class="section"><a href="#d2875e25441">H.2.10. getShortMidpointKey(an optimization for data index block)</a></span></dt></dl></dd><dt><span class="section"><a href="#hfilev3">H.3. HBase File Format with Security Enhancements (version 3)</a></span></dt><dd><dl><dt><span class="section"><a href="#hfilev3.motivation">H.3.1. Motivation </a></span></dt><dt><span class="section"><a href="#hfilev3.overview">H.3.2. Overview</a></span></dt><dt><span class="section"><a href="#hvilev3.infoblock">H.3.3. File Info Block in Version 3</a></span></dt><dt><span class="section"><a href="#hfilev3.datablock">H.3.4. Data Blocks in Version 3</a></span></dt><dt><span class="section"><a href="#hfilev3.fixedtrailer">H.3.5. Fixed File Trailer in Version 3</a></span></dt></dl></dd></dl></div><p>This appendix describes the evolution of the HFile format.</p><div class="section" title="H.1.&nbsp;HBase File Format (version 1)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hfilev1"></a>H.1.&nbsp;HBase File Format (version 1)</h2></div></div></div><p>As we will be discussing changes to the HFile format, it is useful to give a short overview of the original (HFile version 1) format.</p><div class="section" title="H.1.1.&nbsp;Overview of Version 1"><div class="titlepage"><div><div><h3 class="title"><a name="hfilev1.overview"></a>H.1.1.&nbsp;Overview of Version 1</h3></div></div></div><p>An HFile in version 1 format is structured as follows:</p><div class="figure"><a name="d2875e24976"></a><p class="title"><b>Figure&nbsp;H.1.&nbsp;HFile V1 Format</b></p><div class="figure-contents"><div class="mediaobject" align="center"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0"><tr><td align="center" valign="middle"><img src="images/hfile.png" align="middle" alt="HFile Version 1"></td></tr></table><div class="caption"><p>Image courtesy of Lars George, <a class="link" href="http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html" target="_top">hbase-architecture-101-storage.html</a>.</p></div></div></div></div><br class="figure-break"></div><div class="section" title="H.1.2.&nbsp; Block index format in version 1"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e24991"></a>H.1.2.&nbsp; Block index format in version 1 </h3></div></div></div><p>The block index in version 1 is very straightforward. For each entry, it contains: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Offset (long)</p></li><li class="listitem"><p>Uncompressed size (int)</p></li><li class="listitem"><p>Key (a serialized byte array written using Bytes.writeByteArray) </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Key length as a variable-length integer (VInt)
                  </p></li><li class="listitem"><p>
                     Key bytes
                 </p></li></ol></div></li></ol></div><p>The number of entries in the block index is stored in the fixed file trailer, and has to be passed in to the method that reads the block index. One of the limitations of the block index in version 1 is that it does not provide the compressed size of a block, which turns out to be necessary for decompression. Therefore, the HFile reader has to infer this compressed size from the offset difference between blocks. We fix this limitation in version 2, where we store on-disk block size instead of uncompressed size, and get uncompressed size from the block header.</p></div></div><div class="section" title="H.2.&nbsp; HBase file format with inline blocks (version 2)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hfilev2"></a>H.2.&nbsp;
      HBase file format with inline blocks (version 2)
      </h2></div></div></div><p>Note:  this feature was introduced in HBase 0.92</p><div class="section" title="H.2.1.&nbsp;Motivation"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25020"></a>H.2.1.&nbsp;Motivation </h3></div></div></div><p>We found it necessary to revise the HFile format after encountering high memory usage and slow startup times caused by large Bloom filters and block indexes in the region server. Bloom filters can get as large as 100 MB per HFile, which adds up to 2 GB when aggregated over 20 regions. Block indexes can grow as large as 6 GB in aggregate size over the same set of regions. A region is not considered opened until all of its block index data is loaded. Large Bloom filters produce a different performance problem: the first get request that requires a Bloom filter lookup will incur the latency of loading the entire Bloom filter bit array.</p><p>To speed up region server startup we break Bloom filters and block indexes into multiple blocks and write those blocks out as they fill up, which also reduces the HFile writer&#8217;s memory footprint. In the Bloom filter case, &#8220;filling up a block&#8221; means accumulating enough keys to efficiently utilize a fixed-size bit array, and in the block index case we accumulate an &#8220;index block&#8221; of the desired size. Bloom filter blocks and index blocks (we call these &#8220;inline blocks&#8221;) become interspersed with data blocks, and as a side effect we can no longer rely on the difference between block offsets to determine data block length, as it was done in version 1.</p><p>HFile is a low-level file format by design, and it should not deal with application-specific details such as Bloom filters, which are handled at StoreFile level. Therefore, we call Bloom filter blocks in an HFile "inline" blocks. We also supply HFile with an interface to write those inline blocks. </p><p>Another format modification aimed at reducing the region server startup time is to use a contiguous &#8220;load-on-open&#8221; section that has to be loaded in memory at the time an HFile is being opened. Currently, as an HFile opens, there are separate seek operations to read the trailer, data/meta indexes, and file info. To read the Bloom filter, there are two more seek operations for its &#8220;data&#8221; and &#8220;meta&#8221; portions. In version 2, we seek once to read the trailer and seek again to read everything else we need to open the file from a contiguous block.</p></div><div class="section" title="H.2.2.&nbsp;Overview of Version 2"><div class="titlepage"><div><div><h3 class="title"><a name="hfilev2.overview"></a>H.2.2.&nbsp;Overview of Version 2</h3></div></div></div><p>The version of HBase introducing the above features reads both version 1 and 2 HFiles, but only writes version 2 HFiles. A version 2 HFile is structured as follows:
           <span class="inlinemediaobject"><img src="images/hfilev2.png" align="middle" alt="HFile Version 2"></span>

   </p></div><div class="section" title="H.2.3.&nbsp;Unified version 2 block format"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25043"></a>H.2.3.&nbsp;Unified version 2 block format</h3></div></div></div><p>In the version 2 every block in the data section contains the following fields: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>8 bytes: Block type, a sequence of bytes equivalent to version 1's "magic records". Supported block types are: </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>DATA &#8211; data blocks
                  </p></li><li class="listitem"><p>
                     LEAF_INDEX &#8211; leaf-level index blocks in a multi-level-block-index
                 </p></li><li class="listitem"><p>
                     BLOOM_CHUNK &#8211; Bloom filter chunks
                  </p></li><li class="listitem"><p>
                     META &#8211; meta blocks (not used for Bloom filters in version 2 anymore)
                  </p></li><li class="listitem"><p>
                     INTERMEDIATE_INDEX &#8211; intermediate-level index blocks in a multi-level blockindex
                  </p></li><li class="listitem"><p>
                     ROOT_INDEX &#8211; root&gt;level index blocks in a multi&gt;level block index
                  </p></li><li class="listitem"><p>
                     FILE_INFO &#8211; the &#8220;file info&#8221; block, a small key&gt;value map of metadata
                  </p></li><li class="listitem"><p>
                     BLOOM_META &#8211; a Bloom filter metadata block in the load&gt;on&gt;open section
                  </p></li><li class="listitem"><p>
                     TRAILER &#8211; a fixed&gt;size file trailer. As opposed to the above, this is not an
                     HFile v2 block but a fixed&gt;size (for each HFile version) data structure
                  </p></li><li class="listitem"><p>
                      INDEX_V1 &#8211; this block type is only used for legacy HFile v1 block
                  </p></li></ol></div></li><li class="listitem"><p>Compressed size of the block's data, not including the header (int).
         </p><p>
Can be used for skipping the current data block when scanning HFile data.
                  </p></li><li class="listitem"><p>Uncompressed size of the block's data, not including the header (int)</p><p>
 This is equal to the compressed size if the compression algorithm is NONE
                  </p></li><li class="listitem"><p>File offset of the previous block of the same type (long)</p><p>
 Can be used for seeking to the previous data/index block
                  </p></li><li class="listitem"><p>Compressed data (or uncompressed data if the compression algorithm is NONE).</p></li></ol></div><p>The above format of blocks is used in the following HFile sections:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Scanned block section. The section is named so because it contains all data blocks that need to be read when an HFile is scanned sequentially. &nbsp;Also contains leaf block index and Bloom chunk blocks. </p></li><li class="listitem"><p>Non-scanned block section. This section still contains unified-format v2 blocks but it does not have to be read when doing a sequential scan. This section contains &#8220;meta&#8221; blocks and intermediate-level index blocks.
         </p></li></ol></div><p>We are supporting &#8220;meta&#8221; blocks in version 2 the same way they were supported in version 1, even though we do not store Bloom filter data in these blocks anymore. </p></div><div class="section" title="H.2.4.&nbsp; Block index in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25112"></a>H.2.4.&nbsp; Block index in version 2</h3></div></div></div><p>There are three types of block indexes in HFile version 2, stored in two different formats (root and non-root): </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Data index &#8212; version 2 multi-level block index, consisting of:</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
 Version 2 root index, stored in the data block index section of the file
             </p></li><li class="listitem"><p>
Optionally, version 2 intermediate levels, stored in the non%root format in   the data index section of the file.    Intermediate levels can only be present if leaf level blocks are present
             </p></li><li class="listitem"><p>
Optionally, version 2 leaf levels, stored in the non%root format inline with   data blocks
             </p></li></ol></div></li><li class="listitem"><p>Meta index &#8212; version 2 root index format only, stored in the meta index section of the file</p></li><li class="listitem"><p>Bloom index &#8212; version 2 root index format only, stored in the &#8220;load-on-open&#8221; section as part of Bloom filter metadata.</p></li></ol></div></div><div class="section" title="H.2.5.&nbsp; Root block index format in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25137"></a>H.2.5.&nbsp;
      Root block index format in version 2</h3></div></div></div><p>This format applies to:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Root level of the version 2 data index</p></li><li class="listitem"><p>Entire meta and Bloom indexes in version 2, which are always single-level. </p></li></ol></div><p>A version 2 root index block is a sequence of entries of the following format, similar to entries of a version 1 block index, but storing on-disk size instead of uncompressed size. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Offset (long) </p><p>
This offset may point to a data block or to a deeper&gt;level index block.
             </p></li><li class="listitem"><p>On-disk size (int) </p></li><li class="listitem"><p>Key (a serialized byte array stored using Bytes.writeByteArray) </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>Key (VInt)
             </p></li><li class="listitem"><p>Key bytes
             </p></li></ol></div></li></ol></div><p>A single-level version 2 block index consists of just a single root index block. To read a root index block of version 2, one needs to know the number of entries. For the data index and the meta index the number of entries is stored in the trailer, and for the Bloom index it is stored in the compound Bloom filter metadata.</p><p>For a multi-level block index we also store the following fields in the root index block in the load-on-open section of the HFile, in addition to the data structure described above:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Middle leaf index block offset</p></li><li class="listitem"><p>Middle leaf block on-disk size (meaning the leaf index block containing the reference to the &#8220;middle&#8221; data block of the file) </p></li><li class="listitem"><p>The index of the mid-key (defined below) in the middle leaf-level block.</p></li></ol></div><p></p><p>These additional fields are used to efficiently retrieve the mid-key of the HFile used in HFile splits, which we define as the first key of the block with a zero-based index of (n &#8211; 1) / 2, if the total number of blocks in the HFile is n. This definition is consistent with how the mid-key was determined in HFile version 1, and is reasonable in general, because blocks are likely to be the same size on average, but we don&#8217;t have any estimates on individual key/value pair sizes. </p><p></p><p>When writing a version 2 HFile, the total number of data blocks pointed to by every leaf-level index block is kept track of. When we finish writing and the total number of leaf-level blocks is determined, it is clear which leaf-level block contains the mid-key, and the fields listed above are computed. &nbsp;When reading the HFile and the mid-key is requested, we retrieve the middle leaf index block (potentially from the block cache) and get the mid-key value from the appropriate position inside that leaf block.</p></div><div class="section" title="H.2.6.&nbsp; Non-root block index format in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25190"></a>H.2.6.&nbsp;
      Non-root block index format in version 2</h3></div></div></div><p>This format applies to intermediate-level and leaf index blocks of a version 2 multi-level data block index. Every non-root index block is structured as follows. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>numEntries: the number of entries (int). </p></li><li class="listitem"><p>entryOffsets: the &#8220;secondary index&#8221; of offsets of entries in the block, to facilitate a quick binary search on the key (numEntries + 1 int values). The last value is the total length of all entries in this index block. For example, in a non-root index block with entry sizes 60, 80, 50 the &#8220;secondary index&#8221; will contain the following int array: {0, 60, 140, 190}.</p></li><li class="listitem"><p>Entries. Each entry contains: </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
Offset of the block referenced by this entry in the file (long)
             </p></li><li class="listitem"><p>
On&gt;disk size of the referenced block (int)
             </p></li><li class="listitem"><p>
Key. The length can be calculated from entryOffsets.
             </p></li></ol></div></li></ol></div></div><div class="section" title="H.2.7.&nbsp; Bloom filters in version 2"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25215"></a>H.2.7.&nbsp;
      Bloom filters in version 2</h3></div></div></div><p>In contrast with version 1, in a version 2 HFile Bloom filter metadata is stored in the load-on-open section of the HFile for quick startup. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A compound Bloom filter. </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
 Bloom filter version = 3 (int). There used to be a DynamicByteBloomFilter class that had the Bloom   filter version number 2
             </p></li><li class="listitem"><p>
The total byte size of all compound Bloom filter chunks (long)
             </p></li><li class="listitem"><p>
 Number of hash functions (int
             </p></li><li class="listitem"><p>
Type of hash functions (int)
             </p></li><li class="listitem"><p>
The total key count inserted into the Bloom filter (long)
             </p></li><li class="listitem"><p>
The maximum total number of keys in the Bloom filter (long)
             </p></li><li class="listitem"><p>
The number of chunks (int)
             </p></li><li class="listitem"><p>
Comparator class used for Bloom filter keys, a UTF&gt;8 encoded string stored   using Bytes.writeByteArray
             </p></li><li class="listitem"><p>
 Bloom block index in the version 2 root block index format
             </p></li></ol></div></li></ol></div></div><div class="section" title="H.2.8.&nbsp;File Info format in versions 1 and 2"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25252"></a>H.2.8.&nbsp;File Info format in versions 1 and 2</h3></div></div></div><p>The file info block is a serialized <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/HbaseMapWritable.html" target="_top">HbaseMapWritable</a> (essentially a map from byte arrays to byte arrays) with the following keys, among others. StoreFile-level logic adds more keys to this.</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>
               <p>hfile.LASTKEY </p>
            </td><td>
               <p>The last key of the file (byte array) </p>
            </td></tr><tr><td>
               <p>hfile.AVG_KEY_LEN </p>
            </td><td>
               <p>The average key length in the file (int) </p>
            </td></tr><tr><td>
               <p>hfile.AVG_VALUE_LEN </p>
            </td><td>
               <p>The average value length in the file (int) </p>
            </td></tr></tbody></table></div><p>File info format did not change in version 2. However, we moved the file info to the final section of the file, which can be loaded as one block at the time the HFile is being opened. Also, we do not store comparator in the version 2 file info anymore. Instead, we store it in the fixed file trailer. This is because we need to know the comparator at the time of parsing the load-on-open section of the HFile.</p></div><div class="section" title="H.2.9.&nbsp; Fixed file trailer format differences between versions 1 and 2"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25298"></a>H.2.9.&nbsp;
      Fixed file trailer format differences between versions 1 and 2</h3></div></div></div><p>The following table shows common and different fields between fixed file trailers in versions 1 and 2. Note that the size of the trailer is different depending on the version, so it is &#8220;fixed&#8221; only within one version. However, the version is always stored as the last four-byte integer in the file. </p><p></p><div class="informaltable"><table border="1"><colgroup><col class="c1"><col class="c2"></colgroup><tbody><tr><td>
               <p>Version 1 </p>
            </td><td>
               <p>Version 2 </p>
            </td></tr><tr><td colspan="2" align="center">
               <p>File info offset (long) </p>
            </td></tr><tr><td>
               <p>Data index offset (long) </p>
            </td><td>
                <p>loadOnOpenOffset (long)</p>
                <p><span class="emphasis"><em>The offset of the section that we need toload when opening the file.</em></span></p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Number of data index entries (int) </p>
            </td></tr><tr><td>
               <p>metaIndexOffset (long)</p>
               <p>This field is not being used by the version 1 reader, so we removed it from version 2.</p>
            </td><td>
               <p>uncompressedDataIndexSize (long)</p>
               <p>The total uncompressed size of the whole data block index, including root-level, intermediate-level, and leaf-level blocks.</p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Number of meta index entries (int) </p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Total uncompressed bytes (long) </p>
            </td></tr><tr><td>
               <p>numEntries (int) </p>
            </td><td>
               <p>numEntries (long) </p>
            </td></tr><tr><td colspan="2" align="center">
               <p>Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int) </p>
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p>The number of levels in the data block index (int) </p>
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p>firstDataBlockOffset (long)</p>
               <p>The offset of the first first data block. Used when scanning. </p>
            </td></tr><tr><td>
               <p></p>
            </td><td>
               <p>lastDataBlockEnd (long)</p>
               <p>The offset of the first byte after the last key/value data block. We don't need to go beyond this offset when scanning. </p>
            </td></tr><tr><td>
               <p>Version: 1 (int) </p>
            </td><td>
               <p>Version: 2 (int) </p>
            </td></tr></tbody></table></div><p></p></div><div class="section" title="H.2.10.&nbsp;getShortMidpointKey(an optimization for data index block)"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25441"></a>H.2.10.&nbsp;getShortMidpointKey(an optimization for data index block)</h3></div></div></div><p>Note: this optimization was introduced in HBase 0.95+</p><p>HFiles contain many blocks that contain a range of sorted Cells. Each cell has a key. To save IO when reading Cells, the HFile also has an index that maps a Cell's start key to the offset of the beginning of a particular block. Prior to this optimization, HBase would use the key of the first cell in each data block as the index key.</p><p>In HBASE-7845, we generate a new key that is lexicographically larger than the last key of the previous block and lexicographically equal or smaller than the start key of the current block. While actual keys can potentially be very long, this "fake key" or "virtual key" can be much shorter. For example, if the stop key of previous block is "the quick brown fox", the start key of current block is "the who", we could use "the r" as our virtual key in our hfile index.</p><p>There are two benefits to this:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>having shorter keys reduces the hfile index size, (allowing us to keep more indexes in memory), and</p></li><li class="listitem"><p>using something closer to the end key of the previous block allows us to avoid a potential extra IO when the target key lives in between the "virtual key" and the key of the first element in the target block.</p></li></ul></div><p>This optimization (implemented by the getShortMidpointKey method) is inspired by LevelDB's ByteWiseComparatorImpl::FindShortestSeparator() and FindShortSuccessor().</p></div></div><div class="section" title="H.3.&nbsp;HBase File Format with Security Enhancements (version 3)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hfilev3"></a>H.3.&nbsp;HBase File Format with Security Enhancements (version 3)</h2></div></div></div><p>Note: this feature was introduced in HBase 0.98</p><div class="section" title="H.3.1.&nbsp;Motivation"><div class="titlepage"><div><div><h3 class="title"><a name="hfilev3.motivation"></a>H.3.1.&nbsp;Motivation </h3></div></div></div><p>
        Version 3 of HFile makes changes needed to ease management of encryption at rest and
        cell-level metadata (which in turn is needed for cell-level ACLs and cell-level visibility
        labels). For more information see <a class="xref" href="#hbase.encryption.server" title="8.3.4.&nbsp;Transparent Encryption of Data At Rest">Section&nbsp;8.3.4, &#8220;Transparent Encryption of Data At Rest&#8221;</a>,
        <a class="xref" href="#hbase.tags" title="8.3.1.&nbsp;Tags">Section&nbsp;8.3.1, &#8220;Tags&#8221;</a>, <a class="xref" href="#hbase.accesscontrol.configuration" title="8.3.2.&nbsp;Access Control Labels (ACLs)">Section&nbsp;8.3.2, &#8220;Access Control Labels (ACLs)&#8221;</a>, and
        <a class="xref" href="#">???</a>.
      </p></div><div class="section" title="H.3.2.&nbsp;Overview"><div class="titlepage"><div><div><h3 class="title"><a name="hfilev3.overview"></a>H.3.2.&nbsp;Overview</h3></div></div></div><p>
        The version of HBase introducing the above features reads HFiles in versions 1, 2, and 3 but
        only writes version 3 HFiles. Version 3 HFiles are structured the same as version 2 HFiles.
        For more information see <a class="xref" href="#hfilev2.overview" title="H.2.2.&nbsp;Overview of Version 2">Section&nbsp;H.2.2, &#8220;Overview of Version 2&#8221;</a>.
      </p></div><div class="section" title="H.3.3.&nbsp;File Info Block in Version 3"><div class="titlepage"><div><div><h3 class="title"><a name="hvilev3.infoblock"></a>H.3.3.&nbsp;File Info Block in Version 3</h3></div></div></div><p>
        Version 3 added two additional pieces of information to the reserved keys in the file info
        block.
        </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>
                    <p>hfile.MAX_TAGS_LEN</p>
                 </td><td>
                    <p>
                      The maximum number of bytes needed to store the serialized tags for any single
                      cell in this hfile (int)
                    </p>
                 </td></tr><tr><td>
                    <p>hfile.TAGS_COMPRESSED</p>
                 </td><td>
                    <p>Does the block encoder for this hfile compress tags? (boolean)</p>
                    <p>
                      Should only be present if <code class="classname">hfile.MAX_TAGS_LEN</code> is also
                      present.
                    </p>
                 </td></tr></tbody></table></div><p>
      </p><p>
        When reading a Version 3 HFile the presence of <code class="classname">MAX_TAGS_LEN</code> is used
        to determine how to deserialize the cells within a data block. Therefore, consumers must
        read the file's info block prior to reading any data blocks.
      </p><p>
        When writing a Version 3 HFile, HBase will always include <code class="classname">MAX_TAGS_LEN
        </code> when flushing the memstore to underlying filesystem and when using prefix tree
        encoding for data blocks, as described in <a class="xref" href="#compression" title="Appendix&nbsp;E.&nbsp;Compression and Data Block Encoding In HBase">Appendix&nbsp;E, <i>Compression and Data Block Encoding In
          HBase</i></a>. When compacting
        extant files, the default writer will omit <code class="classname">MAX_TAGS_LEN</code> if all of the
        files selected do not themselves contain any cells with tags. See
        <a class="xref" href="#compaction" title="9.7.7.7.&nbsp;Compaction">Section&nbsp;9.7.7.7, &#8220;Compaction&#8221;</a> for details on the compaction file selection algorithm.
      </p></div><div class="section" title="H.3.4.&nbsp;Data Blocks in Version 3"><div class="titlepage"><div><div><h3 class="title"><a name="hfilev3.datablock"></a>H.3.4.&nbsp;Data Blocks in Version 3</h3></div></div></div><p>
        Within an HFile, HBase cells are stored in data blocks as a sequence of KeyValues (see <a class="xref" href="#hfilev1.overview" title="H.1.1.&nbsp;Overview of Version 1">Section&nbsp;H.1.1, &#8220;Overview of Version 1&#8221;</a>, or <a class="link" href="http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html" target="_top">Lars George's
        excellent introduction to HBase Storage</a>). In version 3, these KeyValue optionally
        will include a set of 0 or more tags:
        </p><div class="informaltable"><table border="1"><colgroup><col class="c1"><col class="c2"></colgroup><tbody><tr><td>
                  <p>Version 1 &amp; 2</p>
                  <p>Version 3 without MAX_TAGS_LEN</p>
                </td><td><p>Version 3 with MAX_TAGS_LEN</p></td></tr><tr><td colspan="2" align="center">
                  <p>Key Length (4 bytes)</p>
                </td></tr><tr><td colspan="2" align="center">
                  <p>Value Length (4 bytes)</p>
                </td></tr><tr><td colspan="2" align="center">
                  <p>Key bytes (variable)</p>
                </td></tr><tr><td colspan="2" align="center">
                  <p>Value bytes (variable)</p>
                </td></tr><tr><td class="auto-generated">&nbsp;</td><td align="center">
                  <p>Tags Length (2 bytes)</p>
                </td></tr><tr><td class="auto-generated">&nbsp;</td><td align="center">
                  <p>Tags bytes (variable)</p>
                </td></tr></tbody></table></div><p>
      </p><p>
        If the info block for a given HFile contains an entry for
        <code class="classname">MAX_TAGS_LEN</code> each cell will have the length of that cell's tags
        included, even if that length is zero. The actual tags are stored as a sequence of tag
        length (2 bytes), tag type (1 byte), tag bytes (variable). The format an individual tag's
        bytes depends on the tag type.
      </p><p>
        Note that the dependence on the contents of the info block implies that prior to reading
        any data blocks you must first process a file's info block. It also implies that prior to
        writing a data block you must know if the file's info block will include
        <code class="classname">MAX_TAGS_LEN</code>.
      </p></div><div class="section" title="H.3.5.&nbsp;Fixed File Trailer in Version 3"><div class="titlepage"><div><div><h3 class="title"><a name="hfilev3.fixedtrailer"></a>H.3.5.&nbsp;Fixed File Trailer in Version 3</h3></div></div></div><p>
        The fixed file trailers written with HFile version 3 are always serialized with protocol
        buffers. Additionally, it adds an optional field to the version 2 protocol buffer named
        encryption_key. If HBase is configured to encrypt HFiles this field will store a data
        encryption key for this particular HFile, encrypted with the current cluster master key
        using AES. For more information see <a class="xref" href="#hbase.encryption.server" title="8.3.4.&nbsp;Transparent Encryption of Data At Rest">Section&nbsp;8.3.4, &#8220;Transparent Encryption of Data At Rest&#8221;</a>.
      </p></div></div></div><div class="appendix" title="Appendix&nbsp;I.&nbsp;Other Information About HBase"><div class="titlepage"><div><div><h2 class="title"><a name="other.info"></a>Appendix&nbsp;I.&nbsp;Other Information About HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#other.info.videos">I.1. HBase Videos</a></span></dt><dt><span class="section"><a href="#other.info.pres">I.2. HBase Presentations (Slides)</a></span></dt><dt><span class="section"><a href="#other.info.papers">I.3. HBase Papers</a></span></dt><dt><span class="section"><a href="#other.info.sites">I.4. HBase Sites</a></span></dt><dt><span class="section"><a href="#other.info.books">I.5. HBase Books</a></span></dt><dt><span class="section"><a href="#other.info.books.hadoop">I.6. Hadoop Books</a></span></dt></dl></div><div class="section" title="I.1.&nbsp;HBase Videos"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.videos"></a>I.1.&nbsp;HBase Videos</h2></div></div></div><p>Introduction to HBase
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="http://www.cloudera.com/content/cloudera/en/resources/library/presentation/chicago_data_summit_apache_hbase_an_introduction_todd_lipcon.html" target="_top">Introduction to HBase</a> by Todd Lipcon (Chicago Data Summit 2011).
			  </p></li><li class="listitem"><p><a class="link" href="http://www.cloudera.com/videos/intorduction-hbase-todd-lipcon" target="_top">Introduction to HBase</a> by Todd Lipcon (2010).
			  </p></li></ul></div><p>
         </p><p><a class="link" href="http://www.cloudera.com/videos/hadoop-world-2011-presentation-video-building-realtime-big-data-services-at-facebook-with-hadoop-and-hbase" target="_top">Building Real Time Services at Facebook with HBase</a> by Jonathan Gray (Hadoop World 2011).
         </p><p><a class="link" href="http://www.cloudera.com/videos/hw10_video_how_stumbleupon_built_and_advertising_platform_using_hbase_and_hadoop" target="_top">HBase and Hadoop, Mixing Real-Time and Batch Processing at StumbleUpon</a> by JD Cryans (Hadoop World 2010).
         </p></div><div class="section" title="I.2.&nbsp;HBase Presentations (Slides)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.pres"></a>I.2.&nbsp;HBase Presentations (Slides)</h2></div></div></div><p><a class="link" href="http://www.cloudera.com/content/cloudera/en/resources/library/hadoopworld/hadoop-world-2011-presentation-video-advanced-hbase-schema-design.html" target="_top">Advanced HBase Schema Design</a> by Lars George (Hadoop World 2011).
         </p><p><a class="link" href="http://www.slideshare.net/cloudera/chicago-data-summit-apache-hbase-an-introduction" target="_top">Introduction to HBase</a> by Todd Lipcon (Chicago Data Summit 2011).
         </p><p><a class="link" href="http://www.slideshare.net/cloudera/hw09-practical-h-base-getting-the-most-from-your-h-base-install" target="_top">Getting The Most From Your HBase Install</a> by Ryan Rawson, Jonathan Gray (Hadoop World 2009).
         </p></div><div class="section" title="I.3.&nbsp;HBase Papers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.papers"></a>I.3.&nbsp;HBase Papers</h2></div></div></div><p><a class="link" href="http://research.google.com/archive/bigtable.html" target="_top">BigTable</a> by Google (2006).
         </p><p><a class="link" href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html" target="_top">HBase and HDFS Locality</a> by Lars George (2010).
         </p><p><a class="link" href="http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf" target="_top">No Relation: The Mixed Blessings of Non-Relational Databases</a> by Ian Varley (2009).
         </p></div><div class="section" title="I.4.&nbsp;HBase Sites"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.sites"></a>I.4.&nbsp;HBase Sites</h2></div></div></div><p><a class="link" href="http://www.cloudera.com/blog/category/hbase/" target="_top">Cloudera's HBase Blog</a> has a lot of links to useful HBase information.
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="link" href="http://www.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/" target="_top">CAP Confusion</a> is a relevant entry for background information on
			distributed storage systems.</p></li></ul></div><p>
         </p><p><a class="link" href="http://wiki.apache.org/hadoop/HBase/HBasePresentations" target="_top">HBase Wiki</a> has a page with a number of presentations.
         </p><p><a class="link" href="http://refcardz.dzone.com/refcardz/hbase" target="_top">HBase RefCard</a> from DZone.
         </p></div><div class="section" title="I.5.&nbsp;HBase Books"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.books"></a>I.5.&nbsp;HBase Books</h2></div></div></div><p><a class="link" href="http://shop.oreilly.com/product/0636920014348.do" target="_top">HBase:  The Definitive Guide</a> by Lars George.
         </p></div><div class="section" title="I.6.&nbsp;Hadoop Books"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="other.info.books.hadoop"></a>I.6.&nbsp;Hadoop Books</h2></div></div></div><p><a class="link" href="http://shop.oreilly.com/product/9780596521981.do" target="_top">Hadoop:  The Definitive Guide</a> by Tom White.
         </p></div></div><div class="appendix" title="Appendix&nbsp;J.&nbsp;HBase History"><div class="titlepage"><div><div><h2 class="title"><a name="hbase.history"></a>Appendix&nbsp;J.&nbsp;HBase History</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>2006:  <a class="link" href="http://research.google.com/archive/bigtable.html" target="_top">BigTable</a> paper published by Google.
	  </p></li><li class="listitem"><p>2006 (end of year):  HBase development starts.
	  </p></li><li class="listitem"><p>2008:  HBase becomes Hadoop sub-project.
	  </p></li><li class="listitem"><p>2010:  HBase becomes Apache top-level project.
	  </p></li></ul></div></div><div class="appendix" title="Appendix&nbsp;K.&nbsp;HBase and the Apache Software Foundation"><div class="titlepage"><div><div><h2 class="title"><a name="asf"></a>Appendix&nbsp;K.&nbsp;HBase and the Apache Software Foundation</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#asf.devprocess">K.1. ASF Development Process</a></span></dt><dt><span class="section"><a href="#asf.reporting">K.2. ASF Board Reporting</a></span></dt></dl></div><p>HBase is a project in the Apache Software Foundation and as such there are responsibilities to the ASF to ensure
    a healthy project.</p><div class="section" title="K.1.&nbsp;ASF Development Process"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="asf.devprocess"></a>K.1.&nbsp;ASF Development Process</h2></div></div></div><p>See the <a class="link" href="http://www.apache.org/dev/#committers" target="_top">Apache Development Process page</a>
        for all sorts of information on how the ASF is structured (e.g., PMC, committers, contributors), to tips on contributing
        and getting involved, and how open-source works at ASF.
        </p></div><div class="section" title="K.2.&nbsp;ASF Board Reporting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="asf.reporting"></a>K.2.&nbsp;ASF Board Reporting</h2></div></div></div><p>Once a quarter, each project in the ASF portfolio submits a report to the ASF board.  This is done by the HBase project
         lead and the committers.  See <a class="link" href="http://www.apache.org/foundation/board/reporting" target="_top">ASF board reporting</a> for more information.
         </p></div></div><div class="appendix" title="Appendix&nbsp;L.&nbsp;Apache HBase Orca"><div class="titlepage"><div><div><h2 class="title"><a name="orca"></a>Appendix&nbsp;L.&nbsp;Apache HBase Orca</h2></div></div></div><span class="inlinemediaobject"><img src="images/jumping-orca_rotated_25percent.png" align="middle"></span><p><a class="link" href="https://issues.apache.org/jira/browse/HBASE-4920" target="_top">An Orca is the Apache HBase mascot.</a>
      See NOTICES.txt.  Our Orca logo we got here: http://www.vectorfree.com/jumping-orca
      It is licensed Creative Commons Attribution 3.0.  See https://creativecommons.org/licenses/by/3.0/us/
      We changed the logo by stripping the colored background, inverting
      it and then rotating it some.
    </p></div><div class="appendix" title="Appendix&nbsp;M.&nbsp;Enabling Dapper-like Tracing in HBase"><div class="titlepage"><div><div><h2 class="title"><a name="tracing"></a>Appendix&nbsp;M.&nbsp;Enabling Dapper-like Tracing in HBase</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#tracing.spanreceivers">M.1. SpanReceivers</a></span></dt><dt><span class="section"><a href="#tracing.client.modifications">M.2. Client Modifications</a></span></dt><dt><span class="section"><a href="#tracing.client.shell">M.3. Tracing from HBase Shell</a></span></dt></dl></div><p>
    <a class="link" href="https://issues.apache.org/jira/browse/HBASE-6449" target="_top">HBASE-6449</a> added support
    for tracing requests through HBase, using the open source tracing library, <a class="link" href="http://github.com/cloudera/htrace" target="_top">HTrace</a>. Setting up tracing is quite
    simple, however it currently requires some very minor changes to your client code (it would not
    be very difficult to remove this requirement). </p><div class="section" title="M.1.&nbsp;SpanReceivers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tracing.spanreceivers"></a>M.1.&nbsp;SpanReceivers</h2></div></div></div><p> The tracing system works by collecting information in structs called 'Spans'. It is up to
      you to choose how you want to receive this information by implementing the
        <code class="classname">SpanReceiver</code> interface, which defines one method: </p><pre class="programlisting">
public void receiveSpan(Span span);
</pre><p>This method serves as a callback whenever a span is completed. HTrace allows you to use as
      many SpanReceivers as you want so you can easily send trace information to multiple
      destinations. </p><p> Configure what SpanReceivers you'd like to us by putting a comma separated list of the
      fully-qualified class name of classes implementing <code class="classname">SpanReceiver</code> in
        <code class="filename">hbase-site.xml</code> property:
        <code class="varname">hbase.trace.spanreceiver.classes</code>. </p><p> HTrace includes a <code class="classname">LocalFileSpanReceiver</code> that writes all span
      information to local files in a JSON-based format. The
        <code class="classname">LocalFileSpanReceiver</code> looks in <code class="filename">hbase-site.xml</code>
      for a <code class="varname">hbase.local-file-span-receiver.path</code> property with a value describing
      the name of the file to which nodes should write their span information. </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.trace.spanreceiver.classes&lt;/name&gt;
  &lt;value&gt;org.htrace.impl.LocalFileSpanReceiver&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.local-file-span-receiver.path&lt;/name&gt;
  &lt;value&gt;/var/log/hbase/htrace.out&lt;/value&gt;
&lt;/property&gt;
</pre><p> HTrace also provides <code class="classname">ZipkinSpanReceiver</code> which converts spans to <a class="link" href="http://github.com/twitter/zipkin" target="_top">Zipkin</a> span format and send them to
      Zipkin server. In order to use this span receiver, you need to install the jar of
      htrace-zipkin to your HBase's classpath on all of the nodes in your cluster. </p><p>
      <code class="filename">htrace-zipkin</code> is published to the maven central repository. You could get
      the latest version from there or just build it locally and then copy it out to all nodes,
      change your config to use zipkin receiver, distribute the new configuration and then (rolling)
      restart. </p><p> Here is the example of manual setup procedure. </p><pre class="screen">
$ git clone https://github.com/cloudera/htrace
$ cd htrace/htrace-zipkin
$ mvn compile assembly:single
$ cp target/htrace-zipkin-*-jar-with-dependencies.jar $HBASE_HOME/lib/
  # copy jar to all nodes...
</pre><p>The <code class="classname">ZipkinSpanReceiver</code> looks in <code class="filename">hbase-site.xml</code>
      for a <code class="varname">hbase.zipkin.collector-hostname</code> and
        <code class="varname">hbase.zipkin.collector-port</code> property with a value describing the Zipkin
      collector server to which span information are sent. </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.trace.spanreceiver.classes&lt;/name&gt;
  &lt;value&gt;org.htrace.impl.ZipkinSpanReceiver&lt;/value&gt;
&lt;/property&gt; 
&lt;property&gt;
  &lt;name&gt;hbase.zipkin.collector-hostname&lt;/name&gt;
  &lt;value&gt;localhost&lt;/value&gt;
&lt;/property&gt; 
&lt;property&gt;
  &lt;name&gt;hbase.zipkin.collector-port&lt;/name&gt;
  &lt;value&gt;9410&lt;/value&gt;
&lt;/property&gt; 
</pre><p> If you do not want to use the included span receivers, you are encouraged to write your
      own receiver (take a look at <code class="classname">LocalFileSpanReceiver</code> for an example). If
      you think others would benefit from your receiver, file a JIRA or send a pull request to <a class="link" href="http://github.com/cloudera/htrace" target="_top">HTrace</a>. </p></div><div class="section" title="M.2.&nbsp;Client Modifications"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tracing.client.modifications"></a>M.2.&nbsp;Client Modifications</h2></div></div></div><p> In order to turn on tracing in your client code, you must initialize the module sending
      spans to receiver once per client process. </p><pre class="programlisting">
private SpanReceiverHost spanReceiverHost;

...

  Configuration conf = HBaseConfiguration.create();
  SpanReceiverHost spanReceiverHost = SpanReceiverHost.getInstance(conf);
</pre><p>Then you simply start tracing span before requests you think are interesting, and close it
      when the request is done. For example, if you wanted to trace all of your get operations, you
      change this: </p><pre class="programlisting">
HTable table = new HTable(conf, "t1");
Get get = new Get(Bytes.toBytes("r1"));
Result res = table.get(get);
</pre><p>into: </p><pre class="programlisting">
TraceScope ts = Trace.startSpan("Gets", Sampler.ALWAYS);
try {
  HTable table = new HTable(conf, "t1");
  Get get = new Get(Bytes.toBytes("r1"));
  Result res = table.get(get);
} finally {
  ts.close();
}
</pre><p>If you wanted to trace half of your 'get' operations, you would pass in: </p><pre class="programlisting">
new ProbabilitySampler(0.5)
</pre><p>in lieu of <code class="varname">Sampler.ALWAYS</code> to <code class="classname">Trace.startSpan()</code>.
      See the HTrace <code class="filename">README</code> for more information on Samplers. </p></div><div class="section" title="M.3.&nbsp;Tracing from HBase Shell"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tracing.client.shell"></a>M.3.&nbsp;Tracing from HBase Shell</h2></div></div></div><p> You can use <span class="command"><strong>trace</strong></span> command for tracing requests from HBase Shell.
        <span class="command"><strong>trace 'start'</strong></span> command turns on tracing and <span class="command"><strong>trace
        'stop'</strong></span> command turns off tracing. </p><pre class="programlisting">
hbase(main):001:0&gt; trace 'start'
hbase(main):002:0&gt; put 'test', 'row1', 'f:', 'val1'   # traced commands
hbase(main):003:0&gt; trace 'stop'
</pre><p>
      <span class="command"><strong>trace 'start'</strong></span> and <span class="command"><strong>trace 'stop'</strong></span> always returns boolean
      value representing if or not there is ongoing tracing. As a result, <span class="command"><strong>trace
        'stop'</strong></span> returns false on suceess. <span class="command"><strong>trace 'status'</strong></span> just returns if
      or not tracing is turned on. </p><pre class="programlisting">
hbase(main):001:0&gt; trace 'start'
=&gt; true

hbase(main):002:0&gt; trace 'status'
=&gt; true

hbase(main):003:0&gt; trace 'stop'
=&gt; false

hbase(main):004:0&gt; trace 'status'
=&gt; false
</pre></div></div><div class="appendix" title="Appendix&nbsp;N.&nbsp;0.95 RPC Specification"><div class="titlepage"><div><div><h2 class="title"><a name="hbase.rpc"></a>Appendix&nbsp;N.&nbsp;0.95 RPC Specification</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d2875e25940">N.1. Goals</a></span></dt><dt><span class="section"><a href="#d2875e25953">N.2. TODO</a></span></dt><dt><span class="section"><a href="#d2875e25969">N.3. RPC</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e25983">N.3.1. Connection Setup</a></span></dt><dt><span class="section"><a href="#d2875e26013">N.3.2. Request</a></span></dt><dt><span class="section"><a href="#d2875e26045">N.3.3. Response</a></span></dt><dt><span class="section"><a href="#d2875e26075">N.3.4. Exceptions</a></span></dt><dt><span class="section"><a href="#d2875e26082">N.3.5. CellBlocks</a></span></dt></dl></dd><dt><span class="section"><a href="#d2875e26087">N.4. Notes</a></span></dt><dd><dl><dt><span class="section"><a href="#d2875e26090">N.4.1. Constraints</a></span></dt><dt><span class="section"><a href="#d2875e26095">N.4.2. One fat pb request or header+param</a></span></dt><dt><span class="section"><a href="#rpc.configs">N.4.3. RPC Configurations</a></span></dt></dl></dd></dl></div><p>In 0.95, all client/server communication is done with <a class="link" href="https://code.google.com/p/protobuf/" target="_top">protobuf&#8217;ed</a> Messages rather than
        with <a class="link" href="http://hadoop.apache.org/docs/current/api/org/apache/hadoop/io/Writable.html" target="_top">Hadoop
            Writables</a>. Our RPC wire format therefore changes. This document describes the
        client/server request/response protocol and our new RPC wire-format.</p><p></p><p>For what RPC is like in 0.94 and previous, see Beno&icirc;t/Tsuna&#8217;s <a class="link" href="https://github.com/OpenTSDB/asynchbase/blob/master/src/HBaseRpc.java#L164" target="_top">Unofficial
            Hadoop / HBase RPC protocol documentation</a>. For more background on how we arrived
        at this spec., see <a class="link" href="https://docs.google.com/document/d/1WCKwgaLDqBw2vpux0jPsAu2WPTRISob7HGCO8YhfDTA/edit#" target="_top">HBase
            RPC: WIP</a></p><p></p><div class="section" title="N.1.&nbsp;Goals"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e25940"></a>N.1.&nbsp;Goals</h2></div></div></div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A wire-format we can evolve</p></li><li class="listitem"><p>A format that does not require our rewriting server core or radically
                        changing its current architecture (for later).</p></li></ol></div><p>
        </p></div><div class="section" title="N.2.&nbsp;TODO"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e25953"></a>N.2.&nbsp;TODO</h2></div></div></div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>List of problems with currently specified format and where we would like
                        to go in a version2, etc. For example, what would we have to change if
                        anything to move server async or to support streaming/chunking?</p></li><li class="listitem"><p>Diagram on how it works</p></li><li class="listitem"><p>A grammar that succinctly describes the wire-format. Currently we have
                        these words and the content of the rpc protobuf idl but a grammar for the
                        back and forth would help with groking rpc. Also, a little state machine on
                        client/server interactions would help with understanding (and ensuring
                        correct implementation).</p></li></ol></div><p>
        </p></div><div class="section" title="N.3.&nbsp;RPC"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e25969"></a>N.3.&nbsp;RPC</h2></div></div></div><p>The client will send setup information on connection establish. Thereafter, the client
            invokes methods against the remote server sending a protobuf Message and receiving a
            protobuf Message in response. Communication is synchronous. All back and forth is
            preceded by an int that has the total length of the request/response. Optionally,
            Cells(KeyValues) can be passed outside of protobufs in follow-behind Cell blocks
            (because <a class="link" href="https://docs.google.com/document/d/1WEtrq-JTIUhlnlnvA0oYRLp0F8MKpEBeBSCFcQiacdw/edit#" target="_top">we
                can&#8217;t protobuf megabytes of KeyValues</a> or Cells). These CellBlocks are encoded
            and optionally compressed.</p><p></p><p>For more detail on the protobufs involved, see the <a class="link" href="http://svn.apache.org/viewvc/hbase/trunk/hbase-protocol/src/main/protobuf/RPC.proto?view=markup" target="_top">RPC.proto</a>
            file in trunk.</p><div class="section" title="N.3.1.&nbsp;Connection Setup"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e25983"></a>N.3.1.&nbsp;Connection Setup</h3></div></div></div><p>Client initiates connection.</p><div class="section" title="N.3.1.1.&nbsp;Client"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e25988"></a>N.3.1.1.&nbsp;Client</h4></div></div></div><p>On connection setup, client sends a preamble followed by a connection header. </p><div class="section" title="N.3.1.1.1.&nbsp;<preamble&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e25993"></a>N.3.1.1.1.&nbsp;&lt;preamble&gt;</h5></div></div></div><pre class="programlisting">&lt;MAGIC 4 byte integer&gt; &lt;1 byte RPC Format Version&gt; &lt;1 byte auth type&gt;</pre><p> We need the auth method spec. here so the connection header is encoded if auth enabled.</p><p>E.g.: HBas0x000x50 -- 4 bytes of MAGIC -- &#8216;HBas&#8217; -- plus one-byte of
                        version, 0 in this case, and one byte, 0x50 (SIMPLE). of an auth
                        type.</p></div><div class="section" title="N.3.1.1.2.&nbsp;<Protobuf ConnectionHeader Message&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26002"></a>N.3.1.1.2.&nbsp;&lt;Protobuf ConnectionHeader Message&gt;</h5></div></div></div><p>Has user info, and &#8220;protocol&#8221;, as well as the encoders and compression the
                        client will use sending CellBlocks. CellBlock encoders and compressors are
                        for the life of the connection. CellBlock encoders implement
                        org.apache.hadoop.hbase.codec.Codec. CellBlocks may then also be compressed.
                        Compressors implement org.apache.hadoop.io.compress.CompressionCodec. This
                        protobuf is written using writeDelimited so is prefaced by a pb varint with
                        its serialized length</p></div></div><div class="section" title="N.3.1.2.&nbsp;Server"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e26008"></a>N.3.1.2.&nbsp;Server</h4></div></div></div><p>After client sends preamble and connection header, server does NOT respond if
                    successful connection setup. No response means server is READY to accept
                    requests and to give out response. If the version or authentication in the
                    preamble is not agreeable or the server has trouble parsing the preamble, it
                    will throw a org.apache.hadoop.hbase.ipc.FatalConnectionException explaining the
                    error and will then disconnect. If the client in the connection header -- i.e.
                    the protobuf&#8217;d Message that comes after the connection preamble -- asks for for
                    a Service the server does not support or a codec the server does not have, again
                    we throw a FatalConnectionException with explanation.</p></div></div><div class="section" title="N.3.2.&nbsp;Request"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e26013"></a>N.3.2.&nbsp;Request</h3></div></div></div><p>After a Connection has been set up, client makes requests. Server responds.</p><p>A request is made up of a protobuf RequestHeader followed by a protobuf Message
                parameter. The header includes the method name and optionally, metadata on the
                optional CellBlock that may be following. The parameter type suits the method being
                invoked: i.e. if we are doing a getRegionInfo request, the protobuf Message param
                will be an instance of GetRegionInfoRequest. The response will be a
                GetRegionInfoResponse. The CellBlock is optionally used ferrying the bulk of the RPC
                data: i.e Cells/KeyValues.</p><div class="section" title="N.3.2.1.&nbsp;Request Parts"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e26020"></a>N.3.2.1.&nbsp;Request Parts</h4></div></div></div><div class="section" title="N.3.2.1.1.&nbsp;<Total Length&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26023"></a>N.3.2.1.1.&nbsp;&lt;Total Length&gt;</h5></div></div></div><p>The request is prefaced by an int that holds the total length of what
                        follows.</p></div><div class="section" title="N.3.2.1.2.&nbsp;<Protobuf RequestHeader Message&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26028"></a>N.3.2.1.2.&nbsp;&lt;Protobuf RequestHeader Message&gt;</h5></div></div></div><p>Will have call.id, trace.id, and method name, etc. including optional
                        Metadata on the Cell block IFF one is following. Data is protobuf&#8217;d inline
                        in this pb Message or optionally comes in the following CellBlock</p></div><div class="section" title="N.3.2.1.3.&nbsp;<Protobuf Param Message&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26033"></a>N.3.2.1.3.&nbsp;&lt;Protobuf Param Message&gt;</h5></div></div></div><p>If the method being invoked is getRegionInfo, if you study the Service
                        descriptor for the client to regionserver protocol, you will find that the
                        request sends a GetRegionInfoRequest protobuf Message param in this
                        position.</p></div><div class="section" title="N.3.2.1.4.&nbsp;<CellBlock&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26038"></a>N.3.2.1.4.&nbsp;&lt;CellBlock&gt;</h5></div></div></div><p>An encoded and optionally compressed Cell block.</p></div></div></div><div class="section" title="N.3.3.&nbsp;Response"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e26045"></a>N.3.3.&nbsp;Response</h3></div></div></div><p>Same as Request, it is a protobuf ResponseHeader followed by a protobuf Message
                response where the Message response type suits the method invoked. Bulk of the data
                may come in a following CellBlock.</p><div class="section" title="N.3.3.1.&nbsp;Response Parts"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e26050"></a>N.3.3.1.&nbsp;Response Parts</h4></div></div></div><div class="section" title="N.3.3.1.1.&nbsp;<Total Length&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26053"></a>N.3.3.1.1.&nbsp;&lt;Total Length&gt;</h5></div></div></div><p>The response is prefaced by an int that holds the total length of what
                        follows.</p></div><div class="section" title="N.3.3.1.2.&nbsp;<Protobuf ResponseHeader Message&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26058"></a>N.3.3.1.2.&nbsp;&lt;Protobuf ResponseHeader Message&gt;</h5></div></div></div><p>Will have call.id, etc. Will include exception if failed processing.
                        &nbsp;Optionally includes metadata on optional, IFF there is a CellBlock
                        following.</p></div><div class="section" title="N.3.3.1.3.&nbsp;<Protobuf Response Message&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26063"></a>N.3.3.1.3.&nbsp;&lt;Protobuf Response Message&gt;</h5></div></div></div><p>Return or may be nothing if exception. If the method being invoked is
                        getRegionInfo, if you study the Service descriptor for the client to
                        regionserver protocol, you will find that the response sends a
                        GetRegionInfoResponse protobuf Message param in this position.</p></div><div class="section" title="N.3.3.1.4.&nbsp;<CellBlock&gt;"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e26068"></a>N.3.3.1.4.&nbsp;&lt;CellBlock&gt;</h5></div></div></div><p>An encoded and optionally compressed Cell block.</p></div></div></div><div class="section" title="N.3.4.&nbsp;Exceptions"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e26075"></a>N.3.4.&nbsp;Exceptions</h3></div></div></div><p>There are two distinct types. There is the request failed which is encapsulated
                inside the response header for the response. The connection stays open to receive
                new requests. The second type, the FatalConnectionException, kills the
                connection.</p><p>Exceptions can carry extra information. See the ExceptionResponse protobuf type.
                It has a flag to indicate do-no-retry as well as other miscellaneous payload to help
                improve client responsiveness.</p></div><div class="section" title="N.3.5.&nbsp;CellBlocks"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e26082"></a>N.3.5.&nbsp;CellBlocks</h3></div></div></div><p>These are not versioned. Server can do the codec or it cannot. If new version of a
                codec with say, tighter encoding, then give it a new class name. Codecs will live on
                the server for all time so old clients can connect.</p></div></div><div class="section" title="N.4.&nbsp;Notes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2875e26087"></a>N.4.&nbsp;Notes</h2></div></div></div><div class="section" title="N.4.1.&nbsp;Constraints"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e26090"></a>N.4.1.&nbsp;Constraints</h3></div></div></div><p>In some part, current wire-format -- i.e. all requests and responses preceeded by
                a length -- has been dictated by current server non-async architecture.</p></div><div class="section" title="N.4.2.&nbsp;One fat pb request or header+param"><div class="titlepage"><div><div><h3 class="title"><a name="d2875e26095"></a>N.4.2.&nbsp;One fat pb request or header+param</h3></div></div></div><p>We went with pb header followed by pb param making a request and a pb header
                followed by pb response for now. Doing header+param rather than a single protobuf
                Message with both header and param content:</p><p>
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Is closer to what we currently have</p></li><li class="listitem"><p>Having a single fat pb requires extra copying putting the already pb&#8217;d
                            param into the body of the fat request pb (and same making
                            result)</p></li><li class="listitem"><p>We can decide whether to accept the request or not before we read the
                            param; for example, the request might be low priority. &nbsp;As is, we read
                            header+param in one go as server is currently implemented so this is a
                            TODO.</p></li></ol></div><p>
            </p><p>The advantages are minor. &nbsp;If later, fat request has clear advantage, can roll out
                a v2 later.</p></div><div class="section" title="N.4.3.&nbsp;RPC Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="rpc.configs"></a>N.4.3.&nbsp;RPC Configurations</h3></div></div></div><div class="section" title="N.4.3.1.&nbsp;CellBlock Codecs"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e26118"></a>N.4.3.1.&nbsp;CellBlock Codecs</h4></div></div></div><p>To enable a codec other than the default <code class="classname">KeyValueCodec</code>,
                    set <code class="varname">hbase.client.rpc.codec</code> to the name of the Codec class to
                    use. Codec must implement hbase's <code class="classname">Codec</code> Interface. After
                    connection setup, all passed cellblocks will be sent with this codec. The server
                    will return cellblocks using this same codec as long as the codec is on the
                    servers' CLASSPATH (else you will get
                        <code class="classname">UnsupportedCellCodecException</code>).</p><p>To change the default codec, set
                        <code class="varname">hbase.client.default.rpc.codec</code>. </p><p>To disable cellblocks completely and to go pure protobuf, set the default to
                    the empty String and do not specify a codec in your Configuration. So, set
                        <code class="varname">hbase.client.default.rpc.codec</code> to the empty string and do
                    not set <code class="varname">hbase.client.rpc.codec</code>. This will cause the client to
                    connect to the server with no codec specified. If a server sees no codec, it
                    will return all responses in pure protobuf. Running pure protobuf all the time
                    will be slower than running with cellblocks. </p></div><div class="section" title="N.4.3.2.&nbsp;Compression"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e26148"></a>N.4.3.2.&nbsp;Compression</h4></div></div></div><p>Uses hadoops compression codecs. To enable compressing of passed CellBlocks,
                    set <code class="varname">hbase.client.rpc.compressor</code> to the name of the Compressor
                    to use. Compressor must implement Hadoops' CompressionCodec Interface. After
                    connection setup, all passed cellblocks will be sent compressed. The server will
                    return cellblocks compressed using this same compressor as long as the
                    compressor is on its CLASSPATH (else you will get
                        <code class="classname">UnsupportedCompressionCodecException</code>).</p></div></div></div></div><div class="index" title="Index"><div class="titlepage"><div><div><h2 class="title"><a name="book_index"></a>Index</h2></div></div></div><div class="index"><div class="indexdiv"><h3>C</h3><dl><dt>Cells, <a class="indexterm" href="#cells">Cells</a></dt><dt>Column Family, <a class="indexterm" href="#columnfamily">Column Family</a></dt><dt>column
            family qualifier</dt><dd><dl><dt>Column Family Qualifier, <a class="indexterm" href="#columnfamily">Column Family</a></dt></dl></dd><dt>Compression</dt><dd><dl><dt>Data Block
          Encoding, <a class="indexterm" href="#compression">Compression and Data Block Encoding In
          HBase</a></dt><dd><dl><dt>(see also codecs)</dt></dl></dd></dl></dd></dl></div><div class="indexdiv"><h3>D</h3><dl><dt>dfs.datanode.max.transfer.threads, <a class="indexterm" href="#dfs.datanode.max.transfer.threads">dfs.datanode.max.transfer.threads</a></dt></dl></div><div class="indexdiv"><h3>H</h3><dl><dt>Hadoop, <a class="indexterm" href="#hadoop">Hadoop</a></dt></dl></div><div class="indexdiv"><h3>I</h3><dl><dt>IntegrationTests, <a class="indexterm" href="#hbase.unittests">Unit Tests</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt>LargeTests, <a class="indexterm" href="#hbase.unittests">Unit Tests</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt>MediumTests, <a class="indexterm" href="#hbase.unittests">Unit Tests</a></dt><dt>MSLAB, <a class="indexterm" href="#gcpause">Long GC pauses</a></dt></dl></div><div class="indexdiv"><h3>N</h3><dl><dt>nproc, <a class="indexterm" href="#basic.prerequisites">Basic Prerequisites</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt>Raw L1+L2, <a class="indexterm" href="#enable.bucketcache">How to Enable BucketCache</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt>SmallTests, <a class="indexterm" href="#hbase.unittests">Unit Tests</a></dt></dl></div><div class="indexdiv"><h3>T</h3><dl><dt>Test Resource
                        Checker, <a class="indexterm" href="#hbase.unittests.resource.checker">Test Resource Checker</a></dt></dl></div><div class="indexdiv"><h3>U</h3><dl><dt>ulimit, <a class="indexterm" href="#basic.prerequisites">Basic Prerequisites</a></dt></dl></div><div class="indexdiv"><h3>V</h3><dl><dt>Versions, <a class="indexterm" href="#versions">Versions</a></dt></dl></div><div class="indexdiv"><h3>Z</h3><dl><dt>ZooKeeper, <a class="indexterm" href="#zookeeper">ZooKeeper</a></dt></dl></div></div></div></div><div id="disqus_thread"></div><script type="text/javascript">
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></body></html>