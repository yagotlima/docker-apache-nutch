<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Chapter&nbsp;1.&nbsp;Apache HBase Configuration</title><link rel="stylesheet" type="text/css" href="css/freebsd_docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><script type="text/javascript">
    var disqus_shortname = 'hbase'; // required: replace example with your forum shortname
    var disqus_url = 'http://hbase.apache.org/book/configuration.html';
    </script><div class="chapter" title="Chapter&nbsp;1.&nbsp;Apache HBase Configuration"><div class="titlepage"><div><div><h2 class="title"><a name="configuration"></a>Chapter&nbsp;1.&nbsp;Apache HBase Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#basic.prerequisites">1.1. Basic Prerequisites</a></span></dt><dd><dl><dt><span class="section"><a href="#hadoop">1.1.1. Hadoop</a></span></dt><dt><span class="section"><a href="#zookeeper.requirements">1.1.2. ZooKeeper Requirements</a></span></dt></dl></dd><dt><span class="section"><a href="#standalone_dist">1.2. HBase run modes: Standalone and Distributed</a></span></dt><dd><dl><dt><span class="section"><a href="#standalone">1.2.1. Standalone HBase</a></span></dt><dt><span class="section"><a href="#distributed">1.2.2. Distributed</a></span></dt><dt><span class="section"><a href="#fully_dist">1.2.3. Fully-distributed</a></span></dt></dl></dd><dt><span class="section"><a href="#confirm">1.3. Running and Confirming Your Installation</a></span></dt><dt><span class="section"><a href="#config.files">1.4. Configuration Files</a></span></dt><dd><dl><dt><span class="section"><a href="#hbase.site">1.4.1. <code class="filename">hbase-site.xml</code> and <code class="filename">hbase-default.xml</code></a></span></dt><dt><span class="section"><a href="#hbase.env.sh">1.4.2. <code class="filename">hbase-env.sh</code></a></span></dt><dt><span class="section"><a href="#log4j">1.4.3. <code class="filename">log4j.properties</code></a></span></dt><dt><span class="section"><a href="#client_dependencies">1.4.4. Client configuration and dependencies connecting to an HBase cluster</a></span></dt></dl></dd><dt><span class="section"><a href="#example_config">1.5. Example Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#d1604e3078">1.5.1. Basic Distributed HBase Install</a></span></dt></dl></dd><dt><span class="section"><a href="#important_configurations">1.6. The Important Configurations</a></span></dt><dd><dl><dt><span class="section"><a href="#required_configuration">1.6.1. Required Configurations</a></span></dt><dt><span class="section"><a href="#recommended_configurations">1.6.2. Recommended Configurations</a></span></dt><dt><span class="section"><a href="#other_configuration">1.6.3. Other Configurations</a></span></dt></dl></dd><dt><span class="section"><a href="#dyn_config">1.7. Dynamic Configuration</a></span></dt></dl></div><p>This chapter expands upon the <a class="xref" href="#">???</a> chapter to further explain
    configuration of Apache HBase. Please read this chapter carefully, especially <a class="xref" href="#basic.prerequisites" title="1.1.&nbsp;Basic Prerequisites">Section&nbsp;1.1, &#8220;Basic Prerequisites&#8221;</a> to ensure that your HBase testing and deployment goes
    smoothly, and prevent data loss.</p><p> Apache HBase uses the same configuration system as Apache Hadoop. All configuration files
    are located in the <code class="filename">conf/</code> directory, which needs to be kept in sync for each
    node on your cluster.</p><div class="variablelist" title="HBase Configuration Files"><p class="title"><b>HBase Configuration Files</b></p><dl><dt><span class="term"><code class="filename">backup-masters</code></span></dt><dd><p>Not present by default. A plain-text file which lists hosts on which the Master should
          start a backup Master process, one host per line.</p></dd><dt><span class="term"><code class="filename">hadoop-metrics2-hbase.properties</code></span></dt><dd><p>Used to connect HBase Hadoop's Metrics2 framework. See the <a class="link" href="http://wiki.apache.org/hadoop/HADOOP-6728-MetricsV2" target="_top">Hadoop Wiki
            entry</a> for more information on Metrics2. Contains only commented-out examples by
          default.</p></dd><dt><span class="term"><code class="filename">hbase-env.cmd</code> and <code class="filename">hbase-env.sh</code></span></dt><dd><p>Script for Windows and Linux / Unix environments to set up the working environment for
        HBase, including the location of Java, Java options, and other environment variables. The
        file contains many commented-out examples to provide guidance.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In HBase 0.98.5 and newer, you must set <code class="envar">JAVA_HOME</code> on each node of
            your cluster. <code class="filename">hbase-env.sh</code> provides a handy mechanism to do
            this.</p></div></dd><dt><span class="term"><code class="filename">hbase-policy.xml</code></span></dt><dd><p>The default policy configuration file used by RPC servers to make authorization
          decisions on client requests. Only used if HBase security (<a class="xref" href="#">???</a>) is enabled.</p></dd><dt><span class="term"><code class="filename">hbase-site.xml</code></span></dt><dd><p>The main HBase configuration file. This file specifies configuration options which
          override HBase's default configuration. You can view (but do not edit) the default
          configuration file at <code class="filename">docs/hbase-default.xml</code>. You can also view the
          entire effective configuration for your cluster (defaults and overrides) in the
            <span class="guilabel">HBase Configuration</span> tab of the HBase Web UI.</p></dd><dt><span class="term"><code class="filename">log4j.properties</code></span></dt><dd><p>Configuration file for HBase logging via <code class="code">log4j</code>.</p></dd><dt><span class="term"><code class="filename">regionservers</code></span></dt><dd><p>A plain-text file containing a list of hosts which should run a RegionServer in your
          HBase cluster. By default this file contains the single entry
          <code class="literal">localhost</code>. It should contain a list of hostnames or IP addresses, one
          per line, and should only contain <code class="literal">localhost</code> if each node in your
          cluster will run a RegionServer on its <code class="literal">localhost</code> interface.</p></dd></dl></div><div class="tip" title="Checking XML Validity" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Checking XML Validity</h3><p>When you edit XML, it is a good idea to use an XML-aware editor to be sure that your
      syntax is correct and your XML is well-formed. You can also use the <span class="command"><strong>xmllint</strong></span>
      utility to check that your XML is well-formed. By default, <span class="command"><strong>xmllint</strong></span> re-flows
      and prints the XML to standard output. To check for well-formedness and only print output if
      errors exist, use the command <span class="command"><strong>xmllint -noout
        <em class="replaceable"><code>filename.xml</code></em></strong></span>.</p></div><div class="warning" title="Keep Configuration In Sync Across the Cluster" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Keep Configuration In Sync Across the Cluster</h3><p>When running in distributed mode, after you make an edit to an HBase configuration, make
      sure you copy the content of the <code class="filename">conf/</code> directory to all nodes of the
      cluster. HBase will not do this for you. Use <span class="command"><strong>rsync</strong></span>, <span class="command"><strong>scp</strong></span>,
      or another secure mechanism for copying the configuration files to your nodes. For most
      configuration, a restart is needed for servers to pick up changes An exception is dynamic
      configuration. to be described later below.</p></div><div class="section" title="1.1.&nbsp;Basic Prerequisites"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="basic.prerequisites"></a>1.1.&nbsp;Basic Prerequisites</h2></div></div></div><p>This section lists required services and some required system configuration. </p><div class="table"><a name="java"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Java</b></p><div class="table-contents"><table summary="Java" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>HBase Version</th><th>JDK 6</th><th>JDK 7</th><th>JDK 8</th></tr></thead><tbody><tr><td>1.0</td><td><a class="link" href="http://search-hadoop.com/m/DHED4Zlz0R1" target="_top">Not Supported</a></td><td>yes</td><td><p>Running with JDK 8 will work but is not well tested.</p></td></tr><tr><td>0.98</td><td>yes</td><td>yes</td><td><p>Running with JDK 8 works but is not well tested. Building with JDK 8 would
                require removal of the deprecated remove() method of the PoolMap class and is under
                consideration. See ee <a class="link" href="https://issues.apache.org/jira/browse/HBASE-7608" target="_top">HBASE-7608</a>
                for more information about JDK 8 support.</p></td></tr><tr><td>0.96</td><td>yes</td><td>yes</td><td>&nbsp;</td></tr><tr><td>0.94</td><td>yes</td><td>yes</td><td>&nbsp;</td></tr></tbody></table></div><div class="longdesc-link" align="right"><br clear="all"><span class="longdesc-link">[<a href="java.html" target="longdesc">D</a>]</span></div></div><br class="table-break"><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In HBase 0.98.5 and newer, you must set <code class="envar">JAVA_HOME</code> on each node of
        your cluster. <code class="filename">hbase-env.sh</code> provides a handy mechanism to do
        this.</p></div><div class="variablelist" title="Operating System Utilities"><a name="os"></a><p class="title"><b>Operating System Utilities</b></p><dl><dt><a name="ssh"></a><span class="term">ssh</span></dt><dd><p>HBase uses the Secure Shell (ssh) command and utilities extensively to communicate
            between cluster nodes. Each server in the cluster must be running <span class="command"><strong>ssh</strong></span>
            so that the Hadoop and HBase daemons can be managed. You must be able to connect to all
            nodes via SSH, including the local node, from the Master as well as any backup Master,
            using a shared key rather than a password. You can see the basic methodology for such a
            set-up in Linux or Unix systems at <a class="xref" href="#">???</a>. If your cluster nodes use OS X, see the
            section, <a class="link" href="http://wiki.apache.org/hadoop/Running_Hadoop_On_OS_X_10.5_64-bit_%28Single-Node_Cluster%29" target="_top">SSH:
              Setting up Remote Desktop and Enabling Self-Login</a> on the Hadoop wiki.</p></dd><dt><a name="dns"></a><span class="term">DNS</span></dt><dd><p>HBase uses the local hostname to self-report its IP address. Both forward and
            reverse DNS resolving must work in versions of HBase previous to 0.92.0. The <a class="link" href="https://github.com/sujee/hadoop-dns-checker" target="_top">hadoop-dns-checker</a>
                tool can be used to verify DNS is working correctly on the cluster. The project
                README file provides detailed instructions on usage. </p><p>If your server has multiple network interfaces, HBase defaults to using the
            interface that the primary hostname resolves to. To override this behavior, set the
              <code class="code">hbase.regionserver.dns.interface</code> property to a different interface. This
            will only work if each server in your cluster uses the same network interface
            configuration.</p><p>To choose a different DNS nameserver than the system default, set the
              <code class="varname">hbase.regionserver.dns.nameserver</code> property to the IP address of
            that nameserver.</p></dd><dt><a name="loopback.ip"></a><span class="term">Loopback IP</span></dt><dd><p>Prior to hbase-0.96.0, HBase only used the IP address
              <code class="systemitem">127.0.0.1</code> to refer to <code class="code">localhost</code>, and this could
            not be configured. See <a class="xref" href="#loopback.ip">Loopback IP</a>.</p></dd><dt><a name="ntp"></a><span class="term">NTP</span></dt><dd><p>The clocks on cluster nodes should be synchronized. A small amount of variation is
            acceptable, but larger amounts of skew can cause erratic and unexpected behavior. Time
            synchronization is one of the first things to check if you see unexplained problems in
            your cluster. It is recommended that you run a Network Time Protocol (NTP) service, or
            another time-synchronization mechanism, on your cluster, and that all nodes look to the
            same service for time synchronization. See the <a class="link" href="http://www.tldp.org/LDP/sag/html/basic-ntp-config.html" target="_top">Basic NTP
              Configuration</a> at <em class="citetitle">The Linux Documentation Project (TLDP)</em>
            to set up NTP.</p></dd><dt><a name="ulimit"></a><span class="term">Limits on Number of Files and Processes (<span class="command"><strong>ulimit</strong></span>)
          <a class="indexterm" name="d1604e276"></a><a class="indexterm" name="d1604e279"></a>
        </span></dt><dd><p>Apache HBase is a database. It requires the ability to open a large number of files
            at once. Many Linux distributions limit the number of files a single user is allowed to
            open to <code class="literal">1024</code> (or <code class="literal">256</code> on older versions of OS X).
            You can check this limit on your servers by running the command <span class="command"><strong>ulimit
              -n</strong></span> when logged in as the user which runs HBase. See <a class="xref" href="#">???</a> for some of the problems you may
            experience if the limit is too low. You may also notice errors such as the
            following:</p><pre class="screen">
2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Exception increateBlockOutputStream java.io.EOFException
2010-04-06 03:04:37,542 INFO org.apache.hadoop.hdfs.DFSClient: Abandoning block blk_-6935524980745310745_1391901
          </pre><p>It is recommended to raise the ulimit to at least 10,000, but more likely 10,240,
            because the value is usually expressed in multiples of 1024. Each ColumnFamily has at
            least one StoreFile, and possibly more than 6 StoreFiles if the region is under load.
            The number of open files required depends upon the number of ColumnFamilies and the
            number of regions. The following is a rough formula for calculating the potential number
            of open files on a RegionServer. </p><div class="example"><a name="d1604e301"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;Calculate the Potential Number of Open Files</b></p><div class="example-contents"><pre class="screen">(StoreFiles per ColumnFamily) x (regions per RegionServer)</pre></div></div><br class="example-break"><p>For example, assuming that a schema had 3 ColumnFamilies per region with an average
            of 3 StoreFiles per ColumnFamily, and there are 100 regions per RegionServer, the JVM
            will open 3 * 3 * 100 = 900 file descriptors, not counting open JAR files, configuration
            files, and others. Opening a file does not take many resources, and the risk of allowing
            a user to open too many files is minimal.</p><p>Another related setting is the number of processes a user is allowed to run at once.
            In Linux and Unix, the number of processes is set using the <span class="command"><strong>ulimit -u</strong></span>
            command. This should not be confused with the <span class="command"><strong>nproc</strong></span> command, which
            controls the number of CPUs available to a given user. Under load, a
              <code class="varname">nproc</code> that is too low can cause OutOfMemoryError exceptions. See
            Jack Levin's <a class="link" href="http://thread.gmane.org/gmane.comp.java.hadoop.hbase.user/16374" target="_top">major
              hdfs issues</a> thread on the hbase-users mailing list, from 2011.</p><p>Configuring the fmaximum number of ile descriptors and processes for the user who is
            running the HBase process is an operating system configuration, rather than an HBase
            configuration. It is also important to be sure that the settings are changed for the
            user that actually runs HBase. To see which user started HBase, and that user's ulimit
            configuration, look at the first line of the HBase log for that instance. A useful read
            setting config on you hadoop cluster is Aaron Kimballs' <a class="link" href="http://www.cloudera.com/blog/2009/03/configuration-parameters-what-can-you-just-ignore/" target="_top">Configuration Parameters: What can you just ignore?</a></p><p title="ulimit Settings on Ubuntu"><a name="ulimit_ubuntu"></a><b><span class="command"><strong>ulimit</strong></span> Settings on Ubuntu.&nbsp;</b>To configure <span class="command"><strong>ulimit</strong></span> settings on Ubuntu, edit
                <code class="filename">/etc/security/limits.conf</code>, which is a space-delimited file with
              four columns. Refer to the <a class="link" href="http://manpages.ubuntu.com/manpages/lucid/man5/limits.conf.5.html" target="_top">man
                page for limits.conf</a> for details about the format of this file. In the
              following example, the first line sets both soft and hard limits for the number of
              open files (<code class="literal">nofile</code>) to <code class="literal">32768</code> for the operating
              system user with the username <code class="literal">hadoop</code>. The second line sets the
              number of processes to 32000 for the same user.</p><pre class="screen">
hadoop  -       nofile  32768
hadoop  -       nproc   32000
          </pre><p>The settings are only applied if the Pluggable Authentication Module (PAM)
            environment is directed to use them. To configure PAM to use these limits, be sure that
            the <code class="filename">/etc/pam.d/common-session</code> file contains the following line:</p><pre class="screen">session required  pam_limits.so</pre></dd><dt><a name="windows"></a><span class="term">Windows</span></dt><dd><p>Prior to HBase 0.96, testing for running HBase on Microsoft Windows was limited.
            Running a on Windows nodes is not recommended for production systems.</p><p>To run versions of HBase prior to 0.96 on Microsoft Windows, you must install <a class="link" href="http://cygwin.com/" target="_top">Cygwin</a> and run HBase within the Cygwin
          environment. This provides support for Linux/Unix commands and scripts. The full details are explained in the <a class="link" href="http://hbase.apache.org/cygwin.html" target="_top">Windows Installation</a> guide. Also <a class="link" href="http://search-hadoop.com/?q=hbase+windows&amp;fc_project=HBase&amp;fc_type=mail+_hash_+dev" target="_top">search
            our user mailing list</a> to pick up latest fixes figured by Windows users.</p><p>Post-hbase-0.96.0, hbase runs natively on windows with supporting
            <span class="command"><strong>*.cmd</strong></span> scripts bundled. </p></dd></dl></div><div class="section" title="1.1.1.&nbsp;Hadoop"><div class="titlepage"><div><div><h3 class="title"><a name="hadoop"></a>1.1.1.&nbsp;<a class="link" href="http://hadoop.apache.org" target="_top">Hadoop</a><a class="indexterm" name="d1604e387"></a></h3></div></div></div><p>The following table summarizes the versions of Hadoop supported with each version of
        HBase. Based on the version of HBase, you should select the most
        appropriate version of Hadoop. You can use Apache Hadoop, or a vendor's distribution of
        Hadoop. No distinction is made here. See <a class="link" href="http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support" target="_top">http://wiki.apache.org/hadoop/Distributions%20and%20Commercial%20Support</a>
        for information about vendors of Hadoop.</p><div class="tip" title="Hadoop 2.x is recommended." style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Hadoop 2.x is recommended.</h3><p>Hadoop 2.x is faster and includes features, such as short-circuit reads, which will
          help improve your HBase random read profile. Hadoop 2.x also includes important bug fixes
          that will improve your overall HBase experience. HBase 0.98 drops support for Hadoop 1.0, deprecates use of Hadoop 1.1+,
          and HBase 1.0 will not support Hadoop 1.x.</p></div><p>Use the following legend to interpret this table:</p><table border="0" summary="Simple list" class="simplelist"><tr><td>S = supported and tested,</td></tr><tr><td>X = not supported,</td></tr><tr><td>NT = it should run, but not tested enough.</td></tr></table><div class="table"><a name="d1604e408"></a><p class="title"><b>Table&nbsp;1.2.&nbsp;Hadoop version support matrix</b></p><div class="table-contents"><table summary="Hadoop version support matrix" border="1"><colgroup><col align="left" class="c1"><col align="center" class="c2"><col align="center" class="c3"><col align="center" class="c4"><col align="center" class="c5"><col align="center" class="c6"></colgroup><thead><tr><th align="left"> </th><th align="center">HBase-0.92.x</th><th align="center">HBase-0.94.x</th><th align="center">HBase-0.96.x</th><th align="center"><p>HBase-0.98.x (Support for Hadoop 1.1+ is deprecated.)</p></th><th align="center"><p>HBase-1.0.x (Hadoop 1.x is NOT supported)</p></th></tr></thead><tbody><tr><td align="left">Hadoop-0.20.205</td><td align="center">S</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-0.22.x </td><td align="center">S</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-1.0.x</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-1.1.x </td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">NT</td><td align="center">X</td></tr><tr><td align="left">Hadoop-0.23.x </td><td align="center">X</td><td align="center">S</td><td align="center">NT</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-2.0.x-alpha </td><td align="center">X</td><td align="center">NT</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-2.1.0-beta </td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">X</td><td align="center">X</td></tr><tr><td align="left">Hadoop-2.2.0 </td><td align="center">X</td><td align="center"><a class="link" href="#hadoop2.hbase-0.94" title="1.1.1.1.&nbsp;Apache HBase 0.94 with Hadoop 2">NT</a></td><td align="center">S</td><td align="center">S</td><td align="center">NT</td></tr><tr><td align="left">Hadoop-2.3.x</td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">NT</td></tr><tr><td align="left">Hadoop-2.4.x</td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">S</td></tr><tr><td align="left">Hadoop-2.5.x</td><td align="center">X</td><td align="center">NT</td><td align="center">S</td><td align="center">S</td><td align="center">S</td></tr></tbody></table></div></div><br class="table-break"><div class="note" title="Replace the Hadoop Bundled With HBase!" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="replace.hadoop"></a>Replace the Hadoop Bundled With HBase!</h3><p> Because HBase depends on Hadoop, it bundles an instance of the Hadoop jar under its
            <code class="filename">lib</code> directory. The bundled jar is ONLY for use in standalone mode.
          In distributed mode, it is <span class="emphasis"><em>critical</em></span> that the version of Hadoop that
          is out on your cluster match what is under HBase. Replace the hadoop jar found in the
          HBase lib directory with the hadoop jar you are running on your cluster to avoid version
          mismatch issues. Make sure you replace the jar in HBase everywhere on your cluster. Hadoop
          version mismatch issues have various manifestations but often all looks like its hung up.
        </p></div><div class="section" title="1.1.1.1.&nbsp;Apache HBase 0.94 with Hadoop 2"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop2.hbase-0.94"></a>1.1.1.1.&nbsp;Apache HBase 0.94 with Hadoop 2</h4></div></div></div><p>To get 0.94.x to run on hadoop 2.2.0, you need to change the hadoop
        2 and protobuf versions in the <code class="filename">pom.xml</code>: Here is a diff with
        pom.xml changes: </p><pre class="programlisting">$ svn diff pom.xml
Index: pom.xml
===================================================================
--- pom.xml     (revision 1545157)
+++ pom.xml     (working copy)
@@ -1034,7 +1034,7 @@
     &lt;slf4j.version&gt;1.4.3&lt;/slf4j.version&gt;
     &lt;log4j.version&gt;1.2.16&lt;/log4j.version&gt;
     &lt;mockito-all.version&gt;1.8.5&lt;/mockito-all.version&gt;
-    &lt;protobuf.version&gt;2.4.0a&lt;/protobuf.version&gt;
+    &lt;protobuf.version&gt;2.5.0&lt;/protobuf.version&gt;
     &lt;stax-api.version&gt;1.0.1&lt;/stax-api.version&gt;
     &lt;thrift.version&gt;0.8.0&lt;/thrift.version&gt;
     &lt;zookeeper.version&gt;3.4.5&lt;/zookeeper.version&gt;
@@ -2241,7 +2241,7 @@
         &lt;/property&gt;
       &lt;/activation&gt;
       &lt;properties&gt;
-        &lt;hadoop.version&gt;2.0.0-alpha&lt;/hadoop.version&gt;
+        &lt;hadoop.version&gt;2.2.0&lt;/hadoop.version&gt;
         &lt;slf4j.version&gt;1.6.1&lt;/slf4j.version&gt;
       &lt;/properties&gt;
       &lt;dependencies&gt;
                   </pre><p>The next step is to regenerate Protobuf files and assuming that the Protobuf
                    has been installed:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Go to the hbase root folder, using the command line;</p></li><li class="listitem"><p>Type the following commands:</p><p>
                        </p><pre class="programlisting">$ protoc -Isrc/main/protobuf --java_out=src/main/java src/main/protobuf/hbase.proto</pre><p>
                      </p><p>
                        </p><pre class="programlisting">$ protoc -Isrc/main/protobuf --java_out=src/main/java src/main/protobuf/ErrorHandling.proto</pre><p>
                      </p></li></ul></div><p> Building against the hadoop 2 profile by running something like the
                    following command: </p><pre class="screen">$  mvn clean install assembly:single -Dhadoop.profile=2.0 -DskipTests</pre></div><div class="section" title="1.1.1.2.&nbsp;Apache HBase 0.92 and 0.94"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.hbase-0.94"></a>1.1.1.2.&nbsp;Apache HBase 0.92 and 0.94</h4></div></div></div><p>HBase 0.92 and 0.94 versions can work with Hadoop versions, 0.20.205, 0.22.x, 1.0.x,
          and 1.1.x. HBase-0.94 can additionally work with Hadoop-0.23.x and 2.x, but you may have
          to recompile the code using the specific maven profile (see top level pom.xml)</p></div><div class="section" title="1.1.1.3.&nbsp;Apache HBase 0.96"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.hbase-0.96"></a>1.1.1.3.&nbsp;Apache HBase 0.96</h4></div></div></div><p> As of Apache HBase 0.96.x, Apache Hadoop 1.0.x at least is required. Hadoop 2 is
          strongly encouraged (faster but also has fixes that help MTTR). We will no longer run
          properly on older Hadoops such as 0.20.205 or branch-0.20-append. Do not move to Apache
          HBase 0.96.x if you cannot upgrade your Hadoop.. See <a class="link" href="http://search-hadoop.com/m/7vFVx4EsUb2" target="_top">HBase, mail # dev - DISCUSS:
                Have hbase require at least hadoop 1.0.0 in hbase 0.96.0?</a></p></div><div class="section" title="1.1.1.4.&nbsp;Hadoop versions 0.20.x - 1.x"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.older.versions"></a>1.1.1.4.&nbsp;Hadoop versions 0.20.x - 1.x</h4></div></div></div><p> HBase will lose data unless it is running on an HDFS that has a durable
            <code class="code">sync</code> implementation. DO NOT use Hadoop 0.20.2, Hadoop 0.20.203.0, and
          Hadoop 0.20.204.0 which DO NOT have this attribute. Currently only Hadoop versions
          0.20.205.x or any release in excess of this version -- this includes hadoop-1.0.0 -- have
          a working, durable sync. The Cloudera blog post <a class="link" href="http://www.cloudera.com/blog/2012/01/an-update-on-apache-hadoop-1-0/" target="_top">An
            update on Apache Hadoop 1.0</a> by Charles Zedlweski has a nice exposition on how all
          the Hadoop versions relate. Its worth checking out if you are having trouble making sense
          of the Hadoop version morass. </p><p>Sync has to be explicitly enabled by setting
            <code class="varname">dfs.support.append</code> equal to true on both the client side -- in
            <code class="filename">hbase-site.xml</code> -- and on the serverside in
            <code class="filename">hdfs-site.xml</code> (The sync facility HBase needs is a subset of the
          append code path).</p><pre class="programlisting">  
&lt;property&gt;
  &lt;name&gt;dfs.support.append&lt;/name&gt;
  &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;</pre><p> You will have to restart your cluster after making this edit. Ignore the
          chicken-little comment you'll find in the <code class="filename">hdfs-default.xml</code> in the
          description for the <code class="varname">dfs.support.append</code> configuration. </p></div><div class="section" title="1.1.1.5.&nbsp;Apache HBase on Secure Hadoop"><div class="titlepage"><div><div><h4 class="title"><a name="hadoop.security"></a>1.1.1.5.&nbsp;Apache HBase on Secure Hadoop</h4></div></div></div><p>Apache HBase will run on any Hadoop 0.20.x that incorporates Hadoop security features
          as long as you do as suggested above and replace the Hadoop jar that ships with HBase with
          the secure version. If you want to read more about how to setup Secure HBase, see <a class="xref" href="#">???</a>.</p></div><div class="section" title="1.1.1.6.&nbsp;dfs.datanode.max.transfer.threads"><div class="titlepage"><div><div><h4 class="title"><a name="dfs.datanode.max.transfer.threads"></a>1.1.1.6.&nbsp;<code class="varname">dfs.datanode.max.transfer.threads</code><a class="indexterm" name="d1604e678"></a></h4></div></div></div><p>An HDFS datanode has an upper bound on the number of files that it will serve
          at any one time. Before doing any loading, make sure you have configured
          Hadoop's <code class="filename">conf/hdfs-site.xml</code>, setting the
          <code class="varname">dfs.datanode.max.transfer.threads</code> value to at least the following:
        </p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;dfs.datanode.max.transfer.threads&lt;/name&gt;
  &lt;value&gt;4096&lt;/value&gt;
&lt;/property&gt;
      </pre><p>Be sure to restart your HDFS after making the above configuration.</p><p>Not having this configuration in place makes for strange-looking failures. One
        manifestation is a complaint about missing blocks. For example:</p><pre class="screen">10/12/08 20:10:31 INFO hdfs.DFSClient: Could not obtain block
          blk_XXXXXXXXXXXXXXXXXXXXXX_YYYYYYYY from any node: java.io.IOException: No live nodes
          contain current block. Will get new block locations from namenode and retry...</pre><p>See also <a class="xref" href="#">???</a> and note that this
          property was previously known as <code class="varname">dfs.datanode.max.xcievers</code> (e.g.
          <a class="link" href="http://ccgtech.blogspot.com/2010/02/hadoop-hdfs-deceived-by-xciever.html" target="_top">
            Hadoop HDFS: Deceived by Xciever</a>).
        </p></div></div><div class="section" title="1.1.2.&nbsp;ZooKeeper Requirements"><div class="titlepage"><div><div><h3 class="title"><a name="zookeeper.requirements"></a>1.1.2.&nbsp;ZooKeeper Requirements</h3></div></div></div><p>ZooKeeper 3.4.x is required as of HBase 1.0.0. HBase makes use of the
        <code class="methodname">multi</code> functionality that is only available since 3.4.0
        (The <span class="property">useMulti</span> is defaulted true in HBase 1.0.0).
        See HBASE-12241 The crash of regionServer when taking deadserver's replication queue breaks replication
        and Use ZK.multi when available for HBASE-6710 0.92/0.94 compatibility fix for background.</p></div></div><div class="section" title="1.2.&nbsp;HBase run modes: Standalone and Distributed"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="standalone_dist"></a>1.2.&nbsp;HBase run modes: Standalone and Distributed</h2></div></div></div><p>HBase has two run modes: <a class="xref" href="#standalone" title="1.2.1.&nbsp;Standalone HBase">Section&nbsp;1.2.1, &#8220;Standalone HBase&#8221;</a> and <a class="xref" href="#distributed" title="1.2.2.&nbsp;Distributed">Section&nbsp;1.2.2, &#8220;Distributed&#8221;</a>. Out of the box, HBase runs in standalone mode. Whatever your mode,
      you will need to configure HBase by editing files in the HBase <code class="filename">conf</code>
      directory. At a minimum, you must edit <code class="code">conf/hbase-env.sh</code> to tell HBase which
        <span class="command"><strong>java</strong></span> to use. In this file you set HBase environment variables such as the
      heapsize and other options for the <span class="application">JVM</span>, the preferred location for
      log files, etc. Set <code class="varname">JAVA_HOME</code> to point at the root of your
        <span class="command"><strong>java</strong></span> install.</p><div class="section" title="1.2.1.&nbsp;Standalone HBase"><div class="titlepage"><div><div><h3 class="title"><a name="standalone"></a>1.2.1.&nbsp;Standalone HBase</h3></div></div></div><p>This is the default mode. Standalone mode is what is described in the <a class="xref" href="#">???</a> section. In standalone mode, HBase does not use HDFS -- it uses
        the local filesystem instead -- and it runs all HBase daemons and a local ZooKeeper all up
        in the same JVM. Zookeeper binds to a well known port so clients may talk to HBase.</p></div><div class="section" title="1.2.2.&nbsp;Distributed"><div class="titlepage"><div><div><h3 class="title"><a name="distributed"></a>1.2.2.&nbsp;Distributed</h3></div></div></div><p>Distributed mode can be subdivided into distributed but all daemons run on a single node
        -- a.k.a <span class="emphasis"><em>pseudo-distributed</em></span>-- and
          <span class="emphasis"><em>fully-distributed</em></span> where the daemons are spread across all nodes in
        the cluster. The pseudo-distributed vs fully-distributed nomenclature comes from Hadoop.</p><p>Pseudo-distributed mode can run against the local filesystem or it can run against an
        instance of the <span class="emphasis"><em>Hadoop Distributed File System</em></span> (HDFS).
        Fully-distributed mode can ONLY run on HDFS. See the Hadoop <a class="link" href="http://hadoop.apache.org/common/docs/r1.1.1/api/overview-summary.html#overview_description" target="_top">
          requirements and instructions</a> for how to set up HDFS for Hadoop 1.x. A good
        walk-through for setting up HDFS on Hadoop 2 is at <a class="link" href="http://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide" target="_top">http://www.alexjf.net/blog/distributed-systems/hadoop-yarn-installation-definitive-guide</a>.</p><p>Below we describe the different distributed setups. Starting, verification and
        exploration of your install, whether a <span class="emphasis"><em>pseudo-distributed</em></span> or
          <span class="emphasis"><em>fully-distributed</em></span> configuration is described in a section that
        follows, <a class="xref" href="#confirm" title="1.3.&nbsp;Running and Confirming Your Installation">Section&nbsp;1.3, &#8220;Running and Confirming Your Installation&#8221;</a>. The same verification script applies to both deploy types.</p><div class="section" title="1.2.2.1.&nbsp;Pseudo-distributed"><div class="titlepage"><div><div><h4 class="title"><a name="pseudo"></a>1.2.2.1.&nbsp;Pseudo-distributed</h4></div></div></div><div class="note" title="Pseudo-Distributed Quickstart" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Pseudo-Distributed Quickstart</h3><p>A quickstart has been added to the <a class="xref" href="#">???</a> chapter. See <a class="xref" href="#">???</a>. Some of the information that was originally in this
            section has been moved there.</p></div><p>A pseudo-distributed mode is simply a fully-distributed mode run on a single host. Use
          this configuration testing and prototyping on HBase. Do not use this configuration for
          production nor for evaluating HBase performance.</p></div></div><div class="section" title="1.2.3.&nbsp;Fully-distributed"><div class="titlepage"><div><div><h3 class="title"><a name="fully_dist"></a>1.2.3.&nbsp;Fully-distributed</h3></div></div></div><p>By default, HBase runs in standalone mode. Both standalone mode and pseudo-distributed
        mode are provided for the purposes of small-scale testing. For a production environment,
        distributed mode is appropriate. In distributed mode, multiple instances of HBase daemons
        run on multiple servers in the cluster.</p><p>Just as in pseudo-distributed mode, a fully distributed configuration requires that you
        set the <code class="code">hbase-cluster.distributed</code> property to <code class="literal">true</code>.
        Typically, the <code class="code">hbase.rootdir</code> is configured to point to a highly-available HDFS
        filesystem. </p><p>In addition, the cluster is configured so that multiple cluster nodes enlist as
        RegionServers, ZooKeeper QuorumPeers, and backup HMaster servers. These configuration basics
        are all demonstrated in <a class="xref" href="#">???</a>.</p><p title="Distributed RegionServers"><a name="regionserver"></a><b>Distributed RegionServers.&nbsp;</b>Typically, your cluster will contain multiple RegionServers all running on different
          servers, as well as primary and backup Master and Zookeeper daemons. The
            <code class="filename">conf/regionservers</code> file on the master server contains a list of
          hosts whose RegionServers are associated with this cluster. Each host is on a separate
          line. All hosts listed in this file will have their RegionServer processes started and
          stopped when the master server starts or stops.</p><p title="ZooKeeper and HBase"><a name="hbase.zookeeper"></a><b>ZooKeeper and HBase.&nbsp;</b>See section <a class="xref" href="#">???</a> for ZooKeeper setup for HBase.</p><div class="example"><a name="d1604e840"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;Example Distributed HBase Cluster</b></p><div class="example-contents"><p>This is a bare-bones <code class="filename">conf/hbase-site.xml</code> for a distributed HBase
          cluster. A cluster that is used for real-world work would contain more custom
          configuration parameters. Most HBase configuration directives have default values, which
          are used unless the value is overridden in the <code class="filename">hbase-site.xml</code>. See <a class="xref" href="#config.files" title="1.4.&nbsp;Configuration Files">Section&nbsp;1.4, &#8220;Configuration Files&#8221;</a> for more information.</p><pre class="programlisting">
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://namenode.example.org:8020/hbase&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
      &lt;value&gt;node-a.example.com,node-b.example.com,node-c.example.com&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;

        </pre><p>This is an example <code class="filename">conf/regionservers</code> file, which contains a list
          of each node that should run a RegionServer in the cluster. These nodes need HBase
          installed and they need to use the same contents of the <code class="filename">conf/</code>
          directory as the Master server..</p><pre class="programlisting">
node-a.example.com
node-b.example.com
node-c.example.com
        </pre><p>This is an example <code class="filename">conf/backup-masters</code> file, which contains a
          list of each node that should run a backup Master instance. The backup Master instances
          will sit idle unless the main Master becomes unavailable.</p><pre class="programlisting">
node-b.example.com
node-c.example.com
        </pre></div></div><br class="example-break"><p title="Distributed HBase Quickstart"><b>Distributed HBase Quickstart.&nbsp;</b>See <a class="xref" href="#">???</a> for a walk-through of a simple three-node
          cluster configuration with multiple ZooKeeper, backup HMaster, and RegionServer
          instances.</p><div class="procedure" title="Procedure&nbsp;1.1.&nbsp;HDFS Client Configuration"><a name="hdfs_client_conf"></a><p class="title"><b>Procedure&nbsp;1.1.&nbsp;HDFS Client Configuration</b></p><ul class="procedure"><li class="step" title="Step 1"><p>Of note, if you have made HDFS client configuration on your Hadoop cluster, such as
            configuration directives for HDFS clients, as opposed to server-side configurations, you
            must use one of the following methods to enable HBase to see and use these configuration
            changes:</p><ul class="stepalternatives">
            <li class="step" title="Step 1.1"><p>Add a pointer to your <code class="varname">HADOOP_CONF_DIR</code> to the
                  <code class="varname">HBASE_CLASSPATH</code> environment variable in
                  <code class="filename">hbase-env.sh</code>.</p></li>

            <li class="step" title="Step 1.2"><p>Add a copy of <code class="filename">hdfs-site.xml</code> (or
                  <code class="filename">hadoop-site.xml</code>) or, better, symlinks, under
                  <code class="filename">${HBASE_HOME}/conf</code>, or</p></li>

            <li class="step" title="Step 1.3"><p>if only a small set of HDFS client configurations, add them to
                  <code class="filename">hbase-site.xml</code>.</p></li>
          </ul></li></ul></div><p>An example of such an HDFS client configuration is <code class="varname">dfs.replication</code>.
        If for example, you want to run with a replication factor of 5, hbase will create files with
        the default of 3 unless you do the above to make the configuration available to
        HBase.</p></div></div><div class="section" title="1.3.&nbsp;Running and Confirming Your Installation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="confirm"></a>1.3.&nbsp;Running and Confirming Your Installation</h2></div></div></div><p>Make sure HDFS is running first. Start and stop the Hadoop HDFS daemons by running
          <code class="filename">bin/start-hdfs.sh</code> over in the <code class="varname">HADOOP_HOME</code>
        directory. You can ensure it started properly by testing the <span class="command"><strong>put</strong></span> and
          <span class="command"><strong>get</strong></span> of files into the Hadoop filesystem. HBase does not normally use
        the mapreduce daemons. These do not need to be started.</p><p><span class="emphasis"><em>If</em></span> you are managing your own ZooKeeper, start it and confirm its
        running else, HBase will start up ZooKeeper for you as part of its start process.</p><p>Start HBase with the following command:</p><pre class="screen">bin/start-hbase.sh</pre><p>Run the above from the <code class="varname">HBASE_HOME</code> directory.</p><p>You should now have a running HBase instance. HBase logs can be found in the
          <code class="filename">logs</code> subdirectory. Check them out especially if HBase had trouble
        starting.</p><p>HBase also puts up a UI listing vital attributes. By default its deployed on the Master
        host at port 16010 (HBase RegionServers listen on port 16020 by default and put up an
        informational http server at 16030). If the Master were running on a host named
          <code class="varname">master.example.org</code> on the default port, to see the Master's homepage
        you'd point your browser at <code class="filename">http://master.example.org:16010</code>.</p><p>Prior to HBase 0.98, the default ports the master ui was deployed on port 16010, and the
        HBase RegionServers would listen on port 16020 by default and put up an informational http
        server at 16030. </p><p>Once HBase has started, see the <a class="xref" href="#">???</a> for how to create tables, add data, scan your insertions, and
        finally disable and drop your tables.</p><p>To stop HBase after exiting the HBase shell enter</p><pre class="screen">$ ./bin/stop-hbase.sh
stopping hbase...............</pre><p>Shutdown can take a moment to complete. It can take longer if your cluster is comprised
        of many machines. If you are running a distributed operation, be sure to wait until HBase
        has shut down completely before stopping the Hadoop daemons.</p></div><div class="section" title="1.4.&nbsp;Configuration Files"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="config.files"></a>1.4.&nbsp;Configuration Files</h2></div></div></div><div class="section" title="1.4.1.&nbsp;hbase-site.xml and hbase-default.xml"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.site"></a>1.4.1.&nbsp;<code class="filename">hbase-site.xml</code> and <code class="filename">hbase-default.xml</code></h3></div></div></div><p>Just as in Hadoop where you add site-specific HDFS configuration to the
          <code class="filename">hdfs-site.xml</code> file, for HBase, site specific customizations go into
        the file <code class="filename">conf/hbase-site.xml</code>. For the list of configurable properties,
        see <a class="xref" href="#hbase_default_configurations" title="HBase Default Configuration">HBase Default Configuration</a> below or view the raw
          <code class="filename">hbase-default.xml</code> source file in the HBase source code at
          <code class="filename">src/main/resources</code>. </p><p> Not all configuration options make it out to <code class="filename">hbase-default.xml</code>.
        Configuration that it is thought rare anyone would change can exist only in code; the only
        way to turn up such configurations is via a reading of the source code itself. </p><p> Currently, changes here will require a cluster restart for HBase to notice the change. </p><div class="glossary" title="HBase Default Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_default_configurations"></a>HBase Default Configuration</h4></div></div></div><p>
The documentation below is generated using the default hbase configuration file,
<code class="filename">hbase-default.xml</code>, as source.
</p><dl><dt><a name="hbase.tmp.dir"></a><code class="varname">hbase.tmp.dir</code></dt><dd><p>Temporary directory on the local filesystem.
    Change this setting to point to a location more permanent
    than '/tmp', the usual resolve for java.io.tmpdir, as the
    '/tmp' directory is cleared on machine restart.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${java.io.tmpdir}/hbase-${user.name}</code></p></dd><dt><a name="hbase.rootdir"></a><code class="varname">hbase.rootdir</code></dt><dd><p>The directory shared by region servers and into
    which HBase persists.  The URL should be 'fully-qualified'
    to include the filesystem scheme.  For example, to specify the
    HDFS directory '/hbase' where the HDFS instance's namenode is
    running at namenode.example.org on port 9000, set this value to:
    hdfs://namenode.example.org:9000/hbase.  By default, we write
    to whatever ${hbase.tmp.dir} is set too -- usually /tmp --
    so change this configuration or else all data will be lost on
    machine restart.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.tmp.dir}/hbase</code></p></dd><dt><a name="hbase.cluster.distributed"></a><code class="varname">hbase.cluster.distributed</code></dt><dd><p>The mode the cluster will be in. Possible values are
      false for standalone mode and true for distributed mode.  If
      false, startup will run all HBase and ZooKeeper daemons together
      in the one JVM.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.zookeeper.quorum"></a><code class="varname">hbase.zookeeper.quorum</code></dt><dd><p>Comma separated list of servers in the ZooKeeper ensemble
    (This config. should have been named hbase.zookeeper.ensemble).
    For example, "host1.mydomain.com,host2.mydomain.com,host3.mydomain.com".
    By default this is set to localhost for local and pseudo-distributed modes
    of operation. For a fully-distributed setup, this should be set to a full
    list of ZooKeeper ensemble servers. If HBASE_MANAGES_ZK is set in hbase-env.sh
    this is the list of servers which hbase will start/stop ZooKeeper on as
    part of cluster start/stop.  Client-side, we will take this list of
    ensemble members and put it together with the hbase.zookeeper.clientPort
    config. and pass it into zookeeper constructor as the connectString
    parameter.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">localhost</code></p></dd><dt><a name="hbase.local.dir"></a><code class="varname">hbase.local.dir</code></dt><dd><p>Directory on the local filesystem to be used
    as a local storage.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.tmp.dir}/local/</code></p></dd><dt><a name="hbase.master.port"></a><code class="varname">hbase.master.port</code></dt><dd><p>The port the HBase Master should bind to.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60000</code></p></dd><dt><a name="hbase.master.info.port"></a><code class="varname">hbase.master.info.port</code></dt><dd><p>The port for the HBase Master web UI.
    Set to -1 if you do not want a UI instance run.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60010</code></p></dd><dt><a name="hbase.master.info.bindAddress"></a><code class="varname">hbase.master.info.bindAddress</code></dt><dd><p>The bind address for the HBase Master web UI
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.0.0.0</code></p></dd><dt><a name="hbase.master.logcleaner.plugins"></a><code class="varname">hbase.master.logcleaner.plugins</code></dt><dd><p>A comma-separated list of LogCleanerDelegate invoked by
    the LogsCleaner service. These WAL/HLog cleaners are called in order,
    so put the HLog cleaner that prunes the most HLog files in front. To
    implement your own LogCleanerDelegate, just put it in HBase's classpath
    and add the fully qualified class name here. Always add the above
    default log cleaners in the list.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.cleaner.TimeToLiveLogCleaner</code></p></dd><dt><a name="hbase.master.logcleaner.ttl"></a><code class="varname">hbase.master.logcleaner.ttl</code></dt><dd><p>Maximum time a HLog can stay in the .oldlogdir directory,
    after which it will be cleaned by a Master thread.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">600000</code></p></dd><dt><a name="hbase.master.hfilecleaner.plugins"></a><code class="varname">hbase.master.hfilecleaner.plugins</code></dt><dd><p>A comma-separated list of HFileCleanerDelegate invoked by
    the HFileCleaner service. These HFiles cleaners are called in order,
    so put the cleaner that prunes the most files in front. To
    implement your own HFileCleanerDelegate, just put it in HBase's classpath
    and add the fully qualified class name here. Always add the above
    default log cleaners in the list as they will be overwritten in
    hbase-site.xml.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.cleaner.TimeToLiveHFileCleaner</code></p></dd><dt><a name="hbase.master.catalog.timeout"></a><code class="varname">hbase.master.catalog.timeout</code></dt><dd><p>Timeout value for the Catalog Janitor from the master to
    META.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">600000</code></p></dd><dt><a name="fail.fast.expired.active.master"></a><code class="varname">fail.fast.expired.active.master</code></dt><dd><p>If abort immediately for the expired master without trying
      to recover its zk session.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.master.dns.interface"></a><code class="varname">hbase.master.dns.interface</code></dt><dd><p>The name of the Network Interface from which a master
      should report its IP address.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.master.dns.nameserver"></a><code class="varname">hbase.master.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a master should use to determine the host name used
      for communication and display purposes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.port"></a><code class="varname">hbase.regionserver.port</code></dt><dd><p>The port the HBase RegionServer binds to.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60020</code></p></dd><dt><a name="hbase.regionserver.info.port"></a><code class="varname">hbase.regionserver.info.port</code></dt><dd><p>The port for the HBase RegionServer web UI
    Set to -1 if you do not want the RegionServer UI to run.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60030</code></p></dd><dt><a name="hbase.regionserver.info.bindAddress"></a><code class="varname">hbase.regionserver.info.bindAddress</code></dt><dd><p>The address for the HBase RegionServer web UI</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.0.0.0</code></p></dd><dt><a name="hbase.regionserver.info.port.auto"></a><code class="varname">hbase.regionserver.info.port.auto</code></dt><dd><p>Whether or not the Master or RegionServer
    UI should search for a port to bind to. Enables automatic port
    search if hbase.regionserver.info.port is already in use.
    Useful for testing, turned off by default.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.regionserver.handler.count"></a><code class="varname">hbase.regionserver.handler.count</code></dt><dd><p>Count of RPC Listener instances spun up on RegionServers.
    Same property is used by the Master for count of master handlers.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">30</code></p></dd><dt><a name="hbase.ipc.server.callqueue.handler.factor"></a><code class="varname">hbase.ipc.server.callqueue.handler.factor</code></dt><dd><p>Factor to determine the number of call queues.
      A value of 0 means a single queue shared between all the handlers.
      A value of 1 means that each handler has its own queue.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.1</code></p></dd><dt><a name="hbase.ipc.server.callqueue.read.share"></a><code class="varname">hbase.ipc.server.callqueue.read.share</code></dt><dd><p>Split the call queues into read and write queues.
      A value of 0 indicate to not split the call queues.
      A value of 0.5 means there will be the same number of read and write queues
      A value of 1.0 means that all the queues except one are used to dispatch read requests.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0</code></p></dd><dt><a name="hbase.regionserver.msginterval"></a><code class="varname">hbase.regionserver.msginterval</code></dt><dd><p>Interval between messages from the RegionServer to Master
    in milliseconds.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3000</code></p></dd><dt><a name="hbase.regionserver.regionSplitLimit"></a><code class="varname">hbase.regionserver.regionSplitLimit</code></dt><dd><p>Limit for the number of regions after which no more region
    splitting should take place. This is not a hard limit for the number of
    regions but acts as a guideline for the regionserver to stop splitting after
    a certain limit. Default is MAX_INT; i.e. do not block splitting.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2147483647</code></p></dd><dt><a name="hbase.regionserver.logroll.period"></a><code class="varname">hbase.regionserver.logroll.period</code></dt><dd><p>Period at which we will roll the commit log regardless
    of how many edits it has.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3600000</code></p></dd><dt><a name="hbase.regionserver.logroll.errors.tolerated"></a><code class="varname">hbase.regionserver.logroll.errors.tolerated</code></dt><dd><p>The number of consecutive WAL close errors we will allow
    before triggering a server abort.  A setting of 0 will cause the
    region server to abort if closing the current WAL writer fails during
    log rolling.  Even a small value (2 or 3) will allow a region server
    to ride over transient HDFS errors.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.regionserver.hlog.reader.impl"></a><code class="varname">hbase.regionserver.hlog.reader.impl</code></dt><dd><p>The HLog file reader implementation.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.regionserver.wal.ProtobufLogReader</code></p></dd><dt><a name="hbase.regionserver.hlog.writer.impl"></a><code class="varname">hbase.regionserver.hlog.writer.impl</code></dt><dd><p>The HLog file writer implementation.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.regionserver.wal.ProtobufLogWriter</code></p></dd><dt><a name="hbase.regionserver.global.memstore.upperLimit"></a><code class="varname">hbase.regionserver.global.memstore.upperLimit</code></dt><dd><p>Maximum size of all memstores in a region server before new
      updates are blocked and flushes are forced. Defaults to 40% of heap.
      Updates are blocked and flushes are forced until size of all memstores
      in a region server hits hbase.regionserver.global.memstore.lowerLimit.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.4</code></p></dd><dt><a name="hbase.regionserver.global.memstore.lowerLimit"></a><code class="varname">hbase.regionserver.global.memstore.lowerLimit</code></dt><dd><p>Maximum size of all memstores in a region server before
      flushes are forced. Defaults to 38% of heap.
      This value equal to hbase.regionserver.global.memstore.upperLimit causes
      the minimum possible flushing to occur when updates are blocked due to
      memstore limiting.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.38</code></p></dd><dt><a name="hbase.regionserver.optionalcacheflushinterval"></a><code class="varname">hbase.regionserver.optionalcacheflushinterval</code></dt><dd><p>
    Maximum amount of time an edit lives in memory before being automatically flushed.
    Default 1 hour. Set it to 0 to disable automatic flushing.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3600000</code></p></dd><dt><a name="hbase.regionserver.catalog.timeout"></a><code class="varname">hbase.regionserver.catalog.timeout</code></dt><dd><p>Timeout value for the Catalog Janitor from the regionserver to META.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">600000</code></p></dd><dt><a name="hbase.regionserver.dns.interface"></a><code class="varname">hbase.regionserver.dns.interface</code></dt><dd><p>The name of the Network Interface from which a region server
      should report its IP address.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.dns.nameserver"></a><code class="varname">hbase.regionserver.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a region server should use to determine the host name used by the
      master for communication and display purposes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.regionserver.region.split.policy"></a><code class="varname">hbase.regionserver.region.split.policy</code></dt><dd><p>
      A split policy determines when a region should be split. The various other split policies that
      are available currently are ConstantSizeRegionSplitPolicy, DisabledRegionSplitPolicy, 
      DelimitedKeyPrefixRegionSplitPolicy, KeyPrefixRegionSplitPolicy etc.  
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.regionserver.IncreasingToUpperBoundRegionSplitPolicy</code></p></dd><dt><a name="zookeeper.session.timeout"></a><code class="varname">zookeeper.session.timeout</code></dt><dd><p>ZooKeeper session timeout in milliseconds. It is used in two different ways.
      First, this value is used in the ZK client that HBase uses to connect to the ensemble.
      It is also used by HBase when it starts a ZK server and it is passed as the 'maxSessionTimeout'. See
      http://hadoop.apache.org/zookeeper/docs/current/zookeeperProgrammers.html#ch_zkSessions.
      For example, if a HBase region server connects to a ZK ensemble that's also managed by HBase, then the
      session timeout will be the one specified by this configuration. But, a region server that connects
      to an ensemble managed with a different configuration will be subjected that ensemble's maxSessionTimeout. So,
      even though HBase might propose using 90 seconds, the ensemble can have a max timeout lower than this and
      it will take precedence. The current default that ZK ships with is 40 seconds, which is lower than HBase's.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">90000</code></p></dd><dt><a name="zookeeper.znode.parent"></a><code class="varname">zookeeper.znode.parent</code></dt><dd><p>Root ZNode for HBase in ZooKeeper. All of HBase's ZooKeeper
      files that are configured with a relative path will go under this node.
      By default, all of HBase's ZooKeeper file path are configured with a
      relative path, so they will all go under this directory unless changed.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">/hbase</code></p></dd><dt><a name="zookeeper.znode.rootserver"></a><code class="varname">zookeeper.znode.rootserver</code></dt><dd><p>Path to ZNode holding root region location. This is written by
      the master and read by clients and region servers. If a relative path is
      given, the parent folder will be ${zookeeper.znode.parent}. By default,
      this means the root location is stored at /hbase/root-region-server.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">root-region-server</code></p></dd><dt><a name="zookeeper.znode.acl.parent"></a><code class="varname">zookeeper.znode.acl.parent</code></dt><dd><p>Root ZNode for access control lists.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">acl</code></p></dd><dt><a name="hbase.zookeeper.dns.interface"></a><code class="varname">hbase.zookeeper.dns.interface</code></dt><dd><p>The name of the Network Interface from which a ZooKeeper server
      should report its IP address.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.zookeeper.dns.nameserver"></a><code class="varname">hbase.zookeeper.dns.nameserver</code></dt><dd><p>The host name or IP address of the name server (DNS)
      which a ZooKeeper server should use to determine the host name used by the
      master for communication and display purposes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">default</code></p></dd><dt><a name="hbase.zookeeper.peerport"></a><code class="varname">hbase.zookeeper.peerport</code></dt><dd><p>Port used by ZooKeeper peers to talk to each other.
    Seehttp://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper
    for more information.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2888</code></p></dd><dt><a name="hbase.zookeeper.leaderport"></a><code class="varname">hbase.zookeeper.leaderport</code></dt><dd><p>Port used by ZooKeeper for leader election.
    See http://hadoop.apache.org/zookeeper/docs/r3.1.1/zookeeperStarted.html#sc_RunningReplicatedZooKeeper
    for more information.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3888</code></p></dd><dt><a name="hbase.zookeeper.useMulti"></a><code class="varname">hbase.zookeeper.useMulti</code></dt><dd><p>Instructs HBase to make use of ZooKeeper's multi-update functionality.
    This allows certain ZooKeeper operations to complete more quickly and prevents some issues
    with rare Replication failure scenarios (see the release note of HBASE-2611 for an example).
    IMPORTANT: only set this to true if all ZooKeeper servers in the cluster are on version 3.4+
    and will not be downgraded.  ZooKeeper versions before 3.4 do not support multi-update and
    will not fail gracefully if multi-update is invoked (see ZOOKEEPER-1495).</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.config.read.zookeeper.config"></a><code class="varname">hbase.config.read.zookeeper.config</code></dt><dd><p>
        Set to true to allow HBaseConfiguration to read the
        zoo.cfg file for ZooKeeper properties. Switching this to true
        is not recommended, since the functionality of reading ZK
        properties from a zoo.cfg file has been deprecated.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.zookeeper.property.initLimit"></a><code class="varname">hbase.zookeeper.property.initLimit</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The number of ticks that the initial synchronization phase can take.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.zookeeper.property.syncLimit"></a><code class="varname">hbase.zookeeper.property.syncLimit</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The number of ticks that can pass between sending a request and getting an
    acknowledgment.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">5</code></p></dd><dt><a name="hbase.zookeeper.property.dataDir"></a><code class="varname">hbase.zookeeper.property.dataDir</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The directory where the snapshot is stored.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.tmp.dir}/zookeeper</code></p></dd><dt><a name="hbase.zookeeper.property.clientPort"></a><code class="varname">hbase.zookeeper.property.clientPort</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    The port at which the clients will connect.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2181</code></p></dd><dt><a name="hbase.zookeeper.property.maxClientCnxns"></a><code class="varname">hbase.zookeeper.property.maxClientCnxns</code></dt><dd><p>Property from ZooKeeper's config zoo.cfg.
    Limit on number of concurrent connections (at the socket level) that a
    single client, identified by IP address, may make to a single member of
    the ZooKeeper ensemble. Set high to avoid zk connection issues running
    standalone and pseudo-distributed.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">300</code></p></dd><dt><a name="hbase.client.write.buffer"></a><code class="varname">hbase.client.write.buffer</code></dt><dd><p>Default size of the HTable client write buffer in bytes.
    A bigger buffer takes more memory -- on both the client and server
    side since server instantiates the passed write buffer to process
    it -- but a larger buffer size reduces the number of RPCs made.
    For an estimate of server-side memory-used, evaluate
    hbase.client.write.buffer * hbase.regionserver.handler.count</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2097152</code></p></dd><dt><a name="hbase.client.pause"></a><code class="varname">hbase.client.pause</code></dt><dd><p>General client pause value.  Used mostly as value to wait
    before running a retry of a failed get, region lookup, etc.
    See hbase.client.retries.number for description of how we backoff from
    this initial pause amount and how this pause works w/ retries.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.client.retries.number"></a><code class="varname">hbase.client.retries.number</code></dt><dd><p>Maximum retries.  Used as maximum for all retryable
    operations such as the getting of a cell's value, starting a row update,
    etc.  Retry interval is a rough function based on hbase.client.pause.  At
    first we retry at this interval but then with backoff, we pretty quickly reach
    retrying every ten seconds.  See HConstants#RETRY_BACKOFF for how the backup
    ramps up.  Change this setting and hbase.client.pause to suit your workload.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">35</code></p></dd><dt><a name="hbase.client.max.total.tasks"></a><code class="varname">hbase.client.max.total.tasks</code></dt><dd><p>The maximum number of concurrent tasks a single HTable instance will
    send to the cluster.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.client.max.perserver.tasks"></a><code class="varname">hbase.client.max.perserver.tasks</code></dt><dd><p>The maximum number of concurrent tasks a single HTable instance will
    send to a single region server.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">5</code></p></dd><dt><a name="hbase.client.max.perregion.tasks"></a><code class="varname">hbase.client.max.perregion.tasks</code></dt><dd><p>The maximum number of concurrent connections the client will
    maintain to a single Region. That is, if there is already
    hbase.client.max.perregion.tasks writes in progress for this region, new puts
    won't be sent to this region until some writes finishes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1</code></p></dd><dt><a name="hbase.client.scanner.caching"></a><code class="varname">hbase.client.scanner.caching</code></dt><dd><p>Number of rows that will be fetched when calling next
    on a scanner if it is not served from (local, client) memory. Higher
    caching values will enable faster scanners but will eat up more memory
    and some calls of next may take longer and longer times when the cache is empty.
    Do not set this value such that the time between invocations is greater
    than the scanner timeout; i.e. hbase.client.scanner.timeout.period</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.client.keyvalue.maxsize"></a><code class="varname">hbase.client.keyvalue.maxsize</code></dt><dd><p>Specifies the combined maximum allowed size of a KeyValue
    instance. This is to set an upper boundary for a single entry saved in a
    storage file. Since they cannot be split it helps avoiding that a region
    cannot be split any further because the data is too large. It seems wise
    to set this to a fraction of the maximum region size. Setting it to zero
    or less disables the check.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10485760</code></p></dd><dt><a name="hbase.client.scanner.timeout.period"></a><code class="varname">hbase.client.scanner.timeout.period</code></dt><dd><p>Client scanner lease period in milliseconds.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60000</code></p></dd><dt><a name="hbase.client.localityCheck.threadPoolSize"></a><code class="varname">hbase.client.localityCheck.threadPoolSize</code></dt><dd><p></p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.client.prefetch"></a><code class="varname">hbase.client.prefetch</code></dt><dd><p>Toggles region location prefetching on or off.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.client.prefetch.limit"></a><code class="varname">hbase.client.prefetch.limit</code></dt><dd><p>The maximum number of region locations that will be
    prefetched at one time.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.bulkload.retries.number"></a><code class="varname">hbase.bulkload.retries.number</code></dt><dd><p>Maximum retries.  This is maximum number of iterations
    to atomic bulk loads are attempted in the face of splitting operations
    0 means never give up.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0</code></p></dd><dt><a name="hbase.balancer.period%0A    "></a><code class="varname">hbase.balancer.period
    </code></dt><dd><p>Period at which the region balancer runs in the Master.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">300000</code></p></dd><dt><a name="hbase.regions.slop"></a><code class="varname">hbase.regions.slop</code></dt><dd><p>Rebalance if any regionserver has average + (average * slop) regions.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.2</code></p></dd><dt><a name="hbase.server.thread.wakefrequency"></a><code class="varname">hbase.server.thread.wakefrequency</code></dt><dd><p>Time to sleep in between searches for work (in milliseconds).
    Used as sleep interval by service threads such as log roller.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10000</code></p></dd><dt><a name="hbase.server.versionfile.writeattempts"></a><code class="varname">hbase.server.versionfile.writeattempts</code></dt><dd><p>
    How many time to retry attempting to write a version file
    before just aborting. Each attempt is seperated by the
    hbase.server.thread.wakefrequency milliseconds.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3</code></p></dd><dt><a name="hbase.hregion.memstore.flush.size"></a><code class="varname">hbase.hregion.memstore.flush.size</code></dt><dd><p>
    Memstore will be flushed to disk if size of the memstore
    exceeds this number of bytes.  Value is checked by a thread that runs
    every hbase.server.thread.wakefrequency.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">134217728</code></p></dd><dt><a name="hbase.hregion.preclose.flush.size"></a><code class="varname">hbase.hregion.preclose.flush.size</code></dt><dd><p>
      If the memstores in a region are this size or larger when we go
      to close, run a "pre-flush" to clear out memstores before we put up
      the region closed flag and take the region offline.  On close,
      a flush is run under the close flag to empty memory.  During
      this time the region is offline and we are not taking on any writes.
      If the memstore content is large, this flush could take a long time to
      complete.  The preflush is meant to clean out the bulk of the memstore
      before putting up the close flag and taking the region offline so the
      flush that runs under the close flag has little to do.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">5242880</code></p></dd><dt><a name="hbase.hregion.memstore.block.multiplier"></a><code class="varname">hbase.hregion.memstore.block.multiplier</code></dt><dd><p>
    Block updates if memstore has hbase.hregion.memstore.block.multiplier
    times hbase.hregion.memstore.flush.size bytes.  Useful preventing
    runaway memstore during spikes in update traffic.  Without an
    upper-bound, memstore fills such that when it flushes the
    resultant flush files take a long time to compact or split, or
    worse, we OOME.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">4</code></p></dd><dt><a name="hbase.hregion.memstore.mslab.enabled"></a><code class="varname">hbase.hregion.memstore.mslab.enabled</code></dt><dd><p>
      Enables the MemStore-Local Allocation Buffer,
      a feature which works to prevent heap fragmentation under
      heavy write loads. This can reduce the frequency of stop-the-world
      GC pauses on large heaps.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.hregion.max.filesize"></a><code class="varname">hbase.hregion.max.filesize</code></dt><dd><p>
    Maximum HStoreFile size. If any one of a column families' HStoreFiles has
    grown to exceed this value, the hosting HRegion is split in two.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10737418240</code></p></dd><dt><a name="hbase.hregion.majorcompaction"></a><code class="varname">hbase.hregion.majorcompaction</code></dt><dd><p>The time (in miliseconds) between 'major' compactions of all
    HStoreFiles in a region.  Default: Set to 7 days.  Major compactions tend to
    happen exactly when you need them least so enable them such that they run at
    off-peak for your deploy; or, since this setting is on a periodicity that is
    unlikely to match your loading, run the compactions via an external
    invocation out of a cron job or some such.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">604800000</code></p></dd><dt><a name="hbase.hregion.majorcompaction.jitter"></a><code class="varname">hbase.hregion.majorcompaction.jitter</code></dt><dd><p>Jitter outer bound for major compactions.
    On each regionserver, we multiply the hbase.region.majorcompaction
    interval by some random fraction that is inside the bounds of this
    maximum.  We then add this + or - product to when the next
    major compaction is to run.  The idea is that major compaction
    does happen on every regionserver at exactly the same time.  The
    smaller this number, the closer the compactions come together.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.50</code></p></dd><dt><a name="hbase.hstore.compactionThreshold"></a><code class="varname">hbase.hstore.compactionThreshold</code></dt><dd><p>
    If more than this number of HStoreFiles in any one HStore
    (one HStoreFile is written per flush of memstore) then a compaction
    is run to rewrite all HStoreFiles files as one.  Larger numbers
    put off compaction but when it runs, it takes longer to complete.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">3</code></p></dd><dt><a name="hbase.hstore.flusher.count"></a><code class="varname">hbase.hstore.flusher.count</code></dt><dd><p>
    The number of flush threads. With less threads, the memstore flushes will be queued. With
    more threads, the flush will be executed in parallel, increasing the hdfs load. This can
    lead as well to more compactions.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.hstore.blockingStoreFiles"></a><code class="varname">hbase.hstore.blockingStoreFiles</code></dt><dd><p>
    If more than this number of StoreFiles in any one Store
    (one StoreFile is written per flush of MemStore) then updates are
    blocked for this HRegion until a compaction is completed, or
    until hbase.hstore.blockingWaitTime has been exceeded.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.hstore.blockingWaitTime"></a><code class="varname">hbase.hstore.blockingWaitTime</code></dt><dd><p>
    The time an HRegion will block updates for after hitting the StoreFile
    limit defined by hbase.hstore.blockingStoreFiles.
    After this time has elapsed, the HRegion will stop blocking updates even
    if a compaction has not been completed.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">90000</code></p></dd><dt><a name="hbase.hstore.compaction.max"></a><code class="varname">hbase.hstore.compaction.max</code></dt><dd><p>Max number of HStoreFiles to compact per 'minor' compaction.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.hstore.compaction.kv.max"></a><code class="varname">hbase.hstore.compaction.kv.max</code></dt><dd><p>How many KeyValues to read and then write in a batch when flushing
        or compacting.  Do less if big KeyValues and problems with OOME.
        Do more if wide, small rows.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hbase.storescanner.parallel.seek.enable"></a><code class="varname">hbase.storescanner.parallel.seek.enable</code></dt><dd><p>
      Enables StoreFileScanner parallel-seeking in StoreScanner,
      a feature which can reduce response latency under special conditions.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.storescanner.parallel.seek.threads"></a><code class="varname">hbase.storescanner.parallel.seek.threads</code></dt><dd><p>
      The default thread pool size if parallel-seeking feature enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10</code></p></dd><dt><a name="hfile.block.cache.size"></a><code class="varname">hfile.block.cache.size</code></dt><dd><p>Percentage of maximum heap (-Xmx setting) to allocate to block cache
        used by HFile/StoreFile. Default of 0.4 means allocate 40%.
        Set to 0 to disable but it's not recommended; you need at least
        enough cache to hold the storefile indices.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0.4</code></p></dd><dt><a name="hfile.block.index.cacheonwrite"></a><code class="varname">hfile.block.index.cacheonwrite</code></dt><dd><p>This allows to put non-root multi-level index blocks into the block
          cache at the time the index is being written.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hfile.index.block.max.size"></a><code class="varname">hfile.index.block.max.size</code></dt><dd><p>When the size of a leaf-level, intermediate-level, or root-level
          index block in a multi-level block index grows to this size, the
          block is written out and a new block is started.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">131072</code></p></dd><dt><a name="hfile.format.version"></a><code class="varname">hfile.format.version</code></dt><dd><p>The HFile format version to use for new files. Set this to 1 to test
          backwards-compatibility. The default value of this option should be
          consistent with FixedFileTrailer.MAX_VERSION.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hfile.block.bloom.cacheonwrite"></a><code class="varname">hfile.block.bloom.cacheonwrite</code></dt><dd><p>Enables cache-on-write for inline blocks of a compound Bloom filter.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="io.storefile.bloom.block.size"></a><code class="varname">io.storefile.bloom.block.size</code></dt><dd><p>The size in bytes of a single block ("chunk") of a compound Bloom
          filter. This size is approximate, because Bloom blocks can only be
          inserted at data block boundaries, and the number of keys per data
          block varies.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">131072</code></p></dd><dt><a name="hbase.rs.cacheblocksonwrite"></a><code class="varname">hbase.rs.cacheblocksonwrite</code></dt><dd><p>Whether an HFile block should be added to the block cache when the
          block is finished.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.rpc.server.engine"></a><code class="varname">hbase.rpc.server.engine</code></dt><dd><p>Implementation of org.apache.hadoop.hbase.ipc.RpcServerEngine to be
    used for server RPC call marshalling.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.ipc.ProtobufRpcServerEngine</code></p></dd><dt><a name="hbase.rpc.timeout"></a><code class="varname">hbase.rpc.timeout</code></dt><dd><p>This is for the RPC layer to define how long HBase client applications
        take for a remote call to time out. It uses pings to check connections
        but will eventually throw a TimeoutException.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60000</code></p></dd><dt><a name="hbase.rpc.shortoperation.timeout"></a><code class="varname">hbase.rpc.shortoperation.timeout</code></dt><dd><p>This is another version of "hbase.rpc.timeout". For those RPC operation
        within cluster, we rely on this configuration to set a short timeout limitation
        for short operation. For example, short rpc timeout for region server's trying
        to report to active master can benefit quicker master failover process.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">10000</code></p></dd><dt><a name="hbase.ipc.client.tcpnodelay"></a><code class="varname">hbase.ipc.client.tcpnodelay</code></dt><dd><p>Set no delay on rpc socket connections.  See
    http://docs.oracle.com/javase/1.5.0/docs/api/java/net/Socket.html#getTcpNoDelay()</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.master.keytab.file"></a><code class="varname">hbase.master.keytab.file</code></dt><dd><p>Full path to the kerberos keytab file to use for logging in
    the configured HMaster server principal.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.master.kerberos.principal"></a><code class="varname">hbase.master.kerberos.principal</code></dt><dd><p>Ex. "hbase/_HOST@EXAMPLE.COM".  The kerberos principal name
    that should be used to run the HMaster process.  The principal name should
    be in the form: user/hostname@DOMAIN.  If "_HOST" is used as the hostname
    portion, it will be replaced with the actual hostname of the running
    instance.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.regionserver.keytab.file"></a><code class="varname">hbase.regionserver.keytab.file</code></dt><dd><p>Full path to the kerberos keytab file to use for logging in
    the configured HRegionServer server principal.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.regionserver.kerberos.principal"></a><code class="varname">hbase.regionserver.kerberos.principal</code></dt><dd><p>Ex. "hbase/_HOST@EXAMPLE.COM".  The kerberos principal name
    that should be used to run the HRegionServer process.  The principal name
    should be in the form: user/hostname@DOMAIN.  If "_HOST" is used as the
    hostname portion, it will be replaced with the actual hostname of the
    running instance.  An entry for this principal must exist in the file
    specified in hbase.regionserver.keytab.file</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hadoop.policy.file"></a><code class="varname">hadoop.policy.file</code></dt><dd><p>The policy configuration file used by RPC servers to make
      authorization decisions on client requests.  Only used when HBase
      security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">hbase-policy.xml</code></p></dd><dt><a name="hbase.superuser"></a><code class="varname">hbase.superuser</code></dt><dd><p>List of users or groups (comma-separated), who are allowed
    full privileges, regardless of stored ACLs, across the cluster.
    Only used when HBase security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.auth.key.update.interval"></a><code class="varname">hbase.auth.key.update.interval</code></dt><dd><p>The update interval for master key for authentication tokens
    in servers in milliseconds.  Only used when HBase security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">86400000</code></p></dd><dt><a name="hbase.auth.token.max.lifetime"></a><code class="varname">hbase.auth.token.max.lifetime</code></dt><dd><p>The maximum lifetime in milliseconds after which an
    authentication token expires.  Only used when HBase security is enabled.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">604800000</code></p></dd><dt><a name="hbase.ipc.client.fallback-to-simple-auth-allowed"></a><code class="varname">hbase.ipc.client.fallback-to-simple-auth-allowed</code></dt><dd><p>When a client is configured to attempt a secure connection, but attempts to
      connect to an insecure server, that server may instruct the client to
      switch to SASL SIMPLE (unsecure) authentication. This setting controls
      whether or not the client will accept this instruction from the server.
      When false (the default), the client will not allow the fallback to SIMPLE
      authentication, and will abort the connection.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.coprocessor.region.classes"></a><code class="varname">hbase.coprocessor.region.classes</code></dt><dd><p>A comma-separated list of Coprocessors that are loaded by
    default on all tables. For any override coprocessor method, these classes
    will be called in order. After implementing your own Coprocessor, just put
    it in HBase's classpath and add the fully qualified class name here.
    A coprocessor can also be loaded on demand by setting HTableDescriptor.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.rest.port"></a><code class="varname">hbase.rest.port</code></dt><dd><p>The port for the HBase REST server.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">8080</code></p></dd><dt><a name="hbase.rest.readonly"></a><code class="varname">hbase.rest.readonly</code></dt><dd><p>Defines the mode the REST server will be started in. Possible values are:
    false: All HTTP methods are permitted - GET/PUT/POST/DELETE.
    true: Only the GET method is permitted.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.rest.threads.max"></a><code class="varname">hbase.rest.threads.max</code></dt><dd><p>The maximum number of threads of the REST server thread pool.
        Threads in the pool are reused to process REST requests. This
        controls the maximum number of requests processed concurrently.
        It may help to control the memory used by the REST server to
        avoid OOM issues. If the thread pool is full, incoming requests
        will be queued up and wait for some free threads.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">100</code></p></dd><dt><a name="hbase.rest.threads.min"></a><code class="varname">hbase.rest.threads.min</code></dt><dd><p>The minimum number of threads of the REST server thread pool.
        The thread pool always has at least these number of threads so
        the REST server is ready to serve incoming requests.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.rest.support.proxyuser"></a><code class="varname">hbase.rest.support.proxyuser</code></dt><dd><p>Enables running the REST server to support proxy-user mode.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.defaults.for.version.skip"></a><code class="varname">hbase.defaults.for.version.skip</code></dt><dd><p>Set to true to skip the 'hbase.defaults.for.version' check.
    Setting this to true can be useful in contexts other than
    the other side of a maven generation; i.e. running in an
    ide.  You'll want to set this boolean to true to avoid
    seeing the RuntimException complaint: "hbase-default.xml file
    seems to be for and old version of HBase (\${hbase.version}), this
    version is X.X.X-SNAPSHOT"</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.coprocessor.master.classes"></a><code class="varname">hbase.coprocessor.master.classes</code></dt><dd><p>A comma-separated list of
    org.apache.hadoop.hbase.coprocessor.MasterObserver coprocessors that are
    loaded by default on the active HMaster process. For any implemented
    coprocessor methods, the listed classes will be called in order. After
    implementing your own MasterObserver, just put it in HBase's classpath
    and add the fully qualified class name here.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.coprocessor.abortonerror"></a><code class="varname">hbase.coprocessor.abortonerror</code></dt><dd><p>Set to true to cause the hosting server (master or regionserver)
      to abort if a coprocessor fails to load, fails to initialize, or throws an
      unexpected Throwable object. Setting this to false will allow the server to
      continue execution but the system wide state of the coprocessor in question
      will become inconsistent as it will be properly executing in only a subset
      of servers, so this is most useful for debugging only.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.online.schema.update.enable"></a><code class="varname">hbase.online.schema.update.enable</code></dt><dd><p>Set true to enable online schema changes.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.table.lock.enable"></a><code class="varname">hbase.table.lock.enable</code></dt><dd><p>Set to true to enable locking the table in zookeeper for schema change operations.
    Table locking from master prevents concurrent schema modifications to corrupt table
    state.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.thrift.minWorkerThreads"></a><code class="varname">hbase.thrift.minWorkerThreads</code></dt><dd><p>The "core size" of the thread pool. New threads are created on every
    connection until this many threads are created.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">16</code></p></dd><dt><a name="hbase.thrift.maxWorkerThreads"></a><code class="varname">hbase.thrift.maxWorkerThreads</code></dt><dd><p>The maximum size of the thread pool. When the pending request queue
    overflows, new threads are created until their number reaches this number.
    After that, the server starts dropping connections.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.thrift.maxQueuedRequests"></a><code class="varname">hbase.thrift.maxQueuedRequests</code></dt><dd><p>The maximum number of pending Thrift connections waiting in the queue. If
     there are no idle threads in the pool, the server queues requests. Only
     when the queue overflows, new threads are added, up to
     hbase.thrift.maxQueuedRequests threads.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.thrift.htablepool.size.max"></a><code class="varname">hbase.thrift.htablepool.size.max</code></dt><dd><p>The upper bound for the table pool used in the Thrift gateways server.
      Since this is per table name, we assume a single table and so with 1000 default
      worker threads max this is set to a matching number. For other workloads this number
      can be adjusted as needed.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.regionserver.thrift.framed"></a><code class="varname">hbase.regionserver.thrift.framed</code></dt><dd><p>Use Thrift TFramedTransport on the server side.
      This is the recommended transport for thrift servers and requires a similar setting
      on the client side. Changing this to false will select the default transport,
      vulnerable to DoS when malformed requests are issued due to THRIFT-601.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.regionserver.thrift.framed.max_frame_size_in_mb"></a><code class="varname">hbase.regionserver.thrift.framed.max_frame_size_in_mb</code></dt><dd><p>Default frame size when using framed transport</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">2</code></p></dd><dt><a name="hbase.regionserver.thrift.compact"></a><code class="varname">hbase.regionserver.thrift.compact</code></dt><dd><p>Use Thrift TCompactProtocol binary serialization protocol.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.offheapcache.percentage"></a><code class="varname">hbase.offheapcache.percentage</code></dt><dd><p>The amount of off heap space to be allocated towards the experimental
     off heap cache. If you desire the cache to be disabled, simply set this
     value to 0.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">0</code></p></dd><dt><a name="hbase.data.umask.enable"></a><code class="varname">hbase.data.umask.enable</code></dt><dd><p>Enable, if true, that file permissions should be assigned
      to the files written by the regionserver</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.data.umask"></a><code class="varname">hbase.data.umask</code></dt><dd><p>File permissions that should be used to write data
      files when hbase.data.umask.enable is true</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">000</code></p></dd><dt><a name="hbase.metrics.showTableName"></a><code class="varname">hbase.metrics.showTableName</code></dt><dd><p>Whether to include the prefix "tbl.tablename" in per-column family metrics.
	If true, for each metric M, per-cf metrics will be reported for tbl.T.cf.CF.M, if false,
	per-cf metrics will be aggregated by column-family across tables, and reported for cf.CF.M.
	In both cases, the aggregated metric M across tables and cfs will be reported.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.metrics.exposeOperationTimes"></a><code class="varname">hbase.metrics.exposeOperationTimes</code></dt><dd><p>Whether to report metrics about time taken performing an
      operation on the region server.  Get, Put, Delete, Increment, and Append can all
      have their times exposed through Hadoop metrics per CF and per region.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.enabled"></a><code class="varname">hbase.snapshot.enabled</code></dt><dd><p>Set to true to allow snapshots to be taken / restored / cloned.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.format.version"></a><code class="varname">hbase.snapshot.format.version</code></dt><dd><p>The Snapshot format version to use for new snapshots.
        1 is the old format used by 0.94, 0.96 and 0.98 as default.
        2 is the new format, which should be used if all the clients that are
        accessing snapshots via MR job are updated with the latest hbase jars.
        By switching to version 2, the previous snapshots will still be readable.
      </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1</code></p></dd><dt><a name="hbase.snapshot.restore.take.failsafe.snapshot"></a><code class="varname">hbase.snapshot.restore.take.failsafe.snapshot</code></dt><dd><p>Set to true to take a snapshot before the restore operation.
      The snapshot taken will be used in case of failure, to restore the previous state.
      At the end of the restore operation this snapshot will be deleted</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.snapshot.restore.failsafe.name"></a><code class="varname">hbase.snapshot.restore.failsafe.name</code></dt><dd><p>Name of the failsafe snapshot taken by the restore operation.
      You can use the {snapshot.name}, {table.name} and {restore.timestamp} variables
      to create a name based on what you are restoring.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">hbase-failsafe-{snapshot.name}-{restore.timestamp}</code></p></dd><dt><a name="hbase.server.compactchecker.interval.multiplier"></a><code class="varname">hbase.server.compactchecker.interval.multiplier</code></dt><dd><p>The number that determines how often we scan to see if compaction is necessary.
        Normally, compactions are done after some events (such as memstore flush), but if
        region didn't receive a lot of writes for some time, or due to different compaction
        policies, it may be necessary to check it periodically. The interval between checks is
        hbase.server.compactchecker.interval.multiplier multiplied by
        hbase.server.thread.wakefrequency.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1000</code></p></dd><dt><a name="hbase.lease.recovery.timeout"></a><code class="varname">hbase.lease.recovery.timeout</code></dt><dd><p>How long we wait on dfs lease recovery in total before giving up.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">900000</code></p></dd><dt><a name="hbase.lease.recovery.dfs.timeout"></a><code class="varname">hbase.lease.recovery.dfs.timeout</code></dt><dd><p>How long between dfs recover lease invocations. Should be larger than the sum of
        the time it takes for the namenode to issue a block recovery command as part of
        datanode; dfs.heartbeat.interval and the time it takes for the primary
        datanode, performing block recovery to timeout on a dead datanode; usually
        dfs.socket.timeout. See the end of HBASE-8389 for more.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">64000</code></p></dd><dt><a name="hbase.column.max.version"></a><code class="varname">hbase.column.max.version</code></dt><dd><p>New column family descriptors will use this value as the default number of versions
      to keep.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname">1</code></p></dd><dt><a name="hbase.dfs.client.read.shortcircuit.buffer.size"></a><code class="varname">hbase.dfs.client.read.shortcircuit.buffer.size</code></dt><dd><p>If the DFSClient configuration
    dfs.client.read.shortcircuit.buffer.size is unset, we will
    use what is configured here as the short circuit read default
    direct byte buffer size. DFSClient native default is 1MB; HBase
    keeps its HDFS files open so number of file blocks * 1MB soon
    starts to add up and threaten OOME because of a shortage of
    direct memory.  So, we set it down from the default.  Make
    it &gt; the default hbase block size set in the HColumnDescriptor
    which is usually 64k.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">131072</code></p></dd><dt><a name="hbase.regionserver.checksum.verify"></a><code class="varname">hbase.regionserver.checksum.verify</code></dt><dd><p>
        If set to true, HBase will read data and then verify checksums for
        hfile blocks. Checksum verification inside HDFS will be switched off.
        If the hbase-checksum verification fails, then it will switch back to
        using HDFS checksums.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">true</code></p></dd><dt><a name="hbase.hstore.bytes.per.checksum"></a><code class="varname">hbase.hstore.bytes.per.checksum</code></dt><dd><p>
        Number of bytes in a newly created checksum chunk for HBase-level
        checksums in hfile blocks.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">16384</code></p></dd><dt><a name="hbase.hstore.checksum.algorithm"></a><code class="varname">hbase.hstore.checksum.algorithm</code></dt><dd><p>
      Name of an algorithm that is used to compute checksums. Possible values
      are NULL, CRC32, CRC32C.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">CRC32</code></p></dd><dt><a name="hbase.status.published"></a><code class="varname">hbase.status.published</code></dt><dd><p>
      This setting activates the publication by the master of the status of the region server.
      When a region server dies and its recovery starts, the master will push this information
      to the client application, to let them cut the connection immediately instead of waiting
      for a timeout.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.status.publisher.class"></a><code class="varname">hbase.status.publisher.class</code></dt><dd><p>
      Implementation of the status publication with a multicast message.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.ClusterStatusPublisher$MulticastPublisher</code></p></dd><dt><a name="hbase.status.listener.class"></a><code class="varname">hbase.status.listener.class</code></dt><dd><p>
      Implementation of the status listener with a multicast message.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.client.ClusterStatusListener$MulticastListener</code></p></dd><dt><a name="hbase.status.multicast.address.ip"></a><code class="varname">hbase.status.multicast.address.ip</code></dt><dd><p>
      Multicast address to use for the status publication by multicast.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">226.1.1.3</code></p></dd><dt><a name="hbase.status.multicast.address.port"></a><code class="varname">hbase.status.multicast.address.port</code></dt><dd><p>
      Multicast port to use for the status publication by multicast.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">60100</code></p></dd><dt><a name="hbase.dynamic.jars.dir"></a><code class="varname">hbase.dynamic.jars.dir</code></dt><dd><p>
      The directory from which the custom filter/co-processor jars can be loaded
      dynamically by the region server without the need to restart. However,
      an already loaded filter/co-processor class would not be un-loaded. See
      HBASE-1936 for more details.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">${hbase.rootdir}/lib</code></p></dd><dt><a name="hbase.security.authentication"></a><code class="varname">hbase.security.authentication</code></dt><dd><p>
      Controls whether or not secure authentication is enabled for HBase.
      Possible values are 'simple' (no authentication), and 'kerberos'.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">simple</code></p></dd><dt><a name="hbase.rest.filter.classes"></a><code class="varname">hbase.rest.filter.classes</code></dt><dd><p>
      Servlet filters for REST service.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.rest.filter.GzipFilter</code></p></dd><dt><a name="hbase.rest.filter.classes"></a><code class="varname">hbase.rest.filter.classes</code></dt><dd><p>
      Servlet filters for REST service.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.rest.filter.GzipFilter</code></p></dd><dt><a name="hbase.master.loadbalancer.class"></a><code class="varname">hbase.master.loadbalancer.class</code></dt><dd><p>
      Class used to execute the regions balancing when the period occurs.
      See the class comment for more on how it works
      http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/master/balancer/StochasticLoadBalancer.html
      It replaces the DefaultLoadBalancer as the default (since renamed
      as the SimpleLoadBalancer).
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">org.apache.hadoop.hbase.master.balancer.StochasticLoadBalancer</code></p></dd><dt><a name="hbase.security.exec.permission.checks"></a><code class="varname">hbase.security.exec.permission.checks</code></dt><dd><p>
      If this setting is enabled and ACL based access control is active (the
      AccessController coprocessor is installed either as a system coprocessor
      or on a table as a table coprocessor) then you must grant all relevant
      users EXEC privilege if they require the ability to execute coprocessor
      endpoint calls. EXEC privilege, like any other permission, can be
      granted globally to a user, or to a user on a per table or per namespace
      basis. For more information on coprocessor endpoints, see the coprocessor
      section of the HBase online manual. For more information on granting or
      revoking permissions using the AccessController, see the security
      section of the HBase online manual.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd><dt><a name="hbase.procedure.regionserver.classes"></a><code class="varname">hbase.procedure.regionserver.classes</code></dt><dd><p>A comma-separated list of 
    org.apache.hadoop.hbase.procedure.RegionServerProcedureManager procedure managers that are 
    loaded by default on the active HRegionServer process. The lifecycle methods (init/start/stop) 
    will be called by the active HRegionServer process to perform the specific globally barriered 
    procedure. After implementing your own RegionServerProcedureManager, just put it in 
    HBase's classpath and add the fully qualified class name here.
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.procedure.master.classes"></a><code class="varname">hbase.procedure.master.classes</code></dt><dd><p>A comma-separated list of
    org.apache.hadoop.hbase.procedure.MasterProcedureManager procedure managers that are
    loaded by default on the active HMaster process. A procedure is identified by its signature and
    users can use the signature and an instant name to trigger an execution of a globally barriered
    procedure. After implementing your own MasterProcedureManager, just put it in HBase's classpath
    and add the fully qualified class name here.</p><p title="Default"><b>Default.&nbsp;</b><code class="varname"></code></p></dd><dt><a name="hbase.security.visibility.mutations.checkauths"></a><code class="varname">hbase.security.visibility.mutations.checkauths</code></dt><dd><p>
      This property if enabled, will check whether the labels in the visibility expression are associated
      with the user issuing the mutation
    </p><p title="Default"><b>Default.&nbsp;</b><code class="varname">false</code></p></dd></dl></div></div><div class="section" title="1.4.2.&nbsp;hbase-env.sh"><div class="titlepage"><div><div><h3 class="title"><a name="hbase.env.sh"></a>1.4.2.&nbsp;<code class="filename">hbase-env.sh</code></h3></div></div></div><p>Set HBase environment variables in this file. Examples include options to pass the JVM
        on start of an HBase daemon such as heap size and garbage collector configs. You can also
        set configurations for HBase configuration, log directories, niceness, ssh options, where to
        locate process pid files, etc. Open the file at <code class="filename">conf/hbase-env.sh</code> and
        peruse its content. Each option is fairly well documented. Add your own environment
        variables here if you want them read by HBase daemons on startup.</p><p> Changes here will require a cluster restart for HBase to notice the change. </p></div><div class="section" title="1.4.3.&nbsp;log4j.properties"><div class="titlepage"><div><div><h3 class="title"><a name="log4j"></a>1.4.3.&nbsp;<code class="filename">log4j.properties</code></h3></div></div></div><p>Edit this file to change rate at which HBase files are rolled and to change the level at
        which HBase logs messages. </p><p> Changes here will require a cluster restart for HBase to notice the change though log
        levels can be changed for particular daemons via the HBase UI. </p></div><div class="section" title="1.4.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster"><div class="titlepage"><div><div><h3 class="title"><a name="client_dependencies"></a>1.4.4.&nbsp;Client configuration and dependencies connecting to an HBase cluster</h3></div></div></div><p>If you are running HBase in standalone mode, you don't need to configure anything for
        your client to work provided that they are all on the same machine.</p><p> Since the HBase Master may move around, clients bootstrap by looking to ZooKeeper for
        current critical locations. ZooKeeper is where all these values are kept. Thus clients
        require the location of the ZooKeeper ensemble information before they can do anything else.
        Usually this the ensemble location is kept out in the <code class="filename">hbase-site.xml</code>
        and is picked up by the client from the <code class="varname">CLASSPATH</code>.</p><p>If you are configuring an IDE to run a HBase client, you should include the
          <code class="filename">conf/</code> directory on your classpath so
          <code class="filename">hbase-site.xml</code> settings can be found (or add
          <code class="filename">src/test/resources</code> to pick up the hbase-site.xml used by tests). </p><p> Minimally, a client of HBase needs several libraries in its
          <code class="varname">CLASSPATH</code> when connecting to a cluster, including:
        </p><pre class="programlisting">
commons-configuration (commons-configuration-1.6.jar)
commons-lang (commons-lang-2.5.jar)
commons-logging (commons-logging-1.1.1.jar)
hadoop-core (hadoop-core-1.0.0.jar)
hbase (hbase-0.92.0.jar)
log4j (log4j-1.2.16.jar)
slf4j-api (slf4j-api-1.5.8.jar)
slf4j-log4j (slf4j-log4j12-1.5.8.jar)
zookeeper (zookeeper-3.4.2.jar)</pre><p>
      </p><p> An example basic <code class="filename">hbase-site.xml</code> for client only might look as
        follows: </p><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by region servers.
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
</pre><p>
      </p><div class="section" title="1.4.4.1.&nbsp;Java client configuration"><div class="titlepage"><div><div><h4 class="title"><a name="java.client.config"></a>1.4.4.1.&nbsp;Java client configuration</h4></div></div></div><p>The configuration used by a Java client is kept in an <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration" target="_top">HBaseConfiguration</a>
          instance. The factory method on HBaseConfiguration,
            <code class="code">HBaseConfiguration.create();</code>, on invocation, will read in the content of
          the first <code class="filename">hbase-site.xml</code> found on the client's
            <code class="varname">CLASSPATH</code>, if one is present (Invocation will also factor in any
            <code class="filename">hbase-default.xml</code> found; an hbase-default.xml ships inside the
            <code class="filename">hbase.X.X.X.jar</code>). It is also possible to specify configuration
          directly without having to read from a <code class="filename">hbase-site.xml</code>. For example,
          to set the ZooKeeper ensemble for the cluster programmatically do as follows:
          </p><pre class="programlisting">Configuration config = HBaseConfiguration.create();
config.set("hbase.zookeeper.quorum", "localhost");  // Here we are running zookeeper locally</pre><p>
          If multiple ZooKeeper instances make up your ZooKeeper ensemble, they may be specified in
          a comma-separated list (just as in the <code class="filename">hbase-site.xml</code> file). This
          populated <code class="classname">Configuration</code> instance can then be passed to an <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html" target="_top">HTable</a>,
          and so on. </p></div></div></div><div class="section" title="1.5.&nbsp;Example Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="example_config"></a>1.5.&nbsp;Example Configurations</h2></div></div></div><div class="section" title="1.5.1.&nbsp;Basic Distributed HBase Install"><div class="titlepage"><div><div><h3 class="title"><a name="d1604e3078"></a>1.5.1.&nbsp;Basic Distributed HBase Install</h3></div></div></div><p>Here is an example basic configuration for a distributed ten node cluster. The nodes are
        named <code class="varname">example0</code>, <code class="varname">example1</code>, etc., through node
          <code class="varname">example9</code> in this example. The HBase Master and the HDFS namenode are
        running on the node <code class="varname">example0</code>. RegionServers run on nodes
          <code class="varname">example1</code>-<code class="varname">example9</code>. A 3-node ZooKeeper ensemble runs
        on <code class="varname">example1</code>, <code class="varname">example2</code>, and <code class="varname">example3</code>
        on the default ports. ZooKeeper data is persisted to the directory
          <code class="filename">/export/zookeeper</code>. Below we show what the main configuration files --
          <code class="filename">hbase-site.xml</code>, <code class="filename">regionservers</code>, and
          <code class="filename">hbase-env.sh</code> -- found in the HBase <code class="filename">conf</code>
        directory might look like.</p><div class="section" title="1.5.1.1.&nbsp;hbase-site.xml"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_site"></a>1.5.1.1.&nbsp;<code class="filename">hbase-site.xml</code></h4></div></div></div><pre class="programlisting">

&lt;?xml version="1.0"?&gt;
&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;
    &lt;value&gt;example1,example2,example3&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
    &lt;value&gt;/export/zookeeper&lt;/value&gt;
    &lt;description&gt;Property from ZooKeeper config zoo.cfg.
    The directory where the snapshot is stored.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;hdfs://example0:8020/hbase&lt;/value&gt;
    &lt;description&gt;The directory shared by RegionServers.
    &lt;/description&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;The mode the cluster will be in. Possible values are
      false: standalone and pseudo-distributed setups with managed Zookeeper
      true: fully-distributed with unmanaged Zookeeper Quorum (see hbase-env.sh)
    &lt;/description&gt;
  &lt;/property&gt;
&lt;/configuration&gt;

        </pre></div><div class="section" title="1.5.1.2.&nbsp;regionservers"><div class="titlepage"><div><div><h4 class="title"><a name="regionservers"></a>1.5.1.2.&nbsp;<code class="filename">regionservers</code></h4></div></div></div><p>In this file you list the nodes that will run RegionServers. In our case, these nodes
          are <code class="varname">example1</code>-<code class="varname">example9</code>. </p><pre class="programlisting">
example1
example2
example3
example4
example5
example6
example7
example8
example9
        </pre></div><div class="section" title="1.5.1.3.&nbsp;hbase-env.sh"><div class="titlepage"><div><div><h4 class="title"><a name="hbase_env"></a>1.5.1.3.&nbsp;<code class="filename">hbase-env.sh</code></h4></div></div></div><p>The following lines in the <code class="filename">hbase-env.sh</code> file show how to set the
            <code class="envar">JAVA_HOME</code> environment variable (required for HBase 0.98.5 and newer) and
          set the heap to 4 GB (rather than the default value of 1 GB). If you copy and paste this
          example, be sure to adjust the <code class="envar">JAVA_HOME</code> to suit your environment.</p><pre class="screen">
# The java implementation to use.
export JAVA_HOME=/usr/java/jdk1.7.0/          

# The maximum amount of heap to use, in MB. Default is 1000.
export HBASE_HEAPSIZE=4096
        </pre><p>Use <span class="command"><strong>rsync</strong></span> to copy the content of the <code class="filename">conf</code>
          directory to all nodes of the cluster.</p></div></div></div><div class="section" title="1.6.&nbsp;The Important Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="important_configurations"></a>1.6.&nbsp;The Important Configurations</h2></div></div></div><p>Below we list what the <span class="emphasis"><em>important</em></span> Configurations. We've divided this
      section into required configuration and worth-a-look recommended configs. </p><div class="section" title="1.6.1.&nbsp;Required Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="required_configuration"></a>1.6.1.&nbsp;Required Configurations</h3></div></div></div><p>Review the <a class="xref" href="#os" title="Operating System Utilities">Operating System Utilities</a> and <a class="xref" href="#hadoop" title="1.1.1.&nbsp;Hadoop">Section&nbsp;1.1.1, &#8220;Hadoop&#8221;</a> sections. </p><div class="section" title="1.6.1.1.&nbsp;Big Cluster Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="big.cluster.config"></a>1.6.1.1.&nbsp;Big Cluster Configurations</h4></div></div></div><p>If a cluster with a lot of regions, it is possible if an eager beaver regionserver
          checks in soon after master start while all the rest in the cluster are laggardly, this
          first server to checkin will be assigned all regions. If lots of regions, this first
          server could buckle under the load. To prevent the above scenario happening up the
            <code class="varname">hbase.master.wait.on.regionservers.mintostart</code> from its default value
          of 1. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-6389" target="_top">HBASE-6389 Modify the
            conditions to ensure that Master waits for sufficient number of Region Servers before
            starting region assignments</a> for more detail. </p></div><div class="section" title="1.6.1.2.&nbsp;If a backup Master, making primary Master fail fast"><div class="titlepage"><div><div><h4 class="title"><a name="backup.master.fail.fast"></a>1.6.1.2.&nbsp;If a backup Master, making primary Master fail fast</h4></div></div></div><p>If the primary Master loses its connection with ZooKeeper, it will fall into a loop
          where it keeps trying to reconnect. Disable this functionality if you are running more
          than one Master: i.e. a backup Master. Failing to do so, the dying Master may continue to
          receive RPCs though another Master has assumed the role of primary. See the configuration <a class="xref" href="#fail.fast.expired.active.master" title="fail.fast.expired.active.master"><code class="varname">fail.fast.expired.active.master</code></a>. </p></div></div><div class="section" title="1.6.2.&nbsp;Recommended Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="recommended_configurations"></a>1.6.2.&nbsp;Recommended Configurations</h3></div></div></div><div class="section" title="1.6.2.1.&nbsp;ZooKeeper Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="recommended_configurations.zk"></a>1.6.2.1.&nbsp;ZooKeeper Configuration</h4></div></div></div><div class="section" title="1.6.2.1.1.&nbsp;zookeeper.session.timeout"><div class="titlepage"><div><div><h5 class="title"><a name="sect.zookeeper.session.timeout"></a>1.6.2.1.1.&nbsp;<code class="varname">zookeeper.session.timeout</code></h5></div></div></div><p>The default timeout is three minutes (specified in milliseconds). This means that if
            a server crashes, it will be three minutes before the Master notices the crash and
            starts recovery. You might like to tune the timeout down to a minute or even less so the
            Master notices failures the sooner. Before changing this value, be sure you have your
            JVM garbage collection configuration under control otherwise, a long garbage collection
            that lasts beyond the ZooKeeper session timeout will take out your RegionServer (You
            might be fine with this -- you probably want recovery to start on the server if a
            RegionServer has been in GC for a long period of time).</p><p>To change this configuration, edit <code class="filename">hbase-site.xml</code>, copy the
            changed file around the cluster and restart.</p><p>We set this value high to save our having to field noob questions up on the mailing
            lists asking why a RegionServer went down during a massive import. The usual cause is
            that their JVM is untuned and they are running into long GC pauses. Our thinking is that
            while users are getting familiar with HBase, we'd save them having to know all of its
            intricacies. Later when they've built some confidence, then they can play with
            configuration such as this. </p></div><div class="section" title="1.6.2.1.2.&nbsp;Number of ZooKeeper Instances"><div class="titlepage"><div><div><h5 class="title"><a name="zookeeper.instances"></a>1.6.2.1.2.&nbsp;Number of ZooKeeper Instances</h5></div></div></div><p>See <a class="xref" href="#">???</a>. </p></div></div><div class="section" title="1.6.2.2.&nbsp;HDFS Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="recommended.configurations.hdfs"></a>1.6.2.2.&nbsp;HDFS Configurations</h4></div></div></div><div class="section" title="1.6.2.2.1.&nbsp;dfs.datanode.failed.volumes.tolerated"><div class="titlepage"><div><div><h5 class="title"><a name="dfs.datanode.failed.volumes.tolerated"></a>1.6.2.2.1.&nbsp;dfs.datanode.failed.volumes.tolerated</h5></div></div></div><p>This is the "...number of volumes that are allowed to fail before a datanode stops
            offering service. By default any volume failure will cause a datanode to shutdown" from
            the <code class="filename">hdfs-default.xml</code> description. If you have &gt; three or four
            disks, you might want to set this to 1 or if you have many disks, two or more. </p></div></div><div class="section" title="1.6.2.3.&nbsp;hbase.regionserver.handler.count"><div class="titlepage"><div><div><h4 class="title"><a name="hbase.regionserver.handler.count-description"></a>1.6.2.3.&nbsp;<code class="varname">hbase.regionserver.handler.count</code></h4></div></div></div><p> This setting defines the number of threads that are kept open to answer incoming
          requests to user tables. The rule of thumb is to keep this number low when the payload per
          request approaches the MB (big puts, scans using a large cache) and high when the payload
          is small (gets, small puts, ICVs, deletes). The total size of the queries in progress is
          limited by the setting "hbase.ipc.server.max.callqueue.size". </p><p> It is safe to set that number to the maximum number of incoming clients if their
          payload is small, the typical example being a cluster that serves a website since puts
          aren't typically buffered and most of the operations are gets. </p><p> The reason why it is dangerous to keep this setting high is that the aggregate size
          of all the puts that are currently happening in a region server may impose too much
          pressure on its memory, or even trigger an OutOfMemoryError. A region server running on
          low memory will trigger its JVM's garbage collector to run more frequently up to a point
          where GC pauses become noticeable (the reason being that all the memory used to keep all
          the requests' payloads cannot be trashed, no matter how hard the garbage collector tries).
          After some time, the overall cluster throughput is affected since every request that hits
          that region server will take longer, which exacerbates the problem even more. </p><p>You can get a sense of whether you have too little or too many handlers by <a class="xref" href="#">???</a> on an individual RegionServer then tailing its logs (Queued
          requests consume memory). </p></div><div class="section" title="1.6.2.4.&nbsp;Configuration for large memory machines"><div class="titlepage"><div><div><h4 class="title"><a name="big_memory"></a>1.6.2.4.&nbsp;Configuration for large memory machines</h4></div></div></div><p> HBase ships with a reasonable, conservative configuration that will work on nearly
          all machine types that people might want to test with. If you have larger machines --
          HBase has 8G and larger heap -- you might the following configuration options helpful.
          TODO. </p></div><div class="section" title="1.6.2.5.&nbsp;Compression"><div class="titlepage"><div><div><h4 class="title"><a name="config.compression"></a>1.6.2.5.&nbsp;Compression</h4></div></div></div><p>You should consider enabling ColumnFamily compression. There are several options that
          are near-frictionless and in most all cases boost performance by reducing the size of
          StoreFiles and thus reducing I/O. </p><p>See <a class="xref" href="#">???</a> for more information.</p></div><div class="section" title="1.6.2.6.&nbsp;Configuring the size and number of WAL files"><div class="titlepage"><div><div><h4 class="title"><a name="config.wals"></a>1.6.2.6.&nbsp;Configuring the size and number of WAL files</h4></div></div></div><p>HBase uses <a class="xref" href="#">???</a> to recover the memstore data that has not been flushed to disk in case
          of an RS failure. These WAL files should be configured to be slightly smaller than HDFS
          block (by default, HDFS block is 64Mb and WAL file is ~60Mb).</p><p>HBase also has a limit on number of WAL files, designed to ensure there's never too
          much data that needs to be replayed during recovery. This limit needs to be set according
          to memstore configuration, so that all the necessary data would fit. It is recommended to
          allocated enough WAL files to store at least that much data (when all memstores are close
          to full). For example, with 16Gb RS heap, default memstore settings (0.4), and default WAL
          file size (~60Mb), 16Gb*0.4/60, the starting point for WAL file count is ~109. However, as
          all memstores are not expected to be full all the time, less WAL files can be
          allocated.</p></div><div class="section" title="1.6.2.7.&nbsp;Managed Splitting"><div class="titlepage"><div><div><h4 class="title"><a name="disable.splitting"></a>1.6.2.7.&nbsp;Managed Splitting</h4></div></div></div><p>HBase generally handles splitting your regions, based upon the settings in your
            <code class="filename">hbase-default.xml</code> and <code class="filename">hbase-site.xml</code>
          configuration files. Important settings include
            <code class="varname">hbase.regionserver.region.split.policy</code>,
            <code class="varname">hbase.hregion.max.filesize</code>,
            <code class="varname">hbase.regionserver.regionSplitLimit</code>. A simplistic view of splitting
          is that when a region grows to <code class="varname">hbase.hregion.max.filesize</code>, it is split.
          For most use patterns, most of the time, you should use automatic splitting. See <a class="xref" href="#">???</a> for more information about manual region
          splitting.</p><p>Instead of allowing HBase to split your regions automatically, you can choose to
          manage the splitting yourself. This feature was added in HBase 0.90.0. Manually managing
          splits works if you know your keyspace well, otherwise let HBase figure where to split for you.
          Manual splitting can mitigate region creation and movement under load. It also makes it so
          region boundaries are known and invariant (if you disable region splitting). If you use manual
          splits, it is easier doing staggered, time-based major compactions spread out your network IO
          load.</p><p title="Disable Automatic Splitting"><b>Disable Automatic Splitting.&nbsp;</b>To disable automatic splitting, set <code class="varname">hbase.hregion.max.filesize</code> to
            a very large value, such as <code class="literal">100 GB</code> It is not recommended to set it to
            its absolute maximum value of <code class="literal">Long.MAX_VALUE</code>.</p><div class="note" title="Automatic Splitting Is Recommended" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Automatic Splitting Is Recommended</h3><p>If you disable automatic splits to diagnose a problem or during a period of fast
            data growth, it is recommended to re-enable them when your situation becomes more
            stable. The potential benefits of managing region splits yourself are not
            undisputed.</p></div><p title="Determine the Optimal Number of Pre-Split Regions"><b>Determine the Optimal Number of Pre-Split Regions.&nbsp;</b>The optimal number of pre-split regions depends on your application and environment.
            A good rule of thumb is to start with 10 pre-split regions per server and watch as data
            grows over time. It is better to err on the side of too few regions and perform rolling
            splits later. The optimal number of regions depends upon the largest StoreFile in your
            region. The size of the largest StoreFile will increase with time if the amount of data
            grows. The goal is for the largest region to be just large enough that the compaction
            selection algorithm only compacts it during a timed major compaction. Otherwise, the
            cluster can be prone to compaction storms where a large number of regions under
            compaction at the same time. It is important to understand that the data growth causes
            compaction storms, and not the manual split decision.</p><p>If the regions are split into too many large regions, you can increase the major
          compaction interval by configuring <code class="varname">HConstants.MAJOR_COMPACTION_PERIOD</code>.
          HBase 0.90 introduced <code class="classname">org.apache.hadoop.hbase.util.RegionSplitter</code>,
          which provides a network-IO-safe rolling split of all regions.</p></div><div class="section" title="1.6.2.8.&nbsp;Managed Compactions"><div class="titlepage"><div><div><h4 class="title"><a name="managed.compactions"></a>1.6.2.8.&nbsp;Managed Compactions</h4></div></div></div><p>By default, major compactions are scheduled to run once in a 7-day period. Prior to HBase 0.96.x, major
          compactions were scheduled to happen once per day by default.</p><p>If you need to control exactly when and how often major compaction runs, you can
          disable managed major compactions. See the entry for
            <code class="varname">hbase.hregion.majorcompaction</code> in the <a class="xref" href="#">???</a> table for details.</p><div class="warning" title="Do Not Disable Major Compactions" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Do Not Disable Major Compactions</h3><p>Major compactions are absolutely necessary for StoreFile clean-up. Do not disable
            them altogether. You can run major compactions manually via the HBase shell or via the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html#majorCompact%28java.lang.String%29" target="_top">HBaseAdmin
              API</a>.</p></div><p>For more information about compactions and the compaction file selection process, see <a class="xref" href="#">???</a></p></div><div class="section" title="1.6.2.9.&nbsp;Speculative Execution"><div class="titlepage"><div><div><h4 class="title"><a name="spec.ex"></a>1.6.2.9.&nbsp;Speculative Execution</h4></div></div></div><p>Speculative Execution of MapReduce tasks is on by default, and for HBase clusters it
          is generally advised to turn off Speculative Execution at a system-level unless you need
          it for a specific case, where it can be configured per-job. Set the properties
            <code class="varname">mapreduce.map.speculative</code> and
            <code class="varname">mapreduce.reduce.speculative</code> to false. </p></div></div><div class="section" title="1.6.3.&nbsp;Other Configurations"><div class="titlepage"><div><div><h3 class="title"><a name="other_configuration"></a>1.6.3.&nbsp;Other Configurations</h3></div></div></div><div class="section" title="1.6.3.1.&nbsp;Balancer"><div class="titlepage"><div><div><h4 class="title"><a name="balancer_config"></a>1.6.3.1.&nbsp;Balancer</h4></div></div></div><p>The balancer is a periodic operation which is run on the master to redistribute regions on the cluster.  It is configured via
           <code class="varname">hbase.balancer.period</code> and defaults to 300000 (5 minutes). </p><p>See <a class="xref" href="#">???</a> for more information on the LoadBalancer.
           </p></div><div class="section" title="1.6.3.2.&nbsp;Disabling Blockcache"><div class="titlepage"><div><div><h4 class="title"><a name="disabling.blockcache"></a>1.6.3.2.&nbsp;Disabling Blockcache</h4></div></div></div><p>Do not turn off block cache (You'd do it by setting <code class="varname">hbase.block.cache.size</code> to zero).
          Currently we do not do well if you do this because the regionserver will spend all its time loading hfile
          indices over and over again.  If your working set it such that block cache does you no good, at least
          size the block cache such that hfile indices will stay up in the cache (you can get a rough idea
          on the size you need by surveying regionserver UIs; you'll see index block size accounted near the
          top of the webpage).</p></div><div class="section" title="1.6.3.3.&nbsp;Nagle's or the small package problem"><div class="titlepage"><div><div><h4 class="title"><a name="nagles"></a>1.6.3.3.&nbsp;<a class="link" href="http://en.wikipedia.org/wiki/Nagle's_algorithm" target="_top">Nagle's</a> or the small package problem</h4></div></div></div><p>If a big 40ms or so occasional delay is seen in operations against HBase,
      try the Nagles' setting.  For example, see the user mailing list thread,
      <a class="link" href="http://search-hadoop.com/m/pduLg2fydtE/Inconsistent+scan+performance+with+caching+set+&amp;subj=Re+Inconsistent+scan+performance+with+caching+set+to+1" target="_top">Inconsistent scan performance with caching set to 1</a>
      and the issue cited therein where setting notcpdelay improved scan speeds.  You might also
      see the graphs on the tail of <a class="link" href="https://issues.apache.org/jira/browse/HBASE-7008" target="_top">HBASE-7008 Set scanner caching to a better default</a>
      where our Lars Hofhansl tries various data sizes w/ Nagle's on and off measuring the effect.</p></div><div class="section" title="1.6.3.4.&nbsp;Better Mean Time to Recover (MTTR)"><div class="titlepage"><div><div><h4 class="title"><a name="mttr"></a>1.6.3.4.&nbsp;Better Mean Time to Recover (MTTR)</h4></div></div></div><p>This section is about configurations that will make servers come back faster after a fail.
          See the Deveraj Das an Nicolas Liochon blog post
          <a class="link" href="http://hortonworks.com/blog/introduction-to-hbase-mean-time-to-recover-mttr/" target="_top">Introduction to HBase Mean Time to Recover (MTTR)</a>
          for a brief introduction.</p><p>The issue <a class="link" href="https://issues.apache.org/jira/browse/HBASE-8389" target="_top">HBASE-8354 forces Namenode into loop with lease recovery requests</a>
          is messy but has a bunch of good discussion toward the end on low timeouts and how to effect faster recovery including citation of fixes
          added to HDFS.  Read the Varun Sharma comments.  The below suggested configurations are Varun's suggestions distilled and tested.  Make sure you are
          running on a late-version HDFS so you have the fixes he refers too and himself adds to HDFS that help HBase MTTR
          (e.g. HDFS-3703, HDFS-3712, and HDFS-4791 -- hadoop 2 for sure has them and late hadoop 1 has some).
          Set the following in the RegionServer.</p><pre class="programlisting">
&lt;property&gt;
&lt;property&gt;
    &lt;name&gt;hbase.lease.recovery.dfs.timeout&lt;/name&gt;
    &lt;value&gt;23000&lt;/value&gt;
    &lt;description&gt;How much time we allow elapse between calls to recover lease.
    Should be larger than the dfs timeout.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.client.socket-timeout&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;Down the DFS timeout from 60 to 10 seconds.&lt;/description&gt;
&lt;/property&gt;
</pre><p>And on the namenode/datanode side, set the following to enable 'staleness' introduced
          in HDFS-3703, HDFS-3912. </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;dfs.client.socket-timeout&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;Down the DFS timeout from 60 to 10 seconds.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.datanode.socket.write.timeout&lt;/name&gt;
    &lt;value&gt;10000&lt;/value&gt;
    &lt;description&gt;Down the DFS timeout from 8 * 60 to 10 seconds.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;ipc.client.connect.timeout&lt;/name&gt;
    &lt;value&gt;3000&lt;/value&gt;
    &lt;description&gt;Down from 60 seconds to 3.&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;ipc.client.connect.max.retries.on.timeouts&lt;/name&gt;
    &lt;value&gt;2&lt;/value&gt;
    &lt;description&gt;Down from 45 seconds to 3 (2 == 3 retries).&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.namenode.avoid.read.stale.datanode&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;Enable stale state in hdfs&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.namenode.stale.datanode.interval&lt;/name&gt;
    &lt;value&gt;20000&lt;/value&gt;
    &lt;description&gt;Down from default 30 seconds&lt;/description&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;dfs.namenode.avoid.write.stale.datanode&lt;/name&gt;
    &lt;value&gt;true&lt;/value&gt;
    &lt;description&gt;Enable stale state in hdfs&lt;/description&gt;
&lt;/property&gt;
</pre></div><div class="section" title="1.6.3.5.&nbsp;JMX"><div class="titlepage"><div><div><h4 class="title"><a name="JMX_config"></a>1.6.3.5.&nbsp;JMX</h4></div></div></div><p>JMX(Java Management Extensions) provides built-in instrumentation that enables you
          to monitor and manage the Java VM. To enable monitoring and management from remote
          systems, you need to set system property com.sun.management.jmxremote.port(the port
          number through which you want to enable JMX RMI connections) when you start the Java VM.
          See <a class="link" href="http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html" target="_top">
          official document</a> for more information. Historically, besides above port mentioned,
          JMX opens 2 additional random TCP listening ports, which could lead to port conflict
          problem.(See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10289" target="_top">HBASE-10289</a>
          for details)
        </p><p>As an alternative, You can use the coprocessor-based JMX implementation provided
          by HBase. To enable it in 0.99 or above, add below property in
          <code class="filename">hbase-site.xml</code>:
        </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.coprocessor.regionserver.classes&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.JMXListener&lt;/value&gt;
&lt;/property&gt;
</pre><p>
          NOTE: DO NOT set com.sun.management.jmxremote.port for Java VM at the same time.
        </p><p>Currently it supports Master and RegionServer Java VM. The reason why you only
          configure coprocessor for 'regionserver' is that, starting from HBase 0.99,
          a Master IS also a RegionServer. (See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10569" target="_top">HBASE-10569</a>
          for more information.)
          By default, the JMX listens on TCP port 10102, you can further configure the port
          using below properties:

        </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;regionserver.rmi.registry.port&lt;/name&gt;
    &lt;value&gt;61130&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
    &lt;name&gt;regionserver.rmi.connector.port&lt;/name&gt;
    &lt;value&gt;61140&lt;/value&gt;
&lt;/property&gt;
</pre><p>
          The registry port can be shared with connector port in most cases, so you only
          need to configure regionserver.rmi.registry.port. However if you want to use SSL
          communication, the 2 ports must be configured to different values.
        </p><p>By default the password authentication and SSL communication is disabled.
          To enable password authentication, you need to update <code class="filename">hbase-env.sh</code>
          like below:
      </p><pre class="screen">
export HBASE_JMX_BASE="-Dcom.sun.management.jmxremote.authenticate=true                  \
                       -Dcom.sun.management.jmxremote.password.file=your_password_file   \
                       -Dcom.sun.management.jmxremote.access.file=your_access_file"

export HBASE_MASTER_OPTS="$HBASE_MASTER_OPTS $HBASE_JMX_BASE "
export HBASE_REGIONSERVER_OPTS="$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE "
      </pre><p>
          See example password/access file under $JRE_HOME/lib/management.
        </p><p>To enable SSL communication with password authentication, follow below steps:
      </p><pre class="screen">
#1. generate a key pair, stored in myKeyStore
keytool -genkey -alias jconsole -keystore myKeyStore

#2. export it to file jconsole.cert
keytool -export -alias jconsole -keystore myKeyStore -file jconsole.cert

#3. copy jconsole.cert to jconsole client machine, import it to jconsoleKeyStore
keytool -import -alias jconsole -keystore jconsoleKeyStore -file jconsole.cert
      </pre><p>
          And then update <code class="filename">hbase-env.sh</code> like below:
      </p><pre class="screen">
export HBASE_JMX_BASE="-Dcom.sun.management.jmxremote.ssl=true                         \
                       -Djavax.net.ssl.keyStore=/home/tianq/myKeyStore                 \
                       -Djavax.net.ssl.keyStorePassword=your_password_in_step_1       \
                       -Dcom.sun.management.jmxremote.authenticate=true                \
                       -Dcom.sun.management.jmxremote.password.file=your_password file \
                       -Dcom.sun.management.jmxremote.access.file=your_access_file"

export HBASE_MASTER_OPTS="$HBASE_MASTER_OPTS $HBASE_JMX_BASE "
export HBASE_REGIONSERVER_OPTS="$HBASE_REGIONSERVER_OPTS $HBASE_JMX_BASE "
      </pre><p>

          Finally start jconsole on client using the key store:
      </p><pre class="screen">
jconsole -J-Djavax.net.ssl.trustStore=/home/tianq/jconsoleKeyStore
      </pre><p>
        </p><p>NOTE: for HBase 0.98, To enable the HBase JMX implementation on Master, you also
          need to add below property in <code class="filename">hbase-site.xml</code>:
        </p><pre class="programlisting">
&lt;property&gt;
    &lt;name&gt;hbase.coprocessor.master.classes&lt;/name&gt;
    &lt;value&gt;org.apache.hadoop.hbase.JMXListener&lt;/value&gt;
&lt;/property&gt;
</pre><p>
          The corresponding properties for port configuration are master.rmi.registry.port
          (by default 10101) and master.rmi.connector.port(by default the same as registry.port)
        </p></div></div></div><div class="section" title="1.7.&nbsp;Dynamic Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dyn_config"></a>1.7.&nbsp;Dynamic Configuration</h2></div><div><h3 class="subtitle">Changing Configuration Without Restarting Servers</h3></div></div></div><p>Since HBase 1.0.0, it is possible to change a subset of the configuration without
      requiring a server restart. In the hbase shell, there are new operators,
      <span class="command"><strong>update_config</strong></span> and <span class="command"><strong>update_all_config</strong></span> that
      will prompt a server or all servers to reload configuration.</p><p>Only a subset of all configurations can currently be changed in the running server.
      Here is an incomplete list:
      <span class="property">hbase.regionserver.thread.compaction.large</span>,
      <span class="property">hbase.regionserver.thread.compaction.small</span>,
      <span class="property">hbase.regionserver.thread.split</span>,
      <span class="property">hbase.regionserver.thread.merge</span>, as well as compaction
      policy and configurations and adjustment to offpeak hours.
      For the full list consult the patch attached to 
      <a class="link" href="https://issues.apache.org/jira/browse/HBASE-12147" target="_top">HBASE-12147 Porting Online Config Change from 89-fb</a>.
    </p></div></div><div id="disqus_thread"></div><script type="text/javascript">
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></body></html>