<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>9.6.&nbsp;RegionServer</title><link rel="stylesheet" type="text/css" href="../css/freebsd_docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><link rel="home" href="book.html" title="The Apache HBase&#153; Reference Guide"><link rel="up" href="architecture.html" title="Chapter&nbsp;9.&nbsp;Architecture"><link rel="prev" href="master.html" title="9.5.&nbsp;Master"><link rel="next" href="regions.arch.html" title="9.7.&nbsp;Regions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9.6.&nbsp;RegionServer</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="master.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;9.&nbsp;Architecture</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="regions.arch.html">Next</a></td></tr></table><hr></div><script type="text/javascript">
    var disqus_shortname = 'hbase'; // required: replace example with your forum shortname
    var disqus_url = 'http://hbase.apache.org/book/regionserver.arch.html';
    </script><div class="section" title="9.6.&nbsp;RegionServer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="regionserver.arch"></a>9.6.&nbsp;RegionServer</h2></div></div></div><p><code class="code">HRegionServer</code> is the RegionServer implementation. It is responsible for
        serving and managing regions. In a distributed cluster, a RegionServer runs on a <a class="xref" href="arch.hdfs.html#arch.hdfs.dn" title="9.9.2.&nbsp;DataNode">Section&nbsp;9.9.2, &#8220;DataNode&#8221;</a>. </p><div class="section" title="9.6.1.&nbsp;Interface"><div class="titlepage"><div><div><h3 class="title"><a name="regionserver.arch.api"></a>9.6.1.&nbsp;Interface</h3></div></div></div><p>The methods exposed by <code class="code">HRegionRegionInterface</code> contain both data-oriented
          and region-maintenance methods: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Data (get, put, delete, next, etc.)</p></li><li class="listitem"><p>Region (splitRegion, compactRegion, etc.)</p></li></ul></div><p> For example, when the <code class="code">HBaseAdmin</code> method
            <code class="code">majorCompact</code> is invoked on a table, the client is actually iterating
          through all regions for the specified table and requesting a major compaction directly to
          each region. </p></div><div class="section" title="9.6.2.&nbsp;Processes"><div class="titlepage"><div><div><h3 class="title"><a name="regionserver.arch.processes"></a>9.6.2.&nbsp;Processes</h3></div></div></div><p>The RegionServer runs a variety of background threads:</p><div class="section" title="9.6.2.1.&nbsp;CompactSplitThread"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.compactsplit"></a>9.6.2.1.&nbsp;CompactSplitThread</h4></div></div></div><p>Checks for splits and handle minor compactions.</p></div><div class="section" title="9.6.2.2.&nbsp;MajorCompactionChecker"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.majorcompact"></a>9.6.2.2.&nbsp;MajorCompactionChecker</h4></div></div></div><p>Checks for major compactions.</p></div><div class="section" title="9.6.2.3.&nbsp;MemStoreFlusher"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.memstore"></a>9.6.2.3.&nbsp;MemStoreFlusher</h4></div></div></div><p>Periodically flushes in-memory writes in the MemStore to StoreFiles.</p></div><div class="section" title="9.6.2.4.&nbsp;LogRoller"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.log"></a>9.6.2.4.&nbsp;LogRoller</h4></div></div></div><p>Periodically checks the RegionServer's HLog.</p></div></div><div class="section" title="9.6.3.&nbsp;Coprocessors"><div class="titlepage"><div><div><h3 class="title"><a name="coprocessors"></a>9.6.3.&nbsp;Coprocessors</h3></div></div></div><p>Coprocessors were added in 0.92. There is a thorough <a class="link" href="https://blogs.apache.org/hbase/entry/coprocessor_introduction" target="_top">Blog Overview
            of CoProcessors</a> posted. Documentation will eventually move to this reference
          guide, but the blog is the most current information available at this time. </p></div><div class="section" title="9.6.4.&nbsp;Block Cache"><div class="titlepage"><div><div><h3 class="title"><a name="block.cache"></a>9.6.4.&nbsp;Block Cache</h3></div></div></div><p>HBase provides two different BlockCache implementations: the default onheap
          LruBlockCache and BucketCache, which is (usually) offheap. This section
          discusses benefits and drawbacks of each implementation, how to choose the appropriate
          option, and configuration options for each.</p><div class="note" title="Block Cache Reporting: UI" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Block Cache Reporting: UI</h3><p>See the RegionServer UI for detail on caching deploy.  Since HBase-0.98.4, the
          Block Cache detail has been significantly extended showing configurations,
          sizings, current usage, time-in-the-cache, and even detail on block counts and types.</p></div><div class="section" title="9.6.4.1.&nbsp;Cache Choices"><div class="titlepage"><div><div><h4 class="title"><a name="d2875e9955"></a>9.6.4.1.&nbsp;Cache Choices</h4></div></div></div><p><code class="classname">LruBlockCache</code> is the original implementation, and is
              entirely within the Java heap. <code class="classname">BucketCache</code> is mainly
              intended for keeping blockcache data offheap, although BucketCache can also
              keep data onheap and serve from a file-backed cache.
              </p><div class="note" title="BucketCache is production ready as of hbase-0.98.6" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">BucketCache is production ready as of hbase-0.98.6</h3><p>To run with BucketCache, you need HBASE-11678. This was included in
                  hbase-0.98.6.
                </p></div><p>
          </p><p>Fetching will always be slower when fetching from BucketCache,
              as compared to the native onheap LruBlockCache. However, latencies tend to be
              less erratic across time, because there is less garbage collection when you use
              BucketCache since it is managing BlockCache allocations, not the GC. If the
              BucketCache is deployed in offheap mode, this memory is not managed by the
              GC at all. This is why you'd use BucketCache, so your latencies are less erratic and to mitigate GCs
              and heap fragmentation.  See Nick Dimiduk's <a class="link" href="http://www.n10k.com/blog/blockcache-101/" target="_top">BlockCache 101</a> for
            comparisons running onheap vs offheap tests. Also see
            <a class="link" href="http://people.apache.org/~stack/bc/" target="_top">Comparing BlockCache Deploys</a>
            which finds that if your dataset fits inside your LruBlockCache deploy, use it otherwise
            if you are experiencing cache churn (or you want your cache to exist beyond the
            vagaries of java GC), use BucketCache.
              </p><p>When you enable BucketCache, you are enabling a two tier caching
              system, an L1 cache which is implemented by an instance of LruBlockCache and
              an offheap L2 cache which is implemented by BucketCache.  Management of these
              two tiers and the policy that dictates how blocks move between them is done by
              <code class="classname">CombinedBlockCache</code>. It keeps all DATA blocks in the L2
              BucketCache and meta blocks -- INDEX and BLOOM blocks --
              onheap in the L1 <code class="classname">LruBlockCache</code>.
              See <a class="xref" href="regionserver.arch.html#offheap.blockcache" title="9.6.4.5.&nbsp;Offheap Block Cache">Section&nbsp;9.6.4.5, &#8220;Offheap Block Cache&#8221;</a> for more detail on going offheap.</p></div><div class="section" title="9.6.4.2.&nbsp;General Cache Configurations"><div class="titlepage"><div><div><h4 class="title"><a name="cache.configurations"></a>9.6.4.2.&nbsp;General Cache Configurations</h4></div></div></div><p>Apart from the cache implementation itself, you can set some general configuration
            options to control how the cache performs. See <a class="link" href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html" target="_top">http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html</a>. After setting any of these options, restart or rolling restart your cluster for the
            configuration to take effect. Check logs for errors or unexpected behavior.</p><p>See also <a class="xref" href="perf.configurations.html#blockcache.prefetch" title="14.4.4.&nbsp;Prefetch Option for Blockcache">Section&nbsp;14.4.4, &#8220;Prefetch Option for Blockcache&#8221;</a>, which discusses a new option
            introduced in <a class="link" href="https://issues.apache.org/jira/browse/HBASE-9857" target="_top">HBASE-9857</a>.</p></div><div class="section" title="9.6.4.3.&nbsp;LruBlockCache Design"><div class="titlepage"><div><div><h4 class="title"><a name="block.cache.design"></a>9.6.4.3.&nbsp;LruBlockCache Design</h4></div></div></div><p>The LruBlockCache is an LRU cache that contains three levels of block priority to
            allow for scan-resistance and in-memory ColumnFamilies: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Single access priority: The first time a block is loaded from HDFS it normally
                has this priority and it will be part of the first group to be considered during
                evictions. The advantage is that scanned blocks are more likely to get evicted than
                blocks that are getting more usage.</p></li><li class="listitem"><p>Mutli access priority: If a block in the previous priority group is accessed
                again, it upgrades to this priority. It is thus part of the second group considered
                during evictions.</p></li><li class="listitem"><p><a name="hbase.cache.inmemory"></a>In-memory access priority: If the block's family was configured to be
                "in-memory", it will be part of this priority disregarding the number of times it
                was accessed. Catalog tables are configured like this. This group is the last one
                considered during evictions.</p><p>To mark a column family as in-memory, call
                </p><pre class="programlisting">HColumnDescriptor.setInMemory(true);</pre><p> if creating a table from java,
                or set <span class="command"><strong>IN_MEMORY =&gt; true</strong></span> when creating or altering a table in
                the shell: e.g.  </p><pre class="programlisting">hbase(main):003:0&gt; create  't', {NAME =&gt; 'f', IN_MEMORY =&gt; 'true'}</pre></li></ul></div><p> For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/LruBlockCache.html" target="_top">LruBlockCache
              source</a>
          </p></div><div class="section" title="9.6.4.4.&nbsp;LruBlockCache Usage"><div class="titlepage"><div><div><h4 class="title"><a name="block.cache.usage"></a>9.6.4.4.&nbsp;LruBlockCache Usage</h4></div></div></div><p>Block caching is enabled by default for all the user tables which means that any
            read operation will load the LRU cache. This might be good for a large number of use
            cases, but further tunings are usually required in order to achieve better performance.
            An important concept is the <a class="link" href="http://en.wikipedia.org/wiki/Working_set_size" target="_top">working set size</a>, or
            WSS, which is: "the amount of memory needed to compute the answer to a problem". For a
            website, this would be the data that's needed to answer the queries over a short amount
            of time. </p><p>The way to calculate how much memory is available in HBase for caching is: </p><pre class="programlisting">
            number of region servers * heap size * hfile.block.cache.size * 0.99
        </pre><p>The default value for the block cache is 0.25 which represents 25% of the available
            heap. The last value (99%) is the default acceptable loading factor in the LRU cache
            after which eviction is started. The reason it is included in this equation is that it
            would be unrealistic to say that it is possible to use 100% of the available memory
            since this would make the process blocking from the point where it loads new blocks.
            Here are some examples: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>One region server with the default heap size (1 GB) and the default block cache
                size will have 253 MB of block cache available.</p></li><li class="listitem"><p>20 region servers with the heap size set to 8 GB and a default block cache size
                will have 39.6 of block cache.</p></li><li class="listitem"><p>100 region servers with the heap size set to 24 GB and a block cache size of 0.5
                will have about 1.16 TB of block cache.</p></li></ul></div><p>Your data is not the only resident of the block cache. Here are others that you may have to take into account:
        </p><div class="variablelist"><dl><dt><span class="term">Catalog Tables</span></dt><dd><p>The <code class="code">-ROOT-</code> (prior to HBase 0.96. See <a class="xref" href="arch.catalog.html#arch.catalog.root" title="9.2.1.&nbsp;-ROOT-">Section&nbsp;9.2.1, &#8220;-ROOT-&#8221;</a>) and <code class="code">hbase:meta</code> tables are forced
                  into the block cache and have the in-memory priority which means that they are
                  harder to evict. The former never uses more than a few hundreds of bytes while the
                  latter can occupy a few MBs (depending on the number of regions).</p></dd><dt><span class="term">HFiles Indexes</span></dt><dd><p>An <em class="firstterm">hfile</em> is the file format that HBase uses to store
                  data in HDFS. It contains a multi-layered index which allows HBase to seek to the
                  data without having to read the whole file. The size of those indexes is a factor
                  of the block size (64KB by default), the size of your keys and the amount of data
                  you are storing. For big data sets it's not unusual to see numbers around 1GB per
                  region server, although not all of it will be in cache because the LRU will evict
                  indexes that aren't used.</p></dd><dt><span class="term">Keys</span></dt><dd><p>The values that are stored are only half the picture, since each value is
                  stored along with its keys (row key, family qualifier, and timestamp). See <a class="xref" href="rowkey.design.html#keysize" title="6.3.3.&nbsp;Try to minimize row and column sizes">Section&nbsp;6.3.3, &#8220;Try to minimize row and column sizes&#8221;</a>.</p></dd><dt><span class="term">Bloom Filters</span></dt><dd><p>Just like the HFile indexes, those data structures (when enabled) are stored
                  in the LRU.</p></dd></dl></div><p>Currently the recommended way to measure HFile indexes and bloom filters sizes is to
            look at the region server web UI and checkout the relevant metrics. For keys, sampling
            can be done by using the HFile command line tool and look for the average key size
            metric. Since HBase 0.98.3, you can view detail on BlockCache stats and metrics
            in a special Block Cache section in the UI.</p><p>It's generally bad to use block caching when the WSS doesn't fit in memory. This is
            the case when you have for example 40GB available across all your region servers' block
            caches but you need to process 1TB of data. One of the reasons is that the churn
            generated by the evictions will trigger more garbage collections unnecessarily. Here are
            two use cases: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Fully random reading pattern: This is a case where you almost never access the
                same row twice within a short amount of time such that the chance of hitting a
                cached block is close to 0. Setting block caching on such a table is a waste of
                memory and CPU cycles, more so that it will generate more garbage to pick up by the
                JVM. For more information on monitoring GC, see <a class="xref" href="trouble.log.html#trouble.log.gc" title="15.2.3.&nbsp;JVM Garbage Collection Logs">Section&nbsp;15.2.3, &#8220;JVM Garbage Collection Logs&#8221;</a>.</p></li><li class="listitem"><p>Mapping a table: In a typical MapReduce job that takes a table in input, every
                row will be read only once so there's no need to put them into the block cache. The
                Scan object has the option of turning this off via the setCaching method (set it to
                false). You can still keep block caching turned on on this table if you need fast
                random read access. An example would be counting the number of rows in a table that
                serves live traffic, caching every block of that table would create massive churn
                and would surely evict data that's currently in use. </p></li></ul></div><div class="section" title="9.6.4.4.1.&nbsp;Caching META blocks only (DATA blocks in fscache)"><div class="titlepage"><div><div><h5 class="title"><a name="data.blocks.in.fscache"></a>9.6.4.4.1.&nbsp;Caching META blocks only (DATA blocks in fscache)</h5></div></div></div><p>An interesting setup is one where we cache META blocks only and we read DATA
              blocks in on each access. If the DATA blocks fit inside fscache, this alternative
              may make sense when access is completely random across a very large dataset.
              To enable this setup, alter your table and for each column family
              set <code class="varname">BLOCKCACHE =&gt; 'false'</code>.  You are 'disabling' the
              BlockCache for this column family only you can never disable the caching of
              META blocks. Since
              <a class="link" href="https://issues.apache.org/jira/browse/HBASE-4683" target="_top">HBASE-4683 Always cache index and bloom blocks</a>,
              we will cache META blocks even if the BlockCache is disabled.
            </p></div></div><div class="section" title="9.6.4.5.&nbsp;Offheap Block Cache"><div class="titlepage"><div><div><h4 class="title"><a name="offheap.blockcache"></a>9.6.4.5.&nbsp;Offheap Block Cache</h4></div></div></div><div class="section" title="9.6.4.5.1.&nbsp;How to Enable BucketCache"><div class="titlepage"><div><div><h5 class="title"><a name="enable.bucketcache"></a>9.6.4.5.1.&nbsp;How to Enable BucketCache</h5></div></div></div><p>The usual deploy of BucketCache is via a managing class that sets up two caching tiers: an L1 onheap cache
                    implemented by LruBlockCache and a second L2 cache implemented with BucketCache. The managing class is <a class="link" href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.html" target="_top">CombinedBlockCache</a> by default.
            The just-previous link describes the caching 'policy' implemented by CombinedBlockCache. In short, it works
            by keeping meta blocks -- INDEX and BLOOM in the L1, onheap LruBlockCache tier -- and DATA
            blocks are kept in the L2, BucketCache tier. It is possible to amend this behavior in
            HBase since version 1.0 and ask that a column family have both its meta and DATA blocks hosted onheap in the L1 tier by
            setting <code class="varname">cacheDataInL1</code> via
                  <code class="code">(HColumnDescriptor.setCacheDataInL1(true)</code>
            or in the shell, creating or amending column families setting <code class="varname">CACHE_DATA_IN_L1</code>
            to true: e.g. </p><pre class="programlisting">hbase(main):003:0&gt; create 't', {NAME =&gt; 't', CONFIGURATION =&gt; {CACHE_DATA_IN_L1 =&gt; 'true'}}</pre><p>The BucketCache Block Cache can be deployed onheap, offheap, or file based.
            You set which via the
            <code class="varname">hbase.bucketcache.ioengine</code> setting.  Setting it to
            <code class="varname">heap</code> will have BucketCache deployed inside the 
            allocated java heap. Setting it to <code class="varname">offheap</code> will have
            BucketCache make its allocations offheap,
            and an ioengine setting of <code class="varname">file:PATH_TO_FILE</code> will direct
            BucketCache to use a file caching (Useful in particular if you have some fast i/o attached to the box such
            as SSDs).
        </p><p><a name="raw.l1.l2"></a>It is possible to deploy an L1+L2 setup where we bypass the CombinedBlockCache
            policy and have BucketCache working as a strict L2 cache to the L1
              LruBlockCache. For such a setup, set <code class="varname">CacheConfig.BUCKET_CACHE_COMBINED_KEY</code> to
              <code class="literal">false</code>. In this mode, on eviction from L1, blocks go to L2.
              When a block is cached, it is cached first in L1. When we go to look for a cached block,
              we look first in L1 and if none found, then search L2.  Let us call this deploy format,
              <span class="emphasis"><em><a class="indexterm" name="d2875e10166"></a></em></span>.</p><p>Other BucketCache configs include: specifying a location to persist cache to across
              restarts, how many threads to use writing the cache, etc.  See the
              <a class="link" href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html" target="_top">CacheConfig.html</a>
              class for configuration options and descriptions.</p><div class="procedure" title="Procedure&nbsp;9.1.&nbsp;BucketCache Example Configuration"><a name="d2875e10175"></a><p class="title"><b>Procedure&nbsp;9.1.&nbsp;BucketCache Example Configuration</b></p><p>This sample provides a configuration for a 4 GB offheap BucketCache with a 1 GB
                  onheap cache. Configuration is performed on the RegionServer.  Setting
                  <code class="varname">hbase.bucketcache.ioengine</code> and 
                  <code class="varname">hbase.bucketcache.size</code> &gt; 0 enables CombinedBlockCache.
                  Let us presume that the RegionServer has been set to run with a 5G heap:
                  i.e. HBASE_HEAPSIZE=5g.
              </p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>First, edit the RegionServer's <code class="filename">hbase-env.sh</code> and set
                  <code class="varname">-XX:MaxDirectMemorySize</code> to a value greater than the offheap size wanted, in
                  this case, 4 GB (expressed as 4G).  Lets set it to 5G.  That'll be 4G
                  for our offheap cache and 1G for any other uses of offheap memory (there are
                  other users of offheap memory other than BlockCache; e.g. DFSClient 
                  in RegionServer can make use of offheap memory). See <a class="xref" href="regionserver.arch.html#direct.memory" title="Direct Memory Usage In HBase">Direct Memory Usage In HBase</a>.</p><pre class="programlisting">-XX:MaxDirectMemorySize=5G</pre></li><li class="step" title="Step 2"><p>Next, add the following configuration to the RegionServer's
                    <code class="filename">hbase-site.xml</code>.</p><pre class="programlisting">
&lt;property&gt;
  &lt;name&gt;hbase.bucketcache.ioengine&lt;/name&gt;
  &lt;value&gt;offheap&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hfile.block.cache.size&lt;/name&gt;
  &lt;value&gt;0.2&lt;/value&gt;
&lt;/property&gt;
&lt;property&gt;
  &lt;name&gt;hbase.bucketcache.size&lt;/name&gt;
  &lt;value&gt;4196&lt;/value&gt;
&lt;/property&gt;
          </pre></li><li class="step" title="Step 3"><p>Restart or rolling restart your cluster, and check the logs for any
                  issues.</p></li></ol></div><p>In the above, we set bucketcache to be 4G.  The onheap lrublockcache we
                configured to have 0.2 of the RegionServer's heap size (0.2 * 5G = 1G).
                In other words, you configure the L1 LruBlockCache as you would normally,
                as you would when there is no L2 BucketCache present.
            </p><p><a class="link" href="https://issues.apache.org/jira/browse/HBASE-10641" target="_top">HBASE-10641</a> introduced the ability to configure multiple sizes for the
              buckets of the bucketcache, in HBase 0.98 and newer. To configurable multiple bucket
              sizes, configure the new property <code class="option">hfile.block.cache.sizes</code> (instead of
                <code class="option">hfile.block.cache.size</code>) to a comma-separated list of block sizes,
              ordered from smallest to largest, with no spaces. The goal is to optimize the bucket
              sizes based on your data access patterns. The following example configures buckets of
              size 4096 and 8192.</p><pre class="screen">
&lt;property&gt;
  &lt;name&gt;hfile.block.cache.sizes&lt;/name&gt;
  &lt;value&gt;4096,8192&lt;/value&gt;
&lt;/property&gt;
              </pre><div class="note" title="Direct Memory Usage In HBase" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="direct.memory"></a>Direct Memory Usage In HBase</h3><p>The default maximum direct memory varies by JVM.  Traditionally it is 64M
                    or some relation to allocated heap size (-Xmx) or no limit at all (JDK7 apparently).
                    HBase servers use direct memory, in particular short-circuit reading, the hosted DFSClient will
                    allocate direct memory buffers.  If you do offheap block caching, you'll
                    be making use of direct memory.  Starting your JVM, make sure
                    the <code class="varname">-XX:MaxDirectMemorySize</code> setting in
                    <code class="filename">conf/hbase-env.sh</code> is set to some value that is
                    higher than what you have allocated to your offheap blockcache
                    (<code class="varname">hbase.bucketcache.size</code>).  It should be larger than your offheap block
                    cache and then some for DFSClient usage (How much the DFSClient uses is not
                    easy to quantify; it is the number of open hfiles * <code class="varname">hbase.dfs.client.read.shortcircuit.buffer.size</code>
                    where hbase.dfs.client.read.shortcircuit.buffer.size is set to 128k in HBase -- see <code class="filename">hbase-default.xml</code>
                    default configurations).
                        Direct memory, which is part of the Java process heap, is separate from the object
                        heap allocated by -Xmx. The value allocated by MaxDirectMemorySize must not exceed
                        physical RAM, and is likely to be less than the total available RAM due to other
                        memory requirements and system constraints.
                </p><p>You can see how much memory -- onheap and offheap/direct -- a RegionServer is
                configured to use and how much it is using at any one time by looking at the
                  <span class="emphasis"><em>Server Metrics: Memory</em></span> tab in the UI. It can also be gotten
                via JMX. In particular the direct memory currently used by the server can be found
                on the <code class="varname">java.nio.type=BufferPool,name=direct</code> bean. Terracotta has
                a <a class="link" href="http://terracotta.org/documentation/4.0/bigmemorygo/configuration/storage-options" target="_top">good write up</a> on using offheap memory in java. It is for their product
                BigMemory but alot of the issues noted apply in general to any attempt at going
                offheap. Check it out.</p></div><div class="note" title="hbase.bucketcache.percentage.in.combinedcache" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a name="hbase.bucketcache.percentage.in.combinedcache"></a>hbase.bucketcache.percentage.in.combinedcache</h3><p>This is a pre-HBase 1.0 configuration removed because it
                      was confusing. It was a float that you would set to some value
                      between 0.0 and 1.0.  Its default was 0.9. If the deploy was using
                      CombinedBlockCache, then the LruBlockCache L1 size was calculated to
                      be (1 - <code class="varname">hbase.bucketcache.percentage.in.combinedcache</code>) * <code class="varname">size-of-bucketcache</code> 
                      and the BucketCache size was <code class="varname">hbase.bucketcache.percentage.in.combinedcache</code> * size-of-bucket-cache.
                      where size-of-bucket-cache itself is EITHER the value of the configuration hbase.bucketcache.size
                      IF it was specified as megabytes OR <code class="varname">hbase.bucketcache.size</code> * <code class="varname">-XX:MaxDirectMemorySize</code> if
                      <code class="varname">hbase.bucketcache.size</code> between 0 and 1.0.
                  </p><p>In 1.0, it should be more straight-forward. L1 LruBlockCache size
                      is set as a fraction of java heap using hfile.block.cache.size setting
                      (not the best name) and L2 is set as above either in absolute
                      megabytes or as a fraction of allocated maximum direct memory.
                  </p></div></div></div></div><div class="section" title="9.6.5.&nbsp;Write Ahead Log (WAL)"><div class="titlepage"><div><div><h3 class="title"><a name="wal"></a>9.6.5.&nbsp;Write Ahead Log (WAL)</h3></div></div></div><div class="section" title="9.6.5.1.&nbsp;Purpose"><div class="titlepage"><div><div><h4 class="title"><a name="purpose.wal"></a>9.6.5.1.&nbsp;Purpose</h4></div></div></div><p>The <em class="firstterm">Write Ahead Log (WAL)</em> records all changes to data in
            HBase, to file-based storage. Under normal operations, the WAL is not needed because
            data changes move from the MemStore to StoreFiles. However, if a RegionServer crashes or
          becomes unavailable before the MemStore is flushed, the WAL ensures that the changes to
          the data can be replayed. If writing to the WAL fails, the entire operation to modify the
          data fails.</p><p>HBase uses an implementation of the <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/wal/HLog.html" target="_top">HLog</a>
            interface for the WAL.
            Usually, there is only one instance of a WAL per RegionServer. The RegionServer records Puts and Deletes to
            it, before recording them to the <a class="xref" href="regions.arch.html#store.memstore" title="9.7.7.1.&nbsp;MemStore">Section&nbsp;9.7.7.1, &#8220;MemStore&#8221;</a> for the affected <a class="xref" href="regions.arch.html#store" title="9.7.7.&nbsp;Store">Section&nbsp;9.7.7, &#8220;Store&#8221;</a>.</p><p>The WAL resides in HDFS in the <code class="filename">/hbase/WALs/</code> directory (prior to
            HBase 0.94, they were stored in <code class="filename">/hbase/.logs/</code>), with subdirectories per
            region.</p><p> For more general information about the concept of write ahead logs, see the
            Wikipedia <a class="link" href="http://en.wikipedia.org/wiki/Write-ahead_logging" target="_top">Write-Ahead Log</a>
            article. </p></div><div class="section" title="9.6.5.2.&nbsp;WAL Flushing"><div class="titlepage"><div><div><h4 class="title"><a name="wal_flush"></a>9.6.5.2.&nbsp;WAL Flushing</h4></div></div></div><p>TODO (describe). </p></div><div class="section" title="9.6.5.3.&nbsp;WAL Splitting"><div class="titlepage"><div><div><h4 class="title"><a name="wal_splitting"></a>9.6.5.3.&nbsp;WAL Splitting</h4></div></div></div><p>A RegionServer serves many regions. All of the regions in a region server share the
            same active WAL file. Each edit in the WAL file includes information about which region
            it belongs to. When a region is opened, the edits in the WAL file which belong to that
            region need to be replayed. Therefore, edits in the WAL file must be grouped by region
            so that particular sets can be replayed to regenerate the data in a particular region.
            The process of grouping the WAL edits by region is called <em class="firstterm">log
              splitting</em>. It is a critical process for recovering data if a region server
            fails.</p><p>Log splitting is done by the HMaster during cluster start-up or by the ServerShutdownHandler
            as a region server shuts down. So that consistency is guaranteed, affected regions
            are unavailable until data is restored. All WAL edits need to be recovered and replayed
            before a given region can become available again. As a result, regions affected by
            log splitting are unavailable until the process completes.</p><div class="procedure" title="Procedure&nbsp;9.2.&nbsp;Log Splitting, Step by Step"><a name="log.splitting.step.by.step"></a><p class="title"><b>Procedure&nbsp;9.2.&nbsp;Log Splitting, Step by Step</b></p><ol class="procedure" type="1"><li class="step" title="The /hbase/WALs/<host&gt;,<port&gt;,<startcode&gt; directory is renamed."><p class="title"><b>The <code class="filename">/hbase/WALs/&lt;host&gt;,&lt;port&gt;,&lt;startcode&gt;</code> directory is renamed.</b></p><p>Renaming the directory is important because a RegionServer may still be up and
                accepting requests even if the HMaster thinks it is down. If the RegionServer does
                not respond immediately and does not heartbeat its ZooKeeper session, the HMaster
                may interpret this as a RegionServer failure. Renaming the logs directory ensures
                that existing, valid WAL files which are still in use by an active but busy
                RegionServer are not written to by accident.</p><p>The new directory is named according to the following pattern:</p><pre class="screen">/hbase/WALs/&lt;host&gt;,&lt;port&gt;,&lt;startcode&gt;-splitting</pre><p>An example of such a renamed directory might look like the following:</p><pre class="screen">/hbase/WALs/srv.example.com,60020,1254173957298-splitting</pre></li><li class="step" title="Each log file is split, one at a time."><p class="title"><b>Each log file is split, one at a time.</b></p><p>The log splitter reads the log file one edit entry at a time and puts each edit
                entry into the buffer corresponding to the edit&#8217;s region. At the same time, the
                splitter starts several writer threads. Writer threads pick up a corresponding
                buffer and write the edit entries in the buffer to a temporary recovered edit
                file. The temporary edit file is stored to disk with the following naming pattern:</p><pre class="screen">/hbase/&lt;table_name&gt;/&lt;region_id&gt;/recovered.edits/.temp</pre><p>This file is used to store all the edits in the WAL log for this region. After
                log splitting completes, the <code class="filename">.temp</code> file is renamed to the
                sequence ID of the first log written to the file.</p><p>To determine whether all edits have been written, the sequence ID is compared to
                the sequence of the last edit that was written to the HFile. If the sequence of the
                last edit is greater than or equal to the sequence ID included in the file name, it
                is clear that all writes from the edit file have been completed.</p></li><li class="step" title="After log splitting is complete, each affected region is assigned to a RegionServer."><p class="title"><b>After log splitting is complete, each affected region is assigned to a
                RegionServer.</b></p><p> When the region is opened, the <code class="filename">recovered.edits</code> folder is checked for recovered
                edits files. If any such files are present, they are replayed by reading the edits
                and saving them to the MemStore. After all edit files are replayed, the contents of
                the MemStore are written to disk (HFile) and the edit files are deleted.</p></li></ol></div><div class="section" title="9.6.5.3.1.&nbsp;Handling of Errors During Log Splitting"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e10369"></a>9.6.5.3.1.&nbsp;Handling of Errors During Log Splitting</h5></div></div></div><p>If you set the <code class="varname">hbase.hlog.split.skip.errors</code> option to
                <code class="constant">true</code>, errors are treated as follows:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Any error encountered during splitting will be logged.</p></li><li class="listitem"><p>The problematic WAL log will be moved into the <code class="filename">.corrupt</code>
                  directory under the hbase <code class="varname">rootdir</code>,</p></li><li class="listitem"><p>Processing of the WAL will continue</p></li></ul></div><p>If the <code class="varname">hbase.hlog.split.skip.errors</code> optionset to
                <code class="literal">false</code>, the default, the exception will be propagated and the
              split will be logged as failed. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2958" target="_top">HBASE-2958 When
                    hbase.hlog.split.skip.errors is set to false, we fail the split but thats
                    it</a>. We need to do more than just fail split if this flag is set.</p><div class="section" title="9.6.5.3.1.1.&nbsp;How EOFExceptions are treated when splitting a crashed RegionServers' WALs"><div class="titlepage"><div><div><h6 class="title"><a name="d2875e10407"></a>9.6.5.3.1.1.&nbsp;How EOFExceptions are treated when splitting a crashed RegionServers'
                WALs</h6></div></div></div><p>If an EOFException occurs while splitting logs, the split proceeds even when
                  <code class="varname">hbase.hlog.split.skip.errors</code> is set to
                <code class="literal">false</code>. An EOFException while reading the last log in the set of
                files to split is likely, because the RegionServer is likely to be in the process of
                writing a record at the time of a crash. For background, see <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2643" target="_top">HBASE-2643
                      Figure how to deal with eof splitting logs</a></p></div></div><div class="section" title="9.6.5.3.2.&nbsp;Performance Improvements during Log Splitting"><div class="titlepage"><div><div><h5 class="title"><a name="d2875e10420"></a>9.6.5.3.2.&nbsp;Performance Improvements during Log Splitting</h5></div></div></div><p>
              WAL log splitting and recovery can be resource intensive and take a long time,
              depending on the number of RegionServers involved in the crash and the size of the
              regions. <a class="xref" href="regionserver.arch.html#distributed.log.splitting" title="9.6.5.3.2.1.&nbsp;Distributed Log Splitting">Section&nbsp;9.6.5.3.2.1, &#8220;Distributed Log Splitting&#8221;</a> and <a class="xref" href="regionserver.arch.html#distributed.log.replay" title="9.6.5.3.2.2.&nbsp;Distributed Log Replay">Section&nbsp;9.6.5.3.2.2, &#8220;Distributed Log Replay&#8221;</a> were developed to improve
              performance during log splitting.
            </p><div class="section" title="9.6.5.3.2.1.&nbsp;Distributed Log Splitting"><div class="titlepage"><div><div><h6 class="title"><a name="distributed.log.splitting"></a>9.6.5.3.2.1.&nbsp;Distributed Log Splitting</h6></div></div></div><p><em class="firstterm">Distributed Log Splitting</em> was added in HBase version 0.92
                (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-1364" target="_top">HBASE-1364</a>) 
                by Prakash Khemani from Facebook. It reduces the time to complete log splitting
                dramatically, improving the availability of regions and tables. For
                example, recovering a crashed cluster took around 9 hours with single-threaded log
                splitting, but only about six minutes with distributed log splitting.</p><p>The information in this section is sourced from Jimmy Xiang's blog post at <a class="link" href="http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/" target="_top">http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/</a>.</p><p title="Enabling or Disabling Distributed Log Splitting"><b>Enabling or Disabling Distributed Log Splitting.&nbsp;</b>Distributed log processing is enabled by default since HBase 0.92. The setting
                  is controlled by the <span class="property">hbase.master.distributed.log.splitting</span>
                  property, which can be set to <code class="literal">true</code> or <code class="literal">false</code>,
                  but defaults to <code class="literal">true</code>. </p><div class="procedure" title="Procedure&nbsp;9.3.&nbsp;Distributed Log Splitting, Step by Step"><a name="d2875e10460"></a><p class="title"><b>Procedure&nbsp;9.3.&nbsp;Distributed Log Splitting, Step by Step</b></p><p>After configuring distributed log splitting, the HMaster controls the process.
                  The HMaster enrolls each RegionServer in the log splitting process, and the actual
                  work of splitting the logs is done by the RegionServers. The general process for
                  log splitting, as described in <a class="xref" href="regionserver.arch.html#log.splitting.step.by.step" title="Procedure&nbsp;9.2.&nbsp;Log Splitting, Step by Step">Procedure&nbsp;9.2, &#8220;Log Splitting, Step by Step&#8221;</a> still applies here.</p><ol class="procedure" type="1"><li class="step" title="Step 1"><p>If distributed log processing is enabled, the HMaster creates a
                    <em class="firstterm">split log manager</em> instance when the cluster is started.
                    The split log manager manages all log files which need
                    to be scanned and split. The split log manager places all the logs into the
                    ZooKeeper splitlog node (<code class="filename">/hbase/splitlog</code>) as tasks. You can
                  view the contents of the splitlog by issuing the following
                    <span class="command"><strong>zkcli</strong></span> command. Example output is shown.</p><pre class="screen">ls /hbase/splitlog
[hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost8.sample.com%2C57020%2C1340474893275-splitting%2Fhost8.sample.com%253A57020.1340474893900, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost3.sample.com%2C57020%2C1340474893299-splitting%2Fhost3.sample.com%253A57020.1340474893931, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost4.sample.com%2C57020%2C1340474893287-splitting%2Fhost4.sample.com%253A57020.1340474893946]                  
                  </pre><p>The output contains some non-ASCII characters. When decoded, it looks much
                    more simple:</p><pre class="screen">
[hdfs://host2.sample.com:56020/hbase/.logs
/host8.sample.com,57020,1340474893275-splitting
/host8.sample.com%3A57020.1340474893900, 
hdfs://host2.sample.com:56020/hbase/.logs
/host3.sample.com,57020,1340474893299-splitting
/host3.sample.com%3A57020.1340474893931, 
hdfs://host2.sample.com:56020/hbase/.logs
/host4.sample.com,57020,1340474893287-splitting
/host4.sample.com%3A57020.1340474893946]                    
                  </pre><p>The listing represents WAL file names to be scanned and split, which is a
                    list of log splitting tasks.</p></li><li class="step" title="The split log manager monitors the log-splitting tasks and workers."><p class="title"><b>The split log manager monitors the log-splitting tasks and workers.</b></p><p>The split log manager is responsible for the following ongoing tasks:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Once the split log manager publishes all the tasks to the splitlog
                        znode, it monitors these task nodes and waits for them to be
                        processed.</p></li><li class="listitem"><p>Checks to see if there are any dead split log
                        workers queued up. If it finds tasks claimed by unresponsive workers, it
                        will resubmit those tasks. If the resubmit fails due to some ZooKeeper
                        exception, the dead worker is queued up again for retry.</p></li><li class="listitem"><p>Checks to see if there are any unassigned
                        tasks. If it finds any, it create an ephemeral rescan node so that each
                        split log worker is notified to re-scan unassigned tasks via the
                          <code class="code">nodeChildrenChanged</code> ZooKeeper event.</p></li><li class="listitem"><p>Checks for tasks which are assigned but expired. If any are found, they
                        are moved back to <code class="code">TASK_UNASSIGNED</code> state again so that they can
                        be retried. It is possible that these tasks are assigned to slow workers, or
                        they may already be finished. This is not a problem, because log splitting
                        tasks have the property of idempotence. In other words, the same log
                        splitting task can be processed many times without causing any
                        problem.</p></li><li class="listitem"><p>The split log manager watches the HBase split log znodes constantly. If
                        any split log task node data is changed, the split log manager retrieves the
                        node data. The
                        node data contains the current state of the task. You can use the
                        <span class="command"><strong>zkcli</strong></span> <span class="command"><strong>get</strong></span> command to retrieve the
                        current state of a task. In the example output below, the first line of the
                        output shows that the task is currently unassigned.</p><pre class="screen">
<strong class="userinput"><code>get /hbase/splitlog/hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost6.sample.com%2C57020%2C1340474893287-splitting%2Fhost6.sample.com%253A57020.1340474893945
</code></strong> 
<code class="computeroutput">unassigned host2.sample.com:57000
cZxid = 0&times;7115
ctime = Sat Jun 23 11:13:40 PDT 2012
...</code>  
                      </pre><p>Based on the state of the task whose data is changed, the split log
                        manager does one of the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Resubmit the task if it is unassigned</p></li><li class="listitem"><p>Heartbeat the task if it is assigned</p></li><li class="listitem"><p>Resubmit or fail the task if it is resigned (see <a class="xref" href="regionserver.arch.html#distributed.log.replay.failure.reasons" title="Reasons a Task Will Fail">Reasons a Task Will Fail</a>)</p></li><li class="listitem"><p>Resubmit or fail the task if it is completed with errors (see <a class="xref" href="regionserver.arch.html#distributed.log.replay.failure.reasons" title="Reasons a Task Will Fail">Reasons a Task Will Fail</a>)</p></li><li class="listitem"><p>Resubmit or fail the task if it could not complete due to
                            errors (see <a class="xref" href="regionserver.arch.html#distributed.log.replay.failure.reasons" title="Reasons a Task Will Fail">Reasons a Task Will Fail</a>)</p></li><li class="listitem"><p>Delete the task if it is successfully completed or failed</p></li></ul></div><div class="itemizedlist" title="Reasons a Task Will Fail"><a name="distributed.log.replay.failure.reasons"></a><p class="title"><b>Reasons a Task Will Fail</b></p><ul class="itemizedlist" type="circle"><li class="listitem"><p>The task has been deleted.</p></li><li class="listitem"><p>The node no longer exists.</p></li><li class="listitem"><p>The log status manager failed to move the state of the task
                          to TASK_UNASSIGNED.</p></li><li class="listitem"><p>The number of resubmits is over the resubmit
                          threshold.</p></li></ul></div></li></ul></div></li><li class="step" title="Each RegionServer's split log worker performs the log-splitting tasks."><p class="title"><b>Each RegionServer's split log worker performs the log-splitting tasks.</b></p><p>Each RegionServer runs a daemon thread called the <em class="firstterm">split log
                      worker</em>, which does the work to split the logs. The daemon thread
                    starts when the RegionServer starts, and registers itself to watch HBase znodes.
                    If any splitlog znode children change, it notifies a sleeping worker thread to
                    wake up and grab more tasks. If if a worker's current task&#8217;s node data is
                    changed, the worker checks to see if the task has been taken by another worker.
                    If so, the worker thread stops work on the current task.</p><p>The worker monitors
                    the splitlog znode constantly. When a new task appears, the split log worker
                    retrieves  the task paths and checks each one until it finds an unclaimed task,
                    which it attempts to claim. If the claim was successful, it attempts to perform
                    the task and updates the task's <span class="property">state</span> property based on the
                    splitting outcome. At this point, the split log worker scans for another
                    unclaimed task.</p><div class="itemizedlist" title="How the Split Log Worker Approaches a Task"><p class="title"><b>How the Split Log Worker Approaches a Task</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>It queries the task state and only takes action if the task is in
                          <code class="literal">TASK_UNASSIGNED </code>state.</p></li><li class="listitem"><p>If the task is is in <code class="literal">TASK_UNASSIGNED</code> state, the
                        worker attempts to set the state to <code class="literal">TASK_OWNED</code> by itself.
                        If it fails to set the state, another worker will try to grab it. The split
                        log manager will also ask all workers to rescan later if the task remains
                        unassigned.</p></li><li class="listitem"><p>If the worker succeeds in taking ownership of the task, it tries to get
                        the task state again to make sure it really gets it asynchronously. In the
                        meantime, it starts a split task executor to do the actual work: </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>Get the HBase root folder, create a temp folder under the root, and
                            split the log file to the temp folder.</p></li><li class="listitem"><p>If the split was successful, the task executor sets the task to
                            state <code class="literal">TASK_DONE</code>.</p></li><li class="listitem"><p>If the worker catches an unexpected IOException, the task is set to
                            state <code class="literal">TASK_ERR</code>.</p></li><li class="listitem"><p>If the worker is shutting down, set the the task to state
                              <code class="literal">TASK_RESIGNED</code>.</p></li><li class="listitem"><p>If the task is taken by another worker, just log it.</p></li></ul></div></li></ul></div></li><li class="step" title="The split log manager monitors for uncompleted tasks."><p class="title"><b>The split log manager monitors for uncompleted tasks.</b></p><p>The split log manager returns when all tasks are completed successfully. If
                    all tasks are completed with some failures, the split log manager throws an
                    exception so that the log splitting can be retried. Due to an asynchronous
                    implementation, in very rare cases, the split log manager loses track of some
                    completed tasks. For that reason, it periodically checks for remaining
                    uncompleted task in its task map or ZooKeeper. If none are found, it throws an
                    exception so that the log splitting can be retried right away instead of hanging
                    there waiting for something that won&#8217;t happen.</p></li></ol></div></div><div class="section" title="9.6.5.3.2.2.&nbsp;Distributed Log Replay"><div class="titlepage"><div><div><h6 class="title"><a name="distributed.log.replay"></a>9.6.5.3.2.2.&nbsp;Distributed Log Replay</h6></div></div></div><p>After a RegionServer fails, its failed region is assigned to another
                RegionServer, which is marked as "recovering" in ZooKeeper. A split log worker directly
                replays edits from the WAL of the failed region server to the region at its new
                location. When a region is in "recovering" state, it can accept writes but no reads
                (including Append and Increment), region splits or merges. </p><p>Distributed Log Replay extends the <a class="xref" href="regionserver.arch.html#distributed.log.splitting" title="9.6.5.3.2.1.&nbsp;Distributed Log Splitting">Section&nbsp;9.6.5.3.2.1, &#8220;Distributed Log Splitting&#8221;</a> framework. It works by
                directly replaying WAL edits to another RegionServer instead of creating
                  <code class="filename">recovered.edits</code> files. It provides the following advantages
                over distributed log splitting alone:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>It eliminates the overhead of writing and reading a large number of
                  <code class="filename">recovered.edits</code> files. It is not unusual for thousands of
                  <code class="filename">recovered.edits</code> files to be created and written concurrently
                  during a RegionServer recovery. Many small random writes can degrade overall
                  system performance.</p></li><li class="listitem"><p>It allows writes even when a region is in recovering state. It only takes seconds for a recovering region to accept writes again. 
</p></li></ul></div><p title="Enabling Distributed Log Replay"><b>Enabling Distributed Log Replay.&nbsp;</b>To enable distributed log replay, set <code class="varname">hbase.master.distributed.log.replay</code> to
                  true. This will be the default for HBase 0.99 (<a class="link" href="https://issues.apache.org/jira/browse/HBASE-10888" target="_top">HBASE-10888</a>).</p><p>You must also enable HFile version 3 (which is the default HFile format starting
                in HBase 0.99. See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-10855" target="_top">HBASE-10855</a>).
                Distributed log replay is unsafe for rolling upgrades.</p></div></div></div><div class="section" title="9.6.5.4.&nbsp;Disabling the WAL"><div class="titlepage"><div><div><h4 class="title"><a name="wal.disable"></a>9.6.5.4.&nbsp;Disabling the WAL</h4></div></div></div><p>It is possible to disable the WAL, to improve performace in certain specific
            situations. However, disabling the WAL puts your data at risk. The only situation where
            this is recommended is during a bulk load. This is because, in the event of a problem,
            the bulk load can be re-run with no risk of data loss.</p><p>The WAL is disabled by calling the HBase client field
              <code class="code">Mutation.writeToWAL(false)</code>. Use the
              <code class="code">Mutation.setDurability(Durability.SKIP_WAL)</code> and Mutation.getDurability()
            methods to set and get the field's value. There is no way to disable the WAL for only a
            specific table.</p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>If you disable the WAL for anything other than bulk loads, your data is at
              risk.</p></div></div></div></div><div id="disqus_thread"></div><script type="text/javascript">
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="master.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="architecture.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="regions.arch.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">9.5.&nbsp;Master&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="book.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;9.7.&nbsp;Regions</td></tr></table></div></body></html>